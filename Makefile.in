# Process this file with autoconf to generate the Makefile
# @configure_input@

# MANIFEST and prefix must match the value defaulted in starconf.
# FIXME: tie these together, and link with starconf values.
prefix=@prefix@
MANIFEST=$(prefix)/manifests

# Keep the following in alphabetical order.  We don't actually _have_ to
# include everything here, just enough to imply all the others that we
# really need.  However, it does no harm to include more components than
# minimally necessary.
#
# Targets not to include:
#     No buildsupport targets: 'buildsupport' handles them below.
#     No pseudo-components such as pcs, installing which actually installs
#         multiple components, with some being potentially out of
#         dependency order.
#     Obsolete components
ALL_TARGETS = \
	$(MANIFEST)/agi \
	$(MANIFEST)/ard \
	$(MANIFEST)/ast \
	$(MANIFEST)/astrom \
	$(MANIFEST)/atools \
	$(MANIFEST)/cat \
	$(MANIFEST)/ccdpack \
	$(MANIFEST)/chr \
	$(MANIFEST)/cnf \
	$(MANIFEST)/coco \
	$(MANIFEST)/convert \
	$(MANIFEST)/datacube \
	$(MANIFEST)/daophot \
	$(MANIFEST)/dipso \
	$(MANIFEST)/docfind \
	$(MANIFEST)/echomop \
	$(MANIFEST)/echwind \
	$(MANIFEST)/ems \
	$(MANIFEST)/esp \
	$(MANIFEST)/extractor \
	$(MANIFEST)/extreme \
	$(MANIFEST)/figaro \
	$(MANIFEST)/findcoords \
	$(MANIFEST)/fio \
	$(MANIFEST)/gaia \
	$(MANIFEST)/gks \
	$(MANIFEST)/gns \
	$(MANIFEST)/graphpar \
	$(MANIFEST)/grp \
	$(MANIFEST)/gsd \
	$(MANIFEST)/gwm \
	$(MANIFEST)/hds \
	$(MANIFEST)/hdstools \
	$(MANIFEST)/hdstrace \
	$(MANIFEST)/hlp \
	$(MANIFEST)/htx \
	$(MANIFEST)/icl \
	$(MANIFEST)/idi \
	$(MANIFEST)/img \
	$(MANIFEST)/info \
	$(MANIFEST)/init \
	$(MANIFEST)/itcl \
	$(MANIFEST)/jpl \
	$(MANIFEST)/kappa \
	$(MANIFEST)/kaprh \
	$(MANIFEST)/mag \
	$(MANIFEST)/mers \
	$(MANIFEST)/messgen \
	$(MANIFEST)/nbs \
	$(MANIFEST)/ndf \
	$(MANIFEST)/ndg \
	$(MANIFEST)/news \
	$(MANIFEST)/one \
	$(MANIFEST)/par \
	$(MANIFEST)/pda \
	$(MANIFEST)/pgp \
	$(MANIFEST)/photom \
	$(MANIFEST)/pisa \
	$(MANIFEST)/polpack \
	$(MANIFEST)/prm \
	$(MANIFEST)/psmerge \
	$(MANIFEST)/psx \
	$(MANIFEST)/ref \
	$(MANIFEST)/rv \
	$(MANIFEST)/sae \
	$(MANIFEST)/scb \
	$(MANIFEST)/sgs \
	$(MANIFEST)/shl \
	$(MANIFEST)/sla \
	$(MANIFEST)/spt \
	$(MANIFEST)/sst \
	$(MANIFEST)/tcl \
	$(MANIFEST)/tk \
	$(MANIFEST)/trn \
	$(MANIFEST)/xdisplay

# The other important target is `buildsupport', the dependencies of
# which are defined in the Makefile.dependencies which is included below.



SUBDIRS = @subdirs@
@SET_MAKE@
LN_S=@LN_S@

# Java support: need a java runtime.  The Java programs below use the
# jar in $(BUILDSUPPORTCP), which is installed
# as part of the starconf component.
JAVA=@JAVA@

# Location of the buildsupport classes.  This default is generally
# the best one, but we make it configurable so we can override it in
# special circumstances.
BUILDSUPPORTCP=`starconf --show buildsupportjar`

# The RECURSIVE_TARGETS support here is based on the similar support
# generated by automake, but isn't identical.
RECURSIVE_TARGETS = all-recursive check-recursive \
	clean-recursive distclean-recursive maintainer-clean-recursive



all: all-recursive
world: $(ALL_TARGETS)
	- test -f $(prefix)/bin/hlink \
	  && test -d $(prefix)/docs \
	  && $(prefix)/bin/hlink $(prefix)/docs
	rm -f world-stamp
	date >world-stamp

# Avoid doing anything if the variable JAVA is NOJAVA -- this is true if
# we're using this file unconfigured during bootstrap (see ./bootstrap
# for the relevant gymnastics).
#
# It might seem like a good idea to create a set of dependencies for
# componentset.xml at the same time, saying that it depends on all the
# component.xml files beneath it in the tree.  It's a bad idea,
# however, since it means that the Makefile can be used only if the
# entire tree is checked out.  If we only check out part of the tree,
# because we only want to build one component, then any make at the
# top level will fail because one or other of the dependencies of
# componentset.xml is missing.  This is also why individual
# component.xml files are checked in to the repository, since this
# allows compenentset.xml to be built without the component.xml files
# being configured.  This, finally, is why we do not declare that
# Makefile.dependencies depends on componentset.xml, and have a
# separate rule for the latter: we can't express any componentset.xml
# dependencies, so once it exists, it wouldn't be updated.
#
# We make the componentset.xml by concatenating all the component.xml
# files we can find.  Sort the list of files to make the order
# deterministic.  The removal of the DOCTYPE lines and PIs is
# admittedly lame, but good enough for the moment.
#
# componentset.xml `really' depends on all the component.xml files
# below it, but don't state this, for the reason explained above.
# If you add a component or changes a component's dependencies,
# then delete Makefile.dependencies here and remake it.
#
# The test of whether $(JAVA) is NOJAVA is important.  An edited
# version of this file is used by the ./bootstrap script, in which the
# JAVA variable is set to NOJAVA (since the directory may not have been
# configured yet); we must not fail in this case.  In this case simply
# do nothing, because the Makefile.dependencies file can be assumed to
# be up-to-date.
#
# If $(JAVA) is NOJAVA and Makefile.dependencies does not exist,
# then what is happening is that the user has deleted
# Makefile.dependencies in order to remake it, but they don't have a
# java binary on their path.  Oh dear.  Just touching the file isn't
# any use here, so fail noisily, and tell the user what they need to do.
#
# if $(JAVA) is NOJAVA and Makefile.dependencies does exist, then
# we're puzzled, because we probably shouldn't be executing this
# rule.  Clearly, `make' has gone mad.  In this case, simply touch
# Makefile.dependencies, since that should at least stop this
# happening again, and hope this turns into someone else's problem.
#
# The hole in the logic below is where we have an unconfigured tree
# (ie, buildsupport/starconf has not been installed) _and_ no
# Makefile.dependencies.  Since the latter is checked into the
# repository, this can only mean that someone is playing
# silly-buggers, and we're stuck.  The error message should cover
# that case, too.
#
Makefile.dependencies componentset-extrainfo.xml:
	rm -f componentset.xml Makefile.dependencies Makefile.dependencies.tmp
	exec 5>componentset.xml; \
	  echo '<!DOCTYPE componentset SYSTEM "componentinfo.dtd">' >&5; \
	  echo '<componentset>' >&5; \
	  find . -name component.xml | sort | \
	    { while read c; do cat $$c; done } | \
	    sed '/^<?/d;/^<!DOCTYPE/d;/^ *<!--.*--> *$$/d' >&5; \
	  echo '</componentset>' >&5
	if test "$(JAVA)" != NOJAVA; then \
	  $(JAVA) -classpath $(BUILDSUPPORTCP) \
	        GenerateDependencies \
	        --makefile=Makefile.dependencies.tmp \
		--flatdeps=componentset-extrainfo.xml \
		componentset.xml \
	  && mv Makefile.dependencies.tmp Makefile.dependencies; \
	elif test -f $@; then \
	  touch $@; \
	else \
	  echo "You are remaking Makefile.dependencies (yes?)."; \
	  echo "To do this, you must have java in your path."; \
	  echo "(and the starconf component must be installed, as the"; \
	  echo "result of a tree-wide bootstrap).  Either call:"; \
	  echo "  make JAVA=/path/to/java Makefile.dependencies"; \
	  echo "or edit PATH appropriately, run"; \
	  echo "  ./configure --no-recursion"; \
	  echo "and then remake Makefile.dependencies"; \
	  false; \
	fi

# Create the componentset.html summary of the componentset.xml file.
# Depends on Makefile.dependencies => componentset.xml.
# Probably only used by USSC maintainer, so limited error recovery.
componentset.html: Makefile.dependencies
	test $(JAVA) != NOJAVA -a -f componentset.xml
	$(JAVA) -classpath $(BUILDSUPPORTCP) \
	  Transformer componentset.xml \
	    buildsupport/misc/summarise-components.xslt $@

# Make a link to an installed componentinfo.dtd file.  This will not
# work at bootstrap time (so the bootstrap file takes care of this
# link).  It does no harm to have the rule in, just in case this is
# used at some other time.
componentinfo.dtd:
	$(LN_S) `starconf --show buildsupportdata`/componentinfo.dtd componentinfo.dtd

# Makefile.dependencies expresses all the dependencies between components.
# It expects the current file to define variable MANIFEST to be the directory
# which holds the manifest files, typically /star/manifests
#
# This include file also contains the TARGET buildsupport
include Makefile.dependencies

# Add extra dependencies on starconf, to ensure that ./configure and
# install-sh are present before we attempt to configure it.
$(MANIFEST)/starconf: buildsupport/starconf/configure

buildsupport/starconf/configure: $(MANIFEST)/automake $(MANIFEST)/autoconf
	cd buildsupport/starconf && autoreconf --install --symlink

# Disable `make install' from this directory
install install-manifest:
	@ echo "To install a component, go to its directory and type"
	@ echo "  'make install' there.  Or delete its manifest from"
	@ echo "  $(MANIFEST), and make $(MANIFEST)/<component-name>".
	@ echo "To install the whole tree, type 'make world'."

clean: clean-recursive

check: check-recursive

# This list is taken from the list generated by automake when it makes
# a Makefile.in, namely $(am__CONFIG_DISTCLEAN_FILES)
CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
	configure.lineno configure.status.lineno

distclean: distclean-recursive
	-rm -f $(CONFIG_DISTCLEAN_FILES)
	-rm -f Makefile

maintainer-clean: maintainer-clean-recursive
	-rm -f $(CONFIG_DISTCLEAN_FILES)
	-rm -rf autom4te.cache
	-rm -f Makefile

$(RECURSIVE_TARGETS):
	for d in $(SUBDIRS); do \
	    if test "$$d" = . ; then \
		echo "Omitting recursive make of current directory"; \
	    else \
		target=`echo $@ | sed s/-recursive//`; \
		(cd $$d && $(MAKE) $$target); \
	    fi; \
	done
