<!DOCTYPE programcode PUBLIC "-//Starlink//DTD DSSSL Source Code 0.7//EN" [
<!ENTITY sldocs.dsl		SYSTEM "sldocs.dsl">
<!ENTITY slsect.dsl		SYSTEM "slsect.dsl">
<!ENTITY slmisc.dsl		SYSTEM "slmisc.dsl">
<!ENTITY slroutines.dsl		SYSTEM "slroutines.dsl">
<!ENTITY slmaths.dsl		SYSTEM "slmaths.dsl">
<!ENTITY sllinks.dsl		SYSTEM "sllinks.dsl">
<!ENTITY sltables.dsl		SYSTEM "sltables.dsl">

<!--
<!ENTITY commonparams.dsl	PUBLIC "-//Starlink//TEXT DSSSL Common Parameterisation//EN">
<!ENTITY slparams.dsl		PUBLIC "-//Starlink//TEXT DSSSL LaTeX Parameterisation//EN">
-->

<!ENTITY lib.dsl		SYSTEM "../lib/sllib.dsl" SUBDOC>
<!ENTITY common.dsl		SYSTEM "../common/slcommon.dsl" SUBDOC>
<!--
<!ENTITY slback.dsl		SYSTEM "slback.dsl" SUBDOC>
-->
]>

<!-- $Id$ -->

<docblock>
<title>Starlink to XML stylesheet
<description>
This is the stylesheet for converting the Starlink General DTD to XML.

<authorlist>
<author id=ng affiliation='Glasgow'>Norman Gray

<copyright>Copyright 1999, 2000 Council for the Central Laboratories of the
Research Councils.


<codereference doc="lib.dsl" id="code.lib">
<title>Library code
<description>
<p>Some of this library code is from the standard, some from Norm
Walsh's stylesheet, other parts from me

<codereference doc="common.dsl" id="code.common">
<title>Common code
<description>
<p>Code which is common to both the HTML and print stylesheets.

<!--
<codereference doc="slback.dsl" id=code.back>
<title>Back-matter
<description>Handles notes, bibliography and indexing
-->

<codegroup use="code.lib code.common" id=xml>
<!-- <codegroup use="code.lib code.common code.back" id=latex> -->
<title>Conversion to XML

<routine>
<description>Declare the flow-object-classes to support the SGML
transformation extensions of Jade.</description>
<codebody>
(declare-flow-object-class element
  "UNREGISTERED::James Clark//Flow Object Class::element")
(declare-flow-object-class empty-element
  "UNREGISTERED::James Clark//Flow Object Class::empty-element")
(declare-flow-object-class document-type
  "UNREGISTERED::James Clark//Flow Object Class::document-type")
(declare-flow-object-class processing-instruction
  "UNREGISTERED::James Clark//Flow Object Class::processing-instruction")
;(declare-flow-object-class entity
;  "UNREGISTERED::James Clark//Flow Object Class::entity")
;(declare-flow-object-class entity-ref
;  "UNREGISTERED::James Clark//Flow Object Class::entity-ref")
;(declare-flow-object-class formatting-instruction
;  "UNREGISTERED::James Clark//Flow Object Class::formatting-instruction")
(define debug
  (external-procedure "UNREGISTERED::James Clark//Procedure::debug"))
(define all-element-number
  (external-procedure "UNREGISTERED::James Clark//Procedure::all-element-number"))


(define %stylesheet-version%
  "Starlink XML stylesheet, version 0.1")

;; incorporate the simple stylesheets directly

&sldocs.dsl;
&slsect.dsl;
&slmisc.dsl;
&slroutines.dsl;
&slmaths.dsl;
&sllinks.dsl;
&sltables.dsl;
<!--
&commonparams.dsl;
&slparams.dsl;
-->

<routine>
<routinename>copy-attributes
<description>Copies the input element's attributes to the output
(from James Clark).
<p>Use as <code>(make element attributes: (copy-attributes))</code>
<returnvalue>List of lists
<argumentlist>
<parameter optional default='current-node'>nd<type>String
  <description>Node to be copied
<codebody>
(define (copy-attributes #!optional (nd (current-node)))
  (let loop ((atts (named-node-list-names (attributes nd))))
    (if (null? atts)
        '()
        (let* ((name (car atts))
               (value (attribute-string name nd)))
          (if value
              (cons (list name value)
                    (loop (cdr atts)))
              (loop (cdr atts)))))))

<routine>
<routinename>copy-element
<description>Copy the input element, with its attributes
<codebody>
(define (copy-element)
  (make element
    attributes: (copy-attributes)
    (process-children-trim)))

<routine>
<description>
The root rule.  Simply generate the XML document.
<codebody>
(root
    (make sequence
      (process-children)
      ;(make-manifest)
      ))

<![IGNORE[
; <routine>
; <routinename>make-manifest
; <description>Construct a list of the LaTeX files generated by the main
; processing.  Done only if <code/suppress-manifest/ is false and 
; <code/%latex-manifest%/ is true, giving the
; name of a file to hold the manifest.  
; <p>This is reasonably simple, since the manifest will typically consist
; of no more than the main output file, plus whatever files are used
; by the "figurecontent" element.
; <argumentlist>
; <parameter optional default='(current-node)'>nd<type>singleton-node-list
;   <description>Node which identifies the grove to be processed.
; <codebody>
; (define (make-manifest #!optional (nd (current-node)))
;   (if (and %latex-manifest% (not suppress-manifest))
;       (let ((element-list (list (normalize "figure")))
; 	    (rde (document-element nd)))
; 	(make entity system-id: %latex-manifest%
; 	      (make fi
; 		data: (string-append (index-file-name) ".tex
; ")) ; see sldocs.dsl
; 	      (with-mode make-manifest-mode
; 		(process-node-list
; 		 (node-list rde		;include current file
; 			    (node-list-filter-by-gi
; 			     (select-by-class (descendants rde)
; 					      'element)
; 			     element-list))))))
;       (empty-sosofo)))
;
; (mode make-manifest-mode
;   (default 
;     (empty-sosofo))
;
;   ;; The selection here should match the processing in slmisc.dsl
;   (element figure
;     (let* ((kids (children (current-node)))
; 	   (content (get-best-figurecontent
; 		     (select-elements kids (normalize "figurecontent"))
; 		     '("eps"))))
;       (if content
; 	  (process-node-list content)
; 	  (empty-sosofo))))
;   (element coverimage
;     (let* ((kids (children (current-node)))
; 	   (content (get-best-figurecontent
; 		     (select-elements kids (normalize "figurecontent"))
; 		     '("eps"))))
;       (if content
; 	  (process-node-list content)
; 	  (empty-sosofo))))
;   ;; the figurecontent element writes out TWO fields in the manifest:
;   ;; the first is the sysid of the figure as referred to by the
;   ;; generated LaTeX, which will have no path, and the second is the sysid as
;   ;; declared in the entity, which may well have a path.  Locations may
;   ;; need some post-processing.
;   (element figurecontent
;     (let* ((image-ent (attribute-string (normalize "image")
; 					(current-node)))
; 	   (full-sysid (and image-ent
; 			    (entity-system-id image-ent)))
; 	   (base-sysid (and image-ent
; 			    (car (reverse
; 				  (tokenise-string
; 				   (entity-system-id image-ent)
; 				   boundary-char?: (lambda (c)
; 						     (char=? c #\/))))))))
;       (if image-ent
; 	  (make fi data: (string-append base-sysid " " full-sysid "
; "))
; 	  (empty-sosofo)))))
]]>


