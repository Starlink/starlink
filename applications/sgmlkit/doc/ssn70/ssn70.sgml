<!DOCTYPE ssn PUBLIC "-//Starlink//DTD Starlink SSN 0.7//EN" [
  <!-- Other Starlink documents referred to -->
  <!ENTITY sgp28	PUBLIC "-//Starlink//DOCUMENT Summary SGP/28//EN"
			SUBDOC
			-- How to write good documents for Starlink -->
  <!ENTITY sun124	PUBLIC "-//Starlink//DOCUMENT Summary SUN/124//EN"
			SUBDOC
			-- HLP -->
  <!ENTITY sun188	PUBLIC "-//Starlink//DOCUMENT Summary SUN/188//EN"
			SUBDOC
			-- HTX -->
  <!ENTITY sun199 	PUBLIC "-//Starlink//DOCUMENT Summary SUN/199//EN"
			SUBDOC
			-- Star2HTML -->

  <!-- Figures -->
  <!ENTITY sgmlsystem.eps SYSTEM 'ssn70_SGMLsystem.eps' NDATA eps>
  <!ENTITY sgmlsystem.gif SYSTEM 'ssn70_SGMLsystem.gif' NDATA gif89a>

  <!-- Local text files included -->
  <!ENTITY swversion	SYSTEM 'sgmlkit-version-string'>
  <!ENTITY starlinkdtddoc	
			SYSTEM '../dtd2sgml/starlink-0.7.sgmltext'>
  <!ENTITY programcodedtddoc
			SYSTEM '../dtd2sgml/programcode-0.7.sgmltext'>
  <!ENTITY dsssl.lib	SYSTEM "../../dsssl/sl/lib/sllib-jade-1.2.1.dsl" SUBDOC
			-- DSSSL library code -->
  <!ENTITY dsssl.common	SYSTEM "../../dsssl/sl/common/slcommon.dsl" SUBDOC
			-- dsssl common code -->
  <!ENTITY dsssl.params	SYSTEM "../../dsssl/sl/common/slparams.sgml" SUBDOC
			-- Parameterisation -->
  <!ENTITY supportbinaries SYSTEM "../../misc/bindocs.sgml" SUBDOC
			-- Generated documentation for sgml2... -->
  <!ENTITY supportlib SYSTEM "../../misc/libdocs.sgml" SUBDOC
			-- Generated documentation for library utils... -->
  <!ENTITY release.notes	
			SYSTEM "ReleaseNotes">
  <!ENTITY release.notes.old
			SYSTEM "ReleaseNotes.old">
  <!ENTITY upconv.bin	SYSTEM "../../upconverter/upconvdocs.sgml" SUBDOC
			-- Documentation for binaries in upconverter package -->
 

  <!-- other miscellanea -->
  <!ENTITY % Feature.Routinelist 'INCLUDE'>
  <!ENTITY rsqbrack ']'	-- needed in order to describe marked sections -->
  <!ENTITY ddash CDATA '--'	-- so I can use this in CODE els without it
				   being recognised as a shortref -->
]>
<!-- $Id$ -->

<title>The Starlink SGML Set
<author email='norman@astro.gla.ac.uk'
	webpage='http://www.astro.gla.ac.uk/users/norman/'
	affiliation='University of Glasgow'
	id=ng
	>Norman Gray
<author email='mbt@ast.cam.ac.uk'
	webpage='http://www.ast.cam.ac.uk/%7Embt/'
	affiliation='University of Cambridge'
	id=mbt
	>Mark Taylor

<softwareversion>&swversion;

<docnumber>70

<history>
<version number=0 date='21-APR-1999' author=ng>Initial version</version>

<distribution string="DR-0.2" date="03-JUN-1999" author=ng>
First real release to other programmers.  Distribution contains only
SGML lib stuff: Jade has to be built separately.

<change date="06-JUN-1999" author="ng" versionid="post-0.2">
Various edits, great and small.  I received comments from Mark Taylor,
arising from the DR-0.2 distribution.  I made considerable additions
to the appendices.  Generally tidying up for release.

<distribution string="DR-0.3" date="15-JUN-1999" author="ng">
More substantial release, CD candidate.

<change date="22-JUN-1999" versionid="post-0.3">
Assorted tweaks, introduced since the release.
</change>

<distribution string="DR-0.4" date="10-SEP-1999" author="ng" versionid=v0-4>
Smallish DTD and DC changes, arising from the programmers' meeting and
discussion with Mark Taylor.
</distribution>

<change date='13-SEP-1999' versionid="post-v0-4">
Assorted tidyups and clarifications from user comments
</change>

<distribution string="DR-0.5" date="19-SEP-1999" author="ng">
Rather rushed distribution, containing implementations of changes to
Programcode DTD and implementations of those in the down-converters.
Time for few documentation updates.
</distribution>

<change date="23-SEP-1999" versionid="post-v0-5">Misc. clarifications.</change>

<distribution string="DR-0.6" date="31-Mar-2000" author="ng" versionid="v0.6">

<!-- Include the RCS Id corresponding to the current version (but
     remove the dollars, so this isn't fiddled with again. -->
<px>RCS: Id: ssn70.sgml,v 1.35 2000/03/31 14:35:38 norman Exp 

<px>Added sgml2docs command.  Significant changes to programcode.
Incorporates decisions from Durham, RAL and
Cambridge SGML meetings.  This is an interim release, intended as
a snapshot for distribution to Rodney Warren-Smith and Mark Taylor.
There will be a proper distribution before 1 June.
</distribution>

<change date="7-APR-2000" versionid="v0-6-1" author=mbt>
<px>Added a description of the HLP file downconversion tool.
<px>Modified documentation of the programcode upconverter to reflect new usage.
</change>

<change date='10-May-2000' versionid='v0-6-2' author=ng>
<px>Miscellaneous tweaks.

<change date='1-JUN-2000' author=mbt>
<px>Thoroughly revised documentation of upconverters.

<change date='2-Jun-2000' versionid='v0-6-3' author=ng>
<px>Some restructuring.  Preparing for distribution

<distribution string='DR-0.7' date='11-Jun-2000' author=ng versionid='v0-7'>
<px>RCS Id: ssn70.sgml,v 1.53 2000/06/11 16:21:27 norman Exp 
<px>First real release to programmers not directly concerned with the
SGML project.

<distribution string='DR-0.7-8' date='23-Aug-2000' author=ng
versionid='v0-7-8'>
<px>RCS Id: ssn70.sgml,v 1.56 2000/08/24 18:16:11 norman Exp 
<px>This release took a couple of goes to get right&ellip;.  But I
took the opportunity of reading through the text, correcting and
updating things here and there.  No big changes, but various things
have been clarified.

<distribution string='DR-0.7-11' date='30-Aug-2000' author=ng
versionid='v0-7-11'>
<px>RCS Id: ssn70.sgml,v 1.59 2000/08/30 14:55:33 norman Exp 
<px>Slight changes to explanations of maths elements.
</distribution>

<distribution string="DR-0.7-12" date="15-Mar-2001" author="ng"
	versionid='v0-7-12'>
<px>RCS Id: ssn70.sgml,v 1.61 2001/03/15 15:45:44 norman Exp </px>
<px>Mentioned the various jadeflags.</px>
</distribution>

<distribution string="DR-0.7-13" date="16-Mar-2001" author="ng"
	versionid='v0-7-13'>
<px>Small documentation changes.</px>
</distribution>

<change date="24-Aug-2001" author="ng" versionid="v0-7-13-edit1">
<px>Minor edits, which I noticed the need for after using the documentation.</px>
</change>

</history>

<coverimage>
<px>An SGML Application Conforming to International Standard ISO 8879
-- Standard Generalized Markup Language
<px>A HyTime application conforming to International Standard ISO/IEC
10744 -- Hypermedia/Time-based Structuring Language
</coverimage>

<copyright>
Copyright 1999, 2000, Particle Physics and Astronomy Research Council
</copyright>

<abstract>
<px>This is a developers' release, not production code.

<px>This document describes the Starlink SGML set.

<px>Audience: 
This document is addressed both at those who need to generate Starlink
documentation of any kind, and at anyone maintaining the Starlink SGML set.
</abstract>

<sect id=intro export>Introduction

<p>The Starlink SGML set supports people writing Starlink documents,
such as SUNs, SSNs, MUDs and the like.<note>To avoid ambiguity, this
somewhat arcane note needs to be here.  The terms `SGML system' and
`SGML application' have precise meanings in the SGML world.  An SGML
system is a program such as Jade or SP which parses SGML.  An SGML
application is a collection of DTDs and other supporting documents
(see the standard <citation/iso8879>, clause~4.279).  This package is
therefore properly referred to as an SGML application, but since this
term could be confusing, I will refer to this package instead
as the (Starlink) SGML Set.</note> It consists of a definition of a
markup language suitable for such documents, plus software to convert
these source documents to reader-friendly form.  At present, these
`output formats' include HTML and &latex (and hence include postscript
and PDF formats).

<p>The SGML set scores over previous solutions to Starlink's
documentation needs, such as <code/runoff> or &latex, because it is a
well-defined system, so that there is excellent support for it in
tools, and it is designed to be converted into whichever presentation
format is most convenient.
The DTD is designed to be flexible, rather than imposing a
particularly tight document structure.  At the same time it has
<em/enough> structure that it can be indexed and stored effectively.

<p>Although this system can help with many of the tasks involved in
document creation, it cannot write the document for you (shame!).  For
advice on that, documents such as <docxref doc=sgp28/> are still vital.

<p>This document is organised as follows.  In <ref id=sgml/>, we
discuss SGML in general terms, describing its general structure and
aims, why it was chosen as the format for the Starlink document set, and
pointing to sources of information.  In <ref id=markup/>, we describe
how you would go about actually writing a document, describing the
structure of Starlink documents which is crystallised in the
specification of this set.  In <ref id=structure/>, we describe the
structure of the document DTD, and the categories of elements you will use.
In <ref id=doccode/>, we describe the
support which exists to support documentation of source code, allowing
you to maintain detailed routine documentation along with the routine
source code.  In <ref id=processing/>, we describe the details of how
you transform your document from SGML to an output format.  In 
<ref id=upconvert/> we describe how to transform a document from
<code/star2html> format to an SGML document.
Finally,
the appendices give the detailed descriptions of the elements in the
two DTDs described here, a more detailed description of SGML than is
necessary for simple use of the set, and documentation for
maintainers of the set.

<!--
In <ref id=future/>, I describe
some possible further improvements in the set (suggestions and
comments are most welcome).  Finally, in <ref id=faq/>, I
answer (I hope) some frequently asked questions about SGML in general
and this set in particular.
-->

<sect id=sgml export>SGML Overview

<p>This section introduces you to SGML, and explains its advantages
over other approaches to document preparation.

<subsect id=why.sgml export>Why SGML?

<p>The problem SGML tries to solve is that humans are good at
intuiting structure from layout, but computers are exceedingly bad at
it.  This means that if we want computers to help us with documents --
displaying them, transforming them, storing them, searching them -- we
have to give the computer some help.  

<p>A common way of providing this
help is through markup systems such as <code/runoff> (or its
variants), or &tex, or &latex;.  The last of these three has served
Starlink very well, and even survived the conversion of Starlink's
document set to hypertext, through the tool <code/Star2HTML> (see <docxref
doc=sun199/>), but the problems of the &latex system illustrate the
advantages of the SGML approach quite well.
<dl>
<dt>LaTeX templates are ill-defined
<!-- Have this as `LaTeX' rather than &latex: the `latex' back-end -->
<!-- messes up SDATA references within (data nd), which is bad, since -->
<!-- latex/slmisc.dsl turns <dt> into \item[blah] using (data ...). -->
<dd>What is a Starlink document?  Although Starlink distributes
templates for the principal document types (for example in
<code>/star/docs/sun.tex</code>), and distributes style guides such as
<docxref doc=sgp28/>, there is no way either of mandating that certain
elements, such as a document number, actually appear, nor of ensuring
that other features, such as raw &tex, do not.  This means that
document authors can never quite be sure that they have produced a
`correct' document; that, since the effective definition of `correct' is
`processable by this tool', there is no guarantee that a document
which is correct at one time will continue to be so; and that tools
which search or process such 
documents have to have contingency strategies available, when the
elements they hope to use are missing.

<dt>The conversion is a hack!
<dd>Because the input documents are not well-defined, the tools which
process them cannot be designed against any standard, but instead have
to rely on heuristics and uncheckable conventions.  &latex documents
are defined to work with one particular tool -- the &tex tokeniser and
parser -- so that using
them with any other tool (which is necessary if you want to produce
anything other than DVI files<note>In fact, there is a version of &tex;
which produces PDF files directly, and a &tex;-to-HTML converter
called TeX4ht (see
<url>http://www.tug.org/applications/tex4ht/mn.html</url>) which
writes special DVI files which work with a 
postprocessor, and so uses the &tex parser to produce HTML
indirectly.  This really just pushes the hack elsewhere.</note>) is
asking for trouble.

<dt>Authors have to know too much.
<dd>When you are writing a <code/Star2HTML> document, you are
riding two horses at once; you must write in that subset of &latex
which <code/Star2HTML> knows about.  Authors must frequently be
sensitive to the treatment of their document by two separate systems.

<dt>Authors <em/can> know too much!
<dd>Part of the strength of &tex and &latex is their flexibility, and
it is easy for authors, especially programmer authors, to exploit this
when writing documentation, and a burst of &tex macro
magic can be an effective antidote to demotivation during the longeurs
of preparing documentation.  However much this flexibility may assist
(or even amuse) authors, it inflicts parsing hell on anyone else who
wants to do something unforseen with the document.
If you restrict what an author <em/can> do, then you limit what a
parser <em/has> to do to repurpose the document.

<dt>Not future-proof
<dd>&latex is not precisely defined; on the contrary, it is
continually being developed, and a completely new version, <webref
url="http://www.oasis-open.org/cover/latex3-9804.html" >&latex;3</webref> is
eagerly anticipated (which will, incidentally, be heavily influenced
by SGML).  Similarly, the <code/LaTeX2HTML> package is continually
being upgraded, causing a <code/Star2HTML> (based on
<code/LaTeX2HTML>) maintenance headache.
</dl>

<p>None of these problems is fatal -- all of them have manifestly been
overcome by the authors and maintainers of the current document set --
but taken together they make the maintenance of the document set more
expensive in time than there is time to spare.

<p>SGML addresses these problems effectively.
<dl>
<dt>SGML documents are well-defined
<dd>The structure of an SGML document is formally specified in the
Document Type Definition (DTD) associated with it.  This specifies
what features must, which may, and which may not, be present in a
document.  This means that systems processing the document need work
only within a much smaller universe of possibilities.

<dt>Future-proof
<dd>SGML has had only two backward-compatible amendments since 1986;
it's not dependent on any particular tool; SGML is designed to be used
decades hence; a sufficient number of
hangarfuls of technical documentation have been produced using SGML
that if and when a replacement comes along, it will have good support.

</dl>

<p>The most eligible candidite for a replacement for SGML is XML.
XML is a cut-down version of SGML, omitting rarely-used or
dispensable features, but preserving many of its strengths (<ref
id=final.xml/>).  The only serious disadvantage of XML, from our point
of view, is its verbosity, since it has discarded SGML's markup
minimisation features (<ref id=markup.min/>), and so can be tediously
verbose to type.

<subsect id=what.sgml export>What is SGML?

<p>SGML is a metalanguage: that is, a language for writing languages
in.

<p>This is not actually as arcane as it sounds.  It simply means that
you use SGML to define the abstract structure of a document type (the
Document Type Definition, or DTD), so
that any documents which claim to be of that type must have a certain
syntactic structure.

<p>HTML is a well known example of an SGML DTD, whose rules are well
known.  An HTML document consists of precisely one <code/head> and one
<code/body> element.  The <code/head> must have precisely one
<code/title> element, and may have zero or more <code/link> elements.
The <code/title> element has simple characters as content.  The
<code/link> element has no content, but has four optional
attributes&ellip, and so on.

<p>Given a document marked up in some specific DTD it will be parsed
by some tool which reads first the DTD then the document, and then
creates some abstract representation of the document which it passes
to a formatter, which in turn produces output in some form which may,
of course, be further processed to a final document.  The SGML parser
and whichever editor you use are both quite generic, but the formatter
is tied to a particular DTD.  There is a diagram of this system in
<ref id=fig.sgml/>.
<figure id=fig.sgml float alt="An SGML system">
<caption>An SGML system
<figurecontent image="sgmlsystem.eps">
<figurecontent image="sgmlsystem.gif">
</figure>

<p>For further information on SGML, see <ref id=appx.sgml/>.  For other
texts, see the well-known
<cite>Gentle Introduction to SGML</cite><citation/gentle>.
For more detailed information,
see the useful but compressed <citation/bradley>; and for an
authoritative account see 
<citation/goldfarb>, which is an exegesis of the standard,
<citation/iso8879>. 

<subsect id=faq export>Frequently Asked Questions

<subsubsect id=faq.html>What's wrong with HTML?

<p>HTML was designed as a flexible and generic markup language.
Unfortunately, it is a little <em/too> flexible and generic to be
really useful.  The power of SGML comes from its ability to represent
the structure of a document faithfully, and HTML cannot do this in
most cases - it has a <code/&lt;title&gt;> element, and some structural
markup <code/&lt;Hn&gt;>, but apart from that, it's little better than
simple ASCII text.  As well, it suffers from some of the same diseases
as &latex;, as described above in <ref id=why.sgml/>, in that the
effective definition of a `good' HTML document is `viewable by
netscape', and that means that you're even less well-assured of the
content and structure of a document than you are if you use &latex;
(if you are going to get involved in validating documents,
you might as well go the whole hog and do it properly).

<subsubsect id=faq.latex>What about &latex;?

<p>See the discussion in <ref id=why.sgml/>, as
that describes SGML's advantages by comparing them to the problems
with the current &latex; system.  &latex; is marvellous -- this system
uses it as a back-end print formatter -- but it's not ideal for a
large and various document set.

<sect id=markup export>Marking up your document

<p>In this section I will introduce you to SGML from the point of view
of writing a document marked up using the particular set of SGML
element types this application defines.  There are many 
features of SGML which I will not describe, for simplicity and
brevity, but if you wish to find out more about the possibilities of
SGML, then see the more detailed documentation in <ref id=appx.sgml/>
or, for the most authoritative (but admittedly largely
incomprehensible) documentation, the SGML standard
<citation/iso8879>.

<subsect id=markup.intro export>Sample document, and overview

<p>A sample SUN is illustrated in <ref id=fig.simplesun/>.
<figure id=fig.simplesun export float alt="Simple SUN document">
<caption>A simple sample SUN</caption>
<px>
<verbatim><![ CDATA [
<!DOCTYPE sun PUBLIC "-//Starlink//DTD Starlink SUN//EN">
<title>The Starlink SGML set
<author email='norman@astro.gla.ac.uk'
        webpage='http://www.astro.gla.ac.uk/users/norman'
        affiliation='University of Glasgow'
        id=ng
        >Norman Gray
<docnumber>1234
<history>
  <version number=0 date='21-APR-1999' author=ng>Initial version
</history>
<abstract>
  This is a sample SUN
</abstract>

<sect id=intro export>Introduction
<p>Starlink SUNs are easy to write.
]]></verbatim>
</figure>
<p>Features to note:
<ul>
<li>The document starts off with a `document type declaration',
<code>&lt;!DOCTYPE sun PUBLIC &quot;-//Starlink//DTD Starlink
SUN//EN&quot;&gt;</code>, which states which DTD this document claims to be
conformant to, in this case the Starlink SUN document type.

<li>The document is structured in terms of `element types' such as
<code/author> or <code/sect>, and these in turn contain further data,
such as a sequence of characters (`Norman Gray') in the case of the
<code/author> element, or further elements (the <code/version> element)
in the case of the <code/history> element.  Elements are delimited by
`opening tags' like <code>&lt;abstract&gt;</code> and `closing tags'
like <code>&lt;/abstract&gt;</code>.<note>Note for pedants: There is a
difference 
between `elements' and `element types': the former are things which
appear in documents, with data in them; the latter are the abstract
things defined by the DTD.  The distinction is not particularly
important outside of a DTD, however, so I will not continue to make it
in the description of the element types below.  It will always be
possible to make the distinction from the context anyway.</note>

<li>Elements have both <em/content> and <em/attributes>.  For example,
the <code/author> element has the characters `Norman Gray' as its
content and a list of strings such as an email address as its
attributes.

<li>Some of the elements (the <code/abstract> element for example)
are closed (ie, have closing tags to match their opening tags), but
the majority are not.  This is because the DTD tells 
the parser that a <code/title> element cannot contain an <code/author>
element, so the appearance of the latter implicitly finishes the
former.

<li>Some elements and attributes are required, others optional.  This
document is close to being a minimal SUN.  It is not quite minimal
because the <code/copyright> element is optional, and it turns out
that the only <em/required> content of a document 
body is the abstract!  Also, the only required attribute of the
<code/author> element is the <code/id> attribute.

<li>Starlink SGML documents are <em/case-sensitive> (unlike most SGML
documents).  The element names must all be lowercase, and SGML
reserved words uppercase, as in this example.

<li>There are actually more elements present here than are apparent to
the eye.  As well as allowing some closing tags to be omitted, a DTD
can be allow certain <em/opening> tags to be omitted, too.  In fact,
the full structure of this document is as seen in 
<ref id=fig.simplesun2/>.
</ul>
<figure float id="fig.simplesun2" export alt="Normalised SUN document">
<caption>A SUN document with all tags in place, the normalised version
of the document in <ref id=fig.simplesun/>.</caption>
<px>
<verbatim><![ CDATA [
<sun>
<docinfo>
<title>The Starlink SGML set</title>
<authorlist>
<author email="norman@astro.gla.ac.uk" webpage="http://www.astro.gla.ac.uk/users/norman" affiliation="University of Glasgow" id="ng">Norman Gray</author>
</authorlist>
<docnumber>1234</docnumber>
<history>
<version number="0" date="21-APR-1999" author="ng">
<px>Initial version</px>
</version>
</history>
</docinfo>
<docbody>
<abstract>
<px>This is a sample SUN</px>
</abstract>
<sect id="intro" export>
<subhead>
<title>Introduction</title>
</subhead>
<p>Starlink SUNs are easy to write.</p>
</sect>
</docbody>
</sun>
]]></verbatim>
</figure>

<p>In <ref id=fig.simplesun2/>, note that the actual content of
the <code/abstract> element is one or more <code/px> elements (a
slightly restricted variant of the standard <code/p> paragraph
element), and that the <code/sect> element contains a <code/subhead>
element, and <em/contains> the paragraphs which constitute it (note
that this is a significant difference from HTML, where the heading
elements <code/hn> contain only a section title).  You will rarely
have to be aware of these `hidden' tags when you are creating a
document, but it will occasionally be
useful to know that these tags are there somewhere, and that you're
glad you don't have to type all of them.
In fact, when I explain the document structure below, I will do it in terms
of the elements which are `really' there.

<p>`Markup minimisation', which is SGML's name for this, was
introduced to SGML to make typing less onerous.  Personally, I like
this, since it seems to make the document look less cluttered, and so
I have designed the DTD to support this quite extensively.  The
minimisation is completely optional, however, and you may insert all
the tags if you prefer.  SGML-aware editors (see <ref id=editors/>)
typically insert all tags.  See also <ref id=markup.min/>.  XML omits
this markup-minimisation feature.

<p>You can see from <ref id=fig.simplesun2/> that the `top-level'
element of this document is <code/sun>.  The top-level element of SSN
documents is <code/ssn>, and similarly for the other Starlink document
types (see <ref id=str.structure/>).  These different document types
are broadly the same, but the 
SSN document type does not, by default, include elements for documenting
programming code, and the MUD document type has a <code/docdate>
element instead of a <code/docnumber> and a <code/history>.  A
particular document can re-enable such omitted features using the
mechanism in <ref id=str.structure/>.  The SUN
document type is the most general.  The top-level <code/sun> element
has only two `children', <code/docinfo>, which contains the document
information such as its author, number, and so on, and <code/docbody>,
which contains the actual content of the document.

<subsect id=markup.entities export>Entity references

<p>Entity references are a mechanism for referring to characters, or
longer pieces of text, which you cannot type on your keyboard, which
must be escaped from the parser, which must be read from external
files, or which you simply want to abbreviate.

<p>A reference to an entity <code/amp> is of the form
<code/&amp;amp;>.  It is prefixed by the character <code/&amp> and
suffixed by a semicolon.

<p>The list of entities predefined by the Starlink general DTD is
given in <ref id=table.entities/>.

<table id="table.entities">
<caption>Entities predefined in the Starlink general DTD.</caption>
<tabular>
<tgroup cols="3">
<colspec colnum=2 align=center>
<thead>
<row><entry>Entity reference<entry>Replacement<entry>Description
<tbody>
<row><entry><code>&amp;copy;</code><entry>&copy<entry>Copyright symbol
<row><entry><code>&amp;amp;</code><entry><code>&amp</code><entry>ampersand
<row><entry><code>&amp;gt;</code><entry><code>&gt</code><entry>greater-than symbol
<row><entry><code>&amp;lt;</code><entry><code>&lt</code><entry>less-than symbol
<row><entry><code>&amp;quot;</code><entry>&quot<entry>quotation mark
<row><entry><code>&amp;nbsp;</code><entry>&nbsp<entry>non-breaking space
<row><entry><code>&amp;hash;</code><entry>&hash<entry>hash sign
<row><entry><code>&amp;pounds;</code><entry>&pounds<entry>pounds sign
<row><entry><code>&amp;dollar;</code><entry>&dollar<entry>dollar sign
<row><entry><code>&amp;ellip;</code><entry>&ellip<entry>ellipses
<row><entry><code>&amp;emdash;</code><entry>&emdash<entry>em dash
<row><entry><code>&amp;endash;</code><entry>&endash<entry>en dash
<row><entry><code>&amp;percent;</code><entry>&percent<entry>percent sign
<row><entry><code>&amp;deg;</code><entry>&deg<entry>degrees symbol
<row><entry><code>&amp;tilde;</code><entry>&tilde<entry>tilde
<row><entry><code>&amp;underscore;</code><entry>&underscore<entry>underscore
<row><entry><code>&amp;backslash;</code><entry>&backslash<entry>backslash
<row><entry><code>&amp;verticalbar;</code><entry>&verticalbar<entry>vertical bar
<row><entry><code>&amp;dot;</code><entry>&dot<entry>non-sentence-ending period
<row><entry><code>&amp;latex;</code><entry>&latex<entry>&latex logo
<row><entry><code>&amp;tex;</code><entry>&tex<entry>&tex logo
</row>
</tbody>
</tgroup>
</tabular>
</table>

<p>Certain of these entities are used sufficiently often that there
are `short references' declared for them: you can type `<code/_>'
instead of `<code/&amp;underscore;>' (unsurprisingly), `<code/&ddash>' for
a punctuation dash (this is currently set to `<code/&amp;endash;>', but
could conceivably change to `<code/&amp;emdash;>' if we make a
typographic decision on that score), `<code/&quot>' instead of
`<code/&amp;quot;>' and `<code/&tilde>' instead of
`<code/&amp;nbsp;>'.  These short-references work within paragraphs.

<p><update versionid="v0-7-11">Noted that entity references should not
be used inside maths elements.</update>See <ref id=str.maths/> for a
brief discussion of using entities within maths elements.

<p>For more details on entities, see <ref id=sgml.entities/>.

<subsect id=markup.dtdsubset export>Defining entities

<p>As explained in <ref id=markup.entities/>, there are a
number of predefined entities which you can refer to in your
documents.  These are defined either for general convenience or
because, as in the case of <code>&lt</code> and <code>&amp</code>,
the characters are significant to the SGML parser.

<p>You can, however, define entities yourself, perhaps to save typing,
or to parameterise a fragment of text which might change.  Also, you
would have to define an entity to refer to other files, or to other
SGML documents.

<p>You define entities in a section of the document which rejoices in
the name of the `internal declaration subset'.  This is a
fragment of SGML markup which is presented within the
<code>&lt;!DOCTYPE></code> declaration, which is formally read before
the reading of the actual DTD the declaration refers to.  There are
many things you can do within the DTD subset, up to and including a
partial rewrite of the DTD (this is generally felt to be A Bad Thing
-- do try to resist the temptation), but the main function of the DTD
subset in normal documents is to define a variety of types of
entities.  For more details about the DTD subset, see 
<ref id=sgml.dtdsubset/>.

<p>The DTD subset is the only place you can define entities -- the
<code>&lt;!ENTITY...></code> declaration is forbidden in the body of
the document.  While this is occasionally inconvenient, it helps keep
all the document's monkey-business in one place, and helps make future
processing that little bit more sane.

<subsubsect>Referring to text

<p>You can make an entity a shorthand for a piece of text which might
either need to be parameterised, or which it is simply inconvenient to
repeatedly retype.

<p>For example:

<verbatim><![CDATA[
<!DOCTYPE sun PUBLIC "-//Starlink//DTD Starlink SUN//EN" [
  <!ENTITY urlroot "http://www.astro.gla.ac.uk/users/norman">
]>
[...]
<p>Here is a <webref url="&urlroot;/star/" >web page</webref>
]]></verbatim>
When the document is parsed, the text for the entity
<code>urlroot</code> is substituted for the entity reference
<code>&amp;urlroot;</code>.

<subsubsect id=markup.files>Referring to files

<p>A feature of SGML's portability is that it abstracts the notion of
files: there are no `files' and `filenames' in the SGML world, only
<em/external entities> which have <em/public identifiers> or <em/system
identifiers>.  You can refer to these external entities as follows:
<verbatim><![CDATA[
<!DOCTYPE sun PUBLIC "-//Starlink//DTD Starlink SUN//EN" [
  <!ENTITY chapter1 SYSTEM 'chaptext/chapter1.text'>
  <!ENTITY fig1.eps SYSTEM 'figure1.eps' NDATA eps>
  <!ENTITY fig1.gif SYSTEM 'figure1.gif' NDATA gif89a>
  <!ENTITY sun199 
        PUBLIC "-//Starlink//DOCUMENT Summary SUN/199//EN" SUBDOC>
]>
]]></verbatim>

<p>There are four entities described here.

<p>`chapter1' is a reference to the object with system
identifier <code>chaptext/chapter1.text</code>.  A system identifier
can refer to an object in a wide variety of ways -- it could be a
database query, or system command -- but in the present system, a
system identifier is just a filename.  When you refer to this entity
by making the reference <code/&amp;chapter1;> where you might
otherwise type text, the SGML system would insert the contents of the
specified file in the document at that point.  This is a way of
breaking your document up into a collection of smaller documents.

<p>The two entities `fig1.eps' and `fig1.gif' are also references to
the two files `figure1.eps' and `figure1.gif' -- note the distinction
between the entity name and the file name.  These entity declarations
have extra information, however, indicating that their <em/notation>
is <code/eps> and <code/gif87a> respectively.  The system currently
recognises these notations, plus `jpeg'.  You would refer to these
entities in an attribute of a <code/figurecontent> element.  For an
overview of figure files, see <ref id=str.figures/>, and
for more details and the list of allowable notations, see the
<code/figurecontent> documetation in <ref id=el.sun.figurecontent/>.

<p>The last entity above is different in two ways.  Firstly, it does not refer
to a system identifier, but to a <em/public identifier>.  The SGML
system maps this identifier into a file using some internal database.
Note that the reference to the DTD, <code>"-//Starlink//DTD Starlink
SUN//EN"</code> is also a public identifier.  Secondly, the keyword
<code/subdoc> indicates that this entity is a <em/subdocument> entity
-- a complete SGML document which the SGML system will have to parse
at some point.  In this case, the entity <code/sun199> has been
declared so that it can be cross-referenced at some point.  See 
<ref id=str.xrefs/> for details.

<subsect id=markup.min export>Markup minimisation

<p>SGML was designed to be readable by computers, but it was also
designed to be written by humans<note>This is unlike XML, which is
likely to be written largely by authoring programs</note>.  It
therefore has several features -- collectively referred to as
<em/markup minimisation> -- designed to cut down the amount of
markup you have to write.

<p>The first such minimisation feature is tag omission: in certain
circumstances you may omit tags which are formally redundant.  This
can happen only when the SGML parser can reliably infer the presence
of the omitted tags, and when the DTD author has permitted this.  For
example, the content of the <ref id=el.sun.sect>sect</ref>
element is a subhead element, followed by zero or more paragraphs (or
figures or tables), followed by zero or more subsect elements.  That
is, the sect element <em/contains> the section, rather than containing
just the title (as is the case for HTML's <code/H1> element, for
example).  The <ref id=el.sun.subhead>subhead</ref> element
contains a <ref id=el.sun.title>title</ref> element, which
finally contains the text of the section heading.  In other words, the
structure of a section is
<verbatim><![CDATA[
<sect>
  <subhead>
    <title>Section 1</title>
  </subhead>
  <p>Paragraph text</p>
</sect>
<sect>
  ... <!-- and so on -->
]]></verbatim>
<p>This would be tedious to type.  However, the parser can infer the
end of the section and paragraph elements (from the start of the next
section and the end of the current section respectively), so those
closing tags can be omitted; and since the section
<em/must> start with a subhead, which <em/must> start with a title,
those tags are redundant, too.  That means that this can be compressed
to just
<verbatim><![CDATA[
<sect>Section 1
<p>Paragraph text
<sect>
...
]]></verbatim>

<p>Many closing tags can be omitted, and a few opening tags, too
(apart from subhead, about the only other one is 
<ref id=el.sun.px>px</ref> since it is the only permissable content
of elements like <ref id=el.sun.abstract>abstract</ref>).  If
you include tags redundantly it doesn't matter (and may even make the
text clearer in some cases), and if you omit them erroneously, the
SGML parser will quickly tell you.

<p>In cases where tags cannot be omitted, you can still cut down the
amount you have to type.  Instead of typing <code>&lt;em&gt;emphasised
text&lt;/em></code>, you can type just <code>&lt;em/emphasised
text&gt;</code>.<note>Note that this is different from the default
SGML minimisation, which would have <code>&lt;em/emphasised
text/</code> -- in order to be able to write XML-style
<code>&lt;ref/&gt;</code>
for empty elements, we had to change the form of this particular
minimisation option.  This much is a convenient shortcut. SGML defines
other tag minimisation locutions, so that
<code>&lt;p&lt;em/emph>&lt;/></code> is legal.  This rarely improves
readability, can get you into terrible messes, and is part of the
`parser hell' which XML was designed to avoid.  I mention it purely
for completeness; some of these rather more extreme minimisation
functions have been disabled in this SGML application.</note>

<p><update versionid="post-0.2">Added note to the effect that
attribute names can be minimised when the value is from a set</update>
In certain cases, attributes may have only one of a limited set of
values.  In this case, specifying one of these values is enough to
indicate which attribute you are referring to.  For example, the 
<ref id=el.sun.figure>figure</ref> element has a `float' attribute, which
can take either of the values `float' or `nofloat'.  You might
normally specify it as <code>&lt;figure float="nofloat"></code>, but
since the attribute values come from a limited set, this can be
abbreviated to <code>&lt;figure nofloat></code>.  The same is true of
the `export' attribute associated with exported IDs.

<p>SGML also has single-character entity references.  The character
<code><![CDATA[~]]></code> in normal text turns into the entity
<code/&amp;nbsp;>, and <code><![CDATA[--]]></code> (two hyphens) turns
into <code/&amp;endash;>.  Such `short reference' characters are used
a little more in the programcode DTD (see <ref id=doccode/>).

<subsect id=markup.ms export>Marked sections

<update versionid="post-0.2">Section added, with text
relocated from appendix. 

<p>A feature you will occasionally use in documents is the `marked
section'.  As an author, you will most likely only ever use the
<code/CDATA> marked section, but the <code/IGNORE> and <code/INCLUDE>
marked sections might also be useful, as well as being common within DTDs.

<p>A marked section is a construction such as
<verbatim>
Here is some text &lt;![ CDATA [ with &lt;odds&gt; &amp sods &rsqbrack;]>
</verbatim>
and
<verbatim>
Here is some text &lt;![ IGNORE [ and here is some ignored text &rsqbrack;]>
</verbatim>
Along with <code/IGNORE> there is <code/INCLUDE>.

<p>The marked section ends at the sequence of characters
<code/&rsqbrack;&rsqbrack;&gt;>, which is therefore the one sequence
which cannot appear within the marked section.

<p>There are some further technical details in <ref id=sgml.ms/>.

<subsubsect id=markup.ms.cdata>CDATA marked sections

<p>Within the <code/cdata> marked section, parsing is switched off, so
that angle brackets, <code/&lt>, and ampersands, <code/&amp>, are no
longer recognised as introducing markup and entity references.

<p>You will typically use a <code/CDATA> marked section to delimit
verbatim text.  The <code/code> and <code/verbatim> elements (see 
<ref id=el.sun.code/> and <ref id=el.sun.verbatim/>) do not make any
provision to switch off parsing of the text within them.  If the text
would be significant to the parser -- that is, if it contains angle
brackets or ampersands -- you must either escape those characters by
giving them as entity references <code/&amp;lt;> or <code/&amp;amp;>,
or else enclose the contents in a <code/CDATA> marked section as
follows.
<verbatim>
&lt;verbatim>&lt;![ CDATA [
Here is some &lt;em>marked-up&lt/em> text
which will be skipped &amp; ignored
&rsqbrack;&rsqbrack&gt;&lt;/verbatim>
</verbatim>
Within a CDATA marked section, no markup is recognised except the
<code/&rsqbrack;&rsqbrack;&gt;> which closes the marked section; thus element
start- and end-tags are not parsed, and entity references not expanded.

<subsubsect id=markup.ms.variants>Paper-only and web-only variants

<p>Text within <code/INCLUDE> and <code/IGNORE> marked sections is
parsed or skipped by the parser, as appropriate.  They are <em/not>
often used outside of DTDs, but the <code/IGNORE> marked section
is occasionally useful as a way of `commenting out' large sections of
text which might itself include SGML comments <code><![CDATA[<!--
... -->]]></code>.

<p>Sometimes, it is necessary to have parts of your document which
vary depending on whether the document is to be viewed on paper or
online.  In general, the best way to manage this is using the <ref
id=el.sun.span>span</ref> element (see <ref id=str.span/>), but this
is limited to use <em/within> paragraphs.  If you need to
conditionally include higher-level chunks of material, you will have
to resort to the blunter instrument of a marked section.  We may add a
suitable element to the DTD in future -- probably called <code/div> --
and deprecate this method.

<p>The Starlink general DTD defines two parameter entities
<code/&percent;Only.paper> and <code/&percent;Only.web>, which you can
use to include or ignore text in a marked section.  By default, both
of these are set to the string 
`IGNORE', but when you use the <code/sgml2docs> script (see 
<ref id=proc.sgml2docs/>), one or the other of these will be set to `INCLUDE', as
appropriate for the type of file being generated.

<p>You would use this facility as follows:
<verbatim>
&lt;p>Here is some text.
&lt;![ %Only.web [ And here is some which would appear
only in webpages. &rsqbrack;&rsqbrack;>
</verbatim>

<p>It is, I hope, clear that you could get yourself in a terrible mess
here, and create a document which is only valid for some settings of
the entities.  Please use this feature with restraint: take care that
your document remains valid for all
settings, <em/including> the case where both entities are set to `IGNORE'.


<subsect id=markup.try export>Try it yourself -- running the SGML parser

<p>Type the document given in <ref id=fig.simplesun/> into a file, and
check it with the distributed SGML parser, as follows.  

<p>Firstly, and most importantly, try converting your document to
HTML.  This uses the script <code/sgml2docs>.  If the document is in a
file <code/sun1234.sgml>, give the command <kbd/sgml2docs
sun1234.sgml>, which will transform your document into a collection of
HTML files, and package them up into a tar-file by the name of
<code/sun1234.tar>.  Alternatively, give the command
<kbd/sgml2docs --latex sun1234.sgml>, which will transform your
document into a &latex; file, and place it, and any figures required
for processing into a file <code/sun1234.tar> (note that the same
output filename is used for both formats, by default).  See <ref
id=proc.sgml2docs/> for further details and options.

<p>Another way of processing your document is to run the underlying
parser on the document -- this is the most efficient way of checking
that your document is valid, in the sense that it conforms to the DTD
is claims to.  Give the command <kbd>parse -s sun1234.sgml</kbd> (see
the detailed documentation for the <coderef id=parse
collection=upconvprogs>parse script</>).  This invokes the
<code/nsgmls> parser, and, with the <code/-s> option, suppresses all
output except warnings and error messages.  This means that for a
valid document, you should see precisely no output from this command.
If you want to see output, leave off the <code/-s> option and the
parser will produce a version of your document in a form (documented
<webref url="http://www.jclark.com/sp/sgmlsout.htm"
>elsewhere</webref>) which is easy for a downstream application to
parse.  If you are experiencing puzzling validation errors with a
document, it can occasionally be useful to examine this output: if you
can make sense of it, it gives you an authoritative account of what
the underlying parser sees in your document.

<p>There are several ways of parsing this output for yourself, should
you want to do that.  For example, <webref
url='http://www.cpan.org/modules/by-module/SGMLS/'
><code>SGMLSpm</code></webref> will parse this output format and allow
you to process SGML documents using Perl.  The crucial thing in this
case is the final line in the output, which should be a single `<code/C>'
command, indicating that the document conforms to its DTD.

<p>If you want to try normalising your document, give the command
<kbd>sgmlnorm sun1234.sgml</kbd>.  This transforms your document into
an equivalent one with all omitted elements reinserted.

<p>Try making parts of your document invalid, and comparing the error
with the error message <code/nsgmls> produces.


<sect id=structure export>The structure of the document

<p>In this section I will describe all of the elements of the General DTD,
grouping them by type.  There is an alternative description of the
elements, listed alphabetically, in <ref id=appx.general.dtd/>.

<p>The elements are thematically grouped in <ref id=table.elements/>,
and each of these groups is discussed in the indicated section.  Note
that the discussion there is intended to provide an overview of the
possibilities provided by the group, and it does not necessarily
describe all of the functionality available; see the individual
element listings for further details.

<p>Remember that the markup of your document is quite distinct from
its processing, so that not all elements and attributes will
necessarily have a detectable effect on the output (ie, formatted)
document you produce.  Nonetheless, you should future-proof your
document by including as much element and attribute detail as you can.

<table id=table.elements float>
<caption>
<px>DTD elements, grouped by type.
<px>Note that a few elements appear in more than one group.
</caption>
<tabular>
<tgroup cols="2">
<colspec colnum=2 colwidth="*">
<thead><row><entry>Group<entry>Elements
<tbody>
<row>
<entry>
<ref id=str.structure/>
<entry>
<ref id='el.sun.abstract' >abstract</ref>,
<ref id='el.sun.appendices' >appendices</ref>,
<ref id='el.sun.author' >author</ref>,
<ref id='el.sun.authorlist' >authorlist</ref>,
<ref id='el.sun.copyright' >copyright</ref>,
<ref id='el.sun.coverimage' >coverimage</ref>,
<ref id='el.sun.docbody' >docbody</ref>,
<ref id='el.sun.docinfo' >docinfo</ref>,
<ref id='el.sun.docnumber' >docnumber</ref>,
<ref id='el.sun.editors' >editors</ref>,
<ref id='el.sun.keyword' >keyword</ref>,
<ref id='el.sun.otherauthors' >otherauthors</ref>,
<ref id='el.sun.sun' >sun</ref>,
<ref id='el.sun.title' >title</ref>,
<ref id='el.sun.mapidlist' >mapidlist</ref>,
<ref id='el.sun.mapid' >mapid</ref>

<row>
<entry>
<ref id=str.sect/>
<entry>
<ref id='el.sun.sect' >sect</ref>,
<ref id='el.sun.subhead' >subhead</ref>,
<ref id='el.sun.subsect' >subsect</ref>,
<ref id='el.sun.subsubsect' >subsubsect</ref>,
<ref id='el.sun.subsubsubsect' >subsubsubsect</ref>
<ref id='el.sun.title' >title</ref>

<row>
<entry>
<ref id=str.backmatter/>
<entry>
<ref id='el.sun.backmatter' >backmatter</ref>,
<ref id='el.sun.citation' >citation</ref>,
<ref id='el.sun.index' >index</ref>,
<ref id='el.sun.note' >note</ref>
<!--
<ref id='el.sun.bibliography' >bibliography</ref>,
<ref id='el.sun.indexcontents' >indexcontents</ref>,
<ref id='el.sun.notecontents' >notecontents</ref>
-->

<row>
<entry>
<ref id=str.code/>
<entry>
<ref id='el.sun.codecollection' >codecollection</ref>,
<ref id='el.sun.routinelist' >routinelist</ref>

<row>
<entry>
<ref id=str.history/>
<entry>
<ref id='el.sun.change' >change</ref>,
<ref id='el.sun.distribution' >distribution</ref>,
<ref id='el.sun.docdate' >docdate</ref>,
<ref id='el.sun.history' >history</ref>,
<ref id='el.sun.update' >update</ref>,
<ref id='el.sun.version' >version</ref>

<row>
<entry>
<ref id=str.xrefs/>
<entry>
<ref id='el.sun.docxref' >docxref</ref>,
<ref id='el.sun.ref' >ref</ref>,
<ref id='el.sun.url' >url</ref>,
<ref id='el.sun.webref' >webref</ref>

<row>
<entry>
<ref id=str.figures/>
<entry>
<ref id='el.sun.caption' >caption</ref>,
<ref id='el.sun.figure' >figure</ref>,
<ref id='el.sun.figurecontent' >figurecontent</ref>

<row>
<entry>
<ref id=str.tables/>
<entry>
<ref id='el.sun.caption' >caption</ref>,
<ref id='el.sun.colspec' >colspec</ref>,
<ref id='el.sun.entry' >entry</ref>,
<ref id='el.sun.row' >row</ref>,
<ref id='el.sun.table' >table</ref>,
<ref id='el.sun.tabular' >tabular</ref>,
<ref id='el.sun.tbody' >tbody</ref>,
<ref id='el.sun.tgroup' >tgroup</ref>,
<ref id='el.sun.thead' >thead</ref>

<row>
<entry>
<ref id=str.text/>
<entry>
<ref id='el.sun.angle' >angle</ref>,
<ref id='el.sun.attribution' >attribution</ref>,
<ref id='el.sun.blockquote' >blockquote</ref>,
<ref id='el.sun.cite' >cite</ref>,
<ref id='el.sun.code' >code</ref>,
<ref id='el.sun.dd' >dd</ref>,
<ref id='el.sun.dl' >dl</ref>,
<ref id='el.sun.draftnote' >draftnote</ref>,
<ref id='el.sun.dt' >dt</ref>,
<ref id='el.sun.em' >em</ref>,
<ref id='el.sun.kbd' >kbd</ref>,
<ref id='el.sun.li' >li</ref>,
<ref id='el.sun.line' >line</ref>,
<ref id='el.sun.linespecific' >linespecific</ref>,
<ref id='el.sun.ol' >ol</ref>,
<ref id='el.sun.p' >p</ref>,
<ref id='el.sun.px' >px</ref>,
<ref id='el.sun.quote' >quote</ref>,
<ref id='el.sun.strong' >strong</ref>,
<ref id='el.sun.ul' >ul</ref>,
<ref id='el.sun.verbatim' >verbatim</ref>

<row>
<entry>
<ref id=str.maths/>
<entry>
<ref id='el.sun.m' >m</ref>,
<ref id='el.sun.meqnarray' >meqnarray</ref>,
<ref id='el.sun.mequation' >mequation</ref>,
<ref id='el.sun.mlabel' >mlabel</ref>,
<ref id='el.sun.mline' >mline</ref>,
<ref id='el.sun.mdefs' >mdefs</ref>.

<row>
<entry>
<ref id=str.span/>
<entry>
<ref id='el.sun.span' >span</ref>

</tbody>
</tgroup>
</tabular>
</table>

<subsect id=str.structure export>Overall structure

<p>Includes
<ref id='el.sun.sun' >sun</ref> (or whatever top-level element is
appropriate for the document type), which contains 
<ref id='el.sun.docinfo' >docinfo</ref> and
<ref id='el.sun.docbody' >docbody</ref>.  The former contains
<ref id='el.sun.abstract' >abstract</ref>,
<ref id='el.sun.author' >author</ref>,
<ref id='el.sun.authorlist' >authorlist</ref>,
<ref id='el.sun.copyright' >copyright</ref>,
<ref id='el.sun.coverimage' >coverimage</ref>,
<ref id='el.sun.docnumber' >docnumber</ref>,
<ref id='el.sun.editors' >editors</ref>,
<ref id='el.sun.keyword' >keyword</ref>,
<ref id='el.sun.manualtype' >manualtype</ref>,
<ref id='el.sun.otherauthors' >otherauthors</ref>,
<ref id='el.sun.softwareversion' >softwareversion</ref>,
<ref id='el.sun.mapidlist' >mapidlist</ref>,
<ref id='el.sun.mapid' >mapid</ref>,
<ref id='el.sun.title' >title</ref>; and the latter contains the body
text, the backmatter, and the
<ref id='el.sun.appendices' >appendices</ref>.

<p>An SGML document always starts with a doctype declaration.  There
are seven document types defined at present:
<verbatim><![CDATA[
<!DOCTYPE sug PUBLIC "-//Starlink//DTD Starlink SUG//EN">
<!DOCTYPE sun PUBLIC "-//Starlink//DTD Starlink SUN//EN">
<!DOCTYPE ssn PUBLIC "-//Starlink//DTD Starlink SSN//EN">
<!DOCTYPE sgp PUBLIC "-//Starlink//DTD Starlink SGP//EN">
<!DOCTYPE sc  PUBLIC "-//Starlink//DTD Starlink SC//EN">
<!DOCTYPE sg  PUBLIC "-//Starlink//DTD Starlink SG//EN">
<!DOCTYPE mud PUBLIC "-//Starlink//DTD Starlink MUD//EN">
]]></verbatim>
These cover, respectively, the Starlink User Guide, Starlink user
notes, system notes, general papers, cookbooks, and guides, and
Miscellaneous User Documents.  These document types are broadly the
same (there is a single DTD underlying them all), but the different
types have different features, summarised in 
<ref id=table.dtdfeatures/>.

<table id=table.dtdfeatures>
<caption>
Starlink DTD feature summary
</caption>
<tabular>
<tgroup cols="6">
<thead>
<row>
<entry>DTD
<entry>Abstract<entry>Versioning<entry>Docnumber<entry>Routinelist<entry>EnforceLinkPolicy
<tbody>
<row>
<entry>sug
<entry>yes<entry>yes<entry>no<entry>no<entry>yes
<row>
<entry>sun
<entry>yes<entry>yes<entry>yes<entry>yes<entry>yes
<row>
<entry>ssn
<entry>yes<entry>yes<entry>yes<entry>no<entry>yes
<row>
<entry>sgp
<entry>yes<entry>yes<entry>yes<entry>no<entry>yes
<row>
<entry>sc
<entry>yes<entry>yes<entry>yes<entry>no<entry>yes
<row>
<entry>sg
<entry>yes<entry>yes<entry>yes<entry>no<entry>yes
<row>
<entry>mud
<entry>opt'l<entry>no<entry>yes<entry>no<entry>no
</tbody>
</tgroup>
</tabular>
</table>

<p>The table headings in <ref id=table.dtdfeatures/> are as follows:
<dl>
<dt>Abstract
<dd>Is an abstract required or optional.
<dt>Versioning
<dd>Is the history mechanism, described in <ref id=str.history/>
required?  If not, the <ref id=el.sun.docdate>docdate</ref>
element is required.
<dt>Docnumber
<dd>Is a document number required?
<dt>Routinelist
<dd>Are the code-documentation elements, described in 
<ref id=str.code/> available?
<dt>EnforceLinkPolicy
<dd>Is the link policy enforced?  See <ref id=str.xrefs/>.
</dl>

<p>These defaults are generally appropriate for the type of document.
If you need to change them for a particular document, however, you
can.  The only case where you are likely to need to change the
default is in in the case of the routine-list feature, if you wish to
add it to a document type which does not have it by default, and you do this by
invoking the SSN DTD (for example) as follows
<verbatim><![CDATA[
<!DOCTYPE ssn PUBLIC "-//Starlink//DTD Starlink SSN//EN" [
  <!ENTITY % Feature.Routinelist 'INCLUDE'>
]>
]]></verbatim>
Note that the entity names are case-sensitive, and note the space
after the `<code/%>' sign.

<p>The top-level element in the document contains two elements, 
<ref id=el.sun.docinfo>docinfo</ref> and
<ref id=el.sun.docbody>docbody</ref>. The second contains all the text of the document, and
the first all the `meta-information' -- the author, title, keywords,
and so on, which are important for identifying and indexing the
document.  The docinfo elements should be self-explanatory, with the
exception of the history element, which is discussed in 
<ref id=str.history/>.

<p>The docbody element contains all the text of the document.
Any document appendices are gathered together in a single 
<ref id=el.sun.appendices>appendices</ref> element, with each appendix in a
<ref id=el.sun.sect>sect</ref> element.

<p>Material such as a bibliography and endnotes do not go in an
appendix, but in a separate backmatter element (see 
<ref id=str.backmatter/>).

<subsect id=str.sect export>Sectioning

<p>Includes
<ref id='el.sun.sect' >sect</ref>,
<ref id='el.sun.subsect' >subsect</ref>,
<ref id='el.sun.subsubsect' >subsubsect</ref>
and
<ref id='el.sun.subsubsubsect' >subsubsubsect</ref>,
which contain the section contents, preceded by 
<ref id='el.sun.subhead' >subhead</ref>, which contains the section
<ref id='el.sun.title' >title</ref>.

<p>The sect element and friends contain the section content (note
that this is different to the behaviour of &latex and HTML, in both of
which the sectioning commands enclose only the section heading).

<p>The content of the sectioning elements start with a 
<ref id=el.sun.subhead>subhead</ref> element, which in
turn contains a <ref id=el.sun.title>title</ref> element, and the
two are followed by the section 
content. Note, however, that since the subhead and title start and end
tags are both omissable (see <ref id=markup.min/>), you may omit both,
and follow the sect start 
tag immediately with the section title.
That is, the structure is formally
<verbatim><![CDATA[
<sect><subhead><title>Section title</title><subhead>
<p>Section body</p>
</sect>
]]></verbatim>
but this may be abbreviated to just
<verbatim><![CDATA[
<sect>Section title
<p>Section body
]]></verbatim>

<p>The sectioning elements have an ID attribute, which allows you to
specify a unique label with which you can refer to the section.  For
both the sect and subsect elements, this ID attribute is required by
the DTD (when the <code>EnforceLinkPolicy</code> feature is enabled --
see <ref id=str.structure/>).  See also <ref id=str.xrefs/> for more
detail on cross-referencing.

<subsect id=str.backmatter export>Backmatter -- notes and bibliography
<update versionid="post-0.2">
Removed mention of the deleted backmatter content elements</update>
<update versionid="post-v0-5">Emphasised that notes will not appear
unless backmatter element is present</update>

<p>The
<ref id='el.sun.backmatter' >backmatter</ref> element
<!--
includes the
<ref id='el.sun.bibliography' >bibliography</ref>,
<ref id='el.sun.indexcontents' >indexcontents</ref> and
<ref id='el.sun.notecontents' >notecontents</ref>
elements, stocked by
-->
is stocked by the 
<ref id='el.sun.citation' >citation</ref>,
<ref id='el.sun.index' >index</ref> and
<ref id='el.sun.note' >note</ref>
elements.

<p>Within your document you may refer to books and articles using the
citation element, and these are collected together in the backmatter
element.  The DTD is quite generic, but in this application, the
bibliography is implemented as a Bib&tex database, so that the
backmatter element's `bibliography' attribute names a Bib&tex
<code>.bib</code> file (without the <code/.bib> extension), and the
citation element's content is a Bib&tex entry key.  Note that the
Bib&tex; processing of your document is done within the context of a
temporary work directory (see <ref id=proc.sgml2docs/>), so you might have
to specify Bib&tex;'s <code/BIBINPUTS> environment variable if
Bib&tex; is to find your bibliography database.  There is no way (at
present) to specify the bibliography formatting style -- the SGML set
uses a customised bibliography style which, incidentally, supports a
URL field in bibliography entries.  See the Bib&tex documentation in,
for example, <citation/lamport> for further details.

<p>You can include notes in your document with the note element.
At present, the notes are presented as footnotes in
the paper version of your document and collected together as endnotes
in the online version.
<!--
Note that since the notes are collected within
the backmatter element, the notes <em/will not be printed> unless
a backmatter element is present.
-->

<p>Although the indexing support is defined in the DTD, there is not
yet any application support for it.  It is likely to use the
<code/makeindex> system associated with &latex;.

<subsect id=str.code export>Documenting code

<p>The 
<ref id='el.sun.routinelist'>routinelist</>
element contains one or more
<ref id='el.sun.codecollection'>codecollection</>
elements.

<p>The routinelist element can be included in any of the sectioning
elements of <ref id=str.sect/>, and replaces any other content that
section might have.  It contains one or
more codecollection elements, each of which makes a link between the
general documentation and a specific file marked up using the
<code/programcode> DTD.  See <ref id=doccode/> for details.

<p>These elements are available only if the document type has the
`Routinelist' feature enabled.  See <ref id=str.structure/>.

<subsect id=str.history export>
<subhead>
<title>History</title>
<update versionid="v0-7-13-edit1">
<px>Added a statement of the syntax for dates, even though this is
briefly repeated in element documentation.</px>
</update>
</subhead>

<p>Includes
<ref id='el.sun.change' >change</ref>,
<ref id='el.sun.distribution' >distribution</ref>,
<ref id='el.sun.docdate' >docdate</ref>,
<ref id='el.sun.history' >history</ref>,
<ref id='el.sun.update' >update</ref>,
<ref id='el.sun.version' >version</ref>.

<p>In a large document which will be revised in future, it is
important to preserve some document history.  This means that readers
can check which version of a document they are reading, and find what
parts of it have changed since the last version they are familiar with.

<p>The history element, within in the docinfo element (see 
<ref id=str.structure/>), records the history of the document.  It is
available in most of the Starlink DTDs, but not all, and when it is
omitted, the <ref id=el.sun.docdate>docdate</ref> element is
required instead.

<p>The history of a document is composed of a sequence of versions,
distributions and changes.  A document has a version number of the
form <code/docnumber.docversion-distribution>.  The document number is the
number declared in the <ref id=el.sun.docnumber>docnumber</ref>
element, as assigned by the Starlink librarian.  The document version
indicates which edit of the document this is -- a significant update
to the document should be marked by incrementing the document version
number.  The release information marks a more minor update to a
document.

<p>All dates within these elements have the format <code/dd-mmm-yyyy>, 
where <code/dd> indicates a <em/two-digit> day number, <code/mmm> a
three-letter month name (such as <code/jan>, <code/feb> and so on, in
any mixture of case), and <code/yyyy> a four-digit year number.  Let's 
keep things Gregorian -- no Julian, French-revolutionary or Mayan
dates, if you would be so kind.

<p>Each of the three elements has paragraph content, to record brief notes
about the change or distribution.

<p>A version of a document (marked by a <ref
id=el.sun.version>version</ref> element in the history) is a
significant release of a document, perhaps describing new
functionality in a package.  The number attribute gives the version
number to be attached to the document.

<p>A distribution of a document (marked by a 
<ref id=el.sun.distribution>distribution</ref> element in the history) is
a less significant update to a document, perhaps for distribution to
readers for comments.  The <code/string> attribute is a label for the
distribution, and could be something like `draft1' or `comments-13',
or `DR-0.7-8'.

<p>Other changes to the document are labelled by a 
<ref id=el.sun.change>change</ref> element.  These record an edit of a
document without a corresponding change to a version number.

<p>The <ref id=el.sun.distribution>distribution</ref> and 
<ref id=el.sun.change>change</ref> elements have an optional
<code/versionid> attribute.  This allows you to specify a label for
this edit.  Any <ref id=el.sun.update>update</ref> elements
elsewhere in the text must attach themselves to one of these elements,
using the <code/versionid> attribute.

<p>For example:
<verbatim><![ CDATA [
<author id=ng>Norman
<editors>
<author id=mb>Martin
...
<history>
<version author=ng date='02-MAR-1999' number=0>Initial version
<distribution author=ng date='03-MAR-1999' string='comm-0.1'>Released
  to programmers for comment.
<change author=ng date='04-MAR-1999' versionid=post-0.1>Various tidyings
<version author=mb date='05-MAR-1999' number=1>First public release
...
<p><update versionid=post-0.1>Corrected typos and reexpressed
argument</update>In this section....
]]></verbatim>
Presumably, the `comm-0.1' release of the document elicited some
comments, and the resulting changes have been logged by the change
element immediately following it.  Any (optional) update elements
scattered throughout the document (they can be children of the list
structures, figures, tables, paragraphs, and the document body itself)
can link back to this element to inherit its authorship and date.
These updates could be collected together by an application, to
generate a change log, or a `new in this release' section.

<subsect id=str.xrefs export>Cross-references
<update versionid="v0.6">Noted that the stylesheets deal gracefully
with missing FPIs</update>

<p>Includes
<ref id='el.sun.docxref' >docxref</ref>,
<ref id='el.sun.ref' >ref</ref>,
<ref id='el.sun.url' >url</ref>
and
<ref id='el.sun.webref' >webref</ref>.

<p>Writing a document, you frequently wish to refer to other parts of
the same or other documents, or else to documents scattered around the
web.

<p>The cross-reference element you will use most often is the 
<ref id=el.sun.ref>ref</ref> element, which refers to another part of the
same document.  It takes a required `id' attribute, giving the ID of
the element you wish to refer to; any element with an ID attribute may
be referred to.  This will produce a named reference to the target
element, based on the type and name of that element, and will make a
link to it if the output format allows that.  If the element has any
content, this will be used as the link text; if it has no content, the
link text will be generated, as something like `Section xxx'.
For example, there is a link, above, to the ref element's
documentation, which was specified in this document's source as
<code>&lt;ref id=el.sun.ref>ref&lt;/ref></code>, but I could have
written just <code>&lt;ref id=el.sun.ref/></code> to get <ref id=el.sun.ref/>.

<p>The <ref id=el.sun.docxref>docxref</ref> element refers to all or
part of another Starlink document.  To use this, you must declare an
entity which refers to the document as follows:
<verbatim>
&lt;!DOCTYPE sun PUBLIC "-//Starlink//DTD Starlink SUN//EN" [
  ...
  &lt;!ENTITY otherdoc 
    PUBLIC "-//Starlink//DOCUMENT Summary SUN/123//EN" SUBDOC>
  ...
]>
</verbatim>
Once you have done that, you can refer to that document with a docxref
element, <code>&lt;docxref doc=otherdoc/></code>.  If you wish, you can
refer to a specific ID within that document using the `loc'
attribute.

<p>In future, the SGML kit will be set up so that this `formal public
identifier' (FPI) will map to a summary document which will allow the
SGML system to effectively query the target document.  At present,
however (release DR-0.7), it has been decided to distribute the kit
with these document summaries missing, and so the down-converters have
been written so that they fail gracefully and silently in this case,
and generate a link to the Starlink documents available at RAL <em/if>
the FPI is declared in this correct format.  Jade will <em/warn> you
about its inability to resolve the FPI, but this can be ignored. See
<ref id=appx.system.summaries/> for maintainer-level discussion of
document summaries.

<p>More straightforwardly, you can use the <code>docxref</code>
element without declaring entities, by simply giving the document
reference as the value of the `doc' attribute: <code>&lt;docxref
doc='SUN/123'/&gt;</code>.  In this case, the link is generated by the
same basic algorithm as mentioned in the previous paragraph.  This is
less robust than using document summaries, but usually good enough.

<p>When linking to other Starlink documents, you may only link to IDs
which have been `exported' from the document; by the same mechanism,
others may only link to IDs which you have exported from your
document.  You export an ID by giving the attribute `export' alongside
the `id' attribute.  To ensure that there is a rich field of targets
for other documents (see also <docxref doc=sun188
loc=establishing_cross_references/>), most of the Starlink document
types enforce a `link policy' (see the `EnforceLinkPolicy' feature in
<ref id=str.structure/>), requiring that <em/all> sect and subsect
elements (at least) have both the `id' and `export' attributes
present.  Note that the export attribute must be explicitly present --
it is not automatically inserted or assumed -- even though it is
redundant when it is mandatory.  The `export' attribute is thus both
an indication to the processing system that it may link to this
element from outside, and an explicit warning to future
maintainers of the document that they should not delete or change this
ID.

<p>The <ref id=el.sun.webref>webref</ref> and 
<ref id=el.sun.url>url</ref> elements are straightforward: they both refer to a
resource on the web.  The webref element is much like HTML's <code/a>
element, providing link text and a URL for the target; the url element
quotes the URL directly.

<p>As rather a special case, these cross-reference elements are
allowable in the <ref id=el.sun.verbatim>verbatim</ref> element,
which is occasionally quite useful.  For example, the contents of 
<ref id=figure.programcode/> makes extensive use of this, to link from the
element names to their documentation in 
<ref id=appx.programcode.dtd/>.  This application uses the ref element's
text attribute, and the result is that the link disappears in the
paper version of the document.  I don't imagine that the docxref
element would often be useful here, but url and webref might be.

<subsect id=str.figures export>Figures
<update versionid=v0-4>Rewrote section to match new figures structure</update>

<p>Includes
<ref id='el.sun.figure' >figure</ref>,
<ref id='el.sun.caption' >caption</ref> and
<ref id='el.sun.figurecontent' >figurecontent</ref>.

<p>You may include images and other figures within your document using
the figure element.  A figure consists of a caption, optionally
followed by a sequence of figurecontent elements, optionally followed
by a single block of px elements.  You provide a
figurecontent element for each alternative figure format you provide.
The processing system selects a usable format from those available;
not all processors can use all formats, so that it would be desirable
to provide an image in both EPS and GIF format, if you can.

<p>You can provide paragraphs of text (perhaps containing a 
<ref id=el.sun.verbatim>verbatim</ref> element) as figure content.

<p>For details, and an example, see <ref id=el.sun.figurecontent/>.

<subsect id=str.tables export>Tables
<update versionid="v0-4">Include description of new tabular element</update>
<update versionid="post-v0-4">
Clarified description of tabular element, and linebreaks.</update>
<update versionid="v0.6">
Principal table attributes now supported in &latex; down-converter.</update>


<p>Includes
<ref id='el.sun.caption' >caption</ref>,
<ref id='el.sun.colspec' >colspec</ref>,
<ref id='el.sun.entry' >entry</ref>,
<ref id='el.sun.row' >row</ref>,
<ref id='el.sun.table' >table</ref>,
<ref id='el.sun.tabular' >tabular</ref>,
<ref id='el.sun.tbody' >tbody</ref>,
<ref id='el.sun.tgroup' >tgroup</ref>,
<ref id='el.sun.thead' >thead</ref>.

<p>The table element contains a tabular element.  The distinction
between the two is that the tabular is the object which contains data
lined up in columns, whilst the table is an object which might float
from its declared position, which has a caption, and
which can be referred to from elsewhere.

<p>The tabular element will most commonly be used within a table
element, but it is also permissible within ordinary paragraphs.  Note,
however, that the tabular element does not necessarily have a
linebreak before and after it in this case.  If you want the tabular
to go on a line by itself (which will usually be the case), you should
include it within a <ref id='el.sun.blockquote' >blockquote</ref>
element.

<p><update versionid="post-0.2">Corrected Oasis URL</update> The
Starlink DTDs use the `Oasis Exchange Table Model' (OASIS document
<webref url='http://www.oasis-open.org/html/a503.htm' >OASIS
TR9503:1995</webref>) as the basis for their tables.  Even though it
is only a portable subset of a more elaborate standard (the
industry-standard CALS table model), there is more in the table model
than has yet been implemented in the Starlink application.  You may
use in your documents all of the elements and attributes in the Oasis
model, but some of the lesser-used attributes are not supported.

<p>The support for Oasis table attributes is as shown in 
<ref id=table.oasis/>.
<table id=table.oasis>
<caption>
Support for Oasis table attributes in Starlink DTDs
</caption>
<tabular>
<tgroup cols="3" align=center>
<colspec colnum=1 align=left>
<colspec colnum=2 colwidth="*">
<colspec colnum=3 colwidth="*">
<thead>
<row>
<entry>Element<entry>Supported<entry>Unsupported
<tbody>
<row>
<entry>tabular<entry>colsep, frame, rowsep<entry>pgwide
<row>
<entry>tgroup<entry>align, cols, colsep, rowsep<entry>(none)
<row>
<entry>thead<entry>(none)<entry>valign
<row>
<entry>tbody<entry>(none)<entry>valign
<row>
<entry>colspec<entry>align, colname, colnum, colsep, rowsep, colwidth
	<entry>char, charoff
<row>
<entry>row<entry>rowsep<entry>valign
<row>
<entry>entry<entry>colname, namest, nameend
	<entry>align, char, charoff, colsep, morerows, rowsep, valign
</tabular>
</table>

<!--
<p>In the current release of the Starlink SGML set, all of the
elements and attributes in the Oasis model are permitted in the
documents you write, but most of the attributes are ignored.  Support
for these will likely be added in future releases, but the only real
inconvenience is that there is currently no control over column
alignment.  Please let me know which features you would like to be
given priority.
-->

<p>You lay out a table as follows:
<verbatim><![CDATA[
<table id="table.entities">
<caption>Entities predefined in the Starlink general DTD.</caption>
<tabular>
<tgroup cols="3">
<colspec colnum=2 align=center>
<thead>
<row><entry>Entity reference<entry>Replacement<entry>Description
<tbody>
<row><entry><code/&amp;copy;><entry>&copy<entry>Copyright symbol
<row><entry><code/&amp;amp;><entry><code/&amp><entry>ampersand
</tabular>
</table>
]]></verbatim>
You specify an ID for the table, and optionally also the `export'
attribute, in the table start tag.  A tabular can have a number of
groups of rows, contained within tgroup elements, and it is in the
start-tag of the tgroup element that you specify the number of columns in
rows in that group.  A group of rows consists of an optional group of
heading rows, followed by one or more groups of body rows.  Each row
consists of a sequence of entry elements.

<p>For more detailed documentation on the tabular element, see <ref
id=el.sun.tabular/> and the documentation of the other tabular
elements.  For alternative documentation, including documentation of
the currently unsupported features, see the Oasis document referred to
above.

<subsect id=str.text export>Text markup
<update versionid="v0.6">Added paragraph describing ANGLE element</update>

<p>Paragraphing
(<ref id='el.sun.p' >p</ref> and
<ref id='el.sun.px' >px</ref>): element p is the normal paragraph,
element px is a restricted paragraph used in the abstract, for
example.  The restricted paragraph is just like the normal one except
that there are a few elements (index, note and draftnote) which may
not appear.

<p>The paragraph elements have an `id' attribute, which allows you to
refer to them using a ref element (see <ref id=el.sun.ref/>).  This
reference will, however, typically be a reference to the section which
contains the paragraph rather than to the paragraph specifically.
This is an instance of the more general warning that you should 
make few assumptions about how elements are rendered, when you are
authoring a document.

<p>Text style
(<ref id='el.sun.em' >em</ref>,
<ref id='el.sun.strong' >strong</ref>,
<ref id='el.sun.cite' >cite</ref>,
<ref id='el.sun.draftnote' >draftnote</ref>): em and strong indicate
degrees of emphasis; cite refers to the title of something such as a
book; and draftnote is a reminder usable whilst drafting a document,
which should be prominently displayed in some way.

<p>Verbatim text
(<ref id='el.sun.code' >code</ref>,
<ref id='el.sun.verbatim' >verbatim</ref>,
<ref id='el.sun.kbd' >kbd</ref>,
<ref id='el.sun.linespecific' >linespecific</ref>):
The `code' and `kbd' elements are verbatim text, displayed using a
fixed-width font in 
the line of a paragraph; the distinction is that kbd text might be
displayed in some way which indicated that it is text a user should
type.  Verbatim content is displayed in a fixed-width font, respecting
line-breaks.  Note that none of these elements perform any escaping of
their contents -- if there are any characters in the content which
would be of significance to the SGML parser (such as <code/&amp> or
<code/&lt>), they should either be escaped with entity references
(<code/&amp;amp;> or <code/&amp;lt;>) or else the content should be
enclosed in a CDATA marked section as follows (see also 
<ref id=markup.ms.cdata/>).
<verbatim>
&lt;verbatim>&lt;![ CDATA [
Here is some &lt;em>marked-up&lt/em> text
which will be skipped &amp; ignored
&rsqbrack;&rsqbrack>&lt;/verbatim>
</verbatim>

<p>The `linespecific' element is slightly different.  It is intended to
mark up a block of text where the linebreaks are significant, but the
text is not otherwise verbatim; the canonical example is that of
verse.  It consists of a sequence of `line' elements.

<p>Quotations
(<ref id='el.sun.quote' >quote</ref>,
<ref id='el.sun.blockquote' >blockquote</ref>,
<ref id='el.sun.attribution' >attribution</ref>): a short quotation
may be enclosed in a quote element, and a longer one in a blockquote
element. In both cases, the content may start with an attribution
element, which notes the source of the quotation.

<p>Lists
(<ref id='el.sun.ol' >ol</ref>,
<ref id='el.sun.ul' >ul</ref>,
<ref id='el.sun.dl' >dl</ref>,
<ref id='el.sun.dt' >dt</ref>,
<ref id='el.sun.dd' >dd</ref>,
<ref id='el.sun.li' >li</ref>): These are the ordered, unordered and
description lists familiar from HTML.  Unlike HTML, however, the dt
and dd elements within the description list must be paired.

<p>Angles (<ref id='el.sun.angle' >angle</ref>): as appropriate for a
DTD designed to document astronomical software, there is a special
element for referring to astronomical angles.  This is an empty
element, with the components of the angle specified as attributes.
See <ref id='el.sun.angle' />.

<p>For example:
<verbatim>&lt;angle angle=45 minutes=30 seconds=10 fraction=0/&gt; is
an angle in 
degrees (the default), and &lt;angle unit=hours angle=6 minutes=45/&gt; is
an angle in hours, with the number of seconds and fractions of seconds
omitted.  An angle like &lt;angle angle=1000 fraction=10/&gt; is
syntactically acceptable, but astronomical nonsense.
</verbatim>
This produces: <angle angle=45 minutes=30 seconds=10 fraction=0/> is
an angle in 
degrees (the default), and <angle unit=hours angle=6 minutes=45/> is
an angle in hours, with the number of seconds and fractions of seconds
omitted.  An angle like <angle angle=1000 fraction=10/> is
syntactically acceptable, but astronomical nonsense.


<subsect id=str.maths export>Maths
<update versionid="v0-4">Slight edit to discuss new mline and mlabel
elements</update>
<update versionid='v0-7-11'>Substantial edit.  Changes to shortref
cleverness made some of the advice in here wrong.  It now tells folk
not to use entity references at all in maths.
</update>

<p>Includes
<ref id='el.sun.m' >m</ref>,
<ref id='el.sun.mequation' >mequation</ref>,
<ref id='el.sun.meqnarray' >meqnarray</ref>,
<ref id='el.sun.mlabel' >mlabel</ref>,
<ref id='el.sun.mline' >mline</ref>,
<ref id='el.sun.mdefs' >mdefs</ref>.

<p>All the maths in Starlink documents uses &latex;
notation.<note>MathML was considered, but is neither well-supported in
browsers, nor designed to be easily written by hand.</note>  The `m'
element is equivalent to <code/&dollar;...&dollar>, `mequation' is
equivalent to <code>\begin{equation} ... \end{equation}</code> and
`meqnarray' is equivalent
to <code>\begin{eqnarray} ... \end{eqnarray}</code>,
with the exception that the `meqnarray' elements contains a sequence
of `mline' elements, rather than having the equation lines separated
by <code>\\</code> commands.

<p>Within the `mequation' and `mline' elements, you may have a single
`mlabel' element.  If this is present, the equation is numbered, and
if you give it an ID, you can refer to that equation number from elsewhere.

<p>Note that, although the parser `knows'
that the content of these elements is in &latex notation there is no
suppression of markup-recognition within them -- entity references and
element start-tags are still recognised as such by the parser.

<p>When you are typing maths, switch your brain completely into
&latex;-mode, and do not use SGML entity references for things like
ampersands, backslashes and the like.  If you do use these, they will
generally appear to 
work, in the sense that your document will process without errors, but
the results will be different from what you expect<note>For example,
<code/&amp;amp;> inside an <code>&lt;meqnarray&gt;</code> element
results in a literal ampersand in the maths, rather than being
interpreted as alignment characters.  I could go on (you guessed!), but
even at this 
temporal distance, I feel my reader's tolerance for parser detail
gurgling down the plughole.</note>.  When you are typing maths,
therefore, you have to make sure you do not type anything the
SGML parser thinks it ought to pay attention to.  That means that
occurrences of <code/&amp> and <code/&lt> should not look like entity
references or tags.  SGML recognises these bits of markup only in
context: only if an ampersand or less-than symbol is immediately
followed by a name-start character (an upper- or lowercase letter) is
it recognised as an entity reference or element start-tag (so that
none of `<code>& x;</code>', `<code>< x></code>' and `<code></ x></code>'
are recognised as entity references or tags).  Thus the following
element is correctly formed:
<verbatim><![CDATA[
<meqnarray><mline>x&\sim& a<mline>\delta&=&4< x</meqnarray>
]]></verbatim>
Rather than worrying about the details of this rule, however, 
the best practice when typing meqnarray
elements is to reflexively put a space after all occurrences of
<code/&amp;> and <code/&lt;>: this will keep the SGML parser from
interfering, and make no difference to &latex, which ignores all
spaces in maths mode anyway.

<p>Alternatively, you can surround the maths element with a CDATA
marked section (see <ref id=markup.ms.cdata/>).  That's more typing,
but switches off SGML recognition completely:
<verbatim>
&lt;meqnarray>
&lt;mline>&lt;![CDATA[    a&lt;b&lt;c&amp;\sim&amp;x    ]]&gt;
&lt;mline>x & = & y
&lt;/meqnarray>
</verbatim>
Hmm -- typing a few extra spaces won't hurt you.

<p>If you need or wish to make some definitions which are to be
effective in all sucessive maths elements -- for example you want to
write the abbreviation <code>\def\degs{^\circ}</code> -- you can put
them in an <ref id=el.sun.mdefs>mdefs</ref> element.  This sits
between or before paragraphs.

<p>The contents of the <code/mdefs> element are processed as arbitrary
&latex;.  However, you should not include anything other than
definition commands and possibly other parameters to do with the
layout of maths, and specifically you should write nothing which
creates any output.  Although this element is processed fairly
straightforwardly when generating &latex; output, the content is moved
around quite a lot when producing HTML output, and hacky fiddling here
has the potential to mess up your document in the present and, what is
much worse, <em>become wrong</em> when processed by a later version of
the down-converter.  In other words: <em>Do Not Hack This!</em></p>


<subsect id=str.span export>Output depending on media type
<update versionid="v0-6-3">Added this section</px>

<p>Includes
<ref id='el.sun.span' >span</ref>.

<p>In certain circumstances, you need to make the text of your
document sensitive to the output medium.  For example, when
documenting a routine prologue (which documentation might reasonably
be expected to be read in a character-based format such as a HLP
file), you might want to write
<verbatim><![CDATA[
The length is
<span media='screen,print'><m>x=r\sin \theta</m></span>
<span media='tty'><code>x = r * sin(theta)</code></span>
]]></verbatim>
to give different versions based on the intended output format.  For
further details, and the list of output media, see 
<ref id=el.sun.span>the span documentation</ref>.

<p>Note that this element can control output only <em/within> a
paragraph.  We may add another element -- probably called <code/div> --
which functions higher up the element hierarchy, but until then, you
will need to use <ref id=markup.ms.variants>marked sections</ref>.

<sect id=doccode export>Documenting source code
<update versionid=v0-6-1>Mention coderef</update>

<p>Many -- perhaps most -- Starlink documents exist to describe a body
of program code, and while the general behaviour and usage of that
program can be described in a document such as this one, the details
of the implementation might be most sensibly kept with the program
code itself.  The Starlink DTDs have facilities to do precisely this,
associating documentation directly with program code, and associating
that detailed documentation with user documents.

<p>As described in <ref id=str.code/>, the Starlink General DTD has an
element <ref id=el.sun.routinelist>routinelist</ref>, containing one
or more <ref id=el.sun.codecollection >codecollection</ref> elements.
Each of these latter elements makes a link between the documentation
and a document marked up using the programcode DTD, which I will now
describe.

<p>If you wish to refer to some element within the codecollection, say
a function to which you gave the ID <code/myfunc> by specifying an
`id' attribute to a <ref id=el.programcode.routine>routine</ref> or
<ref id=el.programcode.routinename>routinename</ref> programcode
element, you do so <foreign/via> the `codecollection' element.  You
make the reference using the <ref id=el.sun.coderef>coderef</ref>
element, which takes two attributes: an ID for the
`codecollection' which contains the programcode file, and (required)
the name of the ID within that file.  For example (assume entities
`myfiles' and `origfiles' have been declared as subdocuments,
referring to programcode documents):
<verbatim><![CDATA[
<p>See also
<coderef collection=mystuff id=myfunc>my funky function</coderef>, 
and compare it with 
<coderef collection=theirstuff id=myfunc>their silly subroutine</coderef>.

[...]
<sect>All the code
<routinelist>
<p>Here's the beef
<codecollection id=mystuff doc=myfiles>
<codecollection id=theirstuff doc=origfiles>
]]>
</verbatim>
Notice that the `codecollection' element provides a sort of
namespacing, so that you don't have to worry about having to give
different IDs to functions in different collections of code.

<p>The programcode document -- the document marked up using the
programcode DTD, pointed to by the main documentation -- may be a
conventional SGML document, maintained separately or generated from
idiolectal source markup by some sed or Perl magic, or it may be a
skeleton document which includes separate (compilable) source files
into itself.  It makes no difference to the SGML parser, but gives the
code author flexibility in deciding how much, and what, markup to
allow into their code comments.

<p>There are distinct document type declarations for the different
supported languages, although they use the same underlying markup.
This is so that the generic programcode DTD can be slightly customised
as appropriate for different languages.  See <ref id=doccode.languages/>.

<p>The programcode DTD is more elaborate than it <em/could> have
been.  Different people have different coding and documenting styles,
and are firmly wedded to them, so I felt that flexibility was more
important than simplicity.  As a result, there is sometimes more than
one place where information can reasonably be placed.  Also, the DTD
makes it possible to exploit tag-omission quite heavily (see 
<ref id=markup.min/>) -- the aim was to indicate an adequate level of
structure using as little markup as possible.

<p>The programcode DTD is designed to document code; there is no
reason why it could not also be used to prettyprint it, by taking a
marked-up document and putting it through a different processor.
That, however, is a project for another time.

<subsect id=doccode.general export>The structure of programcode documents

<subsubsect id=doccode.example>Example document

<p>Let us start in the traditional way, with a (sort of) `hello world'
program:
<verbatim><![ CDATA [
<!DOCTYPE programcode PUBLIC "-//Starlink//DTD Fortran Source Code 0.7//EN">
<title>The `hello world' program
<codegroup>
<title>Group title
<description>First test program
<routine>
<codeopener>
      subroutine helloworld (language)
<routineprologue>
   <routinename id=hi1>
     helloworld
   <description>
     Greets the world with a sunny hello
   <argumentlist>
   <parameter given>
     <name>language
     <type>_integer</type>
     <description>Selects the language to use.
     0=english, 1=sanskrit.
   <authorlist>
   <author id=ng affiliation='Glasgow'>Norman Gray
<codebody>
      write (*,*) 'ack!'
      end
]]></verbatim>

<p>This is, obviously, not a compilable Fortran program, but it is a
good example, firstly because it displays the structure (which will
be a little obscured when we come to consider Fortran programs in 
<ref id=doccode.fortran/>), and secondly because it could plausibly be the
output of some script which extracts documentation from compilable
source code files.

<p>As mentioned above, the programcode DTD allow you to make heavy use
of SGML tag omission features.  As well as the usual such features,
the Fortran code DTD allows further abbreviation, and we shall see
that the above program could be represented as:
<verbatim><![CDATA[
<!DOCTYPE programcode PUBLIC "-//Starlink//DTD Fortran Source Code 0.7//EN">
<title>The `hello world' program
<codegroup>
<title>Group title
<description>First test program
<routine>
<codeopener>
      subroutine helloworld (language)
*+
*   <routinename id=hi1>
*     helloworld
*   <description>
*     Greets the world with a sunny hello
*   <argumentlist>
*   <parameter given>
*     language = _integer
*     Selects the language to use.
*     0=english, 1=sanskrit.
*   <authorlist>
*   <author id=ng affiliation='Glasgow'>Norman Gray
*-
      write (*,*) 'ack!'
      end
]]></verbatim>
All the material after the <code/&lt;codeopener&gt;> start-tag is
compilable Fortran, and might well be read in, using an entity (<ref
id=markup.files/>), from the routine source code.  The fully
normalised version of this document (modulo a few spaces) is in <ref
id=fig.normprog/>.
<figure float id=fig.normprog alt="Normalised programcode document">
<caption>A programcode document with all tags in place, the normalised
version of the fortrancode document in the text.</caption>
<px>
<verbatim><![ CDATA [
<programcode><docblock>
<title>The `hello world' program</title></docblock>
<codegroup><docblock><title>Group title</title>
<description><p>First test program</p></description></docblock>
<routine>
<codeopener>      subroutine helloworld (language)</codeopener>
<routineprologue>
<routinename id="hi1"><name>helloworld</name></routinename>
<description><p>Greets the world with a sunny hello</p></description>
<argumentlist>
<parameter given>
<name>language </name>
<type> _integer</type>
<description><p>Selects the language to use.  0=english, 1=sanskrit.</p>
</description></parameter></argumentlist>
<authorlist>
<author id="ng" affiliation="Glasgow"><name>Norman Gray</name></author>
</authorlist></routineprologue>
<codebody>      write (*,*) 'ack!'
      end</codebody>
</routine></codegroup></programcode>
]]></verbatim></px></figure>

<p><update versionid="post-0.2">Added a note pointing out
that returnvalue and argumentlist have optional `none'
attributes.
<update versionid=v0-6-1>Returnvalue is now omissable</update>
When there is <em/no> return value, in the case of a subroutine, you
can either omit the returnvalue element, or give it the attribute
<code/none>.  The <ref id=el.programcode.argumentlist>argumentlist</ref>
element is not omissable, however (since if the SGML parser finds a
parameter element, it can't know whether it's part of an argumentlist
or a parameterlist element), and this also takes an attribute <code/none>.

<subsubsect id=doccode.elements>The programcode element structure
<update versionid="v0.6">
Substantially redone, to match significant changes to programcode DTD
</update>

<p>In the case of the Starlink General DTD, described in 
<ref id=structure/>, the important features were the meanings of the element
types.  In the case of the programcode DTD, however, the meanings of
the element types are fairly straightforward, and the detail is in the
<em/structure> of the DTD.  It therefore seems best to focus on the
structure of the DTD here, leaving the detailed descriptions of the
elements, and their attributes, to <ref id=appx.programcode.dtd/>.

<p>The programcode DTD includes essentially all of the paragraph-level
elements in the Starlink General DTD, that is, everything that may be
included in a paragraph in that DTD may also be included in a
paragraph in the programcode DTD (except `docxref' and `ref', but with
the addition of the `funcname' element).

<p><ref id=figure.programcode/> displays the element structure of the
programcode DTD.  The syntax is that of a DTD -- see <ref id=sgml.dtd/>
for brief notes on this.

<figure id=figure.programcode alt="programcode DTD element structure">
<caption>Element structure of the programcode DTD</caption>
<px>
<!-- This was extracted from the dtd with the sed script
  sed -n '/^<!ELEMENT/{:again;/> *$/b nextel;p;n;b again;:nextel;p;}' \
	programcode-0.6.dtd 
  ...then reordered for documentation purposes, and the <ref/> elements
  put in.
-->
<verbatim>
&lt;!ELEMENT <ref id=el.programcode.programcode>programcode</ref>   O O (docblock, (codegroup | codereference)+)>
&lt;!ELEMENT <ref id=el.programcode.codegroup>codegroup</ref>     - O (docblock, routine+)>
&lt;!ELEMENT <ref id=el.programcode.codereference>codereference</ref> - O (docblock)>
&lt;!ELEMENT <ref id=el.programcode.docblock>docblock</ref>      O O (title, description?,
                             userkeywords?, softwarekeywords?,
                             authorlist?, copyright?, history?)>

&lt;!ELEMENT <ref id=el.programcode.routine>routine</ref>       O O (codeopener?, routineprologue, codebody)>
&lt;!ELEMENT <ref id=el.programcode.codeopener>codeopener</ref>    O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.codebody>codebody</ref>      O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.routineprologue>routineprologue</ref> O O (
                                (routinename,   diytopic*)? &
                                (moduletype,    diytopic*)? &
                                (purpose,       diytopic*)? &
                                (description,   diytopic*)  & 
                                (returnvalue,   diytopic*)? &
                                (argumentlist,  diytopic*)? &
                                (parameterlist, diytopic*)? &
                                (authorlist,    diytopic*)? &
                                (history,       diytopic*)? &
                                (usage,         diytopic*)? & 
                                (invocation,    diytopic*)? & 
                                (examplelist,   diytopic*)? &
                                (implementationstatus,  diytopic*)? & 
                                (bugs,          diytopic*)?
                                )>

&lt;!ELEMENT <ref id=el.programcode.routinename>routinename</ref>   O O (name, othernames?)>
&lt;!ELEMENT <ref id=el.programcode.moduletype>moduletype</ref>    - O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.name>name</ref>          O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.othernames>othernames</ref>    - O (name+)>

&lt;!ELEMENT <ref id=el.programcode.purpose>purpose</ref>       - O (%p.model)>
&lt;!ELEMENT <ref id=el.programcode.title>title</ref>         O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.description>description</ref>   - O (%paralist;)>
&lt;!ELEMENT (<ref id=el.programcode.userkeywords>userkeywords</ref> | <ref id=el.programcode.softwarekeywords >softwarekeywords</ref>)
                                - O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.returnvalue>returnvalue</ref>   - O (%paralist;)>
&lt;!ELEMENT (<ref id=el.programcode.argumentlist>argumentlist</ref> | <ref id=el.programcode.parameterlist >parameterlist</ref>)
                        O O (parameter*)>
&lt;!ELEMENT <ref id=el.programcode.parameter>parameter</ref>     - O (name, type, description)>
&lt;!ELEMENT <ref id=el.programcode.type>type</ref>          - O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.examplelist>examplelist</ref>   O O ((example,description)+)>
&lt;!ELEMENT <ref id=el.programcode.example>example</ref>       - O (#PCDATA)>
&lt;!ELEMENT (<ref id=el.programcode.usage>usage</ref> | <ref id=el.programcode.invocation >invocation</ref> | <ref id=el.programcode.implementationstatus >implementationstatus</> | bugs)
                        - O (%paralist;)>
&lt;!ELEMENT <ref id=el.programcode.diytopic>diytopic</ref>     - O (title, %paralist;)>
&lt;!ELEMENT <ref id=el.programcode.copyright>copyright</ref>     - O (%paralist;)>

&lt;!ELEMENT <ref id=el.programcode.authorlist>authorlist</ref>    O O ((author+ | authorref+), otherauthors?)>
&lt;!ELEMENT <ref id=el.programcode.otherauthors>otherauthors</ref>  - O (author+ | authorref+)>
&lt;!ELEMENT <ref id=el.programcode.author>author</ref>        - O (name, authornote?)>
&lt;!ELEMENT <ref id=el.programcode.authornote>authornote</ref>    - O (%paralist;)>
<!--&lt;!ELEMENT <ref id=el.programcode.authorref>authorref</ref>     - O EMPTY>-->

&lt;!ELEMENT <ref id=el.programcode.history>history</ref>       O O (change+)>
&lt;!ELEMENT <ref id=el.programcode.change>change</ref>        - O (%paralist;)>

&lt;!ELEMENT <ref id=el.programcode.funcname>funcname</ref>      - - (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.webref>webref</ref> - - (%simpletext)+>
&lt;!ELEMENT <ref id=el.programcode.url>url</ref> - - (#PCDATA)>
</verbatim>
<![IGNORE[
<!-- This is the 0.2 dtd -->
<verbatim>
&lt;!ELEMENT <ref id=el.programcode.programcode>programcode</ref>   O O (docblock, (codegroup | codereference)+)>
&lt;!ELEMENT <ref id=el.programcode.codegroup>codegroup</ref>     - O (docblock, (func | misccode)+)>
&lt;!ELEMENT <ref id=el.programcode.codereference>codereference</ref> - O (docblock)>
&lt;!ELEMENT <ref id=el.programcode.docblock>docblock</ref>      O O (title, description?, authorlist?,
                             copyright?, history?)>

&lt;!ELEMENT <ref id=el.programcode.func>func</ref>          O O (codeprologue, codebody)>
&lt;!ELEMENT <ref id=el.programcode.misccode>misccode</ref>      O O (miscprologue, codebody)>
&lt;!ELEMENT <ref id=el.programcode.codeprologue>codeprologue</ref>  O O (routinename , purpose? , description , 
                                returnvalue , argumentlist ,
                                authorlist? , history?)>
&lt;!ELEMENT <ref id=el.programcode.miscprologue>miscprologue</ref>  O O (description, history?)>
&lt;!ELEMENT <ref id=el.programcode.codebody>codebody</ref>      O O (#PCDATA)>

&lt;!ELEMENT <ref id=el.programcode.routinename>routinename</ref>   O O (name, othernames?)>
&lt;!ELEMENT <ref id=el.programcode.name>name</ref>          O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.othernames>othernames</ref>    - O (name+)>

&lt;!ELEMENT <ref id=el.programcode.title>title</ref>         O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.purpose>purpose</ref>       - O (%para.content;)>
&lt;!ELEMENT <ref id=el.programcode.description>description</ref>   - O (p+)>

&lt;!ELEMENT <ref id=el.programcode.returnvalue>returnvalue</ref>   - O (%para.content | p+)>
&lt;!ELEMENT <ref id=el.programcode.argumentlist>argumentlist</ref>  O O (parameter*)>
&lt;!ELEMENT <ref id=el.programcode.parameter>parameter</ref>     - O (name, type, description)>
&lt;!ELEMENT <ref id=el.programcode.type>type</ref>          - O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.copyright>copyright</ref>     - O (p+)>

&lt;!ELEMENT <ref id=el.programcode.authorlist>authorlist</ref>    O O ((author+ | authorref+), otherauthors?)>
&lt;!ELEMENT <ref id=el.programcode.otherauthors>otherauthors</ref>  - O (author+ | authorref+)>
&lt;!ELEMENT <ref id=el.programcode.author>author</ref>        - O (name, authornote?)>
<!--&lt;!ELEMENT <ref id=el.programcode.authorref>authorref</ref>     - O EMPTY>-->
&lt;!ELEMENT <ref id=el.programcode.authornote>authornote</ref>    - O (p+)>

&lt;!ELEMENT <ref id=el.programcode.history>history</ref>       O O (change+)>
&lt;!ELEMENT <ref id=el.programcode.change>change</ref>        - O (p+)>

&lt;!ENTITY % para.markup '<ref id=el.programcode.code>code</ref> | <ref id=el.programcode.em >em</ref> | <ref id=el.programcode.url >url</ref> | <ref id=el.programcode.funcname >funcname</ref>'>
&lt;!ENTITY % para.content '(#PCDATA | %para.markup | ul)*'>
&lt;!ELEMENT <ref id=el.programcode.p>p</ref>             O O (%para.content;)>
&lt;!ELEMENT (%para.markup;) - - (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.ul>ul</ref>            - - (li+)>
&lt;!ELEMENT <ref id=el.programcode.li>li</ref>            - O (#PCDATA)>
</verbatim>
]]>
</figure>

<p>Below, I describe these elements group-by-group.  This description
concentrates on the structure of the DTD and the relationships between
the elements -- I have not described the details of the elements or
their attributes where these can be found in the detailed element
listing in <ref id=appx.programcode.dtd/>.

<p><verbatim>
&lt;!ELEMENT <ref id=el.programcode.programcode>programcode</ref>   O O (docblock, (codegroup | codereference)+)>
&lt;!ELEMENT <ref id=el.programcode.codegroup>codegroup</ref>     - O (docblock, routine+)>
&lt;!ELEMENT <ref id=el.programcode.codereference>codereference</ref> - O (docblock)>
&lt;!ELEMENT <ref id=el.programcode.docblock>docblock</ref>      O O (title, description?,
                             userkeywords?, softwarekeywords?,
                             authorlist?, copyright?, history?)>
</verbatim>
The <code/programcode> top-level element, like the
<code/codegroup> and <code/codereference> elements which it contains,
starts off with a <code/docblock> element.  This may provide
discussion, author, copyright, change history information, or it may
give as little as a title.  Where this information is provided is up
to the author of the documentation.  The elements in the
<code/docblock> must be present in the order specified here.

<p>A <code/codegroup> element simply
gathers together several related functions (this is deliberately
vague); it might therefore represent all the functions defined in one
source file, or in one directory of a source tree.  
A <code/codereference> is even vaguer: it documents a relationship
between the current programcode document and another one.  In the case
of the DSSSL DTD, this is mapped to the structure in that language which
included one source file in 
another; in the case of the Fortran DTD, it could document the
dependence of a source file on an `include' file.

<p><verbatim>
&lt;!ELEMENT <ref id=el.programcode.routine>routine</ref>       O O (codeopener?, routineprologue, codebody)>
&lt;!ELEMENT <ref id=el.programcode.codeopener>codeopener</ref>    O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.codebody>codebody</ref>      O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.routineprologue>routineprologue</ref> O O (
                                (routinename,   diytopic*)? &
                                (purpose,       diytopic*)? &
                                (description,   diytopic*)  & 
                                (returnvalue,   diytopic*)? &
                                (argumentlist,  diytopic*)? &
                                (parameterlist, diytopic*)? &
                                (authorlist,    diytopic*)? &
                                (history,       diytopic*)? &
                                (usage,         diytopic*)? & 
                                (invocation,    diytopic*)? & 
                                (examplelist,   diytopic*)? &
                                (implementationstatus,  diytopic*)? & 
                                (bugs,          diytopic*)?
                                )>
</verbatim>
A <code/routine> element documents a function, with arguments, a return
value, and the like.

<p><update versionid="post-0.2">
Paragraph rewritten to suggest using a CDATA marked section, instead
of code edits.</update>
The <code/codebody> element is ignored by the processing system,
but is still scanned by the parser.  This could cause you a problem if
there's anything in there which looks like something the parser would
be interested in, namely an element start-tag, an entity reference, or
something that looks like markup.
The ampersand and left angle-bracket are only recognised as markup if
they are immediately followed by a name-start character (upper- or
lowercase letter); markup is something starting with the string
<code>&lt;!...</code>.
If the parser trips up on something, there are two
things you can do.  You can make minor edits 
to your source code (adding a space character
will always be enough), to stop things looking like markup:
<code>&lt;a</code> is the beginning of an element start-tag, but
<code>&lt; a</code>, with an interpolated space, is not.
Alternatively, you can bracket the code in a CDATA marked section
(<ref id=markup.ms.cdata/>) as follows
<verbatim>
* ... end of code prologue
*-&lt;![CDATA[
      ...fortran code including &lt;ignored &amp;markup...
*&rsqbrack;]>
</verbatim>
Which of these alternatives you prefer is largely a matter of taste, I
think, but remember that you'll only have to do this for those
source-code files which you include within your documentation.  It is
undeniable that these strategies are ugly, but something like this is
fairly inevitable as the downside of having your source processable by
more than one system at once.  If both of these are unacceptable to
you (on aesthetic grounds if nothing else), then you can always
preprocess your sources to strip the code out and leave a `pure' SGML
document.<note>Note for SGML initiates: it does
seem a little disappointing that none of SGML's various escaping
mechanisms could help here, but the fact that the code text has to
remain pretty much inviolate (apart from the possibility of a few
spaces here and there) is rather restrictive.  Another possibility I
considered was making the <code/codebody> element have CDATA content,
even though that's generally deprecated in the most lurid terms.  Far from
solving the problem, this would make things worse, however: the
<code>&lt;/</code> which ends the element would still be magic, you'd
have to have an explicit <code>&lt;/codebody></code> closing the
element (no entities recognised), and you'd have to have an explicit
<code>&lt;codebody></code> starting the element, since the
<code>*-</code> short reference doesn't seem to permit the element to
be ended with the <code>&lt;/codebody></code> end-tag.</note>

<p>Note: If the <code/codebody> element actually contains no code at all
(perhaps because the document has been generated by a preprocessor
stage), then you should include the attribute `empty' in the
start-tag; this has no effect at present, but could become significant
if the documents are repurposed in future versions of this set.

<p>The <code/routineprologue> element contains all the `meta-information'
for the routine, such as authorship, argument list, return value and
the like.  The declaration here looks particularly complicated, but
that is largely due to an unwieldiness in SGML's DTD syntax.  This
declaration simply states that each of the <code/routinename>,
<code/purpose>, etc., elements may appear at most once, but that each
of these elements may be freely interspersed with <code/diytopic>
elements.  Only the <code/description> element <em/must> appear.

<p>
<verbatim>
&lt;!ELEMENT <ref id=el.programcode.routinename>routinename</ref>   O O (name, othernames?)>
&lt;!ELEMENT <ref id=el.programcode.moduletype>moduletype</ref>    - O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.name>name</ref>          O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.othernames>othernames</ref>    - O (name+)>
</verbatim>
The <code/routinename> element has structure, though in the usual case
(<code/&lt;routinename>helloworld>) you wouldn't notice this.  The
<code/othernames> element is useful when a function has some generic
name, say <code/allocarray>, plus some specific names, say
<code/allocarray_int> and <code/allocarray_float>.  The
<code/moduletype> element allows you to document that a particular
module is a <code>&lt;moduletype>Perl script</code>, for example.

<p>
<verbatim>
&lt;!ELEMENT <ref id=el.programcode.purpose>purpose</ref>       - O (%p.model)>
&lt;!ELEMENT <ref id=el.programcode.title>title</ref>         O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.description>description</ref>   - O (%paralist;)>
&lt;!ELEMENT (<ref id=el.programcode.userkeywords>userkeywords</ref> | <ref id=el.programcode.softwarekeywords >softwarekeywords</ref>)
                                - O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.returnvalue>returnvalue</ref>   - O (%paralist;)>
&lt;!ELEMENT (<ref id=el.programcode.argumentlist>argumentlist</ref> | <ref id=el.programcode.parameterlist >parameterlist</ref>)
                        O O (parameter*)>
&lt;!ELEMENT <ref id=el.programcode.parameter>parameter</ref>     - O (name, type, description)>
&lt;!ELEMENT <ref id=el.programcode.type>type</ref>          - O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.examplelist>examplelist</ref>   O O ((example,description)+)>
&lt;!ELEMENT <ref id=el.programcode.example>example</ref>       - O (#PCDATA)>
&lt;!ELEMENT (<ref id=el.programcode.usage>usage</ref> | <ref
id=el.programcode.invocation >invocation</ref> | <ref id=el.programcode.implementationstatus>implementationstatus</ref> | bugs)
                        - O (%paralist;)>
&lt;!ELEMENT <ref id=el.programcode.diytopic>diytopic</ref>     - O (title, %paralist;)>
&lt;!ELEMENT <ref id=el.programcode.copyright>copyright</ref>     - O (%paralist;)>

</verbatim>
The distinction between <code/purpose> and <code/description> is that
<code/purpose> is intended for a brief, perhaps one-line, summary
of the function, whereas <code/description> is intended for a longer
discussion.

<p>The <code/description> element is used in the <code/docblock>,
<code/codeprologue>, <code/miscprologue> and <code/parameter>
elements, <code/authorlist> is used in both <code/codeprologue> and
<code/docblock> elements, and <code/name> is used in the <code/author>,
<code/othernames>, <code/parameter> and <code/routinename> elements.

<p>The <code/diytopic> element is for other notes which aren't
otherwise covered by the element types listed here.  It has a very
simple structure: a title followed by paragraphs of text.

<p>The distinction between the <code/userkeywords> and
<code/softwarekeywords> elements is that the former is intended to
supply keywords to help the final user of the software, whereas the
latter is intended to be a home for keywords concerned with the
categorisation of the software within the Starlink project.

<p>The text <code/%p.model;> indicates that at this point, any of the
paragraph-level elements from the Starlink General DTD may be used,
with the exception of the `docxref' and `ref' elements, and the
addition of the `funcname' element.

<p>The text <code/%paralist;> is shorthand for <code/p, (p |
tabular)*>, or in other words, a sequence of paragraphs and tabular elements.

<p>
<verbatim>
&lt;!ELEMENT <ref id=el.programcode.authorlist>authorlist</ref>    O O ((author+ | authorref+), otherauthors?)>
&lt;!ELEMENT <ref id=el.programcode.otherauthors>otherauthors</ref>  - O (author+ | authorref+)>
&lt;!ELEMENT <ref id=el.programcode.author>author</ref>        - O (name, authornote?)>
&lt;!ELEMENT <ref id=el.programcode.authornote>authornote</ref>    - O (%paralist;)>
<!--&lt;!ELEMENT <ref id=el.programcode.authorref>authorref</ref>     - O EMPTY>-->
</verbatim>

Each <code/author> element must be given an ID.  The down-converter
which processes the document will assume that authors with the same ID
are the same author, and will attempt to assemble a full set of
information about that author (ie, email address, webpage) from the
various available author elements with the same ID and, for example,
assemble a list of all the authors represented in a collection of code
at the top of a <ref id=el.sun.codecollection/codecollection>
element.  You should probably try to make the information given in these
scattered author elements consistent, although the down-converter
won't impose this.

<!--
The distinction between the <code/author> and <code/authorref>
elements is important.  The <code/author> element has a required ID
attribute which can be used to refer to this author, and the
associated metadata of URL and email address.  Since IDs must be
unique in an SGML document, it follows that there can be only <em/one>
<code/author> element per author per document: there cannot be an
author element in each function.  It is usual, however, to give
authorship information in each function, and this is done with the
<code/authorref> element, which has a required ID attribute linking
back to the <code/author> element presumably located in the document's
initial <code/docblock> (see the example in <ref id=doccode.example/>).
-->

<p>
<verbatim>
&lt;!ELEMENT <ref id=el.programcode.history>history</ref>       O O (change+)>
&lt;!ELEMENT <ref id=el.programcode.change>change</ref>        - O (p+)>
</verbatim>
The history mechanism in programcode documents is intentionally
simple, as it merely emulates the list-of-changes style in the
majority of the Starlink code-base.  Specifically, it is simpler than
the history mechanism in the General DTD (see <ref id=str.history/>).
The <code/change> element has a
required date, and a required `author' attribute, which links back to
a previous <code/author> element.

<p>
<verbatim>
&lt;!ELEMENT <ref id=el.programcode.funcname>funcname</ref>      - - (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.webref>webref</ref> - - (%simpletext)+>
&lt;!ELEMENT <ref id=el.programcode.url>url</ref> - - (#PCDATA)>
</verbatim>
The only unusual element is <code/funcname>, which
is intended to indicate other functions within the same `world'
(vagueness again): these could be language primitives, or other
documented functions.  At present, this simply functions as a variant
of the <code/code> element, but the system could be extended in future
to generate cross-references for these.

<subsect id=doccode.languages export>Specific language variants

<p>As I mentioned above, the programcode DTD is not invoked directly,
but instead <em/via> a document type declaration specific to the
language of the program being documented, allowing for
language-specific customisation of the generic DTD.

<p>At present, the only languages supported by DTDs are
DSSSL (a language for formatting SGML documents, which has
been used for much of the processing work in this project) and
Fortran.  C and C++ will be added almost immediately, and other
languages as guided by demand.

<subsubsect id=doccode.fortran>Fortran

<p>The principal customisations for Fortran documents are to do with
the definition of `short references' for certain tags, to help you
`hide' SGML within Fortran comments.

<p>The string <code/*+> coming at the beginning of the line, is
equivalent to the <code/func> start-tag, and <code/*-> at the
beginning of the line is recognised as the <code/codebody> start-tag.
Within the <code/func> element, a <code/*> at the beginning of the
line is ignored.  Further, within the <code/parameter> element, an
equals sign, <code/=>, is recognised as a <code/type> start-tag, and
within that element, end-of-line and <code/:> are recognised as a
<code/description> start-tag.

<p>All together, this means that, as trailed in 
<ref id=doccode.example/>, the code fragment
<verbatim><![CDATA[
*+
* <routinename>helloworld
* <description>Greets the world with a sunny hello
* <returnvalue type=string>Suitably formatted greeting
* <parameter given>
*   language = enumerated list
*     Selects the language to use.
*     Allowed values are english and sanskrit.
* <authorlist><authorref id=ng>
*-
      (function source code goes here)
]]></verbatim>
is interpreted as 
<verbatim><![CDATA[
<func>
<routinename>helloworld
<description>Greets the world with a sunny hello
<returnvalue type=string>Suitably formatted greeting
<parameter given>language
  <type>enumerated list<description>Selects the language to use.
  Allowed values are english and sanskrit.
<authorlist><authorref id=ng>
<codebody>
      (function source code goes here)
]]></verbatim>

<subsubsect id=doccode.dsssl>DSSSL

<p>DSSSL is a language defined in ISO/IEC 10179:1996
<citation>iso10179</citation> as a means of specifying the formatting of SGML
documents.  It is the language, as implemented in the free DSSSL
system <webref url='http://www.jclark.com/jade/' >Jade</webref>, used
for almost all the processing of SGML documents in this Starlink SGML
application.  Since the language is likely to be of interest only to
those with some knowledge of SGML, the rest of this section uses
terminology not defined elsewhere in this document.

<p>DSSSL source documents are SGML instances.  When presented with a
source file, Jade does not process it immediately, but instead
extracts (rather nicely) an instance of the `DSSSL' architecture,
which must be declared in the DTD the document conforms to.  The DTD
referred to by <code>-//Starlink//DTD DSSSL Source Code 0.2//EN</code>
declares such an architecture.  It maps the programcode
<code/codegroup> element to the DSSSL <code/style-specification>
architectural form, <code/codereference> to
<code/external-specification> (with attribute name remapping) and
<code/codebody> to <code/style-specification-body>. This follows a
discussion of this technique in <code/comp.text.sgml> by Eliot
Kimber~<citation>kimber97a</citation>.

<p>Also it defines the entity <code/%direction.attr> to be simply
`given', since arguments to DSSSL functions are only passed in.

<p>See <ref id=appx.system/> for further discussion of the DSSSL
code base.

<subsect id=doccode.org export>Organising files

<p>I described above how, for example, the Fortran-code DTD can allow
you to mix program source code and SGML markup.  A Fortran source file
cannot be a complete SGML document on its own, however, even though it
can be a fragment of a valid document, since there is no way to hide
the required <code/&lt;!DOCTYPE ...&gt;> declaration from the compiler.
The source file must therefore be part of a composite document.

<p>Although the object that is pointed to by the General DTD's
<code/codecollection> element is a single SGML document marked up
using the programcode DTD, it need not be a single file.  A suitable
way to manage a collection of source code files, for documentation
purposes, might be as follows.

<p>We can return to the example in <ref id=doccode.example/>, and split
our `hello world' example into two files, a skeleton file holding the
general structure, and including an entity which refers to the source
code:
<verbatim><![CDATA[
<!DOCTYPE programcode PUBLIC "-//Starlink//DTD Fortran Source Code 0.7//EN" [
  <!ENTITY ptest-source SYSTEM 'ptest.f'>
]>
<title>The `hello world' program
<codegroup>
<title>Group title
<description>First test program
<routine>
<codeopener>
&ptest-source;
]]></verbatim>
and a separate file, <code/ptest.for>, containing just the source code:
<verbatim><![CDATA[
      subroutine helloworld (language)
*+
*   <routinename id=hi1>
*     helloworld
*   <description>
*     Greets the world with a sunny hello
*   <argumentlist>
*   <parameter given>
*     language = _integer
*     Selects the language to use.
*     0=english, 1=sanskrit.
*   <authorlist>
*   <author id=ng affiliation='Glasgow'>Norman Gray
*-
      write (*,*) 'ack!'
      end
]]></verbatim>

<!-- Omit this section - more chatty and provisional than appropriate -->
<![ IGNORE [
<subsect id=doccode.devel export>Development of the programcode DTD

<p>As you can see from the programcode structure in 
<ref id=figure.programcode/>, the DTD recognised only two structures,
<code/func> (which includes subroutines since the returnvalue element
can be given the `none' attribute) and miscellaneous-code.  Also, the
structure of the code prologue is quite strict, with routinename,
description, returnvalue and argument list all required, and these and
their optional companions having a fixed order.  It's not clear that
this element structure is ideal, and I would like to solicit feedback
on this at this stage of the project.

<p>On the one
hand, it seemed important to make as much as possible required here,
to encourage folk to include all the important bits of documentation.
On the other hand, I didn't want to fall into the trap of `all the
world is Fortran'.  On the third hand, quite a lot of the world <em/is>
Fortran (or C or IDL or something pretty like them in terms of code
structures), so that's obviously a class of documentable objects I
should map quite faithfully into documentation support.

<p>When I support C++, I'll have to add support in programcode for the
notion of a class which contains methods.  Probably this'll be
something at the same level as `codegroup' (perhaps it should simply
<em/be> `codegroup', with the `func' element documenting individual methods).
I think that'll be just about all the major code structures --
anything else can be bundled in the guards van under `misccode'
without much loss.

<p>When I discussed that with Mark Taylor, however, he suggested a
much more flexible structure:
<verbatim><![CDATA[
I think that imposing a rigid structure could be counterproductive.
My feeling is that if people's (source) code fails to parse it's going 
to be an incentive to leave it unSGMLized or just bung everything in some
In any case there are a lot of differently prologuized
routines out there so imposing a rigid structure on it is going to
be an uphill job.  My inclination would be to have a single element
for putting code into (in which case ROUTINE might be a better GI
than FUNC) with many optional children and no compulsory ones except
perhaps NAME.  I also think that we need a generic element in the
content model.

  <!ELEMENT routine      O O   ( codeprologue, codebody )>
  <!ELEMENT codebody     O O   ( #PCDATA )>
  <!ELEMENT codeprologue O O   ( routinename & purpose? & description? &
                                 returnvalue? & argumentlist? & 
                                 algorithm? & pitfalls? & bugs? &
                                 examples? & usage? & notes? & other* &
                                 authorlist? & history? )>

  <!ELEMENT (description | returnvalue | algorithm |
             pitfalls | bugs | examples | usage | notes | 
             other)      - O   ( p* )>

  <!ELEMENT other        - O   ( othersect* )>
  <!ELEMENT othersect    O O   ( otherhead, p* )>
  <!ELEMENT otherhead    - O   ( #PCDATA )>
]]></verbatim>
I agree that my original may be more
strict than is comfortable to use, but Mark's might be too far
the other way.

<p>My picture of how the programcode DTD would be used was that people
probably wouldn't document so elaborately every routine they wrote,
but only those they intended to incorporate into user or maintainer
documentation; if this constituted a minority of routines, it wasn't
necessarily inappropriate to make the structuring quite strict.  If,
on the other hand, we envisage the majority of routines being marked
up like so, then it would be appropriate to cut folk a little more
slack.  The question then is, how much slack can you afford before the
result looks shapeless?  The structure we give up here, in the
interests of flexibility and authoring ease, is the structure that
makes it easy to write powerful downstream tools in the future.

<p>It is clear that a balance has to be struck here, and that my own
taste would not be universal.  I'm open to suggestion.

]]>

<sect id=processing export>Processing your document

<p>SGML documents are processed using a suite of free tools produced
by James Clark.

<p><webref url="http://www.jclark.com/jade/" >Jade</webref> is a
system which implements the DSSSL language for document formatting
and, in the present case, transformation.  The difference is that
`formatting' refers to the process of turning an SGML document into a
printed, or otherwise readable, form, and `transformation' refers to
the processing of an SGML document into another SGML document.  Thus
the conversion to HTML is really `transformation', but since HTML is
not much cop as a high-level markup language, the HTML transformation
is much more akin to a formatting step; likewise the `formatting' into
&latex;.  In fact, DSSSL has a transformation language as well as a
formatting language; Jade implements only the formatting language, but
with extensions which allow it to be used very easily for
transformation.

<p>Along with Jade is the <webref url="http://www.jclark.com/sp/"
>SP</webref> toolkit.  This consists of a standalone parser,
<code/nsgmls>, and various markup editing tools.

<subsect id=proc.setup export>Setting up

<p>To use the SGML set, give the command 
<verbatim>
% . /star/bin/sgml/sgml_set.sh
</verbatim>
or
<verbatim>
% source /star/bin/sgml/sgml_set.csh
</verbatim>
depending on whether you are using a Bourne-like shell (<code/sh>,
<code/bash>) or a C-shell (<code/csh>, <code/tcsh> or
other variants).  This will set up a couple of environment variables,
and add a binaries directory to your path.


<subsect id=proc.sgml2docs export>sgml2docs
<update versionid="v0-4" >Added section on sgml2stuff commands, and
discussion of very simple processing.</update>
<update versionid="v0.6">Significant change to sgml2docs commands</update>

<p>You should use the command <code/sgml2docs> to process your SGML
documents.  See <coderef collection=supportprogs
id=sgml2docs/> for detailed documentation, or give the command
<kbd/sgml2docs --help> for a quick summary.

<p>The <code/sgml2docs> option <code/--jadeflags> allows you to do
some limited customisation of the output.  See <ref
id=appx.system.paramdsssl/>.  There are some groups of Jade flags
which can more conveniently be set using options, using the
<code/--options> argument.  The &latex; output has options
<code/cts-sect> (do not start a new page with each new section),
<code/cts-appx> (same, for appendices), and <code/onepass> (produce
output which needs only a single pass through &latex;, which means
that the table-of-contents ends up printed last, requiring trivial
rearrangement).</p>

<subsubsect>Jade flags</title>
<update versionid="v0-7-12">
<px>Added Jade flags section.  The information was present, before,
but rather well hidden.</px></update>
<update versionid="v0-7-13">
<px>The --javaflags option now takes its argument with an equals sign.</px>
</update>

<p>There are a few flags which you can pass to the stylesheet via the
<code>--jadeflags</code> option.  For example, to turn on the
<code>show-element-ids</code> and <code>suppress-idindex</code>
options, you would give the <code>sgml2docs</code> option
<code>'--jadeflags=-Vshow-element-ids -Vsuppress-idindex'</code>.
These stylesheet options include the following.  Note that these are
on-switches rather than toggles: due to the way that Jade is
implemented, it's not possible to turn these options off explicitly.</p>

<p>All-format parameterisation:
<dl>
<dt>show-element-ids</dt>
<dd><p>Display exported IDs in the formatted document (can be useful when
working with draft documents).</p></dd>

<dt>suppress-manifest</dt>
<dd>
<p>Suppress the generation of a manifest file in the output tarball.
This can <em>occasionally</em> be useful when something appears to be
going wrong with the packaging, but it's intended for debugging rather 
than production use.</p>
</dd>
</dl></p>

<p>HTML parameterisation:
<dl>

<dt>nochunks</dt>
<dd><p>Output the HTML as a single file, rather than a collection of
smaller ones.</p></dd>

<dt>stream-output</dt>
<dd><p>Send the output to stdout, rather than a generated file name.</p></dd>

<dt>suppress-navig</dt>
<dd><p>Suppress the navigation panels at the top and bottom of each
output file.</p></dd>

<dt>separate-toc</dt>
<dd><p>Put the table of contents in a separate file.</p></dd>

<dt>suppress-banner</dt>
<dd><p>Prevents the Starlink banner from being output.</p></dd>

<dt>suppress-idindex</dt>
<dd><p><update versionid="v0-7-13">
<px>The idindex generation is much speeded up now, making the warning
in the previous version redundant.</px>
</update>
Suppress the generation of the ID Index page.</p></dd>

<dt>suppress-printable</dt>
<dd><p>Suppress the legend `Retrieve hardcopy' on the front page.</p></dd>

</dl>
</p>

<p>LaTeX mode parameterisations (these are more conveniently set via
the <code>--options</code> argument described above):
<dl>
<dt>section-samepage</dt>
<dd><p>Don't start a new page with each section.</p></dd>

<dt>appendix-samepage</dt>
<dd><p>Don't start a new page for the appendices.</p></dd>

<dt>onepass-latex</dt>
<dd><p>Generate LaTeX which does not need a second pass through the
LaTeX processor -- the TOC appears at the end of the file, in this
case, with page numbers which require the paper to be moved to the
beginning of the stack.</p></dd>

</dl>
</p>

<![ %Only.web [ 
<p>See <ref id=appx.system.dssslcode/> for copious further details.
]]>


<subsect id=proc.sgml2hlp export>Generating HELP files
<update versionid="v0-6-1">Added section on HELP files</update>


<p>The command <code/sgml2hlp> can be used to process an SGML document
conforming to the <ref id=appx.programcode.dtd >programcode</ref> DTD,
which will typically contain the marked up prologues of a set of
user-level tasks in a package,
into a <code/.hlp> file, which can be processed into a Starlink help library
using the <code/HLIB> program documented in
<docxref doc="sun124" text="SUN/124"/>.

<p>The program takes as arguments the name of any file(s) consituting
the SGML programcode document, and writes the resulting help text
to standard output.  There are no options.
Invoking it is therefore very straightforward:
<verbatim>
sgml2hlp routines.sgml >package.hlp
</verbatim>

<p>See also the code documentation for <coderef
collection=supportprogs id=sgml2hlp>sgml2hlp</coderef>.


<subsect id=proc.sgml2xml export>Converting to XML
<update versionid=v0-6-2>Added</update>

<p>Converting a document to XML cannot always be done automatically,
since there are some SGML constructs which do not map easily to XML
(for detailed discussions, see James Clark's W3C note on the <webref
url='http://www.w3.org/TR/NOTE-sgml-xml' >differences between SGML and
XML</webref>, and Norm Walsh's notes on <webref
url='http://www.xml.com/xml/pub/98/07/dtd/index.html' >converting an
SGML DTD to XML</webref>, which covers some of the same issues).
However, you can get help with this using the program <code/sgml2xml>,
which converts the body of a document to XML without difficulty, and
additionally attempts to convert the declaration subset (see 
<ref id=markup.dtdsubset/>) by rewriting entities to conform to XML's more
straitened<note>Unusually, the common misspelling `straightened' is also
appropriate here.</note> syntax, and rewriting <code/SUBDOC> entities as
<code/NDATA XML> ones.  It can't do everything, however, and so spits
out warnings whenever it finds anything in the least problematic.

<p>Use is simple:
<verbatim>
sgml2xml myfile.sgml >myfile.xml
</verbatim>
See also the notes in the 
<coderef collection=supportprogs id=sgml2xml>detailed
documentation</coderef>.


<!-- Too long redundant: remove -->
<![ IGNORE [
<subsect id=proc.makefile export>Processing documents -- using the Makefile
<update versionid="v0.6">Makefile approach no longer supported</update>

<p>At one time, the processing of documents was driven by a Makefile.
This is still distributed with the rest of the package, but is no
longer supported, and is not guaranteed to work.

<p>Processing documents is potentially a bit of a headache.

<p>The Jade processor is typically invoked with quite elaborate
command lines, with some options vital and some optional.  Some
documents -- those including maths or bibliographies, for example --
require more or less elaborate preprocessing for some formats.  In
some circumstances the names of output files are significant to the
system.  It is for all these reasons that the system is designed to be
used primarily <em/via> makefiles.  See however, the description of
the <code/sgml2html> and <code/sgml2latex> commands in 
<ref id=proc.sgml2docs/>.

<p>The distribution contains a Makefile,
<code>$STARLINK_SGML_DIR/lib/Makefile.common</code>, which contains
reasonably modular rules for the various stages of the formatting
process.  The aim is that you can process your documents by including
this common makefile in a per-directory makefile, and then simply
expressing the dependencies between your source documents and the
makefile's template targets.

<p>If your document is relatively simply, you may not actually need to
have a makefile in the documentation 
directory in order to use the setup.  Imagine that you want to process
file <code/mydoc.sgml>.  If it has no backmatter or maths, then you
can process this with the command
<kbd>make -f $(STARLINK_SGML_DIR)/lib/Makefile.common
mydoc.html.stamp</kbd>, which will read the set of rules from the
common makefile and apply the one necessary to build the HTML target.
If, in this 
simple case, you wished to have a makefile in the current directory for
the sake of clarity, it need contain nothing more than the line
<verbatim>
include $(STARLINK_SGML_DIR)/lib/Makefile.common
</verbatim>
(assuming that your version of <code/make> supports the `include'
command), and you could build the documentation using the command
<kbd/make mydoc.html.stamp>.  If your document is simple enough to
need no more than this, then you will be able to use the
<code/sgml2html> command described in <ref id=proc.sgml2docs/>.

<p>If your document includes backmatter (bibliography or notes) or
maths, then they will need 
to be preprocessed.  This is done by specifying extra dependencies in
the makefile.  A document with backmatter would need a three-line
makefile like:
<verbatim>
include $(STARLINK_SGML_DIR)/lib/Makefile.common
mydoc.html.stamp:   mydoc.sgml   mydoc.htmlback.stamp
mydoc.latex.stamp:  mydoc.sgml   mydoc.latexback.stamp
</verbatim>
Then the command <kbd/make mydoc.html.stamp> would first process the
backmatter, then generate the main HTML document.  The command
<kbd/make mydoc.latex.stamp> is broadly the same.

<p>If your document contains some maths, then the generation of HTML
requires another preprocessing step, and you declare the need for this
with another target, so that our makefile would become:
<verbatim>
include $(STARLINK_SGML_DIR)/lib/Makefile.common
mydoc.html.stamp:   mydoc.sgml   mydoc.htmlback.stamp   mydoc.imgeq.list.stamp
mydoc.latex.stamp:  mydoc.sgml   mydoc.latexback.stamp
</verbatim>
(there is no need for a &latex; preprocessing stage for maths).

<p>The root of the generated files is itself generated based on data
within the file, and is not configurable.  Do not change filenames yourself,
since HTML cross-references are constructed using the assumption that
no-one has been monkeying with filenames.  

<p>The HTML `front page' includes links to printable versions of the
file.  The files which are linked to are controlled by the
parameterisation variable <code/%link-extension-list%> (see 
<ref id=appx.system.paramdsssl/>).
The stylesheet and makefile neither generate these files nor check
that they are there -- that is left to you.  

<p>You can find out the root filename and the list of linked-to files
by examining the stamp file (which is written from the standard output
of the stylesheet).  This file contains the filename root, a colon,
the list of file extensions it has included links to, and another colon.
The root may therefore be extracted with a command like:
<verbatim>
awk -F: '{print $1}' mydoc.html.stamp
</verbatim>
You might, for example, wish to finish off your processing of a
document by giving a command like <kbd/ln -s SUN-123.html index.html>,
which could be automated as
<verbatim>
ln -s `awk -F: '{print $1}' mydoc.html.stamp` index.html
</verbatim>

<p>The makefile targets are as follows.  With makefiles, the code is
the documentation to a greater extent than with other languages, so
the makefile itself should be consulted if in doubt.  Note, however,
that targets in the makefile that are not mentioned here should not be
used, since they are internal (ie, could disappear without warning),
unstable, or otherwise deprecated.
<dl>
<dt><code/%.html.stamp: %.sgml>
<dd>The main target for generating collections of HTML files.

<dt><code/%.single.html: %.sgml>
<dd>A target for generating HTML using the same stylesheet as above,
but with the entire document in a single file.

<dt><code/%.summary: %.sgml>
<dd>Generate a document-summary for the source file.

<dt><code/%.htmlback.stamp: %.sgml>
<dd>Preprocess a document to generate backmatter in HTML format.  Use
this as a dependency of the <code/%.html.stamp> target, when a document has
backmatter, as in the example above.

<dt><code/%.imgeq.list.stamp: %.sgml>
<dd>Preprocesses a document, producing GIF images of the equations within
it.  Use as with <code/%.htmlback.stamp>

<dt><code/%.latex.stamp: %.sgml>
<dd>Produce a &latex file suitable for subsequent processing.  The
generated &latex document is not particularly readable, but it does
not depend on any external classes or packages other than those which
should be in a standard &latex distribution; it should therefore be
generally portable.

<dt><code/%.latexback.stamp: %.sgml>
<dd>Proprocess a document, producing backmatter in &latex format.  Use
this as a dependency of the <code/%.latex.stamp> target, when a
document has backmatter.

<dt><code/%.parse: %.sgml> 
<dd>The <code/%.parse> target is the SGML parser's view of the
document.  The format is <webref
url="http://www.jclark.com/sp/sgmlsout.htm" >standard</webref>, though
not formally defined, and
can be parsed by Perl libraries such as <webref
url="http://www.cpan.org/modules/by-module/SGMLS/" >SGMLSpm</webref>.

<dt><code/%.data: %.sgml>
<dd>The <code/%.data> target contains all the character data content
of the document.  It's not obvious what use this is, but it's there if
you can think of one.

<dt>Miscellaneous
<dd>The Makefile also defines targets <code/%.ps>, <code/%.dvi>.
There's nothing clever involved in these -- they're present for
convenience.

</dl>

<p>To help you when packaging up your document, the stylesheets write
a manifest of the files which make a complete set.  The names of the
manifest files can be configured as parameters (see 
<ref id=appx.system.paramdsssl/>).
]]>

<subsect id=editors export>Editors

<p>SGML is a text format, so you can write SGML documents using
whichever editor you prefer.

<p>If you use emacs, you can benefit from an emacs SGML mode called
<webref url='http://www.lysator.liu.se/projects/about_psgml.html'
>psgml</>.  This can help with simple things such as automatically
inserting appropriate closing tags, all the way up to validating your
document.

<p>There are no free SGML editors that I'm aware of, but free XML
editors are appearing.  There is now an XML version of the Starlink
DTD, so if you want to play with these, you can.  Note, however, that
the XML version of the DTD has not yet been used extensively, so there may
be problems to be uncovered.

<!-- Upconverter documentation, maintained by Mark Taylor -->
<sect id=upconvert export>Converting existing text to SGML
<update versionid="v0.6">Added Mark's upconverter documentation</update>


<p>If you are not writing a document from scratch, 
then to use the SGML system you will have first to convert existing
documents from their current form to SGML -- in the jargon this
is called <em>upconversion</em>.
Two sets of upconverter programs exist: one for the main
text of Starlink documents in their &latex; form, and one 
for source code which contains prologues which are written in the
normal Starlink way.  In the following sections these
upconverter programs are examined in turn, and then an example 
recipe for converting an existing SUN is given.


<subsect id=upconvert.latex export>Upconversion from &latex;

<p>The &latex; upconverter takes an existing Starlink document
(SUN, SSN, ...)
and outputs an SGML version of the same thing, which conforms to 
the appropriate Starlink DTD.
The upconversion process is somewhat complicated and error-prone
for a number of reasons, and it is unlikely that simply running
the upconverter will give you a perfect SGML document without
further effort -- it will probably be necessary to make a few
changes to the original &latex;, run the upconverter, examine
the log messages given by the converter and the resulting SGML, 
and then either tidy the SGML by hand or make further changes to
the &latex;, and repeat the cycle.
Some documents require relatively little manual adjustment,
and others more.  Since the upconverter makes use of the
<code>latex2html</code> program, if the document cannnot be successfully
processed by <code>star2html</code>/<code>latex2html</code> 
then it's unlikely that the upconverter
will make a good job of it.

<p>At its simplest, a document can be converted using a command like:
<verbatim>
latex2sgml sun321.tex
</verbatim>
This will produce a fair bit of output to the screen and to a file
<code>sun321.translog</code>; this is explained in detail in the
description of 
<coderef id=latex2sgml collection=upconvprogs>latex2sgml</coderef>.

<p>If you're lucky, the program will end by writing a message 
like the following:
<verbatim>
--------------------------------------------------------------------
--- latex2sgml: Parsing final output file sun321.sgml
---             Document sun321.sgml conforms to DTD
---             Removing intermediate files.
--------------------------------------------------------------------
</verbatim>
In this case, the document is syntactically correct 
and you only need to
worry about whether its semantics are as desired,
by looking at the <code>.translog</code> file 
and the converted SGML itself.

<p>However, if the output SGML does not conform to the DTD then 
a message like this will be written:
<verbatim>
--------------------------------------------------------------------
--- latex2sgml: Parsing final output file sun321.sgml
---             Document sun321.sgml does not conform to DTD:
---                 Parse errors: 3
---             Use 'parse -s sun321.sgml |& grep -v :W:' to see messages.
---             Leaving intermediate files (sun321.l2s*)
--------------------------------------------------------------------
</verbatim>
Following the script's advice and running 
<coderef id=parse collection=upconvprogs>parse</coderef>
will give output something like:
<verbatim>
nsgmls:sun321.sgml:698:86:E: document type does not allow element "figure" here
nsgmls:sun321.sgml:3049:80:E: document type does not allow element "figure" here
nsgmls:sun321.sgml:3074:80:E: document type does not allow element "figure" here
</verbatim>
-- the third and fourth fields on each line give line number and column
of the SGML file where the problem occurred.
Such errors sometimes result from deficiencies in the upconverter
and sometimes from errors in the original &latex; file;
you will have to 
either fix up the SGML file by hand or modify the &latex; source
accordingly and re-run the upconverter.

<p>As the output notes, some temporary files are left when the
conversion is not perfect, since they may be of use for debugging 
and so on.
You may wish to delete them by hand if you're not going to use them.

<p id=upconvert.latex.prepare>Unfortunately, there are all 
sorts of things which can go
wrong with the conversion process.
Preparing the &latex; document before starting the conversion
can defend you against some of them; here is a checklist of 
useful things to do before attempting a conversion:

<dl>

<dt>Low level formatting
<dd>
The upconverter will try to ignore most &latex; and HTML
code designed for low level formatting such as tweaks to 
intercharacter spacing and so on -- these things are properly
dealt with by the downconverters and not addressed in the 
source of the document.  &latex; formatting inside math 
elements is an exception to this and will be passed through unchanged.
However in some circumstances low level formatting can confuse
the upconverter, so it is generally a good idea to remove this from 
the &latex; before conversion.  In particular HTML tags output 
from <code>rawhtml</code> environments may be problematic.

<p>If there are user-defined macros in the form
of <code>\newcommand</code> or <code>\newenvironment</code>
commands you can help the conversion by ensuring that these are simplified to
express the logical form of the document rather than its 
physical layout.

<dt>Figures
<dd>
Figures are usually handled differently in latexonly and htmlonly
parts of the original document.
For correct processing, any <code>\includegraphics</code>-type command
for importing GIF or JPEG files into the HTML source,
or postscript files into the &latex, should appear within
a <code>figure</code> environment in the &latex; original.
Often for HTML output captions are inserted as text under the included image 
by custom <code>latex2html</code> code in the document -- if this duplicates
text in a genuine <code>\caption</code> command it should be removed.
Again, this may be best fixed up by modifying user macros which
implement figures.

<dt>Subroutine/Command descriptions
<dd>
Many SUNs contain an appendix with detailed descriptions of 
library subroutines or user commands for reference, usually
coded using the SST macros.
<code>latex2sgml</code> will attempt to convert these to SGML
as part of the main output document,
but it will make a pretty messy job of it.
The correct way to go about this is to code the routine/command
descriptions using the separate programcode DTD and reference
that document using a <ref id=el.sun.codecollection>codecollection</ref> 
element within
the main document, as described in <ref id=doccode></ref>.
There is no converter provided for generating a programcode document
from &latex; source code, but the 
<coderef id=code2sgml collection=upconvprogs>code2sgml</coderef> 
converter will mark up a suitable set of prologues from Fortran or
C source files into programcode SGML 
as described in <ref id=upconvert.sourcecode>the next section</ref>.
If the resulting document is specified to 
<code>latex2sgml</code> using the <code>-R</code> flag, 
it will make appropriate
references to the converted prologues and routine references 
in the final main SGML document.

<dt>Mathematics macros
<dd>
Maths is embedded in &latex notation in the final document within
<ref id=el.sun.m>m</ref>, <ref id=el.sun.mequation>mequation</ref> or
<ref id=el.sun.meqnarray>meqnarray</ref> elements,
and under normal circumstances any user-defined macros are expanded
to produce the &latex content of these elements.
However, if the purpose of the user macros was to make the maths 
clearer or easier to modify, this can be a bad thing.
In order to keep macros from being expanded, you can
remove the relevant macro definition commands 
(<code>\newcommand</code>s and <code>\newenvironment</code>s) from 
the &latex document before 
running <coderef id=latex2sgml collection=upconvprogs>latex2sgml</coderef>
on it, and later replace them in the resulting SGML document
within one or more <ref id=el.sun.mdefs>mdefs</ref> elements. 

</dl>

<p>Even after the best efforts of <code>latex2sgml</code> 
some manual intervention will be required to produce a good SGML document
from your &latex; source.
This is due to several kinds of problem, 
for instance inadequacies in the upconverter,
the fact that the &latex; original may not contain markup 
corresponding to what needs to get put into the SGML output,
and inherent differences between what can be expressed in &latex;
and in the Starlink DTD.
Lists of known deficiencies and bugs in the converter
are given in the detailed description of 
<coderef id=latex2sgml collection=upconvprogs>latex2sgml</coderef>.
On the whole, particular instances of these things are 
flagged up in the <code>.translog</code> file.

<p>To aid in hand tweaking of the &latex; source code, 
the upconverter provides an <code>\sgml{}</code> command and 
a <code>\begin{rawsgml} ... \end{rawsgml}</code> environment.
These do what you would expect: their contents,
after normal expansion of any &latex; macros, 
appear in the output SGML document.
You may find these useful for redefining user macros in the 
&latex; original.

<p>As explained in the 
<coderef id=latex2sgml collection=upconvprogs>latex2sgml 
documentation</coderef>,
the <code>-R</code> flag can be used to specify a document
containing associated routine/command descriptions marked up
according to the Programcode DTD.
In this case an appropriate 
<ref id=el.sun.codecollection>codecollection</ref>
element will be inserted as the first appendix and references to
IDs defined in the Programcode document will be inserted appropriately
as <ref id=el.sun.coderef>coderef</ref> elements.


<subsect id=upconvert.sourcecode export>Upconversion from source code

<p>If presented with subroutine or command descriptions in a SUN
then <coderef id=latex2sgml collection=upconvprogs>latex2sgml</coderef>
will turn them into SGML like the rest of the text in the document.
However, it will not make a very pretty job of it;
the proper way is to 
mark these up using the Programcode DTD, and
reference the resulting document via a
<ref id=el.sun.codecollection>codecollection</ref> 
element in the main document, as described
in <ref id=doccode></ref>.

<p>If the corresponding source files are written with prologues 
in the normal Starlink style, then a source code upconverter,
<coderef id=code2sgml collection=upconvprogs>code2sgml</coderef>,
is provided which
can mark these up as SGML conforming to the Programcode DTD.
It can behave in different ways according to how you wish to 
organise the files -- it can either produce a set of files 
which are still the same compilable source code as before but can
also be included directly into an SGML document,
or it can produce a document containing just the marked up prologues
to be included.  Which it does is controlled by the <code>-d</code>
and <code>-D</code> flags.

<p>To invoke the source code upconverter in the simplest instance, simply type
<verbatim>
code2sgml file.f
</verbatim>
and you will see what the marked up source code looks like.
The form of the prologue is kept as closely as possible to its
original format, and all the SGML markup is guaranteed to be hidden
from the compiler in comments (in the very rare case that this is 
not possible the upconverter will exit with a fatal error).
By default, only comment lines between the 
`<code>*+</code>' and `<code>*-</code>', 
one comment line immediately after that, and a comment line at the
end of the file (or before the next prologue) are changed in any way.
If the <code>-1</code> flag is given, then only the first prologue
in a given file is marked up.

<p>To make actual use of the marked up prologues you must turn them
somehow into a full SGML document.  This can be done in two ways.
The command:
<verbatim>
code2sgml -D x.f y.f z.f > converted/routines.sgml
</verbatim>
will make a single monolithic SGML document containing the marked up
prologues, though not the body of the code from the files in question.
The original files are left untouched.  
Alternatively, you can do
<verbatim>
code2sgml x.f > converted/x.f
code2sgml y.f > converted/y.f
code2sgml z.f > converted/z.f
code2sgml -d x.f y.f z.f > converted/routines.sgml
</verbatim>
The first three lines write 
new versions of the given source files into a new directory,
and the last line writes a container SGML document which has
a minimum of necessary heading and footing, and includes 
the named files by reference.
The new source files will look exactly the same to the Fortran
compiler (only comment lines have changed), and may if desired
be used as the new primary copies of the source code.

<p>Either way, you now have a Programcode document which can be 
included in a <ref id=el.sun.codecollection>codecollection</ref> element
in an SGML SUN.
The individual routines can then be referenced from the main document
using the <ref id=el.sun.coderef>coderef</ref> element;
a document (in directory <code>converted</code>)
in which this was done might contain the following
excerpts:
<verbatim><![ CDATA [
<!DOCTYPE sun PUBLIC "-//Starlink//DTD Starlink SUN//EN" [
   <!ENTITY routine.documentation SYSTEM 'routines.sgml'>
]>
    ...
See description of <coderef id=x collection=xyz>routine x</coderef> ...
    ...
<routinelist><codecollection doc=routine.documentation id=xyz>
]]></verbatim>
   
<p>Where the original prologues follow the normal Starlink (SST) conventions
for comment formatting, conversion is usually quite good
and the output may not need much further attention to make it 
into final SGML for document production.
However, it may not be possible to infer the logical structure
of the text by looking at its physical form, so it is always
a good idea to look at the SGML output of the program.
If there are consistent usages in the original which are not being
understood by the converter
it may be worth setting up and experimenting 
with a configuration file as
explained in the 
<coderef id=code2sgml collection=upconvprogs>code2sgml documentation</coderef>. 
To a limited extent this can enable the converter to 
work with source files using different conventions for 
comment syntax, header titles, list format, and so on.


<subsect id=upconvert.recipe export>Example: SUN upconversion step by step

<p>The following gives an example of the steps which might be
followed to generate an SGML SUN from existing source in a &latex; 
document and prologues of associated source files.
An actual conversion might skip some of the steps below or 
use some more, 
but this should provide a useful reference for how to proceed.
More discussion of the steps can be found in the previous 
subsections and in the 
<coderef id=code2sgml collection=upconvprogs>code2sgml</coderef>
and
<coderef id=latex2sgml collection=upconvprogs>latex2sgml</coderef>
command descriptions.

<p>First, generate marked up prologues:

<ol>
<li>Identify the relevant source files 
(those for user-level subroutines or commands) from the source archive.

<li>Use <code>code2sgml</code> to mark them up as SGML;
if you want to generate copies of the source files marked up in 
SGML to be used in future as the primary source, do
<verbatim>
code2sgml this.f > new/this.f
code2sgml that.f > new/that.f
code2sgml other.f > new/other.f
code2sgml -d this.f that.f other.f > new/routines.sgml
</verbatim>
but if you want to make a one-off conversion just for the sake of 
generating this copy of the SUN, do
<verbatim>
code2sgml -D this.f that.f other.f > routines.sgml
</verbatim>

<li>Assess how well the conversion went:
<ul>
<li>Examine any warnings which <code>code2sgml</code> wrote to
    standard error.
<li>Check whether the resulting document conforms to the programcode DTD:
<verbatim>
parse -s routines.sgml
</verbatim>
(this will print errors to standard output if there is a problem --
see the <coderef id=parse collection=upconvprogs>parse</coderef> 
documentation for details).
<li>Examine the marked up prologues by hand to see if the markup looks 
semantically correct.  In particular keep an eye out for
   <ul compact>
   <li>Blocks marked up <ref id=el.sun.verbatim>verbatim</ref> 
       which shouldn't be
   <li>Blocks not marked up <ref id=el.sun.verbatim>verbatim</ref> 
       which should be
   <li>Single element <ref id=el.sun.ul>ul</ref> lists which could 
       more appropriately be marked up otherwise
   </ul>
</ul>

<li>If there have been problems,
then either fix up the resulting SGML by hand, or
modify the original source files and repeat the conversion.
If there appear to be consistent differences in usage between 
the existing source prologues and what <code>code2sgml</code> is expecting,
it may be worth tailoring the configuration 
file before attempting the
conversion again;
use one of the default files 
<code>c2s.fortran</code> or <code>c2s.script</code> 
which live in the same directory as 
<coderef id=code2sgml collection=upconvprogs>code2sgml</coderef>
as a template:
<verbatim>
cp /star/bin/sgml/c2s.fortran ./c2sconfig
vi c2sconfig
code2sgml -c c2sconfig -D this.f that.f other.f > routines.sgml
</verbatim>

<li>The resulting SGML document can now be used for generating 
both the descriptions of commands or routines in the SUN
and, if applicable, Starlink <code>.hlp</code> 
files for use by the HLP system (<docxref doc=sun124 text='SUN/124'/>).
Because of the way that the files have been generated, they
will contain only ASCII-like content.
If you want to include more sophisticated content,
for instance &latex; representations of mathematics,
the new prologues can be altered.
If they will be used for generating HLP files (viewed on a character
terminal) as well as the SUN descriptions, then alternative 
forms of such parts should be retained using the 
<ref id=el.sun.span>span</ref> element, e.g.
<verbatim><![ CDATA [
<span media='tty'>
<verbatim>
   x**n + y**n = z**n
</verbatim>
</span>
<span media='print,screen'>
<mequation>
   x^n + y^n = z^n
</mequation>
</span>
]]></verbatim>

<li>If the conversion is satisfactory, you may wish to 
check that the converted copies of the source files still compile
(they certainly should) and replace the originals in the source archive.
</ol>

<p>The prologues having been marked up, the main text of the SUN
must now be converted to SGML.
This can be a somewhat iterative process depending
on the success of the various stages.

<ol>
<li>Remove the appendix which contains command/subroutine 
descriptions from the &latex; file.

<li>Make preparatory adjustments to the &latex; as advised in 
<ref id=upconvert.latex.prepare></ref>:
<ul>
<li>Remove low level HTML and &latex; formatting commands where possible,
especially in user macros
<li>Ensure that figures, including 
<code>\includegraphics</code>-type commands, 
are contained within &latex; <code>figure</code> environments
<li>Remove (and make a note of) any &latex; macro definitions which 
you want to remain as user macros instead of being expanded 
in the final document
</ul>

<li>Perform the conversion, specifying the location of the SGML
command/subroutine documentation if applicable:
<verbatim>
latex2sgml -R routines.sgml sun321.tex
</verbatim>

<li>Assess how well the conversion went:
<ul>
<li>Attend to anything which <code>latex2html</code> itself complains
about (the first part of the screen output of <code>latex2sgml</code>)
<li>Look at the <code>sun321.translog</code> file, especially lines 
beginning with `<code>4:</code>' or lower numbers.
<li>Check whether the resulting document conforms to the programcode DTD:
<verbatim>
parse -s sun321.sgml |& grep -v :W:
</verbatim>
(this invocation ignores warnings about missing Summary subdocument 
entities, which are harmless)
<li>Examine the resulting document by hand to see whether the markup
looks right semantically.
</ul>

<li>If there have been problems,
then either edit the original &latex; document accordingly and do the
upconversion again, or edit the resulting SGML.
In fact some combination of these techniques 
combined with repeating various parts of the
checking and conversion process will probably be required --
some trial and error may be necessary.

<li>If you removed any &latex; macro definitions to protect them
from expansion in maths elements, replace them now within 
one or more <ref id=el.sun.mdefs>mdefs</ref> elements in the SGML.

<li>The <ref id=el.sun.routinelist>routinelist</ref> 
element will have been inserted in
the first appendix of the document.  If this is not the right place,
you may wish to move it.

</ol>

If you have successfully eliminated parse errors you now have a 
document which conforms syntactically to the appropriate DTD.
You can now try <em>downconverting</em> it to produce the resulting
HTML, and &latex; for eventual user consumption, as described
in <ref id=processing></ref>:
<note>In fact the <code>sgml2docs</code> command produces a file called
      <em>doc</em><code>.tar</code>, so running either of these commands
      directly after the other would overwrite the result of
      the former one.</note>
<verbatim>
sgml2docs --html sun321.sgml
sgml2docs --latex sun321.sgml
</verbatim>
and if appropriate the HLP file too:
<verbatim>
sgml2hlp routines.sgml > routines.hlp
</verbatim>
The results can then be compared with the pre-SGML end user documentation.
It is inevitable that they will not be identical; 
some of this may be addressed by modifying the SGML source, but
since the SGML system is still under development there may be 
things it was possible to do in &latex; which are, by design
or otherwise, not possible with the current SGML DTDs.
Anything which constitutes a serious problem should be fed back into
the design discussions for future development of the SGML project.


<sect id=final export>Finally

<subsect id=final.development export>Further developments
<update versionid="post-0.3">
Added extended Oasis table support to the wish list.
</update>


<p>What's next?  This section contains rather miscellaneous ideas for
further work.  They're ordered from most to least work, but on the
basis of about two seconds' reflection, so nothing should be pinned on
this.  The work involved seems to correspond rather neatly with their
expected utility.

<dl>
<dt>XML
<dd>I'd like to support XML (see <ref id=final.xml/>).  This requires
a little development of the DTD but, more substantially, also requires
investigating what level of support we can reasonably expect from
users' browsers.  There is a great deal of work being done on XML at
present (mid-1999) -- when the developments settle down we can start
to exploit them.  There's a big range of possibilities here, so this
could be a smallish task or a huge one, depending on what we wanted to do.

<dt>Searching
<dd>I'd like to support sophisticated searching.  The Starlink HTX
system allows some context-based searching (see <docxref
doc="sun188" loc='searching_for_information'/>), and it should be easy
to support this and more in the SGML set.  This would involve
finding a suitable SGML-aware search engine.  The <webref
url="http://info.ox.ac.uk/bnc/sara/" >BNC's SARA server</webref> might
be a possibility: I think it's free, but I haven't yet investigated
the extent to which it's specific to the BNC, or to its windows
client.

<dt>Table support
<dd>I'd like to support more of the Oasis table subset (see 
<ref id=str.tables/>).  I can add support incrementally, as folk suggest
priorities.

<dt>CSS stylesheets
<dd>At present, the formatting is controlled by the parameters file.
I could remove this and instead distribute a CSS stylesheet, which
would also allow individual users to selectively override things they
didn't like.

<dt>Include elements for Examples, Notes, Warnings?
<dd>How important is this?  It might be nice to have explicit support
for these, but I don't want to bloat the DTD with too many features,
so it's a question of balance.  I'd thought of something like:
<code>&lt;callout type=warning>Switch the computer on before
attempting to read your mail&lt;/callout></code>.  Having `type' be
`example', `note' or `warning' gives the thing attractive symmetry,
but would this improperly bundle different things together.
<!--
I think that examples should go within %body.content, and
contain paragraphs.  Notes and warnings should be in p.content?  I'm
not sure how necessary it is to support these so explicitly.
-->

<dt>Link colouring
<dd>Output, for example, a little coloured dot (4x2 pixels) before all or some
links, indicating what type of link this is.  For example, unadorned
links are to other parts of the same document (ie, <code/&lt;ref&gt;>), a
red dot indicates a reference to another Starlink document (ie,
<code/&lt;docxref&gt;>), a blue one to a miscellaneous URL.  I've
implemented a similar thing on another system, and it's both
unobtrusive and rather helpful.

</dl>

<subsect id=final.xml export>XML

<p>The primary XML resources are
<ul>
<li><url>http://www.w3.org/XML</url> for the W3C's XML spec
<li><url>http://www.ucc.ie/xml/</url> for the XML FAQ
<li><url>http://www.xml.com/xml/pub/axml/axmlintro.html</url> for the
annotated spec
</ul>

<subsubsect>XML is SGML&ddash;
<p><ul>
<li>An SGML document consists of an `SGML declaration' which
sets various options, a `document type definition' (DTD) which
establishes the syntax of a document type, and a `document instance',
which is the actual document.

<li>XML has a single, fixed, SGML declaration, which sets most of the
SGML options to `off'.  For example, in XML all element names are case
sensitive, there is no tag omission, there are some restrictions on
the possible syntaxes expressible by the DTD, and more exotic features
such as SUBDOC are forbidden.  For a more detailed discussion of the
differences, see 
<webref url='http://www.w3.org/TR/WD-xml-lang.html#secA.'
>appendix A</webref> of the spec.

<li>This means that parsers are easy to write, and there are numerous
such parsers available for free.

<li>XML dispenses with the SGML declaration; it can dispense with a
DTD as well.  XML introduces the notion of `well-formed' versus
`valid' documents.
<p>If a document has all closing tags present,
and all elements properly nested, and starts with the declaration
<verbatim>
   &lt;?xml version="1.0" standalone="yes"?>
</verbatim>
and empty elements are
written <code>&lt;empty/></code>, then it is `<webref
url='http://www.ucc.ie/xml/#FAQ-WF' >well-formed</webref>', and may
be processed in the absence of a DTD.

<li>A file which has a DTD and which conforms to it (which will also
be well-formed), is `<webref url='http://www.ucc.ie/xml/#FAQ-VALID'
>valid</webref>'.  It may optionally also begin with the XML declaration
<verbatim>
&lt;?xml version="1.0"?>
</verbatim>

<li>That is, a valid XML document is also a conforming SGML document.
This has been made possible by recent subtle, technical, changes to
the SGML standard.

<li>The latter has come about because there has been close cooperation
between the developers of XML and the wider SGML community.  That is,
XML is fully legit as SGML.

</ul>

<subsubsect>XML is not HTML++

<p><ul>
<li>XML is a real standard (well, there <em/are> HTML standards, but
noone pays any attention to them).
<li>HTML has a fixed element set, and associates fixed semantics with
those elements.  XML has neither restriction.
</ul>

<subsubsect>Associated standards

<p><ul>

<li><webref url='http://www.w3.org/TR/WD-xlink' >XLink</webref> is a draft
specification for links in XML. It's closely related to the hyperlinks
module of HyTime.

<li><webref url='http://www.w3.org/TR/WD-xptr' >XPointer</webref> is a
draft specification for location specifiers in XML, so that you
can refer, for example, to `the second section beneath the
element with id so-and-so'. As with XLink, it's closely related
to HyTime.

<li><webref url='http://www.w3.org/Style/XSL/' >XSL</webref> are style
sheets for XML.  These are vital if XML is to be readable when it is
served over the web (because it doesn't have the fixed semantics HTML
has, XML rendering can't be left entirely to a browser).

<li>The <webref url='http://www.w3.org/DOM/' >Document Object
Model</webref> (DOM) is `a platform- and language-neutral interface that
allows programs and scripts to dynamically access and update the
content, structure and style of documents' [from the spec].  It's a
simple set of O-O declarations for querying and manipulating XML
documents in simple ways (small subset of DSSSL).

<li><webref url='http://www.hytime.org/' >HyTime</webref> is a very
high-level standard for associating semantics with SGML DTDs.

<li><webref url='http://www.oasis-open.org/cover/dsssl.html'
>DSSSL</webref> is the Document Style and Semantics Specification
Language. It's a language for writing stylesheets in.  Both HyTime and
DSSSL are specific to SGML, but have informed the other standards
above.

</ul>

<subsubsect>Future developments

<p><ul>

<li>SGML technology will work with XML (as long as it conforms to the
minor technical corrigenda mentioned above)

<li>Because XML is <em/much> easier to parse than fully general SGML,
it is <em/much> easier to produce parsers for it.  It is therefore
very likely that we will soon see many XML editors and XML-aware
browsers in the months to come.

<li>We should also see XML-aware search engines, potentially finally
realising the possibilities offered by hightly structured information
storage and retrieval.

<li>The development of 
<webref url='http://www.w3.org/Math/' >MathML</webref> should help see
maths on the internet

</ul>

<subsect id=final.ack export>Acknowledgements

<p>I've benefited greatly from various contributers to the usenet
newsgroup <code/comp.text.sgml>, from the Oasis SGML pages at
<url>http://www.oasis-open.org/cover/</url> and references there, and
specifically from the various papers made available by Eliot Kimber
and co.~at <webref url='http://www.isogen.com' >Isogen International
Corp</webref>. 

<p>The DSSSL code started off heavily based on Norman Walsh's <webref
url="http://nwalsh.com/docbook/dsssl/" >DocBook
DSSSL stylesheets</webref>.

<p>We should like to thank Rodney Warren-Smith, Martin Bly, Peter
Draper and David Berry for detailed discussions and criticisms in
several <em/long> meetings during this Kit's development.

<appendices>

<sect id=appx.sgml export>SGML -- some of the details

<p>This section covers some SGML topics in a little more detail than is
necessary if you simply want to write Starlink documents.  It should
give you enough understanding to allow you to read most DTDs.

<p>This section is for extra, or more detailed, information than it
was necessary to include in <ref id=markup/>.  It will not, therefore,
repeat information presented there.

<subsect id=sgml.std export>Standard identification

<p>The SGML Standard Identification:
<blockquote>
An SGML Application Conforming to International Standard ISO 8879 --
Standard Generalized Markup Language
</blockquote>
SGML has many features not described in this document.
For further details, see the standard, <citation/iso8879> or
<citation/goldfarb> (better, since it contains all the standard text
plus commentary).

<p>The HyTime Standard Identification:
<blockquote>
A HyTime application conforming to International Standard ISO/IEC
10744 -- Hypermedia/Time-based Structuring Language
</blockquote>
For further details of the possibilities available via HyTime, see
<ref id=appx.system.hytime/>, or the HyTime
standard,~<citation/iso10744>.

<subsect id=sgml.dtd export>Reading DTDs

<p>The discussion in <ref id=markup/> should be enough to let you
produce your own documents but, now or in the future, you may find it
useful to be able to read the DTD directly.<note>Note for pedants:
there is a distinction between document type declaration and
definition.  The document type definition is the collection of rules
which specifies which elements can go where, what attributes they
have, and so on; the declaration is the <code>&lt;!DOCTYPE...></code>
invocation at the top of the document file -- the `document instance'
in SGML parlance -- which associates that instance with a particular
definition.  The abbreviation `DTD' usually refers to the definition,
and it is the definition that this section is about.</note> Once you
are familiar with the underlying ideas, the expression of them in the
DTD turns out to be agreeably compact and reasonably readable.

<p>My account of the DTD syntax will be rather compressed -- see
<citation/gentle>, or the other references in 
<ref id=what.sgml/> for alternatives.

<p>A simple HTML-like DTD could be declared as follows:
<verbatim><![ CDATA [
<!ELEMENT html      O O (head, body, copyright?)>
<!ELEMENT head      O O (title & link*)>
<!ELEMENT title     - - (#PCDATA)>
<!ELEMENT link      - O EMPTY>
<!ELEMENT body      O O (p | dl)+>
<!ELEMENT p         - O (#PCDATA)>
<!ELEMENT dl        - - (dt, dd)+>
<!ELEMENT (dt|dd)   - O (#PCDATA)>
<!ELEMENT copyright - - (#PCDATA)>

<!ENTITY % URL "CDATA"
        -- The term URL means a CDATA attribute
           whose value is a Uniform Resource Locator,
           See RFC1808 (June 95) and RFC1738 (Dec 94).
        -->
<!ATTLIST link
    href  %URL          #REQUIRED  -- URL for linked resource --
    rel   (next | prev) #IMPLIED   -- reverse link types --
    >
<!ENTITY amp "&">
]]></verbatim>
And here is a simple document which uses this DTD:
<verbatim><![ CDATA [
<link href="http://www.astro.gla.ac.uk/users/norman/" rel=next>
<title>This is a title</title>

<p>And here is a paragraph
<dl>
<dt>With a delimited list
<dd>Correctly formed &amp; OK
</dl>
]]></verbatim>
This displays most of the important syntactical features in an SGML
DTD, so if we explain it line-by-line, it should illustrate the
features you need to make some sense of most DTDs.

<p><verbatim><![ CDATA [
<!ELEMENT html    O O (head, body, copyright?)>
]]></verbatim>
This `element declaration'
declares the <code/html> element.  The element type name is followed
by a statement of whether the start and end tags may be omitted if the
parser can infer their presence.  The minimisation specifications may
be either `-' (minus), indicating that the corresponding tag is
required, or `O' (letter~O), indicating that it may be omitted.
Following this is the `content model' which, in this case, states that
the <code/html> element must consist of one <code/head>, one
<code/body>, and an optional <code/copyright>, in that order -- the
comma connecting the element 
names specifies that they must be in order, and the question mark
following the copyright element indicates that it may occur zero or
one times. 
The omission of the start element is possible in this case, since the
first element in the <code/html> element must be a <code/head>
element, so whenever the parser finds a <code/head> element, it can
know that the <code/html> element has begun.

<p>So what is in the <code/head> element?
<verbatim><![ CDATA [
<!ELEMENT head    O O (title & link*)>
]]></verbatim>
The <code/head> element consists of precisely one title, and zero or
more <code/link> elements, in either order.  The <code/head> tags
can be inferred from the presence of
the <code/title> and <code/link> elements, and so it is feasible for
us to declare that they may be omitted.  The star following the
<code/link> token in the content model indicates that this element may
appear zero or more times, and the ampersand declares that the
elements on either side of it must both appear, but can do so in
either order.  Note that this content model allows `<code/title>',
`<code/title link link...>' and `<code/link link...title>', but not
`<code/link>' or `<code/link title link>'.

<p>Finally we have some text:
<verbatim><![ CDATA [
<!ELEMENT title   - - (#PCDATA)>
]]></verbatim>
The title element is very simple: neither the start not the end tag
may be omitted, and it may contain only characters (<code/#PCDATA>
stands for `parseable character data') and entity references such as
<code/&amp;amp;>.

<p><verbatim><![ CDATA [
<!ELEMENT link    - O EMPTY>
]]></verbatim>
The <code/link> element has no actual content, so it is given a
content model consisting of the reserved word <code/EMPTY>.  The tag
omission for empty elements is always `<code/- O>'.  The point of the
<code/link> element is to hold its attributes, which we will come to
shortly.

<p><verbatim><![ CDATA [
<!ELEMENT body    O O (p | dl)+>
]]></verbatim>
The document body consists of paragraph elements, or `delimited
lists'.  The `or' connector, `<code/|>', indicates that either of the
<code/p> or <code/dl> elements may appear, and the `plus' occurrence
indicator asserts that the group <code/(p|dl)> must appear one or more
times.  In other words, the body consists of a sequence of <code/p>
and <code/dl> elements in arbitrary order.

<p>Finally, we start to specify the `interesting' content of the document.
<verbatim><![ CDATA [
<!ELEMENT dl      - - (dt, dd)+>
]]></verbatim>
Like the <code/body> itself, the <code/dl> element consists of a
sequence of one or more structures.  Unlike the <code/body> element,
however, the structure is not a list of alternatives, but a sequence.
Where the <code/body> element would allow `<code/p p dl p>' for example, the
<code/dl> element requires that the <code/dt> and <code/dd> elements
alternate -- the repeatable element is the <em/ordered pair> of
elements `<code/dt, dd>'.

<p><verbatim><![ CDATA [
<!ELEMENT (dt|dd) - O (#PCDATA)>
<!ELEMENT p       - O (#PCDATA)>
<!ELEMENT copyright - - (#PCDATA)>
]]></verbatim>
The paragraph, list and copyright elements have simple content
models.  Note that we can specify the structure of more than one
element in the same declaration.

<p>Prior to specifying the attributes for the <code/link> element, we
may declare an abbreviation.
<verbatim><![ CDATA [
<!ENTITY % URL "CDATA"
        -- The term URL means a CDATA attribute
           whose value is a Uniform Resource Locator,
           See RFC1808 (June 95) and RFC1738 (Dec 94).
        -->
]]></verbatim>
This declares <code/URL> to be a `parameter entity', usable only
within this DTD.  The entity reference `<code/%URL>' will be
substituted by the string `<code/CDATA>' (unparsed character data)
when it is encountered.  A DTD may declare an entity more than once,
but any declarations after the first are silently ignored.

<p>Note the structure of the comment in this last declaration: in SGML,
comments may appear only within markup declarations (that is within
`<code/&lt;! ... &gt;>'), they start and end with the string
`<code/&#45;&#45;>', and there may be more than one in a row.  Thus you
may legally find `<code/&lt;!&gt;>' within an SGML file -- this is a
completely empty markup declaration.  Such a declaration may have a
single comment within it, as in `<code><![ CDATA [<!-- this is a comment
-->]]></code>', or it may have several, as in
<code><![ CDATA [<!-- here -- -- is a comment ------>]]></code>, which
has <em/three> comments within it, the third of which is empty. 

<p>Now we declare the attributes for the <code/link> element.
<verbatim><![ CDATA [
<!ATTLIST link
    href  %URL          #REQUIRED  -- URL for linked resource --
]]></verbatim>
This declares an <code/href> attribute.  After expansion of the
<code/%URL> entity reference, this attribute is seen to have a
`declared value' of <code/CDATA> (unparsed character data), and this
attribute is required to be present, so that the SGML parser will
object if it finds a <code/link> element in a document without an
<code/href> attribute.

<p>The <code/rel> attribute can take only two values:
<verbatim><![ CDATA [
    rel   (next | prev) #IMPLIED   -- reverse link types --
    >
]]></verbatim>
The <code/link> element may have the attribute `<code/rel=next>' or
`<code/rel=prev>', but no other strings.  Since this attribute is
`<code/#IMPLIED>', it is also permitted to omit it entirely.  A
document may even specify this as simply `<code/&lt;link
href=&quot;here.html&quot; next>>' and the parser will infer that the value
`<code/next>' is associated with the attribute name `<code/rel>'.

<p><verbatim><![ CDATA [
<!ENTITY amp "&">
]]></verbatim>
Entity references (other than parameter entities, which are internal
to a DTD) are made using a
construction such as `<code/&amp;entname;>.  This presents a problem
if you want to include the ampersand in your text, but this
declaration sets up an entity called `amp', which can be used to
include an ampersand in text by typing `<code/&amp;amp;>'.  You can
use this in your own documents to create shorthand forms for bits of
text you don't want to retype.

<subsect id=sgml.dtdsubset export>Document type declaration subset

<p>As explained above, the structure of your document type, plus a
variety of entities, is declared in the DTD, which, because it is
common to a large number of documents, is held separately
from the document you are writing.

<p>It is possible, however, for a specific document to adjust or add to the
declarations within the DTD, and this is done within the `document
type declaration subset'.

<p>The DTD subset is typically used to declare entities of one type or
another, as described in <ref id=markup.dtdsubset/>.

<p>The subset is a DTD fragment which is processed <em/before> the
declaration refers to.  Thus, any (parameter) entity declarations
there override corresponding ones in the DTD, so it is possible for a
document author to do some limited rewriting of the DTD on the fly.
This will be most common when a DTD is modular, as the Starlink DTD
is.  As described in <ref id=str.structure/>, you can enable features
within your DTD by setting a suitable entity.

<p>This get-out-of-jail-free card is obviously eminently abusable, and
you should avoid doing anything clever here.

<subsect id=sgml.entities export>SGML entities

<p>As described in <ref id=markup.entities/>, entity references are a
mechanism for referring to characters, or 
longer pieces of text, which you cannot type on your keyboard, which
must be escaped from the parser, or which you simply want to
abbreviate.

<p>As well as general entities, there are parameter entities.  These
can be referenced only within markup declarations, and hence are
effectively restricted to the DTD.  The only time you'd use them in a
document instance would be within a marked section (
<ref id=markup.ms.variants/>).  The point of parameter entities is that a document
author can define any entities they want in the declaration subset,
without having to worry that they might conflict with declarations in
the DTD.

<p>A reference to an entity <code/amp> is of the form
<code/&amp;amp;>.  It is prefixed by the character <code/&amp> and
suffixed by a semicolon.  In fact, you can omit the trailing semicolon
if the character following the entity name is not a name character --
not a letter, number, hyphen or dot.  Similarly, an ampersand not
followed by a name-start character (upper- and lowercase letters) is
recognised as an ampersand, and not a malformed entity reference.  It
is possibly bad to get into the habit of abbreviating entity
references, but you might need to be aware that these features both
exist and are legal.

<p>The list of entities predefined by the Starlink general DTD is
given in <ref id=table.entities/>.

<p>It is not an error to define an entity twice.  In this case, the
second definition is silently ignored.

<p>You can define entities, including parameter entities, in the
document's `declaration subset' (see <ref id=markup.dtdsubset/>), since
these conceptually come before, and hence have priority over,
definitions in the DTD.  Also, SGML parsers usually allow 
on-the-fly definitions on the command line.  However, resist resist
resist the temptation to do clever things here, since it is easy to
make your document unreadable and, a much more heinous crime, invalid.

<subsect id=sgml.ms export>Marked sections

<update versionid="post-0.2">This section trimmed, and the
discussion of the `author-visible' uses of MSs moved to the `Marking
up...' section.

<p>As described in <ref id=markup.ms/>, SGML includes the notion of a
`marked section'.  These are used only rather occasionally by authors,
but are very frequently used within DTDs, particularly the
<code/IGNORE> and <code/INCLUDE> marked sections.

<subsubsect>IGNORE and INCLUDE marked sections

<p>About the only use of the <code/IGNORE> and <code/INCLUDE> marked
sections in documents is to delimit variant sections of text (see 
<ref id=markup.ms.variants/>).  They are, however, very common within DTDs.

<p>Why on earth would you want to include or exclude text in DTDs?
Because the IGNORE/INCLUDE 
keyword can be the expansion of an entity.  We could have defined our
HTML-like document type as follows:
<!-- can't use marked section when I'm illustrating one! -->
<verbatim>
&lt;!ENTITY % allow.copyright &quot;IGNORE&quot;>
&lt;![ %allow.copyright; [
  &lt;!ENTITY % html.model &quot;head, body, copyright?&quot;>
  &lt;!ELEMENT copyright - - (#PCDATA)>
&rsqbrack;]>
&lt;!ENTITY % html.model &quot;head, body&quot;>
&lt;!ELEMENT html    O O (%html.model;)>
</verbatim>
This looks very strange, but it is a common idiom.  

<p>The entity reference <code/&percent;allow.copyright;> is a
`parameter entity reference' (see section <ref id=sgml.entities/>),
which is distinct from a general entity 
reference such as <code/&amp;amp;>, and can occur only within markup
(ie, within DTDs).

<p>The parameter entity <code/%allow.copyright> is defined to be
<code/IGNORE>.  That means that when the parser finds the marked
section it ignores it, so that the first definition it finds of the parameter
entity <code/%html.model> is the one which sets it to be
`<code/head,body>', so that is what is used as the content model
in the declaration of the <code/html> element in the last line.

<p>Nothing appears to have been achieved here.  However, if the
<code/%allow.copyright> entity had <em/earlier> been set to
<code/INCLUDE>, then the redefinition of it here would have been
ignored, the marked section would have been included, the
<code/%html.model> entity would have been defined as
`<code/head,body,copyright?>' with the (now) second one ignored, and
the <code/html> element would have been defined to allow all three
elements.  That is, marked sections used internally in this way can be
a useful way of parameterising DTDs.

<p>The entity could be declared earlier in the same DTD, in a
particular document's DTD-subset (see <ref id=markup.dtdsubset/>), or
completely externally to the document in a command-line option to the
parser.

<sect id=appx.supportprogs export>Support utilities
<update versionid=v0-6-2>Added codecollections for bin and lib
directory programs</update>
<update versionid=v0-6-3>Moved to a section of their own</update>

<routinelist>
<p>Here you can find documentation for the user tools which are
distributed as part of the SGML kit.

<codecollection doc="supportbinaries" id=supportprogs>
<codecollection doc="upconv.bin" id=upconvprogs>

<sect id=appx.general.dtd export>The Starlink General DTD

<p>This section includes a list of all the elements in the Starlink
General DTD.  For a thematic treatment of the elements, see 
<ref id=structure/>, and the groups in <ref id=table.elements/>.

<p>The elements listed here are shown as children of the top-level
element <code>&lt;sun></code>, because this is the most general of the
document types described in <ref id=str.structure/>.  However, the
listing here does not <em/quite> document the SUN DTD, since it
includes the <ref id=el.sun.docdate>docdate</ref> element which is
only available in those document types which do <em/not> have the
`Versioning' feature (see <ref id=str.structure/> and 
<ref id=str.history/>).

<subsect id=appx.general.elementlist export>Element listing

<p>The following element listing includes all the elements and
attributes defined in the Starlink General DTD.  This includes a
number of attributes with a <em/fixed> value (indicated by a default
keyword of <code/#FIXED>).  These are for internal use by the DTD and
the applications which process it, and are not documented further.

&starlinkdtddoc;

<sect id=appx.programcode.dtd export>The Programcode DTD

<p>See <ref id=doccode/> for an overview of documenting code.

<p>The programcode DTD described here is the same for all languages.
When you invoke it, however, you do so using a document type
declaration specific to the language of the program being documented.
See <ref id=doccode.languages/> for details.

<p>As noted above, in <ref id=doccode.elements/>, the programcode
includes the same paragraph model as the Starlink General DTD.  In the
element listing below, therefore, these are not duplicated separately,
but instead consist of a reference to the appropriate part of the
General DTD's documentation.

<subsect id=appx.programcode.elementlist export>Element listing

&programcodedtddoc;

<sect id=appx.system export>The Starlink SGML set for maintainers
<update versionid="post-0.2">Very substantial additions -- this
section was barely present before.</update>
<update versionid='v0-6-3'>Relocated this section to end of
appendices.</update>


<p>This section is a technical reference for maintainers of the
Starlink SGML set.  The documentation here may be provisional, or
irrelevant, or use terminology not defined elsewhere in the document.
Any functionality described here may change between releases without
warning, and without preserving backward-compatibility.
It is included as an appendix in this user-level documentation for the
benefit of those maintaining the set, and for any others who are interested.

<subsect id=appx.system.sgml export>SGML arcana

<subsubsect id=appx.system.sgmldoc export>The SGML status of this project

<p>The SGML application conforms to the SGML~<citation/iso8879> and
HyTime~<citation/iso10744> standards.  The processing system uses
DSSSL (see <ref id=appx.system.dsssl/> and~<citation/iso10179>), which
is a standard, but generates HTML using DSSSL extensions specific to
Jade, and generates LaTeX using DSSSL extensions specific to a patched
version of Jade.

<p>A good deal of effort has been invested in making the SGML side of
this project both robust and correct.  `Correct' here means a lot more
than merely `it works': it means that it conforms with both the letter
and the spirit of the SGML standard, and with the occasionally
nebulous notions of `best practice' for SGML applications.

<subsubsect id=appx.system.hytime export>HyTime, architectures and groves

<p>As noted above, in <ref id=appx.system.sgmldoc/>, this DTD is an
application of the HyTime standard.

<p>The HyTime standard <citation/iso10744> specifies three things,
which are distinct, but easily confused (the standards document is not
an easy read -- not because it is unclear, but because it is so very
abstract; there are unfortunately few accessible alternatives).  It
defines a standard processing model for SGML documents in terms of the
`grove'; it extends the SGML standard by introducing the notion of
`architectures'; and it specifies a particular architecture -- the
HyTime architecture -- for abstracting the semantics of document
links.

<p>A `grove' is an acyclic directed labelled graph (I think!) --
alternatively defined, even in the HyTime standard, as `a bunch of
trees and other stuff' -- which is the data structure into which an
SGML document is nominally transformed, and with respect to which the
semantics of SGML standards (SGML itself, HyTime, DSSSL and others)
are now formally defined.  DSSSL is designed to be able to query the
grove straightforwardly and efficiently, but unless you are
maintaining the more recondite parts of the DSSSL sources, which query
a few grove properties directly, you will not need to be aware of
anything more than the grove's formal existence.  The grove is
formally defined in <webref
url="http://www.ornl.gov/sgml/wg8/document/n1920/html/clause-A.4.html"
>ISO/IEC 10179, clause~A.4</webref>: there are introductions and
tutorials on the relevant Oasis <webref
url='http://www.oasis-open.org/cover/topics.html#groves' >special
topic</webref> list, of which Paul Prescod's tutorial
<citation/prescod99> is particularly good, and Kimber has written
variously on this <citation/kimber97c>.

<p>An `architecture' is a skeleton DTD (the HyTime first edition name
for it was `meta-DTD').  An individual DTD may declare itself to be a
`client' of the architecture by asserting the fact, and defining (or
allowing to be defaulted) a mapping between the element forms it
defines, and those defined in the architecture (the architectural
elements are referred to as `architectural forms' in that context).
For example, the Starlink General DTD declares itself to be a client
of the DocumentSummary DTD (which is easy, because the elements
defined in the latter are a subset of the elements defined in the
former), and the DSSSL programcode DTD declares itself to be a client
of the DSSSL architecture, with suitable remappings of element and
attribute names (see <ref id=doccode.dsssl/> for discussion, and see
the reference cited there).  For formal details see the HyTime
standard, particularly clause~A.3, <cite/Architectural forms
declaration requirement>.  The relevant Oasis
<webref url='http://www.oasis-open.org/cover/topics.html#archForms'
>special topic</webref> has an overwhelming number of references on
this, of which Kimber's article <citation/kimber97b> is very good.

<p>Finally, the HyTime standard defines a particular architecture --
the so-called HyTime Architecture.  This architecture defines forms
(ie, elements in a meta-DTD) suitable for expressing all kinds of
linking semantics, from a simple link from one part of a document to
another, all the way up to indirect many-to-many links between
fragments of non-SGML media (for example sections of an image or
passages in a piece of music).  Crucially, it defines the semantics of
these forms formally and precisely.

<p>As a consequence a DTD can declare itself
to be a client of (some subset of) the HyTime architecture, formally associate
elements it defines with the available architectural forms, and thus
inherit the precise semantics and associated documentation.
The point of this is twofold.  Firstly, it means that the DTD
inherits the documentation of the forms it has referred to.  A reader
of the DTD, who is familiar with HyTime, can therefore look at a
declaration and immediately know what its intended meaning is.
Secondly, that reader of the DTD need not be human: a `HyTime engine'
is a processor which can interpret the HyTime forms in a document and
process them correctly without further configuration.

<p>For example,
the Panorama SGML viewer is an application, which is also available as
a Netscape plug-in, which will display SGML.  When it displays SGML,
it formats it appropriately, guided by a style-sheet which expresses
things like what font to display headings in.  It also, however, has
built-in knowledge about the HyTime <code/clink> element (`contextual
link'), and knows what to do with it.  If the viewer is given a
document and DTD which has properly declared itself as a HyTime
client, such as the Starlink General DTD, then Panorama can format and
follow <code>&lt;ref></code> elements (for example) immediately.

<p>The <ref id=el.sun.webref>webref</ref> element in the Starlink
General DTD is declared much as follows (compare <citation/iso10744>,
clause~7.8)
<verbatim>
&lt;!ELEMENT WEBREF - - (#PCDATA)>
&lt;!ATTLIST WEBREF
    url      CDATA #REQUIRED
    &ddash HyTime attributes... &ddash;
    HyTime   NAME  #FIXED clink
    HyNames  CDATA #FIXED "linkend url"
    anchcstr NAMES #FIXED "self required"
    linktrav NAMES #FIXED "A D"
    loctype  CDATA #FIXED "url QUERYLOC URL"
    >
</verbatim>
Line-by-line, this says that the element is mapped to the HyTime
`clink' element, that that element's `linkend' attribute should be
mapped to the webref element's `url' attribute, that the direction of
the link is from the link itself to a to a required target, that
traversal of the link consists of arriving at it (putting a mouse over
it and clicking, for example) and then departing from it (ie, the link
is one-way -- the fact that a browser may add semantics to this by
providing a back button is not part of the definition of a webref
element, nor part of its meaning in the context of a particular
document), and finally that the content of the `url' attribute is a
query in a predefined notation referred to as `URL'.  A HyTime
processor therefore transforms the element <code>&lt;webref
url="http://www.hytime.org">Hello&lt;/webref></code> into
<code>&lt;clink linkend="http://www.hytime.org" linktrav="A D"
loctype="url QUERYLOC URL">&lt;/clink></code>.
<!-- FIXME: is this right, or should it be loctype="linkend queryloc url"?-->

<p>If you're curious, you can obtain the HyTime view of a document
with the command <kbd/sgmlnorm -A hytime ssn70.sgml>.<note>Note that
this currently doesn't work fully -- there's some defect in the HyTime
declaration of the docxref element type which I haven't been able to
identify.</note>

<p>The linking elements in the Starlink General DTD have been defined
in terms of HyTime.  This is partly for documentation purposes, partly
for completeness, but mostly so that the groundwork will have been
done when there is an opportunity to use a HyTime-aware application
such as Panorama.  I will claim this as a full implementation,
however: I have no access to a HyTime engine, and so I cannot test
that the HyTime declarations here are in fact correct.

<p>See <ref id=appx.system.online/> for online resources.

<subsubsect id=appx.system.dsssl export>DSSSL

<p>The SGML processing part of this package is implemented in DSSSL,
which is a standard <citation/iso10179> for device independent
formatting of SGML documents.  DSSSL includes both a style language
and a (DTD to DTD) transformation language.  

<p>I have used James Clark's Jade
implementation of DSSSL.  This implements the style language, but not
the transformation language.<note>Although I believe Clark was involved with
the specification of the DSSSL standard, he has said (on the <webref
url="http://www.mulberrytech.com/dsssl/dssslist/" >DSSSList
discussion list</webref>, May 1999) that the transformation
language has significant weaknesses.</note>  Jade has back-ends which
generate RTF, MIF and rather odd &tex; requiring a specialised
&tex; format.  Clark added an SGML-transformation back-end, as a Jade
extension of the standard, which uses non-standard flow-object
constructors to specify SGML elements, entities and the like.  In
addition, I added a back-end which generates &latex;.

<p>It follows that the stylesheets which implement this Starlink
package are not standards-conforming, and are specific to Jade.  This
needs a little justification.

<ul>
<li>There are not too many alternative ways of producing HTML.  Perl
is a contender, since the <code/SGMLSpm> package (see <webref
url='http://www.cpan.org' >CPAN</webref>) can parse the output of
<code/nsgmls>.  This is perfectly legitimate, but I know from
experience that it can become rather messy.<note>It's a matter of
taste whether you prefer Perl or DSSSL.  DSSSL, based on Scheme Lisp,
is undeniably odd, but I've grown to rather like it.  A language with
no assignments, no loops, no real sequences of actions, and where
absolutely everything is a function, has a certain rather twisted
glamour to it, like a nature programme about fish-life four miles down
the Marianas Trench.</note>

<li>DSSSL has very good access to the SGML grove, and processes the
document in a generally `SGML-ish' way.  This feels like keeping
things in the family, as it were, even if the non-standard back-ends
have something of the wicked stepmother about them.

<li>One alternative is through XML and XSLT, but this would require
doing the work to transform the document from SGML to XML (which would
lose the subdocument processing features), and using XSLT which, from
what I've seen of it, looks like hell on earth.

</ul>

<p>This does not in any way affect the standards conformance of the
rest of the SGML set -- the various DTDs and the HyTime support --
since the processing of documents is by design completely independent
of the standards which define their markup.

<p>See <ref id=appx.system.online/> for online resources.

<p><ref id=appx.system.dssslcode/> includes documentation for some of
the important DSSSL stylesheets.

<p>Notes on the code:
<ul>
<li>In almost all cases, the code for the HTML stylesheet was
developed first, then adapted for the &latex stylesheet.  This makes
sense in general, as the HTML stylesheet has to do much more elaborate
formatting and rearrangement, whereas &latex can do much of the
simple information-shuffling itself.  It does, however, mean
that some fragments of code are duplicated in the two stylesheets,
even although the <code/slcommon.dsl> stylesheet is supposed to cover
all of that -- when it happens, this is typically an error, rather
than some great subtlety.

<li>The code started off as adaptations to Norman Walsh's DocBook stylesheets.
In some modules -- primarily the <code/slnavig.dsl> code which was the
section I began development with -- there are still relics of this
here and there.  There isn't a lint for Jade, so it's not trivial to
find and remove these.

<li>It's unattractive that the print-based stylesheet is so specific
to &latex;, and goes against the format-independent goals of DSSSL.
If it becomes necessary to produce another output format at the same
level of abstraction as &latex; -- 'roff would be an example, though
that seems unlikely -- the way to proceed would be to adapt the
&latex; stylesheet to produce output marked in some DTD which matches
the abstraction level of &latex; -- that is, describing sections and
paragraphs and so on, rather than the placement on the page which is
characteristic of the standard DSSSL FOs -- and then translate that to
&latex; and whatever.  The latter translation would be easy, since
there would likely be no information shuffling at all, but a
translation task little more demanding than search and replace.

</ul>

<subsubsubsect id=appx.system.jade>Jade and OpenJade
<update versionid="v0.6">Included description of, and pointer to,
OpenJade</update>

<p>James Clark's Jade distribution, at
<url>http://www.jclark.com/jade/</url>, has been frozen at Jade 1.2.1.
Jade development has now forked, with `OpenJade' being developed by
the community.  This is based at 
<url>http://jade-cvs.avionitek.com/</url>.  I hope to move to this
distribution when time is available.

<subsubsubsect id=appx.system.paramdsssl>Customising the DSSSL source
code.

<p>The DSSSL source code which produces the HTML and &latex; output
has been parameterised to a limited extent.  As described in 
<ref id=appx.system.dssslcode/>, it can therefore be customised either on the
Jade command line, or by providing Jade with an alternative DSSSL
parameters file.

<p>Jade has a <code/-V> option which takes a DSSSL variable name as
argument; this variable is then given the value <code/#t> (true),
overriding any other definition in a stylesheet.  Several of the
stylesheets' parameters are designed to be settable this way.  You can
either give this option explicitly on a Jade command line, or pass it
to Jade via the <code/sgml2docs> command line (see <ref id=proc.sgml2docs/>):
<verbatim>
sgml2docs '--jadeflags=-Vshow-element-ids' ...
</verbatim>

<p>If this type of customising is insufficient, then you may take a
copy of the appropriate parameters file in <code
fspath>$STARLINK_SGML_DIR/dsssl/sl/html/slparams.dsl</code> (or the
corresponding <code>.../latex</code> file), call it, say
<code/my-params.dsl>, and change what parameters 
you like.  The stylesheets refer to the parameters files by the public
identifiers <code>PUBLIC "-//Starlink//TEXT DSSSL Common Parameterisation//EN"</code>,
<code>PUBLIC "-//Starlink//TEXT DSSSL HTML Parameterisation//EN"</code>
and <code>PUBLIC "-//Starlink//TEXT DSSSL LaTeX Parameterisation//EN"</code>,
and these are mapped to the real files by the catalogue file in <code
fspath>$STARLINK_SGML_DIR/dtd/CATALOG.starlink</code>.  To direct the system to
your own parameter file instead, create a catalogue file of your own
(conventionally given the name <code/CATALOG>), and include the
appropriate line like
<verbatim>
PUBLIC "-//Starlink//TEXT DSSSL HTML Parameterisation//EN" my-params.dsl
</verbatim>
(you can give a path relative to the location of the catalogue, and
it's best if you quote the entry exactly as here).  To direct the SGML
system to this catalogue, you must include the file at the beginning
of the <code/SGML_CATALOG_FILES> environment variable:
<verbatim>
SGML_CATALOG_FILES=./CATALOG:$SGML_CATALOG_FILES
</verbatim>
(or use the corresponding <code/setenv> command).

<subsect id=appx.system.summaries export>Document summaries

<p>When referring to an external Starlink document via a 
<ref id=el.sun.docxref>docxref</ref> element, the processing system must
generate both the link text and, in the case of the HTML stylesheet,
the URL which is the link target.  It does this by processing the
document referred to by the element's `doc' attribute.  This document
must be marked up using the `document summary' DTD,
<code>"-//Starlink//DTD Document Summary 0.1//EN"</code>.

<p>The Document Summary DTD has the same general structure as the
Starlink General one, but the only text in it is the abstract
(possibly) and the content of the various section headings.  The
SGML set uses the structure expressed in here, to work out the section
number which will be given to the link text.
The DTD has attributes to control a `link policy' (whether we may link
to all elements, or only those with the export attribute present), and
exercise some control over the URLs which will be used in HTML
targets, if these are not to be generated using the same algorithm
used for the main document.  There is more flexibility in the Document
Summary DTD than is used at present.  The DTD is well-commented, and
you should refer to it for further details.

<![ IGNORE [
<p>The installation procedure generates document summaries for all the
Starlink documents it can find, using the script
<code fspath>$STARLINK_SGML_DIR/lib/abstract-star2html.pl</code> to scan
documents marked up ready for processing by Star2HTML.  This script
does not currently do a very neat job -- it's primarily designed to be
robust enough to be used in an unattended installation procedure, so its
&latex; parsing is somewhat simpleminded.  As noted in 
<ref id=appx.system.htx/>, the installation makefile invokes this script in
a precise way, to make generated HTML output conform to the
requirements of HTX.
]]>

<p>Since the Starlink General DTD declares itself as a client of the
Document Summary DTD (see <ref id=appx.system.hytime/> for a discussion
of architectures), the processing of cross-referenced documents could
be done by having the `doc' attribute point to the main SGML source of
the target document and extracting the DocumentSummary architectural
instance.  DSSSL's <code/(sgml-parse)> function does not, however,
support the extraction of architectural instances.  There is a Jade
patch at <webref url='http://www.isogen.com' >Isogen</webref> which
adds this as a Jade extension; this has been incorporated into the
OpenJade distribution (see <ref id=appx.system.jade/>), but not (yet)
into the Starlink version of Jade which accompanies this
set.  Note, however, that this is almost entirely an implementation
issue: if this feature were to be added to Jade, as it might be if it
conforms to any updated DSSSL standard which includes this feature,
the only changes necessary would be a possible adjustment of that
element's HyTime declaration, some adjustment of the call of the
relevant <code/(sgml-parse)> function, and corresponding changes in
the package's installation script so that the document summary
catalogue points to the original documents rather than a
freshly-generated set of summaries.  There would be no need for
documentation updates, since there would be no user-visible changes.
It is possible to extract the DocumentSummary architectural instance
by hand, using the command <kbd>sgmlnorm -A documentsummary
ssn70.sgml</kbd> for example.

<subsect id=appx.system.htx export>Cross-references, installing
documents, and the interaction with HTX

<p>The system generates cross-references to other Starlink documents
without further editing.  It does not test that the HTML target
exists, but assumes that if the document summary files exist, then the
HTML targets exist, or will exist by the time the output documentation
is installed.  An alternative system would have the link targets refer
to a live document server, so that the targets would be resolved when
they are referenced, rather than when the document is processed.  This
would, however, be unnecessarily complicated for a first version of
the system, as well as going beyond the current, and adequate, HTX
model.

<p>The current SGML set uses Star2html and HTX.  Star2html (see <docxref
doc=sun199/>) generates a distributable document set with correct
internal cross-references, and `best guess', but possibly broken,
external ones.  These references are then patched up in a separate
installation phase, being edited by a copy of HTX primed with
appropriate local knowledge (see <docxref doc=sun188
loc=how_linking_works/>).

<p>The aim of the current set is to produce documents which are in
their final form, and can be moved to their final location without
further editing -- this assumes that documents are distributed in
(SGML) source form and processed at installation time, and that the
SGML set is the only system producing documentation.  This aim has
been achieved in the current version, but could benefit from more
convenient parameterisation.

<p>Since HTX is likely to remain in use for the forseeable future, 
the current set is intended to be used with HTX, and is claimed
to be compatible with it.  It produces links in the format recognised
by HTX, as described (or defined?) in <docxref doc=sun188
loc=referring_to_targets/>.  Note two points, however.  

<ul>
<li>The generated
document set is compatible as <em/input> to HTX, and does not attempt
to emulate it to the extent of generating HTX index, catalogue and log
files.  This would not, however, be terribly difficult, and might
appear in a future version of this set.  There is therefore at
least a potential interaction between the development of the two
systems, and if you are involved in the development of either, some
liason would be useful.

<li>The compatibility is assured by cooperation between several
disjoint processing steps.  The DSSSL style sheets generate
appropriate internal labels, and the HTML parameters style sheet
contains a variable which sets the `document server' which is used
when generating URLs.  The document-summary DTD (see 
<ref id=appx.system.summaries/>) includes a <code/urlpath> attribute in its
section and label elements which specifies the tail of the URL where a
particular section lives, relative to an (unspecified) document
server.  The <code/abstract-star2html.pl> script includes a
<code/&ddash;prefix> option to control the start of this attribute,
and this option is used when this script is invoked during the
installation stage of the package makefile, so that the <code/urlpath>
attribute starts with the string <code>sunNNN.htx/</code> (as
appropriate), ready to be recognised by HTX.  This separation may seem
complicated, but it separates, as much as possible, features which are
internal to the system (internal labels and generated HTML filenames)
from features which are properly external (URL paths and locations in
a filesystem), using the document-summary files and the script used to
generate them as the interface.

</ul>

<subsect id=appx.system.dssslcode export>The DSSSL source code

<![ %Only.paper; [
<p>The online version of this document, not subject to space constraints,
includes documentation for a number of internal functions and
parameters of interest only to maintainers of the DSSSL code set.
]]>

<![ %Only.web [
<!-- These are long-winded, and not terribly useful to the general
     reader.  Since they're all tiny, as well, they take up a _lot_ of
     paper. -->
<routinelist>
<p>The following sections document some of the more important DSSSL
style sheets.

<codecollection doc="dsssl.params">
<codecollection doc="dsssl.common">
<codecollection doc="dsssl.lib">
]]>

<subsect id=appx.system.software export>Other supporting software

<p>This distribution primarily consists of SGML materials --
that is, the DTDs and associated DSSSL stylesheets.  It also relies on
the Jade DSSSL engine, suitably patched, and the
<code/dvi2bitmap> package (to help generate the GIFs used when
displaying maths on the web.   See <ref id=install/> for further
details of obtaining and building these.

<p>As well as these supporting applications, which must be obtained
and installed separately, there is some auxiliary software distributed
with the package itself.  This is located in <code
fspath>$STARLINK_SGML_DIR/lib</code>.

<dl>

<dt><code/img-eqlist.pl>
<dd>This post-processes the file produced by the <code/img.maths> mode
of <code fspath>$STARLINK_SGML_DIR/dsssl/sl/html/slmaths.dsl</code>.
See <coderef collection=supportlibs
id=img-eqlist>the file header</coderef> for further documentation.

<dt><code/abstract-star2html.pl>
<dd>A Perl script which does a simple but robust parse of &latex;
files suitable for the Star2HTML system, generating DocumentSummary
documents.  See <ref id=appx.system.summaries/>, and the detailed
documentation in <coderef id=abstract-star2html collection=supportlibs/>.

<dt><code/plainhtml.bst> and <code/plainlatex.bst>
<dd>These are Bib&tex; style files used by the Bib&tex; step in the
common makefile.

<dt><code/postprocess-bbl.sed>
<dd>This postprocesses the bibliography file produced by
<code/plainhtml.bst>, rejoining the long lines which Bib&tex;
erroneously splits.

</dl>

<p><ref id=appx.system.dssslcode/> includes a selection of the more important
DSSSL code modules.

<subsubsect id=appx.system.software.lib>Library scripts

<routinelist>

<p>The following are scripts which are either used internally by the
down-conversion process (such as <coderef id=img-eqlist
collection=supportlibs/>) or are usable by the installation process
(such as <coderef id=abstract-star2html collection=supportlibs/>,
though this is not actually used at present).

<codecollection doc="supportlib" id=supportlibs>

<subsect id=appx.system.online export>Online resources

<subsubsect>HyTime and architectures

<p><dl>

<dt><url>http://www.ornl.gov/sgml/wg4/docs/n1920/</url>
<dd>Online materials for the HyTime standard

<dt><url>http://www.hytime.org/</url>
<dd>The HyTime users' group, including
<url>http://www.hytime.org/papers/htguide.html</url>,
The HyTime reader's guide

<dt><url>http://www.oasis-open.org/cover/hytime.html</url>
<dd>The HyTime pages at Oasis.

<dt><url>http://www.isogen.com/papers/archintro.html</url>
<dd>A very good tutorial introduction to SGML architectures

<dt><url>http://www.cogsci.ed.ac.uk/%7eht/grove.html</url>
<dd>A picture of a grove.

<dt><url>http://www.hytime.org/materials/sgmlpropset/index.html</url>
<dd>An online, hyperlinked, version of the SGML Property Set.  This
requires some understanding of the grove concept and the SGML property
set, but once you have that, it's invaluable.

</dl>

<subsubsect>DSSSL

<p><dl>

<dt><url>ftp://ftp.ornl.gov/pub/sgml/WG4/DSSSL/</url>
<dd>The DSSSL standard

<dt><url>http://www.oasis-open.org/cover/dsssl.html</url>
<dd>The DSSSL pages at the Oasis SGML site

<dt><url>http://itrc.uwaterloo.ca/%7epapresco/dsssl/tutorial.html</url>
<dd>Paul Prescod's excellent DSSSL tutorial

<dt><url>http://www.mulberrytech.com/dsssl/</url>
<dd>Mulberry Technologies' DSSSL pages

<dt><url>http://www.mulberrytech.com/dsssl/dssslist/</url>
<dd>The DSSSList archive

<dt><url>http://www-swiss.ai.mit.edu/scheme-home.html</url>
<dd>The home page for the programming language Scheme, which is the
basis for the DSSSL language.  The language reference manual here is
excellently concise.

</dl>

<subsect id=install export>Installation

<p>The installation procedure should be standard.  When you have
unpacked the distribution, define the <code/SYSTEM> and <code/INSTALL>
environment variables as usual, and type
<verbatim>
% ./mk build
% ./mk install
</verbatim>
This will install the DTD, DSSSL scripts and documentation in the
correct places.
<!--
, and generate document summaries for all the Starlink
documents it can find in <code fspath>/star/docs</code> (these
summaries are not necessarily perfect, as they do not attempt to do
anything clever with &latex; markup in the documents they are
abstracting; however the script which generates them should not
collapse during the installation).
-->
As noted in <ref id=proc.setup/>, you prepare the set for use by
sourcing one of two scripts.

<p>This will also install a patched version of <code/Jade>, and an
appropriate copy of the <code/dvi2bitmap> package.

<!-- Keep old Jade build instructions for the moment -->
<![ IGNORE [
<p>The SGML set does not have Jade packaged up within it, largely
because it's rather difficult to build.  I hope to work on this, but
at present, you will need to obtain, patch, and build Jade yourself.

<p>Unfortunately, Jade turns out
to be a real hassle to build with a compiler other than gcc.  The
author, James Clark, is a fine programmer, but apparently a bit of a
standards purist (he was involved with writing the DSSSL standard, and
with the development of XML/XSL): he seems to take the position that a
standards document is an adequate C++ user manual, and doesn't appear
to believe that porting software to non-conforming compilers should be
high on his priority list.  Now, I greatly approve of this attitude,
<em/but> I'd rather I had the attitude alone, rather than sharing it
with Clark.  Jade builds
perfectly happily on gcc, but I've been struggling away for ages
trying to get it to build using Sun's and Digital's C++ compilers.  I
will distribute a runnable version of Jade eventually, but for the
moment, you'll have to build Jade yourself.  If <em/you> manage to
build it using one of those, could you tell me what you had to do&ellip;.

<p>Get Jade from Clark's <webref
url='http://www.jclark.com/jade/' >Jade pages</webref>.  Before you
build it, you need to patch it to a Starlink-specific version, using
the patch at
<url>http://www.astro.gla.ac.uk/users/norman/distrib/jade.html</url>.
The configuration you'll need is:
<verbatim>
% mkdir -p /my/star/bin/sgml/bin /my/star/bin/sgml/lib
% ./configure &ddash;enable-latex &ddash;prefix=/my/star/bin/sgml
% make
% make install
</verbatim>
The stylesheets need Jade patched to version
<code/1.2.1-starlink-1.0b2> (you can check Jade's version with
<kbd>jade -v &lt;/dev/null</kbd>).  Don't install Jade in the same
place as this package installs its binaries -- the installation script
for the SGML set assumes it has complete control over that
subdirectory, and will squash anything else it finds there.
]]>

<![ IGNORE [
<p>The application <code/dvi2bitmap> is also required.  This is
distributed separately.  Until it finds its way onto the Starlink CD,
however, you can obtain a copy on <webref
url="http://www.astro.gla.ac.uk/users/norman/star/dvi2bitmap/" >my
dvi2bitmap page</webref>.
]]>

<sect id=appx.releasenotes export>Release Notes

&release.notes;
&release.notes.old;

<backmatter bibliography=ssn70>
