#! /bin/sh -
#    Copyright 2000, 2001, Council of the Central
#    Laboratory of the Research Councils.  See
#    http://www.starlink.rl.ac.uk/store/conditions.html for
#    conditions.

RCSID='$Id$'
ident_string='Starlink SGML Kit, release ((PKG_VERS))'

#+
#  <routinename id=sgml2docs>
#     sgml2docs
#
#  <moduletype>
#     Shell script
#
#  <purpose>
#     Generate HTML or LaTeX files from an SGML source file, marked up using
#     one of the Starlink DTDs.
#
#  <description>
#     Given a single argument, specifying an SGML source file, this
#     uses the Starlink DSSSL stylesheets to process this into a
#     collection of HTML files and GIFs, or LaTeX and EPS files
#     places them in a subdirectory named after the source file, and
#     then creates a tarball in the source directory holding the
#     generated files.
#
#  <argumentlist>
#     <parameter>arg1
#     <type>filename
#     <description>SGML file to be processed.
#
#  <diytopic>Options
#     <dl>
#     <dt>--html<dd>generate HTML (the default).
#     <dt>--htmlsingle<dd>generate HTML in a single file.  Not really
#           supported, so not often tested.
#     <dt>--latex<dd>generate LaTeX.
#     <dt>--packagedir=my-dir<dd>package up the generated files into a
#           directory called `my-dir'.  The default directory is based
#           on the input filename.
#     <dt>--tarball=my.tar<dd>bundle the package-dir into a tarball
#           named `my.tar'.  The default tarball name is based
#           on the input filename.
#     <dt>--jadeflags=flags<dd>add the given flags to the invocation
#           of Jade.  See the
#           <webref url='http://www.jclark.com/jade/' 
#           >Jade documentation</webref> for details.
#     <dt>--ignore-manifest<dd>Do not use the generated manifest when
#           bundling up files, but instead just bundle everything in
#           sight.  You will need to use this only if there is some
#           bug in the mechanism which generates the manifest.
#     <dt>--quiet<dd>Don't chatter (not completely silent, since it
#           doesn't suppress output from TeX).
#     <dt>--options=opt,opt,...<dd>set format-specific options.
#	    <p>With <code>--latex</code>: options are
#	    <code>cts-sect</code> and <code>cts-appx</code>, which suppresses
#	    any page-break between sections in the main text and
#	    appendices; and <code>onepass-latex</code>, which generates
#	    LaTeX which should need only a single pass to produce a
#	    table of contents.
#	    <p>With <code>--html</code>: options are <code>nonorm</code>,
#	    <code>simplenorm</code> and <code>sgmlnorm</code>.  These control
#	    how much the generated HTML files are normalised.  In the
#	    first case, no normalisation is done: this is fine if you
#	    simply want to display the resulting HTML, but the
#	    resulting output confuses the HTX system something
#	    rotten.  The simple normalisation (done using sed) should
#	    be enough for HTX, but isn't bulletproof; the full
#	    normalisation, using the <code>sgmlnorm</code> application
#	    should indeed be bulletproof, but is also rather slow.
#	    the default is currently <code>simplenorm</code>, but might well
#	    change in future.
#     <dt>--help<dd>display usage and exit.
#     <dt>--version<dd>display version and exit.
#     <dt>--debug<dd>do some debugging.  Specifically, don't tidy up at end.
#     <dt>-n<dd>don't actually run anything, just show what would happen.
#     </dl>
#
#
#  <examplelist>
#     <example>
#       sgml2docs --html --tarball mydocs.tar docfile.sgml
#     <examplenote>
#       This converts the document <code>docfile.sgml</code> to a set of
#       HTML files, bundling the result into a tarball
#       <code>mydocs.tar</code>, rather than the default based on the
#       source file's name.
#     <example>
#       sgml2docs --latex --options cts-sect,cts-appx docfile.sgml
#     <examplenote>
#       Converts the document to a bundle of files which may be
#       LaTeXed.  The page breaks between sections are suppressed.
#       
#  <diytopic>Environment
#     <p>Requires that the environment variable <code>STARLINK_SGML_DIR</code> is
#     properly set, pointing to the root of the Starlink SGML kit.  It
#     also requires that <code>dvi2bitmap</code> is in the <code>PATH</code>  The
#     script is currently rather sensitive to the available version of
#     <code>dvi2bitmap</code>, and does a rather cautious check.
#
#     <p>The script creates a work directory and does its processing
#     there.  If it is necessary to run BibTeX, it will be done with
#     that temporary directory as the current directory, so that it
#     might be necessary to set <code>BIBINPUTS</code> (for example) to let the
#     system find the bibliography database.
#
#  <authorlist>
#  <author id=ng 
#          webpage='http://www.astro.gla.ac.uk/users/norman/'
#          email='norman@astro.gla.ac.uk'
#          affiliation='Starlink, Glasgow University'>
#     Norman Gray
#
#  <copyright>
#    <p>Copyright 2000, 2001, Council of the Central
#    Laboratory of the Research Councils.  See
#    <url>http://www.starlink.rl.ac.uk/store/conditions.html</url> for
#    conditions.
#
#  <history>
#    <change author=ng date='29-SEP-1999'>Initial version.
#    <change author=ng date='16-Jan-2001'>Added explicit (rather
#      than defaulted) copyright statement.
#-

LIBDIR=${STARLINK_SGML_DIR}/lib
DECL=${STARLINK_SGML_DIR}/dtd/starlink.decl
ICONTARBALL=${STARLINK_SGML_DIR}/lib/icons.tar
STYLESHEET=${STARLINK_SGML_DIR}/dsssl/sl

# Binaries
# Allow the names of the jade and sgmlnorm binaries to be overridden
# (mostly for testing, though I can imagine _some_ production use of
# this feature).
test -n "$JADE"       || JADE=jade
test -n "$SGMLNORM"   || SGMLNORM=sgmlnorm
JADEFLAGS=
test -n "$IMGEQ"      || IMGEQ=$LIBDIR/img-eqlist.pl
test -n "$DVI2BITMAP" || DVI2BITMAP='dvi2bitmap'
test -n "$LATEX"      || LATEX=latex
test -n "$BIBTEX"     || BIBTEX=bibtex

TARGETFORMAT=0			# html
OPTIONS=

DEBUGGING=false
USEMANIFEST=true
VERBOSE=true
NORMTYPE=simplenorm  # simple normalisation by default
run=
runn=
tempdest=tmp.stamp

# The dvi2bitmap call is currently rather sensitive to the version
#DVI2BITMAPVERSION=`$DVI2BITMAP -V|sed -n '1s/^[^ ]* *\([^ ]*\).*$/\1/p'`
# I'm in two minds about how elaborate this is.  On one hand, there
# are significant issues about version skew, since this script does
# depend rather heavily on the dvi2bitmap version, but on the other,
# this logic is just begging to go wrong somewhere....
DVI2BITMAPVERSION=`$DVI2BITMAP -V | sed -n '1s/[-.,]/ /gp'|awk '{print $3}'`
if [ $DVI2BITMAPVERSION -lt 9 ]; then
    echo "Using" $DVI2BITMAP "at"
    which `echo $DVI2BITMAP | awk '{print $1}'`
    echo "Need dvi2bitmap version 0.9+, but $DVI2BITMAP is version "`$DVI2BITMAP -V|sed -n 1p`
    exit 1
fi

PROGNAME=`basename $0`

tidy-up ()
{
    if $DEBUGGING; then
	echo "$PROGNAME:I: Work directory $WORKDIR not deleted"
    else
	if [ -w "$WORKDIR" ]; then
	    rm -Rf $WORKDIR
	fi
	if [ -d "$WORKDIR" ]; then
	    echo "$PROGNAME:W: Couldn't delete work directory $WORKDIR"
	fi
    fi
}
trap tidy-up 0

# Start parsing the arguments

USAGE="Usage: $0 [--latex] [--html] [--htmlsingle]\
	[--packagedir=directory] [--tarball=file.tar] [--jadeflags=flags]\
	[--ignore-manifest] [--quiet]\
	[--help] [--debug] [--version] [-n]\
	[--options=options...]\
	sgml-file\
    (--latex options: cts-sect, cts-appx, onepass)\
    (--html options: sgmlnorm, simplenorm, nonorm)"

while [ $# -gt 0 ]; do
    case $1 in
	--html) TARGETFORMAT=0 ;;
	--latex) TARGETFORMAT=1 ;;
	--htmlsingle) TARGETFORMAT=0; 
	    JADEFLAGS="$JADEFLAGS -V nochunks -isingle.file" ;;
	--packagedir*) arg=`expr match $1 '.*=\(.*\)'`
	    if test -z "$arg"
	    then 
		PACKAGEDIR=$2; shift
	    else
		PACKAGEDIR=$arg
	    fi
	    ;;
	--tarball*) arg=`expr match $1 '.*=\(.*\)'`
	    if test -z "$arg"
	    then 
		TARNAME=$2; shift
	    else
		TARNAME=$arg
	    fi
	    ;;
	--jadeflags*) arg=`expr match $1 '.*=\(.*\)'`
	    if test -z "$arg"
	    then 
		JADEFLAGS="$JADEFLAGS $2"; shift
	    else
		JADEFLAGS="$JADEFLAGS $arg"
	    fi
	    ;;
	--options*) arg=`expr match $1 '.*=\(.*\)'`
	    if test -z "$arg"
	    then 
		OPTIONS=$2; shift
	    else
		OPTIONS=$arg
	    fi
	    ;;
	--ignore-manifest) USEMANIFEST=false ;;
	--quiet) VERBOSE=false; DVI2BITMAP="$DVI2BITMAP -q" ;;
	--debug) DEBUGGING=true ;;
	--help) echo $USAGE; exit 0;;
	--version) echo "$PROGNAME:I:" $ident_string; echo "$PROGNAME:I:" $RCSID; exit 0;;
	-n) run=echo; runn=: ; tempdest=/dev/stdout; ;;
	-*) echo $USAGE; exit 1 ;;
	*) SGMLSRC=$1 ;;
    esac
    shift
done

# Check that the SGMLSRC argument is present, and prepend `pwd` if it isn't
# an absolute file name.
case $SGMLSRC in
	'') echo $USAGE; exit 1 ;;
	/*) ;;
	*) SGMLSRC=$PWD/$SGMLSRC ;;
esac

# Sanity-check: we _do_ have a source file, don't we?
if [ ! -r $SGMLSRC ]; then
    echo "$PROGNAME:E: I can't find file $SGMLSRC !"
    exit 1
fi

$VERBOSE && echo "$PROGNAME:I: Processing $SGMLSRC..."
case $TARGETFORMAT in
    0)  $VERBOSE && echo "$PROGNAME:I: Target HTML...";
	PACKAGEEXT='.htx' ;;
    1)  $VERBOSE && echo "$PROGNAME:I: Target LaTeX...";
	PACKAGEEXT='.latex' ;;
    *) echo $USAGE; exit 1 ;;
esac

# Set the PACKAGEDIR and TARNAME variables, unless they've already
# been set by options above.
SRCDIR=`dirname $SGMLSRC`
test -n "$PACKAGEDIR" \
    || PACKAGEDIR=`basename $SGMLSRC | sed 's/\(\.sgml\)\?$/'$PACKAGEEXT/`

# Make sure the TARNAME variable has been set, and make sure it's
# an abosulte pathname
test -n "$TARNAME" \
    || TARNAME=`echo $SGMLSRC | sed 's/\(\.sgml\)\?$/.tar/'`
TARNAME=`expr $TARNAME : '\(/.*\)' \| $PWD/$TARNAME`


# Make a work directory.  Can't use mktemp, as that only creates files.
# Fail if the directory already exists.
WORKDIR=/tmp/$PROGNAME.$$
if [ -d $WORKDIR -o -f $WORKDIR ]; then
	echo "$PROGNAME:W: temp dir $WORKDIR already exists - not overwriting"
	exit 1
fi

mkdir -p $WORKDIR
if [ $? -ne 0 ]; then
    echo "$PROGNAME:E: Can't make temp dir $WORKDIR"
    exit 1
fi

cd $WORKDIR
if [ $? -ne 0 ]; then
    echo "$PROGNAME:E: Can't cd to temp dir $WORKDIR"
    exit 1
fi

# We'll package up the generated files into a tarball, after moving them into
# a subdirectory.

# Before we do anything else, create the package directory.
mkdir $PACKAGEDIR
if [ ! -d $PACKAGEDIR ]; then
    echo "$PROGNAME:E: Can't create subdir $WORKDIR/$PACKAGEDIR"
    exit 1
fi

if $DEBUGGING; then
    echo "$PROGNAME:I: JADE=$JADE"
    echo "$PROGNAME:I: SGMLNORM=$SGMLNORM"
    echo "$PROGNAME:I: LIBDIR=$LIBDIR"
    echo "$PROGNAME:I: DVI2BITMAP=$DVI2BITMAP"
    echo "$PROGNAME:I: LATEX=$LATEX"
    echo "$PROGNAME:I: BIBTEX=$BIBTEX"
    echo "$PROGNAME:I: WORKDIR=$WORKDIR"
    echo "$PROGNAME:I: JADEFLAGS=$JADEFLAGS"
    echo "$PROGNAME:I: TARGETFORMAT=$TARGETFORMAT"
    echo "$PROGNAME:I: NORMTYPE=$NORMTYPE"
fi



# Start processing

if [ $TARGETFORMAT -eq 0 ]; then
    # Generate HTML

    if [ -n "$OPTIONS" ]; then
	for o in `echo $OPTIONS | sed 's/,/ /g'`; do
	    case $o in
		nonorm|simplenorm|sgmlnorm) NORMTYPE=$o;;
		*)  echo "$PROGNAME:E: HTML options (nonorm|simplenorm|sgmlnorm)";
		    exit 1;;
	    esac
	done
	if $DEBUGGING; then
	    echo "$PROGNAME:I: NORMTYPE (post-options)=$NORMTYPE"
	fi
    fi

    if $VERBOSE; then
	OUTPUTDEST=''
    else
	OUTPUTDEST='>> output.log'
    fi

    # Generate $ROOT.imgeq.list and convert it to a set of bitmaps.
    # Also extract citations ready for BibTeX.
    $VERBOSE && echo "$PROGNAME:I: Pre-processing..."
    $run $JADE -t sgml -iOnly.web $JADEFLAGS \
	    -d $STYLESHEET/html/slpreprocess.dsl#preprocess.main \
	    $DECL $SGMLSRC \
	    > $tempdest
    test -f tmp.stamp && ROOT=`awk -F: '{print $1}' tmp.stamp`

    # If there are no maths-mode elements, there's no list file generated.
    # Test if the file is of non-zero size, since <codecollection> is
    # listed in `maths-element-list' even though it'll produce no
    # output if there's no maths in the codecollection.  Same goes for
    # element <mdefs>.
    if [ -s "$ROOT.imgeq.list" ]; then
	# Find dvi2bitmap's default format
	# Default to gif if the dvi2bitmap version doesn't have the -Qt option
	#imgfmt=`($DVI2BITMAP -Qt 2>/dev/null || echo gif gif) | awk '{print $2}'`
	# Force the image format to be gif -- PNG transparency isn't
	# yet well-enough supported in browsers.
	imgfmt='gif'
	$VERBOSE && echo "$PROGNAME:I: $IMGEQ --imgformat $imgfmt $ROOT.imgeq.list"
	$run $IMGEQ --imgformat $imgfmt $ROOT.imgeq.list

	$VERBOSE && echo "$PROGNAME:I: $LATEX $ROOT.imgeq.tex"
	$run $LATEX $ROOT.imgeq.tex $OUTPUTDEST

	$VERBOSE && echo "$PROGNAME:I: $DVI2BITMAP -m 3 -s 3 -Pt $ROOT.imgeq.dvi" 
	$run $DVI2BITMAP -m 3 -s 3 -Pt -q -Qb $ROOT.imgeq.dvi >dvi2bitmap.log

	if [ -r dvi2bitmap.log -a -r $ROOT.imgeq.labelmap ]; then
	    awk '
	    /^Qb/ { map[$2]=sprintf(" width=\"%s\" height=\"%s\"", $3, $4) }
	    /^label/ { printf("<img-eq label=\"%s\" sysid=\"%s\"%s/>\n", 
		$2, $3, map[$3]?map[$3]:"") }
	    BEGIN { print "<?xml version=\"1.0\"?>\n<!DOCTYPE img-eqlist SYSTEM \"img-eqlist\">\n<img-eqlist>" }
	    END { print "</img-eqlist>" }
	    ' dvi2bitmap.log $ROOT.imgeq.labelmap >$ROOT.imgeq.xml
	else
	    echo "$PROGNAME:W: failed generating equation-image refs"
	fi
    else
	$VERBOSE && echo "$PROGNAME:I: (no maths in document)"
    fi

    # Generate backmatter.  Don't fail if no .aux file was generated
    if [ -r "$ROOT.htmlbib.aux" ]; then
	$VERBOSE && echo "$PROGNAME:I: Backmatter..."
	# BSTINPUTS set here; require the user to do any setting of BIBINPUTS
	BSTINPUTS=$LIBDIR $run $BIBTEX $ROOT.htmlbib
	$runn sed -f $LIBDIR/postprocess-bbl.sed $ROOT.htmlbib.bbl > t.bbl
	$runn mv t.bbl $ROOT.htmlbib.bbl
    fi

    # Generate the destination file
    $VERBOSE && echo "$PROGNAME:I: Generating output..."
    $run $JADE -t sgml -iHTML.entities -iOnly.web $JADEFLAGS \
	    -d $STYLESHEET/html/sl.dsl#html \
	    $DECL $SGMLSRC \
	    > $tempdest

    # create the file named MANIFEST, removing duplicates (ie, some gifs)
    # from generated manifest file
    if $USEMANIFEST; then
	test -r HTML.manifest && sort HTML.manifest | uniq > MANIFEST
    else
	# just scoop everything up
	find . -maxdepth 1 -type f ! -name MANIFEST > MANIFEST
    fi
	

elif [ $TARGETFORMAT -eq 1 ]; then
    # Generate LaTeX

    if [ -n "$OPTIONS" ]; then
	for o in `echo $OPTIONS | sed 's/,/ /g'`; do
	    case $o in
		cts-sect) JADEFLAGS="$JADEFLAGS -V section-samepage" ;;
		cts-appx) JADEFLAGS="$JADEFLAGS -V appendix-samepage" ;;
		onepass)  JADEFLAGS="$JADEFLAGS -V onepass-latex" ;;
		*) echo "$PROGNAME:E: LaTeX options (cts-sect|cts-appx|onepass)" ;
		   exit 1 ;;
	    esac
	done
	if $DEBUGGING; then
	    echo "$PROGNAME:I: JADEFLAGS (post-options)=$JADEFLAGS"
	fi
    fi

    $run $JADE -t sgml -iLaTeX.entities -iOnly.paper $JADEFLAGS \
	-d $STYLESHEET/latex/slback.dsl#back.main \
	$DECL $SGMLSRC \
	> $tempdest
    test -f tmp.stamp && ROOT=`awk -F: '{print $1}' tmp.stamp`

    # If there was no backmatter, then don't invoke BibTeX
    if [ -r $ROOT.latexbib.aux ]; then
	BSTINPUTS=$LIBDIR $run $BIBTEX $ROOT.latexbib
    fi

    # Generate the final file
    $run $JADE -t latex -iLaTeX.entities -iOnly.paper $JADEFLAGS \
	    -d $STYLESHEET/latex/sl.dsl#latex \
	    $DECL $SGMLSRC \
	    > $tempdest

    if $USEMANIFEST; then
	test -r LaTeX.manifest && ln -s LaTeX.manifest MANIFEST
    else
	find . -maxdepth 1 -type f ! -name MANIFEST > MANIFEST
    fi

else

    echo "$PROGNAME:E: Illegal TARGETFORMAT=$TARGETFORMAT !"
    exit 1

fi

# Package up the generated files into a tarball named after the source
# file.  There are either one or two fields on each line of the
# manifest (see file .../{html,latex}/sl.dsl).  If there is only one field,
# then this is a generated file.  If there are two fields, then
# the first is the sysid of the figure as referred to by the
# generated material, which will have no path, and the second is the sysid as
# declared in the entity, which may have a path.
#
# hlink and showme/findme get confused by Jade's way of generating elements.
# To help out, run the files through one of the normalising methods.
# The option `simplenorm' just uses sed, and normalises the <a>
# opening tags so that the entire opening tag is on one line;
# sgmlnorm is bulletproof, but slow and more than seems necessary.
if [ -r MANIFEST -o -n "$run" ]; then
    #mv `awk 'NF==1 {print $1}' MANIFEST` $PACKAGEDIR
    for f in `awk 'NF==1 {print $1}' MANIFEST`; do
	case $f in
	*.html)
	    case $NORMTYPE in
		nonorm) 
		    cp $f $PACKAGEDIR/$f ;;

		simplenorm)
		    sed '/<[aA] *$/{:a;N;s/\n>/ >/;t;s/\n/ /;b a;}' $f >$PACKAGEDIR/$f ;;
		sgmlnorm)
		    $run $SGMLNORM -d $DECL $f >$PACKAGEDIR/$f \
			2>>$PACKAGEDIR/sgmlnorm.errors ;;
		*)
		    echo "$PROGNAME:W: Impossible normtype=$NORMTYPE.  Doing simple copy"
		    cp $f $PACKAGEDIR/$f ;;
	    esac		    
	    ;;
	*)
	    $run mv $f $PACKAGEDIR
	    ;;
	esac
    done
    # Now process the list of entities which have to be renamed --
    # those with two fields in the manifest file.
    # Use awk to send a stack of cp commands into a new shell (use
    # this technique rather than eval, so that we avoid
    # any potential problem with maximum line lengths.  Harmless if
    # there are no two-entry lines in the file.
    awk "BEGIN {print \"cd $SRCDIR\"}; NF==2 {printf \"$run cp %s $WORKDIR/$PACKAGEDIR/%s\n\","'$2,$1}' $WORKDIR/MANIFEST | sh
    $run cp MANIFEST $PACKAGEDIR

    if [ $TARGETFORMAT -eq 0 ]; then
	# Generating HTML:
	# At this point append the contents of the icons tarball to the
	# MANIFEST.  Don't do this earlier, since these files weren't
	# present to be copied.
	(cd $PACKAGEDIR; \
	    tar tf $ICONTARBALL | sed '/\/$/d' >> MANIFEST)
    fi
else
    # It's not clear what to do here, since _something_ has clearly
    # gone wrong if we don't have a manifest.  However, package up all
    # (?) the generated files and hope for the best.
    $VERBOSE && echo "$PROGNAME:W: Can't find manifest -- something's gone wrong:  I'm tarring up everything and hoping for the best!"
    $run mv * $PACKAGEDIR
fi

if [ $TARGETFORMAT -eq 0 ]; then
    # Unpack the icons into the target directory, to match the manifest.
    (cd $PACKAGEDIR; tar xf $ICONTARBALL)
fi

$run tar cf $TARNAME $PACKAGEDIR


# No need to remove the workdir, as that'll be done through the exit trap

$VERBOSE && echo "$PROGNAME:I: Created $TARNAME"

exit 0

