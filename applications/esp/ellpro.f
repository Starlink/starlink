       SUBROUTINE ELLPRO(STATUS)
*+
*  Name:
*     ELLPRO

*  Purpose:
*     Performs an ellipse fitting galaxy profile using simple
*     intensity analysis.  

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELLPRO( STATUS )

*  Arguments:   
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description: 
*     Performs an ellipse fitting galaxy profile using simple
*     intensity analysis. The position of the centre of the galaxy 
*     (and a number of other parameters) may be specified 
*     interactively (using cursor or keyboard) or the location
*     within the image of several galaxies may be specified using
*     an ASCII text file.  
*
*     A number of options allow the user to determine criteria for;
*     when profiling should end, whether an ARD file is to be used
*     to mask out bad areas of the image, whether the initial galaxy
*     centre value is to be fixed throughout profiling and also
*     whether or not the initial galaxy centre co-ordinates provided 
*     by the user may be refined by the application before the first
*     profile is generated.
* 
*     The position of the centre of the galaxy in question may be 
*     input interactively, MODE=TRUE), or (if there are many galaxies 
*     to be considered) may be read in from a text file (MODE=FALSE).
*     In addition, when in MODE=TRUE the galaxy can be identified
*     using a cursor (CURSOR=TRUE) as opposed to a keyboard entry of
*     its co-ordinates.

*  Usage:
*     ELLPRO MODE BACK SIGMA PSIZE ZEROP ARDFIL DEVICE OUT
*            AUTOL AUTOLT FRZORI [CURSOR] [COSYS] [IN] [ORIGIN] (FAST) 
*            (FINE) [RLIM] (LIM1) (LIM2) (LIM3) (FRACT) [SAME] 
*            [AGAIN] [INFILE) [IMGDEV] (COLOUR) (ANGCON) (ANGOFF)
 
*  ADAM Parameters:                   
*     AGAIN=_LOGICAL (Read)             
*        Allows the user to elect to repeat the profiling operation
*        on the current input image.
*     ANGCON=_LOGICAL (Read)
*        Angle rotation convention. Defines if clockwise or
*        anticlockwise is considered positive. TRUE=Clockwise.
*     ANGOFF=_REAL (Read) 
*        Angular offset for position angles generated. Units degrees.
*     ARDFIL=_CHAR (Read)
*        The name of an ARD file to be used to mask out regions of the
*        image that are not to be used.
*     AUTOL=_LOGICAL (Read)
*        Is a better estimate of the galaxy centre position to be 
*        obtained? If AUTOL=True the program attempts to find a better
*        candidate for the galaxy centre.
*     AUTOLT=_LOGICAL (Read)
*        The type of centroiding method used. N=centroid, Y=weighted mean
*     BACK=_REAL (Read)
*        The background count value for the image. Units counts.
*     COLOUR = _INTEGER (Given)
*        Colour of the pen used to mark galaxy centres.
*     COSYS=_CHAR (Read)
*        Use world or data co-ordinate system? (D=data W=world)
*     CURSOR=_LOGICAL (Read)
*        Whether the galaxy locations are to be identified using the 
*        graphics cursor or the keyboard. True=cursor. False=keyboard.
*     DEVICE=_DEVICE (Read) 
*        Name of the graphics device on which the results graph should 
*        be displayed.
*     FAST=_LOGICAL (Read)
*        Is the faster method of profiling to be used? Default value is 
*        true. The slower version should yield better values at low 
*        radii values since surface interpolation (rather than 
*        bi-linear) is used. The surface generated by the slow method to 
*        model the galaxy near its centre is a 8x8 bi-cubic spline, so
*        considerable calculation is involved. 
*     FINE=_REAL (Read)
*        A factor modifying the default separation of ellipses 
*        profiled. The default value is 1. Decreasing this value 
*        increases the number of profiles generated for a given object. 
*        Increasing this value above 2.0 is not recommended. 
*     FRACT=_REAL (Read)
*        The minimum fraction of the points round the ellipse for which 
*        no value was available due to either image pixels set to the
*        bad value or parts of the ellipse being beyond the bounds of 
*        the image. If the fraction of points available for a given 
*        ellipse drops below this value the results for that radius 
*        are not kept.  
*     FRZORI=_LOGICAL (Read)
*        Allows the origin given (or the values determined via AUTOL)
*        to remain unchanged throughout if FRZORI=TRUE.
*     IMGDEV=_DEVICE (Read)
*        Name of the graphics graphics device displaying an image.
*     INFILE=_CHAR (Read)
*        Name of a text file containing the co-ordinates of galaxies 
*        to be profiled. (Only used in file mode i.e. MODE=FALSE)
*     IN=_NDF (Read)
*        The name of the source NDF data structure/file.
*     LIM1=_REAL (Read)
*        The maximum ratio that is permitted between the average mean
*        count value of the two preceeding radii profiled and that of
*        the current radius. If this value is exceeded, the profiling 
*        operation stops. 
*     LIM2=_REAL (Read)
*        The lower limit for mean profile count value (above sky). 
*        If the mean count value for the current profile drops below 
*        this value the profiling operation stops. Units
*        are standard deviations.
*     LIM3=_REAL (Read)
*        The distance from the galaxy origin at which the profile is
*        assumed to maintain a constant position angle, origin and 
*        ellipticity. At radii beyond these, parameters are no longer 
*        modified. The position angle, origin and ellipticity are not 
*        frozen if a value of zero or less than zero is suggested. 
*        Units are pixels 
*     MODE=_LOGICAL (Read)
*        Whether the application is to run in file input mode or 
*        interactively. Interactive MODE=TRUE. File mode=FALSE.
*     ORIGIN=_REAL (Read)
*        Image indices for the origin point to be used. Units pixels.
*     OUT=_CHAR (Read)
*        File name for the output text file containing the profile 
*        data.
*     PSIZE=_REAL (Read)
*        Size of the image pixels in arc seconds.
*     RLIM=_REAL (Read)
*        Radius at which the profiling will be stopped. Units pixels.
*     SAME=_LOGICAL (Read)
*        Is the results graph to be displayed on the device currently
*        displaying the input image? Only valid if CURSOR is true.
*        If SAME is set to true then the user is prompted to identify 
*        the quadrant of the input device in which graph will be 
*        displayed. 
*     SIGMA=_REAL (Read)
*        The standard deviation of the background value. Units counts. 
*     ZEROP=_REAL (Read)
*        Zero point of the scale for surface brightness plots. Units 
*        magnitudes per arc seconds.

*  Examples: 
*     ellpro mode=true back=6200 sigma=390 psize=1.
*            zerop=27.5 ardfil=^ardfile.dat device=xwindows 
*            out=elp1.dat autol=true frzori=false cursor=false 
*            cosys=d in=p2 rlim=10 origin=96,92
*
*        Performs profiling on an object positioned at (pixel 
*        co-ordinates) 96,92 on image P2. The profile determined will 
*        be output to a graphical display on device XWINDOWS and to 
*        text file ELP1.DAT. The galaxy centre provided will be 
*        refined by the application and during profiling the galaxy centre 
*        will be allowed to change. The profiling will be stopped at 
*        a radius of 10 pixels.
*                                       
*     ellpro mode=true back=6200 sigma=390 psize=1. zerop=27.5
*            ardfil=^ardfile.dat device=xwindows out=elp1.dat 
*            autol=false frzori=true cursor=true
*
*       Performs profiling on a galaxy identified using a cursor/mouse
*       and the most recently displayed image. The ARD area definition
*       contained in the file ARDFILE.DAT is used to mask out bad 
*       parts of the image. The galaxy centre identified by the user 
*       is not refined by the software and is not allowed to change 
*       during profiling. The galaxy location is defined using a 
*       cursor/mouse on the most recently displayed image.
*
*     ellpro mode=false back=760 sigma=12 psize=0.44 zerop=27.5 
*            ardfil=^arddef.dat in=p2 infile=p2log.dat
*            out=output.dat cosys=w autol=true frzori=false
*
*       The appliication reads the object locations in file P2LOG.DAT
*       (taking them as world co-ordinates) and performs profiling on 
*       those locations on image P2. The profiling output is displayed 
*       on the text screen and is also placed in file OUTPUT.DAT.

*  Notes:
*     Parameters surrounded by curved brackets may only be
*     modified via the command line.

*  Authors:
*     GJP: Grant Privett (STARLINK)
*     {enter_new_authors_here}

*  History:
*     19-JUL-1994 (GJP).
*     Original version
*     16-OCT-1996 (GJP).
*     NAG free version.
*     27-JAN-1997 (GJP).
*     Modified output formatting to make it work better with 
*     very large images. Also tweaked ELP1_SOLVE routine
*     to enhance robustness/speed. Some pointer usage slightly modified.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
         
*  Status:     
      INTEGER STATUS                  ! Global status

*  Local Variables:      
      LOGICAL CURSOR                  ! Keyboard or cursor origin selction
      LOGICAL MODE                    ! Interactive or file mode
      REAL TEMP                       ! Temporary value

*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Initialise the random number generator.
      CALL ELP1_RAND(0,2001,TEMP,STATUS)
      
*   Show that the application is running.
      CALL MSG_BLANK(STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999
      CALL MSG_OUT(' ','ESP ELLPRO running.',STATUS)

*   Get the user selection of working interactively or by file?
      CALL PAR_GET0L('MODE',MODE,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999

*   Transfer control to a fully interactive mode or to file input
*   handling routine.
      IF (.NOT.MODE) THEN

*      Pass control to a file input routine.
         CALL ELP1_FMODE(STATUS)

      ELSE

*      Get the user selection of using the cursor or a keyboard?
         CALL PAR_GET0L('CURSOR',CURSOR,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Pass control to an appropriate interactive routine.
         IF (.NOT.CURSOR) THEN
*         Keyboard user input.
            CALL ELP1_KMODE(STATUS)
         ELSE
*         Keyboard and mouse input.
            CALL ELP1_CMODE(STATUS)
         END IF

      END IF

*   Abort the program.
 9999 CONTINUE

      END 


      SUBROUTINE ELP1_AGICO(ONOFF,MODE,NEW,AGIID,STATUS)
*+
*  Name:
*     ELP1_AGICO

*  Purpose:
*     Turns on/off the AGI/PGPLOT interface used for plotting the graphs.
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_AGICO(ONOFF,MODE,NEW,AGIID,STATUS)    

*  Description:             
*     Depending on the value of ONOFF the subroutine either:-
*     sets up the AGI/PGPLOT interface and enters new information into
*     the AGI database (ONOFF=0) or closes down the database and
*     interface (ONOFF=1). The routine may be called to generate a display
*     on the device currently used or on a new device to be specified.

*  Arguments:                                     
*     ONOFF = INTEGER (Given)
*        Defines whether the routines controlling AGI/PGPLOT should
*        be turned on or off. 0=on 1=off 
*     MODE = INTEGER (Given)
*        Defines whether or not the ADAM parameter is the current
*        graphics device or a new one to be specified. 0=current 1=new.
*     NEW = INTEGER (Given)
*        Defines whether or not a new viewport should be created
*        and to determine if UPDATE or WRITE mode is required in
*        AGI_ASSOC. This influences the tranformation required.
*     AGIID = INTEGER (Given and Returned)
*        An AGI picture identifier used by AGI.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     8-NOV-1992 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:                              
      INTEGER MODE                    ! Defines whether the display will
                                      ! be on a new device or the current
                                      ! one 0=current 1=new
      INTEGER NEW                     ! Defines the WRITE/UPDATE status
                                      ! and whether or not a new
                                      ! viewport transformation is required
      INTEGER ONOFF                   ! Defines whether AGI/PGPLOT
                                      ! must be turned on or off
                                      ! 0=on 1=off

*  Arguments Given and Returned:           
      INTEGER AGIID                   ! An AGI picture identifier
                                           
*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      REAL CR                         ! RGB red index of current 
                                      ! background colour
      REAL CG                         ! RGB green index of current
                                      ! background colour
      REAL CB                         ! RGB blue index of current
                                      ! background colour
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Start an AGI context.
      CALL AGI_BEGIN

*   Setup the AGI/PGPLOT interface.
      IF (ONOFF.EQ.0) THEN

*      Open AGI on a device obtained from the parameter system.
         IF (MODE.EQ.0) THEN 

*         Use a device to be specified by the user.
            IF (NEW.EQ.0) THEN

*            Get the name of the new device.
               CALL AGI_ASSOC('DEVICE','WRITE',AGIID,STATUS) 

*            Ensure that the whole screen is used.
               CALL AGI_IBASE(AGIID,STATUS)
               CALL AGI_SELP(AGIID,STATUS)

            ELSE

               CALL AGI_ASSOC('DEVICE','UPDATE',AGIID,STATUS) 

            END IF
  

         ELSE

*         Associate the window in the correct mode.
            IF (NEW.EQ.0) THEN
               CALL AGI_ASSOC('IMGDEV','WRITE',AGIID,STATUS)
            ELSE
               CALL AGI_ASSOC('IMGDEV','UPDATE',AGIID,STATUS)
            END IF

         END IF
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Activate the PGPLOT interface to AGI.
         CALL AGP_ACTIV(STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Create a new viewport if required.
         IF (NEW.EQ.0) THEN
*         Create the new viewport.
            CALL AGP_NVIEW(.TRUE.,STATUS)
         ELSE
*         Use the old viewport information. No new border and transformations.
            CALL AGP_NVIEW(.FALSE.,STATUS)
         END IF
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Enquire details of the current background colour.
         CALL PGQCR(0,CR,CG,CB)

*      Set the pen colours (otherwise the output does not show on the IKON).
*      User colour index of 1 since it is accepted by all monochrome
*      devices.
         CALL PGSCR(1,1.0-CR,1.0-CG,1.0-CB)
         CALL PGSCI(1)

      END IF

 9999 CONTINUE

*   Closedown the AGI/PGPLOT interface.
      IF ((ONOFF.EQ.1).OR.(STATUS.NE.SAI__OK)) THEN

*      Save the current viewport in the AGI database. 
         CALL AGP_SVIEW('ELLPRO','Galaxy Profile',AGIID,STATUS)

*      Close down PGPLOT. 
         CALL AGP_DEACT(STATUS)

*      Cancel the picture identifier or annul the parameter association 
*      depending on the value of STATUS.
         IF (STATUS.NE.SAI__OK) THEN

*         Cancel the AGI parameter association.       
            IF (MODE.EQ.0) THEN
               CALL AGI_CANCL('DEVICE',STATUS)
            ELSE
               CALL AGI_CANCL('IMGDEV',STATUS)
            END IF

         ELSE

*         Annul the AGI parameter association.       
            CALL AGI_ANNUL(AGIID,STATUS)

         END IF

      END IF

      END


      SUBROUTINE ELP1_AGIC2(GRADEV,ONOFF,NDFS,NAME,NDF1,DEVCAN,
     :                      PICID,STATUS)
*+
*  Name:
*     ELP1_AGIC2

*  Purpose:
*     Turns on/off the AGI/SGS/PGPLOT interface allowing line drawing
*     and a cursor using SGS, displaying graphs using PGPLOT and returning
*     the NDF identifier as required.
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_AGIC2(GRADEV,ONOFF,NDFS,NAME,NDF1,DEVCAN,PICID,STATUS)    

*  Description:
*     Depending on the value of ONOFF the subroutine either:-
*
*     Sets up the AGI interface, obtaining the most recent 'DATA' or 
*     'ELLPRO' picture. Activates SGS so that PGPLOT and normal SGS 
*     routines can be used. PGPLOT is turned on/off to set up its colour
*     tables.
*
*     Also (if required) obtains the NDF identifier for the current picture
*     (if available).
*    
*     Closes down the above in an orderly fashion. (ONOFF=1).

*  Arguments:                
*     GRADEV *(6) = CHARACTER (Given) 
*        The name of the graphics device being used.                    
*     ONOFF = INTEGER (Given)
*        Defines whether the routines controlling AGI/PGPLOT should
*        be turned on or off. 0=on 1=off 
*     NDFS = INTEGER (Given)
*        Defines whether the routines obtaining the NDF used to generate
*        the current picture should be used. 0=No 1=Yes.
*     NAME = INTEGER (Given)
*        Defines whether DATA or ELLPRO pictures are to looked at.
*        0=DATA 1=ELLPRO
*     NDF1 = INTEGER (Returned)
*        NDF identifier for the picture required.
*     DEVCAN = LOGICAL (Given and Returned)
*        The device parameter is to be annuled when ONOFF=1.
*     PICID = INTEGER (Given and Returned)
*        An AGI picture identifier used by AGI.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     18-Jan-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'PAR_ERR'               ! Parameter-system errors
      INCLUDE 'NDF_PAR'               ! NDF constants
      INCLUDE 'DAT_PAR'               ! DAT constants

*  Arguments Given:
      CHARACTER *(6) GRADEV           ! Graphics device name            
      INTEGER NAME                    ! Defines whether pictures of name
                                      ! DATA or ELLPRO are to used
      INTEGER ONOFF                   ! Defines whether AGI/PGPLOT
                                      ! must be turned on or off
                                      ! 0=on 1=off

*  Arguments Returned.                                           
      INTEGER NDFS                    ! Should the NDF identifier be 
                                      ! returned?

*  Arguments Given and Returned:           
      LOGICAL DEVCAN                  ! Defines whether the current
                                      ! picture is to be retained at
                                      ! database closedown
      INTEGER NDF1                    ! An NDF identifier
      INTEGER PICID                   ! An AGI picture identifier

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local Variables:
      LOGICAL   GOTLOC                ! Was a locator found?
      CHARACTER *255 IDENT1           ! HDS identifier for the image 
      CHARACTER *(DAT__SZLOC) IDENT   ! HDS identifier for the image
      INTEGER ZONID                   ! SGS zone identifier of the initial
                                      ! picture
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Set default value.
      DEVCAN=.FALSE.   

*   Setup the AGI/SGS/PGPLOT interface.
      IF (ONOFF.EQ.0) THEN

*      Start a new AGI context.
         CALL AGI_BEGIN

*      Get the graphics device, and open SGS.
         CALL AGI_ASSOC(GRADEV,'UPDATE',PICID,STATUS)
         IF (STATUS.NE.SAI__OK) THEN 
            CALL ERR_FLUSH(STATUS)
            GOTO 9999
         END IF

*      Activate SGS.
         CALL AGS_ACTIV(STATUS)

*      If the graphics device was not available, report the error and
*      leave the programme.
         IF (STATUS.NE.SAI__OK) THEN 
            IF (STATUS.NE.PAR__ABORT) DEVCAN=.TRUE.
            CALL ERR_FLUSH(STATUS)
            GOTO 9999
         END IF

*      Select the base picture as current so that the search for DATA 
*      or ELLPRO later will look through all the pictures.
         CALL AGI_IBASE(PICID,STATUS)
         CALL AGI_SELP(PICID,STATUS)
         IF (STATUS.NE.SAI__OK) THEN 
            CALL ERR_FLUSH(STATUS)
            GOTO 9999
         END IF

*      Create a new SGS_ZONE from current picture of correct name.
         IF (NAME.EQ.0) THEN

*         Find most recent image.
            CALL AGI_RCL('DATA',PICID,STATUS)

         ELSE

*         Find most recent ELLPRO results display.
            CALL AGI_RCL('ELLPRO',PICID,STATUS)

         END IF

*      Abort if it was impossible to find a suitable entry in the AGI database.
         IF (STATUS.NE.SAI__OK) THEN 
            DEVCAN=.TRUE.
            CALL ERR_FLUSH(STATUS)
            GOTO 9999
         END IF

*      Select the AGI database entry selected as the current picture and
*      create the new zone.
         CALL AGI_SELP(PICID,STATUS)
         CALL AGS_NZONE(ZONID,STATUS)

*      Set up PGPLOT so that its colours are used.
         CALL AGP_ACTIV(STATUS)
         IF (STATUS.NE.SAI__OK) THEN 
            CALL ERR_FLUSH(STATUS)
            GOTO 9999
         END IF

*      Try to get the value for the NDF identifier of the selected picture.
         IF (NDFS.EQ.1) THEN

*         Get a locator to the NDF associated with the DATA picture.
            CALL AGI_GTREF(PICID,'READ',IDENT1,STATUS)
            IF (STATUS.NE.SAI__OK) THEN
               CALL ERR_REP(' ',
     :         'Could not get the HDS reference to an image.',
     :          STATUS)
               CALL ERR_FLUSH(STATUS)
               GOTO 9999
            END IF

*         Check to see if the identifier has been supplied in the old
*         DAT__SZLOC length format.
            CALL DAT_VALID(IDENT1(1:DAT__SZLOC),GOTLOC,STATUS)
            IF (STATUS.NE.SAI__OK) GOTO 9999
 
*         Use NDF_FIND in a manner suiatble for the type of
*         identifier found.
            IF (GOTLOC) THEN 
               IDENT=IDENT1(1:DAT__SZLOC)
               CALL NDF_FIND(IDENT,' ',NDF1,STATUS)
            ELSE
               CALL NDF_FIND(DAT__ROOT,IDENT1,NDF1,STATUS)
            END IF
            IF (STATUS.NE.SAI__OK) THEN
               CALL ERR_REP(' ',
     :                      'Could not get the image NDF identifier.',
     :                      STATUS)
               GOTO 9999
            END IF
 
*         Display the name of the file in question.
            CALL NDF_MSG('IN2',NDF1)
            CALL MSG_BLANK(STATUS)
            CALL MSG_OUT(' ','Using ^IN2 as the input NDF.',STATUS)

         END IF

      END IF

 9999 CONTINUE
 

*   Closedown the AGI/SGS interface.
      IF ((ONOFF.EQ.1).OR.(STATUS.NE.SAI__OK)) THEN

*      Deactivate PGPLOT.
         CALL AGP_DEACT(STATUS)

*      Deactivate SGS and close the workstation.
         CALL AGS_DEACT(STATUS)

*      Close the AGI context.
         CALL AGI_END(PICID,STATUS)

*      Close the AGI database. Record the name of the workstation only
*      if it was used successfully.
         IF (DEVCAN) THEN
            CALL AGI_CANCL(GRADEV,STATUS)
         ELSE
            CALL AGI_ANNUL(PICID,STATUS)
         END IF

      END IF

      END



      SUBROUTINE ELP1_AIF_ASFIO (PNFILE,ACMODE,FORM,RECSZ,FD,OPEN,
     :                      EXCLAIM,STATUS)
*+
*    Description :
*
*     This routine opens a sequential file via FIO_ASSOC.  Up to four
*     attempts may be made to open the file.  If a null response is
*     supplied the file is not opened, and the flag returned indicates
*     this fact.
*
*    Invocation :
*
*      CALL ELP1_AIF_ASFIO (PNFILE,ACMODE,FORM,RECSZ,FD,OPEN, 
*                      EXCLAIM,STATUS)

*
*    Arguments :
*
*     PNFILE=CHARACTER*(*)
*         Parameter name by which file is to be opened
*     ACMODE=CHARACTER*(*)
*         Expression giving the required access mode.
*           Valid modes are: 'READ', 'WRITE', 'UPDATE' and 'APPEND'.
*           For details, see FIO_OPEN.
*     FORM=CHARACTER*(*)( READ )
*         Expression giving the required formatting of the file.
*           Valid formats are: 'FORTRAN', 'LIST', 'NONE' and
*           'UNFORMATTED'. For details, see FIO_OPEN.
*     RECSZ=INTEGER( READ )
*         Expression giving the maximum record size in bytes.
*           Set it to zero if the Fortran default is required.
*     FD=INTEGER( WRITE )
*         Variable to contain the file descriptor.
*     OPEN=LOGICAL( WRITE )
*         If true the file has been opened.
*     EXCLAIM=LOGICAL( WRITE )
*         If true then the user input was '!'.
*     STATUS=INTEGER( READ, WRITE )
*         Global status value
*
*    Method :
*
*     Check for error on entry - return if not o.k.
*     Initialise looping flag
*     Do while no error obtaining the name and opening the output file
*       and maximum number of attempts not exceeded
*        Get file name and open file
*        If null returned then
*           Set flag so that a log file will not be created
*           Annul the error
*           Exit from the loop
*        Else if error occurred then
*           If abort requested, do so
*           Increment loop counter
*           If maximum number of attempts not exceeded then
*              Report error
*           Else
*              Set looping flag to exit
*           Endif
*             Cancel parameter used to get filename
*        Else
*           Set flag to indicate that the file has been opened
*           Set looping flag to false
*        Endif
*     Enddo
*     If error then
*        Report and abort
*     Endif
*     Return
*
*    Bugs :
*
*     None known.
*-
*    Authors :
*
*     Malcolm Currie RAL (UK.AC.RL.STAR::CUR)
*
*    History :
*
*     1989 Jul 25: Original (RL.STAR::CUR).
*     1990 Feb 20: Renamed from AIF_OPFIO (RAL::CUR).
*     1994 Mar 1: Modified to return EXCLAIM (CARDIFF::GJP).
*     1997 Feb 24: Modified for Linux (GJP).
*
*    Type definitions :

      IMPLICIT  NONE           ! no implicit typing allowed

*    Global constants :
      INCLUDE  'SAE_PAR'       ! SSE global definitions
      INCLUDE  'PAR_ERR'       ! parameter-system errors

*    Import :
      CHARACTER*(*) PNFILE     ! File Parameter Name
      CHARACTER*(*) ACMODE     ! File access mode
      CHARACTER*(*) FORM       ! Required form of carriagecontrol
      INTEGER RECSZ            ! File record size

*    Export :
      LOGICAL OPEN             ! File opened successfully
      LOGICAL EXCLAIM          ! File name was exclaimation
      INTEGER FD               ! File descriptor

*    Status :
      INTEGER STATUS

*    Local Constants :
      INTEGER MXLOOP           ! Maximum number of attempts at
                               ! opening a data file
      PARAMETER ( MXLOOP=4 )

      INTEGER LOOP             ! Number of attempts to open the file

      LOGICAL LOOPAG           ! Loop again to open output file

*.

*    check status on entry - return if not o.k.

      IF ( STATUS .NE. SAI__OK ) RETURN

      LOOP=0
      LOOPAG=.TRUE.
      OPEN=.FALSE.
      EXCLAIM=.FALSE.
      DO WHILE ( LOOPAG )

*       attempt to obtain and open a file to output listing

         CALL FIO_ASSOC( PNFILE, ACMODE, FORM, RECSZ, FD, STATUS )

         IF ( STATUS .EQ. PAR__NULL ) THEN
            OPEN=.FALSE.
            LOOPAG=.FALSE.
            EXCLAIM=.TRUE.
            CALL ERR_ANNUL( STATUS )
         ELSE IF ( STATUS .NE. SAI__OK ) THEN

            IF ( STATUS .EQ. PAR__ABORT ) GOTO 999

*         Here if filename is not allowed or file is not opened
*         - try again
*         Need to flush error here, as not quitting routine

            LOOP=LOOP + 1
            IF ( LOOP .LE. MXLOOP ) THEN
               CALL MSG_SETC( 'FILNAM', PNFILE )
               CALL ERR_REP( 'ERR_AIF_ASFIO_NOFI',
     :           'AIF_ASFIO: Could not open file $^FILNAM - try again',
     :           STATUS )
               CALL ERR_FLUSH( STATUS )
            ELSE

*             end looping as user is having serious problems

               LOOPAG=.FALSE.
            END IF

            CALL PAR_CANCL( PNFILE, STATUS )

         ELSE

*          no problem, so exit loop

            LOOPAG=.FALSE.
            OPEN=.TRUE.

*       end of file-opened-successfully check

         END IF
      END DO

*    abort for repeated error

      IF ( STATUS .NE. SAI__OK ) THEN
         CALL ERR_REP( 'ERR_AIF_ASFIO_NOOPEN',
     :     'AIF_ASFIO: Repeatedly unable to open a file.', STATUS )
      END IF

 999  CONTINUE

      END




      SUBROUTINE ELP1_ANGLES(X,Y,XC,YC,ANGLE,STATUS)
*+
*  Name:
*     ELP1_ANGLES

*  Purpose:
*     Determine the angle of a point relative to a specified origin.
*     Direction of increasing angle clockwise and origin vertical.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_ANGLES(X,Y,XC,YC,ANGLE,STATUS)    

*  Description:
*     Determines the angle between a point and the vertical axis of the 
*     image (using a user provided origin). The ATAN function is used.
*     To determine the quadrant knowledge of the x/y displacements from
*     the given origin is employed. To avoid overflow errors, zero
*     y displacements are handled carefully.
     
*  Arguments:
*     X = REAL (Given) 
*        X co-ordinate of the pixel required
*     Y = REAL (Given) 
*        Y co=ordinate of the pixel required.
*     XC = REAL (Given)
*        X co-ordinate for the galaxy centre.
*     YC = REAL (Given)
*        Y co-ordinate for the galaxy centre.
*     ANGLE = REAL (Returned)
*        Angle the pixel makes with the galaxy origin. Units degrees.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     4-Apr-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'elp_par'               ! ELLPAR constants

*  Status:
      INTEGER STATUS                  ! Global status

*  Arguments Given:
      REAL X                          ! X location of pixel
      REAL XC                         ! X location of the galaxy origin
      REAL Y                          ! Y location of pixel
      REAL YC                         ! Y location of the galaxy origin

*  Arguments Returned:
      REAL ANGLE                      ! The angle the point/origin
                                      ! line makes with the vertical
                                     
*  Arguments Given and Returned:

*  Local variables:
      REAL ATNVAL                     ! Arctan value
      REAL RX                         ! X displacement of pixel
      REAL RY                         ! Y displacement of pixel
      REAL VALUE                      ! Temporary storage

*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Find the displacements from the origin in terms of x and y.
      RX=X-XC
      RY=Y-YC
  
*   Deal with purely vertical displacements.
      IF (ABS(RX).LT.1E-20) THEN
    
*      Assign angle as 0 or 180 degrees.
         IF (RY.LT.0.0) THEN
            ANGLE=ELP__PIVAL
         ELSE
            ANGLE=0.0
         END IF
 
      ELSE

*      Deal with purely horizontal displacements.
         IF (RY.EQ.0) THEN
   
*         Assign angle as 90 or 270 degrees.
            IF (X-XC.LT.0.0) THEN
               ANGLE=1.5*ELP__PIVAL
            ELSE
               ANGLE=ELP__PIVAL/2.0
            END IF
   
         ELSE
     
*         Deal with all other cases.
            VALUE=RX/RY
            ATNVAL=ATAN(VALUE)
     
*         Sort out the value depending on the quadrant. 
            IF (VALUE.GT.0.0) THEN
               IF (RX.GT.0.0) THEN
                  ANGLE=ATNVAL
               ELSE
                  ANGLE=ELP__PIVAL+ABS(ATNVAL)
               END IF
            ELSE
               IF (RX.GT.0.0) THEN
                  ANGLE=ELP__PIVAL+ATNVAL
               ELSE
                  ANGLE=2.0*ELP__PIVAL+ATNVAL
               END IF
            END IF
   
         END IF

      END IF

*   Convert to degrees.
      ANGLE=ANGLE/ELP__PIVAL*180.

 9999 CONTINUE

      END

 
      SUBROUTINE ELP1_AUTOL(BACK,ELEMS,PRANGE,ARRAY,
     :                      XCO,YCO,STATUS)
*+
*  Name:
*     ELP1_AUTOL

*  Purpose:
*     Looks at the pixels immediately surrounding the user defined galaxy
*     centre and then determines the centroid.
*
*     Two methods are available. Centroiding and weighted mean.
*     Choice is made via parameter AUTOLT.

*  Language:
*     Starlink Fortran 77

*  Invocation:   
*     CALL ELP1_AUTOL(BACK,ELEMS,PRANGE,ARRAY,XCO,YCO,STATUS)   

*  Description:
*     Examines the region of the image immediately surrounding the user 
*     input value and calculates the centroid or weighted mean 
*     co-ordinates. 

*  Arguments:              
*     BACK = REAL (Given)
*        The image background count. 
*     ELEMS = INTEGER (Given)               
*        Number of elements/pixels in the image array. Units pixels.
*     PRANGE(2) = INTEGER (Given)
*        Length of the X and Y axes of the image. Units pixels.
*     ARRAY(ELEMS) = REAL (Given and Returned)
*        The image array. Contains the count values for all the image pixels.
*        Units counts.
*     XCO = REAL (Given and Returned)
*        X index of the galaxy centre/origin supplied by the user.
*        Units pixels.
*     YCO = REAL (Given and Returned)
*        Y index of the galaxy centre/origin supplied by the user.
*        Units pixels.
*     STATUS = INTEGER (Given and Returned)
*        The global status value.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     16-MAR-1993 (GJP)
*     (Original version)
*     14-FEB-1996 (GJP)
*     Added centroiding and Linux fix.
 
*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'PRM_PAR'               ! PRIMDAT primitive data constants

*  Status:     
      INTEGER STATUS                  ! Global status

*  Arguments Given:
      INTEGER ELEMS                   ! Number of elements/pixels in the 
                                      ! image array
      INTEGER PRANGE(2)               ! Length of the X and Y axes of the 
                                      ! image
      REAL BACK                       ! Image background

*  Arguments Returned:
      INTEGER FLAG                    ! It was not possible to find the 
                                      ! central pixel value flag

*  Arguments Given and Returned:
      REAL ARRAY(ELEMS)               ! The image array contains the count 
                                      ! values for all the image pixels
      REAL XCO                        ! X index of the galaxy centre/origin 
                                      ! supplied by the user
      REAL YCO                        ! Y index of the galaxy centre/origin
                                      ! supplied by the user

*  Local variables:
      LOGICAL AUTOLT                  ! Type of estimation to be used
      INTEGER ADDRES                  ! Array address of the element
                                      ! corresponding to pixel indices X,Y 
      INTEGER XMAX                    ! Highest image pixel X index examined
      INTEGER XMIN                    ! Lowest image pixel X index examined
      INTEGER YMAX                    ! Highest image pixel Y index examined
      INTEGER YMIN                    ! Lowest image pixel Y index examined
      REAL CENINC                     ! Amount that the galaxy centre 
                                      ! co-ord is incremented by
      REAL CENRAD                     ! Radius of the area around the galaxy
                                      ! centre to be examined
      REAL CENTXS                     ! Centroid summation X
      REAL CENTYS                     ! Centroid summation Y
 
      REAL MAX                        ! Maximum weighted average pixel value
      REAL NEWX                       ! X value of pixel with highest
                                      ! weighted surrounding values
      REAL NEWY                       ! Y value of the pixel with the highest
                                      ! weighted surrounding values
      REAL TOTAL                      ! Weighted pixel count total
      REAL VALUE                      ! Current pixel count value
      REAL VTOTAL                     ! Pixel intensity total
      REAL WTOTAL                     ! Weighting total
      REAL WEIGHT                     ! Weighting value used when summing the 
                                      ! pixel count values about a given point
      REAL X                          ! Current X index
      REAL X2                         ! Current estimate X index
      REAL Y                          ! Current Y index
      REAL Y2                         ! Current estimate Y index

*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Get the type of estimation to use.
      CALL PAR_GET0L('AUTOLT',AUTOLT,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999
 
      IF (.NOT.AUTOLT) THEN 
 
*      Weighted mean method.
 
*      Set the radius of the area around the assigned galaxy centre 
*      to be considered. Also set the increment between galaxy centre
*      estimates.
         CENRAD=3.0
         CENINC=0.1
 
*      Set a flag to indicate if the pixel count value could be determined.
         FLAG=0
 
*      Set up the minimum and maximum image limits.
         XMIN=1
         XMAX=PRANGE(1)
         YMIN=1
         YMAX=PRANGE(2)
 
*      Set up the initial indices for the pixel with the highest weighted value>
         NEWX=XCO
         NEWY=YCO
         MAX=VAL__MINR
 
*      Loop through all pixels nearby to the chosen origin.
         X=XCO-CENRAD
         DO WHILE (X.LE.XCO+CENRAD)
            Y=YCO-CENRAD
            DO WHILE (Y.LE.YCO+CENRAD)
 
*            Avoid choosing an off image origin.
               IF ((X.GE.XMIN).AND.(X.LE.XMAX).AND.
     :             (Y.GE.YMIN).AND.(Y.LE.YMAX)) THEN
    
*               Initialise the pixel total and its weighting sum.
                  TOTAL=0.0
                  WTOTAL=0.0
 
*               Look at the pixels immediately adjacent to the current pixel.
*               Also check that they are within the image bounds.
                  X2=X-2.0
                  DO WHILE (X2.LE.X+2.0)
                     Y2=Y-2.0
                     DO WHILE (Y2.LE.Y+2.0)
 
*                     Avoid using points that are outside the image.
                        IF ((INT(X2).GE.XMIN).AND.(INT(X2).LE.XMAX)
     :                      .AND.
     :                      (INT(Y2).GE.YMIN).AND.(INT(Y2).LE.YMAX))
     :                      THEN
 
*                        Find the address of one of the surrounding pixels.
                           ADDRES=(INT(Y2)-1)*XMAX+INT(X2)
 
*                        Find the pixel value.
                           VALUE=ARRAY(ADDRES)
       
*                        Check that the pixel is not bad.
                           IF (VALUE.NE.VAL__BADR) THEN
 
*                           Calculate the weighting value.
*                           An arbitrary method.
                              WEIGHT=1./(1.+SQRT(REAL((X2-X)*(X2-X)
     :                               +(Y2-Y)*(Y2-Y))))
 
*                           Add the weighted pixel value to the summation 
*                           and then add the current weighting value to 
*                           the sum of all the weights for the current 
*                           X/Y location.
                              TOTAL=TOTAL+VALUE*WEIGHT
                              WTOTAL=WTOTAL+WEIGHT
 
                           END IF
 
                        END IF
  
*                     Increment the Y value of the pixels being used.
                        Y2=Y2+1.0
 
                    END DO
 
*                  Increment the X value of the pixels being used.   
                     X2=X2+1.0
 
                  END DO
 
*               Check to see if any legal points were found.
                  IF (WTOTAL.GT.0.0) THEN
 
*                  Calculate the weighted mean pixel value surrounding the 
*                  current X/Y value. Keep it and its co-ords if it is bigger 
*                  than the biggest found so far.
                     IF (TOTAL/WTOTAL.GT.MAX) THEN
                        MAX=TOTAL/WTOTAL
                        NEWX=X
                        NEWY=Y
                     END IF
 
                  END IF
 
               END IF
 
*            Increment the current Y position to be considered.
               Y=Y+CENINC
 
            END DO
 
*         Increment the current X position to be considered.
            X=X+CENINC
 
         END DO
 
*      Transfer the new centre location to the XCO YCO variables. Also,
*      pass back the value of the pixel chosen.
         XCO=NEWX
         YCO=NEWY
      ELSE
 
*      Centroid method.
 
*      Set the radius of the area around the assigned galaxy centre 
*      to be considered. 
         CENRAD=3
 
*      Set a flag to indicate if the pixel count value could be determined.
         FLAG=0
 
*      Set up the minimum and maximum image limits.
         XMIN=1
         XMAX=PRANGE(1)
         YMIN=1
         YMAX=PRANGE(2)
 
*      Set up the default indices for the pixel centroid. 
         NEWX=XCO
         NEWY=YCO
 
*      Intitialise summations.
         VTOTAL=0.0
         CENTXS=0.0
         CENTYS=0.0
 
*      Loop through all pixels nearby to the chosen origin.
         DO 100 X=XCO-CENRAD,XCO+CENRAD
            DO 200 Y=YCO-CENRAD,YCO+CENRAD
 
*            Avoid choosing an off image origin.
               IF ((X.GE.XMIN).AND.(X.LE.XMAX).AND.
     :             (Y.GE.YMIN).AND.(Y.LE.YMAX)) THEN
    
*               Find the address of one of the surrounding pixels.
                  ADDRES=(INT(Y)-1)*XMAX+INT(X)
  
*               Find the pixel value.
                  VALUE=ARRAY(ADDRES)
       
*               Check that the pixel is not bad.
                  IF (VALUE.NE.VAL__BADR) THEN
 
*                  Create values needed to calculate the
*                  centroid later.
                     VALUE=VALUE-BACK
                     VTOTAL=VTOTAL+VALUE
                     CENTXS=CENTXS+VALUE*X
                     CENTYS=CENTYS+VALUE*Y
 
                  END IF
         
               END IF
 
 200        CONTINUE
 100     CONTINUE
 
*      Calculate the centroid.
         IF ((VTOTAL.NE.0).AND.(CENTXS.NE.0).AND.
     :                     (CENTYS.NE.0)) THEN
            NEWX=CENTXS/VTOTAL
            NEWY=CENTYS/VTOTAL
 
         END IF 
 
*      Setup the new values to return.
         XCO=NEWX
         YCO=NEWY
 
      END IF
 
 9999 CONTINUE
      
      END



      SUBROUTINE ELP1_CANCL(MODE,STATUS)    
*+
*  Name:
*     ELP1_CANCL

*  Purpose:
*     Cancels a number of input parameters so that they are then in a
*     state where the user is again prompted for an input.
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*      CALL ELP1_CANCL(MODE,STATUS)    

*  Description:
*      Cancels the values of a number of input parameters so that they are
*      changed from active state to Ground state. This means that the next 
*      time values for them are required the user will be reprompted.
*
*      The MODE variable defines which parameters must be cancelled.
*

*  Arguments:               
*     MODE = INTEGER (Given)
*        Defines which parameters must be cancelled. MODE=0 those required
*        for the cursor input or (MODE=1) those for keyboard input. 
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     23-FEB-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:                              
      INTEGER MODE                    ! Defines which parameters are to be
                                      ! cancelled
         
*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:

*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Cancel those parameters required for cursor input.
      IF (MODE.EQ.0) THEN
*      Another profile.
         CALL PAR_CANCL('AGAIN',STATUS)
*      Backgound count.
         CALL PAR_CANCL('BACK',STATUS)
*      Output text file name.
         CALL PAR_CANCL('OUT',STATUS)
*      Refine the position guess.
         CALL PAR_CANCL('AUTOL',STATUS)
*      Position guess type.
         CALL PAR_CANCL('AUTOLT',STATUS)
*      The graphics display device used for the graphs.
         CALL AGI_CANCL('DEVICE',STATUS)
      END IF

*   Cancel those parameters required for keyboard input.
      IF (MODE.EQ.1) THEN
*      Another profile.
         CALL PAR_CANCL('AGAIN',STATUS)
*      Galaxy origin co-ordinates.
         CALL PAR_CANCL('ORIGIN',STATUS)
*      Background  count.
         CALL PAR_CANCL('BACK',STATUS)
*      Refine the position guess.
         CALL PAR_CANCL('AUTOL',STATUS)
*      Position guess type.
         CALL PAR_CANCL('AUTOLT',STATUS)
*      Output text file name.
         CALL PAR_CANCL('OUT',STATUS)
      END IF

 9999 CONTINUE

      END



      SUBROUTINE ELP1_CMODE(STATUS)
*+
*  Name:
*     ELP1_CMODE

*  Purpose:
*     The routine allows the user to input most the information required
*     (position, background value etc) for the galaxy profile to be 
*     performed/displayed  and then calls other routines as necessary. 
* 
*     The routine operates using a combination of keyboard and cursor
*     inputs and examines the latest DATA image in the AGI database
*     for the device specified.
*
*     Information such as pixel size, background count value and its
*     std. dev. are also input.
*

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_CMODE(STATUS)

*  Arguments:   
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description: 
*
*     Profiling is continued until the mean profile value is less than
*     a user defined number of standard deviations above sky (LIM2) or 
*     until the mean profile value increases by a user defined amount
*     compared to the previous profile (LIM1). The difference between the 
*     sizes of profile semi-major axis values is controlled using the 
*     FINE parameter.
*
*     When profiling an ellipse with a small radius one of two methods may
*     be employed to determine the values of points located around each
*     trial ellipse. These are are bi-linear interpolation or a surface
*     interpolation based on a 8x8 grid of surrounding pixels. The latter
*     method is slower but may yield better results at small radii. It 
*     is selected by setting the parameter FAST to false.     
*
*     The initial estimate of the galaxy position may be improved by 
*     selecting the AUTOL option which performs a centroid 
*     analysis of the image area immediately surrounding the input value.
*
*     Contaminating parts of the image may be defined using an ARD file.

*  Implementation Status:
*     Under development

*  Authors:
*     GJP: Grant Privett (STARLINK)
*     {enter_new_authors_here}

*  History:
*     10-Mar-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'NDF_PAR'               ! NDF_ public constant
      INCLUDE 'PRM_PAR'               ! PRIMDAT primitive data constants
      INCLUDE 'elp_par'               ! ELLPRO constants
      INCLUDE 'MSG_PAR'               ! MSG constants
      INCLUDE 'SUBPAR_PAR'            ! SUBPAR constants

         
*  Status:     
      INTEGER STATUS                  ! Global status

*  Local Variables:      
      CHARACTER *(MSG__SZMSG) FILE    ! NDF file name
      LOGICAL ANGCON                  ! Position angle convention
      LOGICAL AGAIN                   ! Determine another profile?
      LOGICAL AUTOL                   ! Is an estimate of the galaxy centre
                                      ! position to be made?
      LOGICAL EXCLAIM                 ! Was an exclaimation mark given for
                                      ! an output file name?
      LOGICAL FAST                    ! Use fast method of profiling?
      LOGICAL FRZORI                  ! Is the galaxy origin frozen?
      LOGICAL GRAPH                   ! Is a graph to be plotted
      LOGICAL INOKAY                  ! Was the most recent input value okay
      LOGICAL SAME                    ! Use the display device the image is
                                      ! on to show the result graphs?
      INTEGER AGIID                   ! AGI identifier
      INTEGER COLOUR                  ! Pen colour used for galaxy marker
      INTEGER ELEMS                   ! Total number of pixels in the NDF
      INTEGER FIOD                    ! FIO file descriptor
      INTEGER FIRST                   ! First time the NDF identifier has been
                                      ! determined
      INTEGER I                       ! Loop variable
      INTEGER LBND(NDF__MXDIM)        ! Lower limit for image index
      INTEGER MINMOD                  ! Which residual to use in minimisation
      INTEGER NDF1                    ! Identifier for the source NDF  
      INTEGER NDIM                    ! Number of dimensions in the 
                                      ! image
      INTEGER POINT0(1)               ! Pointer to the data component of
                                      ! the source NDF
      INTEGER POINT1(1)               ! Pointer to the data component of 
                                      ! for the output NDF
      INTEGER POINT3(1)               ! Pointer to the ARD mask
      INTEGER PRANGE(2)               ! Length of the x and y axes
      INTEGER STLEN                   ! File name length
      INTEGER UBND(NDF__MXDIM)        ! Upper limit for image index
      INTEGER VALIDP                  ! Number of radii for which a 
                                      ! was found
      REAL ANGOFF                     ! Position angle offset
      REAL BACK                       ! Background count value
      REAL FINE                       ! Determines how closely spaced the
                                      ! chosen radii values are
      REAL FRACT                      ! Fraction of the ellipse points that
                                      ! must be available for the profile 
                                      ! at a given radius to be kept
      REAL LIM1                       ! Maximum permitted count increase factor
      REAL LIM2                       ! Lower limit on ellipse count
      REAL LIM3                       ! Radius at which the position angle,
                                      ! ellipticity and origin are
                                      ! no longer adjusted
      REAL PSIZE                      ! Size of the image pixels in arc sec
      REAL RESULT(ELP__NRES,ELP__RESUL)      ! Ellipse parameters
      REAL RLIM                       ! Ellipse maximum size
      REAL SIGMA                      ! Std. dev. of the background value
      REAL X(10)                      ! Indices of the co-ordinates input
      REAL XCO                        ! X index of the galaxy origin
      REAL Y(10)                      ! Indices of the co-ordinates input
      REAL YCO                        ! Y index of the galaxy origin
      REAL ZEROP                      ! Zero point of the surface 
                                      ! brightness graphs
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Set the pen colour required.
      CALL PAR_STATE('COLOUR',I, STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0I('COLOUR',COLOUR,STATUS)
         CALL MSG_OUT(' ','Command line COLOUR value used.',STATUS)
      ELSE
         COLOUR=1
      END IF

*   Look at the command line value for ANGCON.
*   Otherwise, use the default.
      CALL PAR_STATE('ANGCON',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0L('ANGCON',ANGCON,STATUS)
         CALL MSG_OUT(' ','Command line ANGCON value used.',STATUS)
      ELSE
         ANGCON=.TRUE.
      END IF

*   Look at the command line value for ANGOFF.
*   Otherwise, use the default.
      CALL PAR_STATE('ANGOFF',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0R('ANGOFF',ANGOFF,STATUS)
         CALL MSG_OUT(' ','Command line ANGOFF value used.',STATUS)
      ELSE
         ANGOFF=0.0
      END IF

*   Get the minimisation mode (which residual to use)
C      CALL PAR_STATE('MINMOD',I, STATUS)
C      IF (STATUS.NE.SAI__OK) GOTO 9999
C      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
C         CALL PAR_GET0I('MINMOD',MINMOD,STATUS)
C         CALL MSG_OUT(' ','Command line MINMOD value used.',STATUS)
C      ELSE
C         MINMOD=0
C      END IF
      CALL PAR_GET0I('MINMOD',MINMOD,STATUS)
      IF (STATUS .NE. SAI__OK) GOTO 9999



*   Begin an NDF context.                               
      CALL NDF_BEGIN
      IF (STATUS.NE.SAI__OK) GOTO 9999

*     Loop around looking at different parts for the same image.
      AGAIN=.TRUE.
      FIRST=0
      DO WHILE ((AGAIN).AND.(STATUS.EQ.SAI__OK))  

*      Get the cursor position for the galaxy origin. At the same time
*      obtain the NDF identifier for the most recent 'DATA' picture.
         INOKAY=.FALSE.
         DO WHILE ((.NOT.INOKAY).AND.(STATUS.EQ.SAI__OK))  

*         Get the value from the image. Taking care to ensure that
*         the NDF is only obtained by ELP1_CURSO only the first time 
*         a co-ordinate is provided.
            CALL ELP1_CURSO('IMGDEV',FIRST,0,COLOUR,NDF1,X,Y,
     :                      RLIM,STATUS)
            XCO=X(10)
            YCO=Y(10)

*         Get the image bounds and also the size of the axes in pixels.
            CALL NDF_BOUND(NDF1,2,LBND,UBND,NDIM,STATUS)
            PRANGE(1)=UBND(1)-LBND(1)+1
            PRANGE(2)=UBND(2)-LBND(2)+1

*         Check that the co-ordinate values input are legal and
*         annul the parameter if not.
            IF ((XCO.LT.1.0).OR.(XCO.GT.PRANGE(1)).OR.(YCO.LT.0.0).
     :           OR.(YCO.GT.PRANGE(2))) THEN
               CALL MSG_OUT(' ','The position supplied, is not '//
     :                      'within the image.',STATUS)
               CALL PAR_CANCL('ORIGIN',STATUS)
            ELSE
               INOKAY=.TRUE.
            END IF
            FIRST=1

         END DO            
         IF (STATUS.NE.SAI__OK) GOTO 9999 
 
*      Get the radius value from the image. Taking care to ensure that
*      the NDF is only obtained by ELP1_CURSO only the first time 
*      a co-ordinate is provided.
         CALL ELP1_CURSO('IMGDEV',2,0,COLOUR,NDF1,X,Y,RLIM,STATUS)

*      Calculate maximum permitted radius for the ellipse.
         RLIM=SQRT((X(1)-X(2))*(X(1)-X(2))+(Y(1)-Y(2))*(Y(1)-Y(2)))
         IF (RLIM.LT.5.) RLIM=ELP__RLIM

*      Display the circle showing the radius limit. 
         CALL ELP1_CURSO('IMGDEV',3,0,COLOUR,NDF1,X,Y,RLIM,STATUS)
         CALL MSG_BLANK(STATUS)

*      Determine whether or not the origin given is to be used throughout
*      the profiling.
         CALL PAR_GET0L('FRZORI',FRZORI,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Get the background count value.
         CALL PAR_GET0R('BACK',BACK,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Get the background count standard deviation value.
         INOKAY=.FALSE.
         DO WHILE ((.NOT.INOKAY).AND.(STATUS.EQ.SAI__OK))
            CALL PAR_GET0R('SIGMA',SIGMA,STATUS)
            IF (SIGMA.LE.0.0) THEN
*            Display message and annul the parameter.
               CALL MSG_OUT(' ','Sigma supplied, is not '//
     :                      'feasible.',STATUS)
               CALL PAR_CANCL('SIGMA',STATUS)
            ELSE
               INOKAY=.TRUE.  
            END IF
         END DO
         IF (STATUS.NE.SAI__OK) GOTO 9999 

*      Is the default radii separation to be used? 
*      Check the command line for an input.
*      Otherwise, use the value specified in elp_par.
         CALL PAR_STATE('FINE',I,STATUS )
         IF (STATUS.NE.SAI__OK) GOTO 9999
         IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
            CALL PAR_GET0R('FINE',FINE,STATUS)
            CALL MSG_OUT(' ','Command line FINE value used.',STATUS)
         ELSE
            FINE=ELP__FINE
         END IF

*      Get the pixel size value.
         INOKAY=.FALSE.
         DO WHILE ((.NOT.INOKAY).AND.(STATUS.EQ.SAI__OK))
            CALL PAR_GET0R('PSIZE',PSIZE,STATUS)
            IF (PSIZE.LE.0.0) THEN
*            Display message and annul the parameter.
               CALL MSG_OUT(' ','The pixel size supplied, is not '//
     :                      'feasible.',STATUS)
               CALL PAR_CANCL('PSIZE',STATUS)
            ELSE
               INOKAY=.TRUE.
            END IF
         END DO
         IF (STATUS.NE.SAI__OK) GOTO 9999 
        
*      Get the zero point for the surface brightness scale/graphs.
         CALL PAR_GET0R('ZEROP',ZEROP,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Is the galaxy centre to be determined by a centroid around 
*      the coords provided? 
         CALL PAR_GET0L('AUTOL',AUTOL,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Calculate the profiles without using the bi-cubic spline at
*      low radii? Check the command line for the an input.
*      Otherwise, use the value specified in elp_par.
         CALL PAR_STATE('FAST',I,STATUS )
         IF (STATUS.NE.SAI__OK) GOTO 9999
         IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
            CALL PAR_GET0L('FAST',FAST,STATUS)
            CALL MSG_OUT(' ','Command line FAST value used.',STATUS)
         ELSE
            FAST=ELP__FAST
         END IF

*      Check the state of the parameter LIM1, to see if there is a
*      suggested value on the command line.
*      Otherwise, use the value specified in elp_par.
         CALL PAR_STATE('LIM1',I, STATUS )
         IF (STATUS.NE.SAI__OK) GOTO 9999
         IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
            CALL PAR_GET0R('LIM1',LIM1,STATUS)
            CALL MSG_OUT(' ','Command line LIM1 value used.',STATUS)
         ELSE
            LIM1=ELP__LIM1
         END IF

*      Check the state of the parameter LIM2, to see if there is a
*      suggested value on the command line.
*      Otherwise, use the value specified in elp_par.
         CALL PAR_STATE('LIM2',I,STATUS )
         IF (STATUS.NE.SAI__OK) GOTO 9999
         IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
            CALL PAR_GET0R('LIM2',LIM2,STATUS)
            CALL MSG_OUT(' ','Command line LIM2 value used.',STATUS)
         ELSE
            LIM2=ELP__LIM2
         END IF

*      Check the state of the parameter LIM3, to see if there is a
*      suggested value on the command line.
*      Otherwise, use the value specified in elp_par.
         CALL PAR_STATE('LIM3',I,STATUS )
         IF (STATUS.NE.SAI__OK) GOTO 9999
         IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
            CALL PAR_GET0R('LIM3',LIM3,STATUS)
            CALL MSG_OUT(' ','Command line LIM3 value used.',STATUS)
         ELSE
            LIM3=ELP__LIM3
         END IF

*      Check the state of the parameter FRACT, to see if there is a
*      suggested value on the command line.
*      Otherwise, use the value specified in elp_par.
         CALL PAR_STATE('FRACT',I,STATUS )
         IF (STATUS.NE.SAI__OK) GOTO 9999
         IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
            CALL PAR_GET0R('FRACT',FRACT,STATUS)
            CALL MSG_OUT(' ','Command line FRACT value used.',STATUS)
         ELSE
            FRACT=ELP__FRACT
         END IF

*      Map the input NDF data array as _REAL values for reading.
         CALL NDF_MAP(NDF1,'DATA','_REAL','READ',POINT0(1),ELEMS,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Get the name of the file being mapped.
         CALL NDF_MSG('FILE',NDF1)
         CALL MSG_LOAD(' ','^FILE',FILE,STLEN,STATUS)
        
*      Allocate dynamic memory on which to map the NDF.
         CALL PSX_CALLOC(ELEMS,'_REAL',POINT1(1),STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9998

*      Transfer values from the mapped NDF to the allocated memory.
         CALL ELP1_TRANS(ELEMS,%VAL(POINT0(1)),%VAL(POINT1(1)),STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9998

*      Un-map the source NDF. Helps to reduce the resources being used.
         CALL NDF_UNMAP(NDF1,'DATA',STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9998
             
*      Allocate the memory needed for the logical mask array.
         CALL PSX_CALLOC(ELEMS,'_INTEGER',POINT3(1),STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9998
 
*      Transfer to the ARD driver control routine.
         NDIM=2
         CALL ESP_ARD_DRIVER(NDIM,ELEMS,LBND,UBND,POINT1,POINT3,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9998
 
*      Free the dynamic array space of the logical mask.
         CALL PSX_FREE(POINT3(1),STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9998

*      Look for a better (though crude) estimate of the galaxy core position.
         IF (AUTOL) CALL ELP1_AUTOL(BACK,ELEMS,PRANGE,
     :                   %VAL(POINT1(1)),XCO,YCO,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9998

*      Call the routine that profiles the galaxy and sets up the values
*      in the results arrays.
         CALL ELP1_PRO(1,MINMOD,ANGCON,ANGOFF,FRZORI,FINE,
     :             LIM1,LIM2,LIM3,
     :             FRACT,PSIZE,FAST,RLIM,BACK,SIGMA,ELEMS,POINT1,
     :             PRANGE,XCO,YCO,VALIDP,RESULT,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9998

*      Only bother with the graphs if there is more than one data point.
         IF (VALIDP.GT.1) THEN

*         Get the user selection of using the same display as the image
*         to display the results.
            CALL PAR_GET0L('SAME',SAME,STATUS)

*         Display the results graphs on the device used to show the image.
            IF (SAME) THEN

*            Find limits for the window to be used to display the graph.
               CALL ELP1_CURSO('IMGDEV',6,0,COLOUR,NDF1,X,Y,
     :                         RLIM,STATUS)
           
*            Set up the new window.
               CALL ELP1_CURSO('IMGDEV',7,0,COLOUR,NDF1,X,Y,
     :                         RLIM,STATUS)

*            Set up the AGI/PGPLOT interface.
               CALL ELP1_AGICO(0,1,0,AGIID,STATUS)

*            Display the un-analysed data as a graphical plot of radius 
*            (in pixels) versus intensity.
               CALL ELP1_GRAPH(PSIZE,ZEROP,RESULT,VALIDP,
     :                         STATUS)  
               IF (STATUS.NE.SAI__OK) GOTO 9999

*            Turn off the AGI/PGPLOT interface.
               CALL ELP1_AGICO(1,1,0,AGIID,STATUS)

            END IF

         END IF                

*      Display the results graphs on a device specified by the user.
         IF (.NOT.SAME) THEN

*      Only display the graphs if there is more than 1 data point.
             IF (VALIDP.GT.1) THEN

*            Display the graph of the data points i.e. radius versus brightness.
*            Determine if graphical histogram output is required. Set the
*            value for GRAPH accordingly.
               AGIID=0
               GRAPH=.TRUE.
               CALL ERR_MARK
               CALL ELP1_AGICO(0,0,0,AGIID,STATUS)
               IF (STATUS.NE.SAI__OK) THEN
                  GRAPH=.FALSE.
                  CALL ERR_ANNUL(STATUS)
               END IF
               CALL ERR_RLSE

*            Display the un-analysed data as a graphical plot of radius 
*            (in pixels) versus intensity.
               IF (GRAPH) THEN 

                  CALL ELP1_GRAPH(PSIZE,ZEROP,RESULT,VALIDP,
     :                            STATUS)  
                  IF (STATUS.NE.SAI__OK) GOTO 9999

*               Turn off the AGI/PGPLOT interface.
                  CALL ELP1_AGICO(1,0,0,AGIID,STATUS)

               END IF
             
            END IF

         END IF     
      
*      Output a text file containing results if required.
         CALL ELP1_TEXTO(0,NDF1,VALIDP,ZEROP,RESULT,XCO,YCO,BACK,
     :                   SIGMA,PSIZE,LBND,FIOD,EXCLAIM,STATUS)

*      An appropriate place to exit to if the dynamic memory has already
*      been allocated.
 9998    CONTINUE

*      De-allocate the dynamic memory used.
         CALL PSX_FREE(POINT1(1),STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Get the user selection of preparing another galaxy profile 
*      or not.
         CALL PAR_GET0L('AGAIN',AGAIN,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Cancel the parameters so that they must be reinput when
*      looping round.
         IF (AGAIN) CALL ELP1_CANCL(0,STATUS)

      END DO

      IF (STATUS.NE.SAI__OK) GOTO 9999

 9999 CONTINUE

*   End the NDF context.
      CALL NDF_END(STATUS)                              

      END


      SUBROUTINE ELP1_CURSO(GRADEV,POINT,NAME,COLOUR,NDF1,X,Y,
     :                      RLIM,STATUS)
*+
*  Name:
*     ELP1_CURSO

*  Purpose:
*     Multi-purpose routine that allows use of the SGS cursor for returning 
*     the co-ordinate for a given type of image and also controls all SGS 
*     graphics displays (such as that displaying the galaxy origin)
*
*     The routine is used for more than one purpose to 
*     avoid unecessary duplication of code.

*  Language:
*     Starlink Fortran 77

*  Type of Module:
*     ADAM A-task

*  Invocation:
*     CALL ELP1_CURSO(GRADEV,POINT,NAME,COLOUR,NDF1,X,Y,RLIM,STATUS)

*  Arguments:
*     GRADEV *(6) = CHARACTER (Given)
*        Name of the graphics device to be used.
*     POINT = INTEGER (Given)
*        Specifies what action is to be taken by the subroutine.
*     NAME = INTEGER (Given)
*        Defines whether or not pictures of name DATA or ELLPRO will
*        be located.
*     COLOUR = INTEGER (Given)
*        Pen colour marking the galaxy centre.
*     NDF1 = INTEGER (Given and Returned)
*        NDF identifier for the current picture.
*     X(10) = REAL (Given and Returned)
*        Co-ordinate information obtained via the cursor or to be
*        displayed on the workstation.
*     Y(10) = REAL (Given and Returned)
*        Co-ordinate information obtained via the cursor or to be
*        displayed on the workstation.
*     RLIM = REAL (Given and Returned)
*        Radius of the biggest ellipse allowed.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description:
*     The routine undertakes several different tasks. These have been
*     placed together in one routine to avoid unnecessary duplication 
*     of code. The tasks undertaken are:
*
*     - allowing the user to use the SGS cursor to specify the location of 
*     the galaxy to be used and the quadrant in which the graphical results 
*     display are to be shown. The routines include text messages to be 
*     shown to instruct the user. 
*    
*     - return a locator/identifier value from the AGI database, this allows 
*     the NDF that was used to generate the most recently displayed image 
*     named DATA, to be accessed.
*
*     - allow simple SGS routines to be used to display lines etc on top
*     of the image represented in the AGI database by the entry most
*     recently named DATA.
*
*     - inspecting the AGI database to ensure that (as required) the co-ordinate
*     values are being returned for the file most recently stored with 
*     the database name DATA.
*
*     - sets up a new AGI databse entry (ELLPRO) to define part of the screen
*     so that PGPLOT routines may be used to update the display and show 
*     the results graphically in a form more sophisticated than SGS would 
*     normally allow.
*
*     - close down the AGI resources and SGS at the end of each call so
*     that confusion may be avoided at the calling routines.

*  Notes:
*     This program is a massively disembowelled version of KAPPA program
*     CURSOR with a few bits of ZAPLIN used here and there. 
*
*     The application only acts on the most recent picture in the 
*     graphics database named 'DATA' and also an entry called 'ELLPRO' which
*     contains a graphical display of the profile results.
 
*  Authors:
*     GJP: Grant Privett (STARLINK)
*     {enter_new_authors_here}

*  History:
*     See KAPPA CURSOR and ZAPLIN for their history.
*     Original Version: 05/01/93
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-

*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'PAR_ERR'          ! Parameter-system errors
      INCLUDE 'AGI_ERR'          ! AGI error constants

*  Arguments given:
      CHARACTER *(6) GRADEV      ! Name of the graphics device
      INTEGER COLOUR             ! Pen colour of the galaxy marker
      INTEGER NAME               ! Whether pictures of name DATA or ELLPRO
                                 ! are to be used 0=DATA 1=ELLPRO
      INTEGER POINT              ! Which of the describing points is being
                                 ! selected

*  Arguments Given and Returned.
      INTEGER NDF1               ! NDF identifier for the current picture
      REAL X(10)                 ! Position information from the cursor 
                                 ! or to be displayed on the workstation
      REAL Y(10)                 ! Position information from the cursor 
                                 ! or to be displayed on the workstatio
      REAL RLIM                  ! Radius of the most distant permitted 
                                 ! profile ellipse

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      CHARACTER *80 IMGMES(4)    ! Informational messages if device is
                                 ! an image display
      CHARACTER *80 TERMES(4)    ! Informational messages if device is
                                 ! a terminal

      INTEGER HITVAL             ! The selected choice of the cursor
      INTEGER NIMGMS             ! Number of lines of image-display
                                 ! messages
      INTEGER NTERMS             ! Number of lines of terminal messages
      INTEGER PICID              ! Current (input) picture identifier
      REAL CURSIZ                ! Size of the graphics cursor
      REAL TEMPX                 ! Temporary variable
      REAL TEMPY                 ! Temporary variable
      REAL X1,Y1                 ! Lower-left corner of the initial
                                 ! picture
      REAL X2,Y2                 ! Upper-right corner of the initial
                                 ! picture
      REAL XIN                   ! x co-ordinate as measured by the
                                 ! cursor
      REAL XM,YM                 ! Size of the initial picture
      REAL YIN                   ! y co-ordinate as measured by the
                                 ! cursor

      LOGICAL CURCHO             ! Cursor is available with suitable
                                 ! number of choices
      LOGICAL DEVCAN             ! The device parameter is to be
                                 ! cancelled
      LOGICAL IMGDIS             ! Device is nominally an image display

*.

*   Check inherited global status.

      IF (STATUS.NE.SAI__OK) RETURN

*   Create informational messages for use with the cursor.
      CALL ELP1_MESSG(POINT,TERMES,IMGMES,NTERMS,NIMGMS,STATUS)

*   Start the graphics system. If this is the first time the routine has 
*   been used then an identifier/locator to the NDF for the displayed 
*   image is returned as NDF1.
      IF (POINT.EQ.0) THEN 
         CALL ELP1_AGIC2(GRADEV,0,1,NAME,NDF1,DEVCAN,
     :                   PICID,STATUS)
         POINT=1
      ELSE
         CALL ELP1_AGIC2(GRADEV,0,0,NAME,NDF1,DEVCAN,PICID,STATUS)
      END IF
      IF (STATUS.NE.SAI__OK) GOTO 9999

*   Set initial cursor position of the current picture. When identifying the
*   galaxy to be used, the last location selected is supplied as the initial
*   position. Also re-establishes the screen limits.
      CALL SGS_IZONE(X1,X2,Y1,Y2,XM,YM)
      IF ((POINT.NE.2).AND.(POINT.NE.9)) THEN
         XIN=0.5*(X1+X2)
         YIN=0.5*(Y1+Y2)
      ELSE 
         XIN=X(POINT-1)
         YIN=Y(POINT-1)
      END IF  

*   Actually sets the position (code above calculated it).
      CALL SGS_SETCU(XIN,YIN)
      CURSIZ=0.004*MIN(X2-X1,Y2-Y1)

*   Draw the radius limit for the profiling. Is done here so that
*   the value for X1 and Y1 need not be retained between calls to this 
*   routine.
      IF (POINT.EQ.3) THEN
         CALL ELP1_GRBIT(POINT,COLOUR,CURSIZ,X,Y,RLIM,STATUS)
         GOTO 980
      END IF

*   Set up the screen sector that will be used to display the graph results.
      IF (POINT.EQ.7) THEN

*      Set up temporary stores for the x and y range divided by 2.
         TEMPX=(X2-X1)/2.
         TEMPY=(Y2-Y1)/2.

*      Sort out the x co-ordinates for the quadrant position required.
         IF (X(6)-X1.LT.TEMPX) THEN
            X(6)=X1
            X(7)=X1+TEMPX
         ELSE
            X(6)=X1+TEMPX
            X(7)=X2
         END IF

*      Sort out the y co-ordinates for the quadrant required. 
         IF (Y(6)-Y1.LT.TEMPY) THEN
            Y(6)=Y1
            Y(7)=Y1+TEMPY
         ELSE           
            Y(6)=Y1+TEMPY
            Y(7)=Y2
         END IF

*      Draw the box showing the quadrant being used.
         CALL ELP1_GRBIT(POINT,COLOUR,CURSIZ,X,Y,RLIM,STATUS)

*      Sort out the x co-ordinates for within the quadrant required.
         IF (X(6)-X1.LT.TEMPX) THEN
            X(6)=X1+TEMPX*.15
            X(7)=X1+TEMPX*.9
         ELSE
            X(6)=X1+TEMPX*1.15
            X(7)=X1+TEMPX*1.9
         END IF

*      Sort out the y co-ordinates for within the quadrant required. 
         IF (Y(6)-Y1.LT.TEMPY) THEN
            Y(6)=Y1+TEMPY*.15
            Y(7)=Y1+TEMPY*.85
         ELSE           
            Y(6)=Y1+TEMPY*1.15
            Y(7)=Y1+TEMPY*1.85
         END IF

*      Setup the new entry in the database.
         CALL AGI_NUPIC(X(6),X(7),Y(6),Y(7),'ELLPRO','Galaxy Profile',
     :                 0.0,1.0,0.0,1.0,PICID,STATUS)
         IF (STATUS.NE.SAI__OK) THEN
            STATUS=SAI__ERROR
            CALL ERR_REP(' ','Could not create a new picture in the'/
     :                   /' AGI database.',STATUS)
         END IF
         GOTO 980

      END IF

*   Put out a blank line to ensure the commentary appears on the alpha
*   plane of the terminal.
      CALL MSG_BLANK(STATUS)

*   Prepare the cursor for use.
      CALL ELP1_PRPCUR(1,3,TERMES,NTERMS,IMGMES,NIMGMS,'12 .',
     :            CURCHO,IMGDIS,STATUS)
      IF ((.NOT.CURCHO).OR.(STATUS.NE.SAI__OK)) GOTO 980

*   Initialise HITVAL before the main loop is entered.
      HITVAL=0

*   Loop until the point is selected.
*   Values 4 taken as the select.
*   Value 2 as an emergency exit.
*   Values 1 and 3 used to show the current position.
      DO WHILE ((HITVAL.NE.4).AND.(STATUS.EQ.SAI__OK))
        
*      Start a new error context.
         CALL ERR_MARK

*      If a message has already been displayed, and then the cursor
*      is used, the next message is no longer in synchronisation
*      with the cursor. So synchronise the message system.
         CALL MSG_SYNC(STATUS)

*      Read the cursor position and button value.
         CALL SGS_REQCU(XIN,YIN,HITVAL)

*      Emergency exit.
         IF (HITVAL.EQ.2) THEN
            CALL MSG_BLANK(STATUS)
            STATUS=SAI__ERROR
            CALL ERR_REP(' ','You have opted to leave the'/
     :                   /' program.',STATUS)
            GOTO 980
         END IF

*      Convert the world co-ordinates to data system.
         IF ((HITVAL.EQ.1).OR.(HITVAL.EQ.3).OR.(HITVAL.EQ.4)) THEN 
            X(POINT)=XIN                       
            Y(POINT)=YIN
*         Display the cursor results if necessary.
            IF (POINT.LT.6.AND.(HITVAL.EQ.1.OR.HITVAL.EQ.3)) THEN
               CALL ELP1_CURVD(X1,Y1,XIN,YIN,STATUS)
            END IF
         END IF
                
*      Release the new error context.
         CALL ERR_RLSE

      END DO

*   Draw the galaxy origin.
      IF (POINT.EQ.1) CALL ELP1_GRBIT(POINT,COLOUR,CURSIZ,X,Y,
     :                                RLIM,STATUS)
  
*   Convert the world co-ordinate to data co-ordinates so that it can be
*   transfered on return to ELP1_CMODE.
      X(10)=REAL(INT(X(1)-X1+1.))
      Y(10)=REAL(INT(Y(1)-Y1+1.))

 980  CONTINUE

*   Closedown the AGI/SGS/PGPLOT interface.
      CALL ELP1_AGIC2(GRADEV,1,0,NAME,NDF1,DEVCAN,PICID,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999

*    Exit point for errors that occurred before the graphics device
*    was opened.
                 
 9999 CONTINUE

      END


      SUBROUTINE ELP1_CURVD(X1,Y1,XW,YW,STATUS)
*+
*  Name:
*     ELP1_CURVD

*  Purpose:
*     Displays information telling the user what the latest value 
*     is for the cursor position. 

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_CURVD(X1,Y1,XW,YW,STATUS)

*  Description:
*     The routine displays the latest value for the cursor position. 
*     When an image is being displayed output is in the form of world 
*     and data co-ordinates.

*  Arguments:
*     X1 = REAL (Given)
*        X world co-ordinate of the left-hand edge of the image.
*     Y1 = REAL (Given)
*        Y world co-ordinate of the bottom edge of the image.
*     XW = REAL (Given)
*        X world co-ordinate.
*     YW = REAL (Given)
*        Y world co-ordinate.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     15-Mar-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
                     
*  Arguments Given:
      REAL XW                         ! X world co-ordinate
      REAL X1                         ! X world co-ordinate of the image
                                      ! edge
      REAL YW                         ! Y world co-ordinate
      REAL Y1                         ! Y world co-ordinate of the image
                                      ! bottom

*  Arguments Returned:

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local Variables:                                               
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Put the data co-ordinates into message token.
      CALL MSG_SETR('XVALD',XW-X1)
      CALL MSG_SETR('YVALD',YW-Y1)

*   Put the world co-ordinates into message tokens.
      CALL MSG_SETR('XVALW',XW)
      CALL MSG_SETR('YVALW',YW)

*   Display the current X and Y values.
      CALL MSG_OUT(' ','Cursor position (x/y)'/  
     :             /' ^XVALW, ^YVALW (world), '/
     :             /'^XVALD, ^YVALD (data)',STATUS)
 
*   The following call achieves graphics/text synchronisation.
      CALL MSG_SYNC(STATUS)

      END



      SUBROUTINE ELP1_INTER(ELEMS,ARRAY,NUMPOI,X,Y,PRANGE,USED,
     :                       VA,STATUS)                 
*+
*  Name:
*     ELP1_INTER1

*  Purpose:
*     Uses an 8x8 grid based set of image points to obtain the interpolated
*     value at a given image location using PDA spline routines.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_INTER(ELEMS,ARRAY,NUMPOI,X,Y,PRANGE,USED,
*                      VA,STATUS)                 

*  Description:
*     The values of image pixels forming a 8x8 grid surrounding a given
*     image location are passed to a PDA routine which uses it to
*     generate a 3-D surface via a bi-cubic spline method.
*
*     This surface is then used to determine the values of image pixel
*     count at the points around the 'fit' ellipse.
*
*     The first method fails if any of the 8x8 image pixels are not 
*     available due to being BAD or off the edge of the image. This is 
*     A call is then made to another (slower) routine that does not 
*     require an entire grid to be available.

*  Arguments:
*     ELEMS = INTEGER (Given)
*        The number of pixels in the image.
*     ARRAY(ELEMS) = REAL (Given)
*        The image array.
*     NUMPOI = INTEGER (Given)
*        The number of ellipse points defined.
*     X(ELP__MXPOI) = REAL (Given)
*        X co-ordinates of the 'fit' ellipse points.
*     Y(ELP__MXPOI) = REAL (Given)
*        Y co-ordinates of the 'fit' ellipse points.
*     PRANGE(2) = INTEGER (Given)
*        Dimensions of the image. Units pixels.
*     USED(ELP__MXPOI) = INTEGER (Returned)
*        Was a value pixel count value found for a given ellipse
*        'fit' point.
*     VA(ELP__MXPOI) = REAL (Returned)
*        The value found at a given image location. The position
*        is defined in XR and YR arrays. Units counts. 
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     12-Feb-1996 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'PRM_PAR'               ! PRIMDAT primitive data constants
      INCLUDE 'elp_par'               ! ELLPRO constants

*  Status:
      INTEGER STATUS                  ! Global status

*  Arguments Given:
      INTEGER ELEMS                   ! Number of pixels in the image
      INTEGER NUMPOI                  ! Number of ellipse points
      INTEGER PRANGE(2)               ! Dimensions of the image
      REAL ARRAY(ELEMS)               ! Image array
      REAL X(ELP__MXPOI)              ! X co-ord for the translated ellipse
      REAL Y(ELP__MXPOI)              ! Y co-ord for the translated ellipse

*  Arguments Given and Returned:
      INTEGER USED(ELP__MXPOI)        ! Was the interpolation for a given
                                      ! ellipse point successful
      REAL VA(ELP__MXPOI)             ! Value of the pixel count at each
                                      ! of the ellipse locations

*  Local variables:
      INTEGER FAIL                    ! Interpolation failed for method
      INTEGER HIGHX                   ! Grid limits
      INTEGER HIGHY                   ! Grid limits
      INTEGER I                       ! Loop variable
      INTEGER J                       ! Counter
      INTEGER K                       ! Loop variable
      INTEGER L                       ! Counter
      INTEGER LOWX                    ! Grid limits defining edge of grid/mesh
      INTEGER LOWY                    ! Grid limits defining edge of grid/mesh
      INTEGER ORD                     ! Order of polynomial
      REAL VALUE                      ! Pixel count value
      DOUBLE PRECISION FV1(8,8)       ! Grid Z values
      REAL             FV2(64)        ! Gird Z values
      DOUBLE PRECISION XD             ! X coord
      REAL             XR             ! X coord
      DOUBLE PRECISION X1(8)          ! X gird location
      DOUBLE PRECISION YD             ! Y coord
      REAL             YR             ! X coord
      DOUBLE PRECISION Y1(8)          ! Y grid location

      REAL             XV(64)         ! Pixel co-ordinates
      REAL             YV(64)         ! Pixel co-ordinates

      INTEGER ADDR                    ! Pixel address in array
      INTEGER IFAIL                   ! Was the 3-D surface successfully
                                      ! created?
      INTEGER MXY                     ! Size of the grid
      INTEGER ID                      ! Specifies use value not differential

      DOUBLE PRECISION BCOEF(8,8)     ! Array used by GJP_DB2INK
      DOUBLE PRECISION DVALUE         ! Interpolated value returned 
      DOUBLE PRECISION TX(11),TY(11)  ! Array used by GJP_DB2INK
      DOUBLE PRECISION WORK(168)      ! Array used by GJP_DB2INK
 
      INTEGER  IWK(2500)              ! Work space
      INTEGER  NCP,NOP                ! Mode control/number of points
      INTEGER  NXI,NYI                ! Grid size
      INTEGER  MD                     ! Mode
     
      REAL     WK(640)                ! Workspace 
      REAL     XI(1),YI(1)            ! Required coords
      REAL     ZI(1,1)                ! Interpolated value

*.
*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Order of the polynomial used.
      ORD=3

*   Use value rather than differential.
      ID=0

*   Setup parameters for a 8x8 grid of data points.
*   MX must be even numbers.
      MXY=8    

*   Look at each of the ellipse 'fit' locations in turn.
      DO 5 K=1,NUMPOI

*      Assign the latest X and Y co-ordinates.
         XR=X(K)
         YR=Y(K)
         XD=DBLE(XR)
         YD=DBLE(YR)

*      Calculate the grid limits.
         LOWX=INT(XR) -MXY/2
         HIGHX=INT(XR)+MXY/2-1
         LOWY=INT(YR) -MXY/2
         HIGHY=INT(YR)+MXY/2-1

*      Ignore the current value if the x or y values required are off
*      the image. Also set the flag.
         IF ((LOWX.LT.1).OR.(HIGHX.GT.PRANGE(1)).OR.
     :       (LOWY.LT.1).OR.(HIGHY.GT.PRANGE(2))) THEN

            IFAIL=1

         ELSE

*         Set up the array containing the x co-ordinates of the pixel 
*         grid to be used. Points surround the required location.
            J=0
            DO 10 I=LOWX,HIGHX
               J=J+1
               X1(J)=DBLE(I)
 10         CONTINUE

*         Set up the array containing the y co-ordinates of the pixel 
*         grid to be used. Points surround the required location.
            J=0
            DO 20 I=LOWY,HIGHY
               J=J+1
               Y1(J)=DBLE(I)
 20         CONTINUE

*         Set up the array containing the observed pixel counts for the
*         grid points.
            L=0
            DO 30 I=1,MXY
               DO 40 J=1,MXY

*               Calculate the array element in which the image pixel is.
                  ADDR=INT(Y1(J)-1)*PRANGE(1)+INT(X1(I))
                  VALUE=ARRAY(ADDR)
                
*               Check to ensure that no bad points are present.
                  IF (VALUE.NE.VAL__BADR) THEN

*                  Increment the counter.
                     L=L+1

*                  Save the surface data.                     
                     XV(L)=REAL(X1(I))
                     YV(L)=REAL(Y1(J))
                     FV1(I,J)=DBLE(VALUE)
                     FV2(L)=VALUE

                  END IF
                  
 40            CONTINUE

 30         CONTINUE

         END IF

*      Only interpolate if a grid can be constructed.
         IF (L.GT.31.) THEN
            
            FAIL=0
            IF (L.EQ.64) THEN

*            Build surface using complete grid.
               IFAIL=0
               CALL GJP_DB2INK(X1,MXY,Y1,MXY,FV1,MXY,
     :                         ORD,ORD,TX,TY,BCOEF,
     :                         WORK,IFAIL,STATUS)
              
*            See if the routine exited okay
               IF (IFAIL.EQ.1) THEN   

*               Interpolate.
                  IFAIL=0
                  CALL GJP_DB2VAL(XD,YD,ID,ID,TX,TY,
     :                            MXY,MXY,ORD,ORD,BCOEF,WORK,
     :                            DVALUE,IFAIL,STATUS)
                  
                  IF (IFAIL.NE.0) THEN
          
*                  Set the fail flag.
                     FAIL=1

                  ELSE

*                  Keep the result.
                     VA(K)=REAL(DVALUE)
                     USED(K)=1                  
                     
                  END IF

               ELSE
 
*               Reset status.
                  STATUS=SAI__OK
                  FAIL=1

               END IF

            END IF

            IF ((FAIL.GT.0).OR.(L.NE.64)) THEN


*            Set the error flag default value.
               IFAIL=0

*            Set mode and the grid positions (for GJP_IDBVIP).
               MD= 1
               NCP=2
               NOP=1
               NXI=1
               NYI=1             
               
*            Set up locations to interpolate.
               XI(1)=XR
               YI(1)=YR
 
*            Call interpolation subroutine.      
               CALL GJP_IDBVIP(MD,NCP,L,XV,YV,FV2,NOP,XI,YI, 
     :                         ZI,IWK,WK,IFAIL,STATUS)        
               
*            Keep the result.
               IF (IFAIL.EQ.0) THEN

                  VA(K)=ZI(1,1)
                  USED(K)=1                  
                
               ELSE

*               Reset status.
                  STATUS=SAI__OK
 
               END IF

            END IF
       
         END IF

 5    CONTINUE

 9999 CONTINUE

      END


      SUBROUTINE ELP1_INTER0(ELEMS,ARRAY,NUMPOI,XR,YR,PRANGE,USED,
     :                       VA,STATUS)
*+
*  Name:
*     ELP1_INTER0

*  Purpose:
*     Interpolates the value of a point from the image using bi-linear
*     interpolation. This is performed for all the points in the current
*     ellipse being considered.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_INTER0(ELEMS,ARRAY,NUMPOI,XR,YR,PRANGE,USED,
*                      VA,STATUS)

*  Description:
*     For each of the image locations required the values for each of the
*     four image points surrrounding it are determined. These are then used
*     to derive the value at the required location.
*
*     A value is not generated for a given point if any of the four points
*     is BAD or off the edge of the image.

*  Arguments:
*     ELEMS = INTEGER (Given)
*        The number of pixels in the image.
*     ARRAY(ELEMS) = REAL (Given)
*        The image array.
*     NUMPOI = INTEGER (Given)
*        The number of ellipse points defined.
*     XR(ELP__MXPOI) = REAL (Given)
*        X co-ordinates of the 'fit' ellipse points.
*     YR(ELP__MXPOI) = REAL (Given)
*        Y co-ordinates of the 'fit' ellipse points.
*     PRANGE(2) = INTEGER (Given)
*        Dimensions of the image.
*     USED(ELP__MXPOI) = INTEGER (Returned)
*        Was a value pixel count value found for a given ellipse
*        'fit' point.
*     VA(ELP__MXPOI) = REAL (Returned)
*        The value found at the current ellipse fit locations. The position
*        is defined in XR and YR arrays.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     26-Mar-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'PRM_PAR'               ! PRIMDAT primitive data constants
      INCLUDE 'elp_par'               ! ELLPRO constants

*  Status:
      INTEGER STATUS                  ! Global status

*  Arguments Given:
      INTEGER ELEMS                   ! Number of pixels in the image
      INTEGER NUMPOI                  ! Number of ellipse points defined
      INTEGER PRANGE(2)               ! Size of X and Y axes of the image
      REAL ARRAY(ELEMS)               ! Image array
      REAL XR(ELP__MXPOI)             ! X co-ord for the translated ellipse
      REAL YR(ELP__MXPOI)             ! Y co-ord for the translated ellipse

*  Arguments Returned:
      INTEGER USED(ELP__MXPOI)        ! Maximum number of ellipse points
      REAL VA(ELP__MXPOI)             ! Array containing the pixel count
                                      ! values found for ellipse points

*  Arguments Given and Returned:

*  Local variables:
      INTEGER I                       ! Loop counter
      INTEGER XL                      ! The X and Y co-ordinates of the
      INTEGER XH                      ! box within which the current X
      INTEGER YL                      ! Y location of the current
      INTEGER YH                      ! ellipse point may be found
      REAL FX                         ! Fractional X value
      REAL FY                         ! Fractional Y value
      REAL VALUE                      ! Value at the required location
      REAL VALUE1                     ! Value at one of the points
                                      ! defining the box.
      REAL VALUE2                     ! See above.
      REAL VALUE3                     ! See above.
      REAL VALUE4                     ! See above.

*.
*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Look at each of the ellipse 'fit' locations in turn.
      DO 5 I=1,NUMPOI

*      Assign the X and Y co-ordinates of a box surrounding the
*      required loaction.
         XL=INT(XR(I))
         XH=XL+1
         YL=INT(YR(I))
         YH=YL+1

*      Ignore the current value if the x or y values required are off
*      the image. Also set the flag.
         IF ((XL.GE.1).AND.(XH.LE.PRANGE(1)).AND.
     :       (YL.GE.1).AND.(YH.LE.PRANGE(2))) THEN

*         Calculate the array elements in which the
*         image pixels are and obtain the values.

*         Bottom left corner of box.
            VALUE1=ARRAY((YL-1)*PRANGE(1)+XL)

*         Top left corner of box.
            VALUE2=ARRAY((YH-1)*PRANGE(1)+XL)

*         Bottom right corner of box.
            VALUE3=ARRAY((YL-1)*PRANGE(1)+XH)

*         Top right corner of box.
            VALUE4=ARRAY((YH-1)*PRANGE(1)+XH)

*         Check to ensure that no bad points were present.
            IF ((VALUE1.NE.VAL__BADR).AND.(VALUE2.NE.VAL__BADR)
     :         .AND.(VALUE3.NE.VAL__BADR).AND.
     :                  (VALUE4.NE.VAL__BADR)) THEN

*            Calculate the fractional x and y values.
               FX=XR(I)-XL
               FY=YR(I)-YL

*            Assign the value.
               VALUE=(1.-FX)*(1.-FY)*VALUE1+(1.-FX)*FY*VALUE2
               VA(I)=VALUE+FX*(1.-FY)*VALUE3+FX*FY*VALUE4
               USED(I)=1

            END IF

         END IF

 5    CONTINUE

 9999 CONTINUE

      END



      SUBROUTINE ELP1_FILER(FIOID,BACK,LBND,UBND,PRANGE,COSYS,
     :                      NGALS,XC,YC,BACKS,STATUS)
*+
*  Name:
*     ELP1_FILER

*  Purpose:
*     Opens a user specified text file and reads from it a list of co-ordinates
*     indicating the locations where galaxies may exist in the image. Each of
*     these is to be profiled.
*
*     The co-ordinates obtained are returned in the arrays XC and YC. the
*     number of co-ordinate pairs defined is assigned to NGALS. If the 
*     co-ordinates are legal (i.e. within the image) then another value is read
*     from the line (if available) and this is used as the local background 
*     count value when the profile is calculated. 
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*      CALL ELP1_FILER(FIOID,BACK,LBND,UBND,PRANGE,COSYS,NGALS,
*                      XC,YC,BACKS,STATUS)    

*  Description:
*     Looks at each line of the required file in turn.
*     Ignores blank lines and those starting with # or ! since these
*     are assumed to be comments. Others it examines for the presence
*     of two numbers. If these are found it looks for a further number.
*
*     The first two are taken as representing x and y co-ordinates on 
*     an image and are checked to ensure that they lie within the bounds 
*     of the image.
*
*     If it is found that the a co-ordinate pair is not within the 
*     bounds of the image, the values are not retained, otherwise the
*     counter is incremented and the values stored in arrays XC and YC.
*     The line is then examined to determine if a further value is present.
*     If a value is found it is to used as the background count value.

*  Arguments:               
*     FIOID = INTEGER (Given)
*        FIO identifier for the input file.
*     BACK = REAL (Given)
*        The image global background value. Units counts.
*     LBND(2) = INTEGER (Given)
*        Lower bound of the image.
*     UBND(2) = INTEGER (Given)
*        Upper bound of the image.
*     PRANGE(2) = INTEGER (Given)
*        Size of each image axis.
*     COSYS *(256) = CHARACTER (Given)
*        Character defining whether the co-ordinates provided 
*        are world or data format. 
*     NGALS = INTEGER (Returned)
*        Number of galaxies to be profiled.
*     XC(ELP__NGALS) = REAL (Returned)
*        X co-ordinates (for galaxies) obtained from the text file.
*     YC(ELP__NGALS) = REAL (Returned)
*        Y co-ordinates (for galaxies) obtained from the text file.
*     BACKS(ELP__NGALS) = REAL (Returned)
*        The local background value at each of the co-ordinates.
*        Units counts.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     9-JUL-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'FIO_ERR'               ! FIO error definitions
      INCLUDE 'elp_par'               ! ELLPRO constants
      INCLUDE 'NDF_PAR'              ! NDF public constants

*  Arguments Given:                              
      CHARACTER *(256) COSYS          ! Option choice defining how the
                                      ! pixel data format to be input
      INTEGER FIOID                   ! FIO identifier for the input file
      INTEGER LBND(NDF__MXDIM)        ! Lower bounds of image axes 
      INTEGER PRANGE(2)               ! Size of each image axis
      INTEGER UBND(NDF__MXDIM)        ! Upper bounds of image axes
      REAL BACK                       ! Global background count value

*  Arguments returned:
      INTEGER NGALS                   ! The number of galaxies to be profiled
      REAL BACKS(ELP__NGALS)          ! The local background values
      REAL XC(ELP__NGALS)             ! X co-ordinates of the galaxy positions
                                      ! found from the file
      REAL YC(ELP__NGALS)             ! Y co-ordinates of the galaxy positions
                                      ! found from the file

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      LOGICAL ABORT                   ! Has the maximum permitted number of
                                      ! galaxies been exceeded?
      LOGICAL FAIL
      CHARACTER *(80) BUFFER          ! Character string input from the file
      CHARACTER *(80) STRING          ! Input string
      INTEGER FAILN                   ! Number of failures found
      INTEGER I                       ! A loop counter
      INTEGER J                       ! A loop counter
      INTEGER INDEX(2,3)              ! Indices of the words within the 
                                      ! input string
      INTEGER INDEXE                  ! End of a word in the buffer string
      INTEGER INDEXS                  ! Start of a word in the buffer string
      INTEGER NCHAR                   ! Number of characters
      REAL VALUE(3)                   ! Temporary storage of co-ordinates and
                                      ! background value.
*.
      
*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Initialise the galaxy counter
      NGALS=0

*   Start an error context.   
      CALL ERR_MARK
      
*   Read from a file. Stop if the end of file is reached or if the maximum
*   permitted number of galaxies is exceeded.
      ABORT=.FALSE.

      DO WHILE ((STATUS.NE.FIO__EOF).AND.(.NOT.ABORT))
                      
*       Read a line from the steering file.
         CALL FIO_READ(FIOID,BUFFER,NCHAR,STATUS)
         IF (STATUS.EQ.SAI__OK) THEN

*       Parse the buffer read from the file.

*         Check for comment (lines starting # or !) or blank line.
            STRING=BUFFER(1:1)
            IF ((BUFFER.NE.' ').AND.(STRING.NE.'#').AND.
     :         (STRING.NE.'!')) THEN
                  
*             Find the x and y co-ordinates by looking for words in the BUFFER.
               FAIL=.FALSE.
               FAILN=0
               INDEXE=-1
               DO 10 I=1,3
                  
*               Identify the start and end indices of the words in the buffer.
*               If either fails there are not enough words in the buffer.

*               Start a new error context.
                  CALL ERR_MARK

*               Look for the words.
                  INDEXS = INDEXE + 1
                  CALL CHR_FIWS(BUFFER,INDEXS,STATUS)
                  INDEXE = INDEXS
                  CALL CHR_FIWE(BUFFER,INDEXE,STATUS)

*               Store the locations of the words in the string.
                  INDEX(1,I)=INDEXS
                  INDEX(2,I)=INDEXE

*               Set the fail flag if the word extraction failed.
*               Increment times failed counter.
                 IF (STATUS.NE.SAI__OK) THEN
                     FAIL=.TRUE.
                     FAILN=FAILN+1
                     CALL ERR_ANNUL(STATUS)
                 END IF

*               End error context.
                  CALL ERR_RLSE
        
 10            CONTINUE

*            Stop looking at this line of text since two words are not
*            present.
               IF (FAILN.GT.1) THEN 

*               Indicate that the line of text did not contain two numbers.
                  CALL MSG_OUT(' ','Bad text line.',STATUS)
                  GOTO 666

               END IF

*            Look at those words found.
               FAIL=.FALSE.
               DO 20 J=1,3-FAILN  
                
*               Start an new error context.
                  CALL ERR_MARK                        

*               Examine word.
                  STRING=BUFFER(INDEX(1,J):INDEX(2,J))
                  CALL CHR_CTOR(STRING,VALUE(J),STATUS)

*               Display the cause of any problem.
                  IF (STATUS.NE.SAI__OK) THEN
                     FAIL=.TRUE.
                     CALL ERR_ANNUL(STATUS)
                     IF (J.EQ.1) CALL MSG_OUT(' ',
     :                  'X co-ordinate not a number.',STATUS)
                     IF (J.EQ.2) CALL MSG_OUT(' ',
     :                  'Y co-ordinate not a number.',STATUS)
                     IF (J.EQ.3) CALL MSG_OUT(' ',
     :                  'Background not a number.',STATUS)      
                  END IF

*               End error context.
                  CALL ERR_RLSE

 20            CONTINUE

*            Stop looking at this line since less than two valid
*            numbers were found.
               IF ((FAIL).AND.(FAILN.GT.0)) THEN 

*               Indicate that the line of text did not contain two numbers.
                  CALL MSG_OUT(' ','Bad text line.',STATUS)
                  GOTO 666

               END IF
               
*            Check that the two co-ordinates are within the image.
               FAIL=.FALSE.
               DO 30 J=1,2

*               Check the value is within allowed range.
                  IF (COSYS.EQ.'W') THEN

*                  World co-ordinates.

*                  Check that the co-ordinate value input is legal.
                    IF ((VALUE(J).GE.LBND(J)).AND.
     :                 (VALUE(J).LE.UBND(J))) THEN
     
*                    Value within range so assign.
                       VALUE(J)=VALUE(J)-LBND(J)+1

                    ELSE
                                 
*                    Set the fail flag since the point selected 
*                    is not on the image.
                       CALL MSG_OUT(' ',
     :                   'Co-ordinate not on the image.',
     :                   STATUS)
                       FAIL=.TRUE.
                    
                    END IF
                         
                 ELSE

*                 DATA pixel co-ordinates.

*                  Check that the co-ordinate value input is legal.
                    IF ((VALUE(J).LT.1.0).OR.
     :                 (VALUE(J).GT.PRANGE(J))) THEN

*                    Set the fail flag since the point selected 
*                    is not on the image.
                       CALL MSG_OUT(' ',
     :                    'Co-ordinate not on the image.',
     :                    STATUS)
                       FAIL=.TRUE.
                                 
                    END IF

                  END IF
 
 30            CONTINUE

*            Stop looking at this line since one of the co-ordinates
*            was not on the image.
               IF (FAIL) THEN 

*               Indicate that the line of text did not contain two numbers.
                  CALL MSG_OUT(' ','Bad text line.',STATUS)
                  GOTO 666

               END IF

*            Assign the values to the arrays and increment the
*            counter.
               NGALS=NGALS+1
               XC(NGALS)=VALUE(1)
               YC(NGALS)=VALUE(2)
               IF (FAILN.EQ.0) THEN          
                  BACKS(NGALS)=VALUE(3)  
               ELSE
                  CALL MSG_FMTR('XV','F6.1',XC(NGALS))
                  CALL MSG_FMTR('YV','F6.1',YC(NGALS))
                  CALL MSG_OUT(' ','Default background used for'//
     :                         ' object at ^XV, ^YV ',STATUS) 
                  BACKS(NGALS)=BACK
               END IF

*            Stop any further points being taken from the file 
               IF (NGALS.EQ.ELP__NGALS) THEN
                  ABORT=.TRUE.  
                  FAIL=.TRUE.
               END IF

            END IF
                  
 666     END IF
      
      END DO
 217  continue
     
*   Display the error message if necessary. Also, tidy up the error system.
      IF ((STATUS.NE.SAI__OK).AND.(STATUS.NE.FIO__EOF)) THEN
         CALL ERR_REP( ' ','Errors found when reading the data file.',
     :                STATUS)
         CALL ERR_FLUSH( STATUS )
      ELSE
         CALL ERR_ANNUL( STATUS )
      END IF
          
*   End the error context.
      CALL ERR_RLSE

*   Indicate that the file was flawed.
      IF (FAIL) THEN
         CALL MSG_BLANK(STATUS)
         CALL MSG_OUT(' ','Problems found reading the file.',
     :                STATUS)
         CALL MSG_BLANK(STATUS)
      END IF

*   Indicate if the maximum permitted number of galaxies was exceeded.
      IF (ABORT) THEN
         CALL MSG_BLANK(STATUS)
         CALL MSG_OUT(' ','Too many co-ordinate pairs were found.',
     :                STATUS)
         CALL MSG_OUT(' ','Proceeding with the maximum number'/
     :                /' allowed.',STATUS)
         CALL MSG_BLANK(STATUS)
      END IF

 9999 CONTINUE

      END 


      SUBROUTINE ELP1_FMODE(STATUS)
*+
*  Name:
*     ELP1_FMODE

*  Purpose:
*     The routine obtains the user inputs required to perform 
*     galaxy profiling for a given image. The co-ordinates of the 
*     points on the image denoting the suggested galaxy centres are
*     defined via an ASCII text file.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_FMODE(STATUS)

*  Arguments:   
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description: 
*     Information such as pixel size, background count value and its
*     standard deviation etc are input.
*
*     Profiling is continued until the mean profile value is less than
*     a user defined number of standard deviations above sky (LIM2) or 
*     until the mean profile value increases by a user defined amount
*     compared to the previous profile (LIM1). The difference between the 
*     sizes of profile semi-major axis values is controlled using the 
*     FINE parameter.
*
*     When profiling an ellipse with a small radius one of two methods may
*     be employed to determine the values of points located around each
*     trial ellipse. These are are bi-linear interpolation or a surface
*     interpolation based on a 8x8 grid of surrounding pixels. The latter
*     method is slower but may yield better results at small radii. It 
*     is selected by setting the parameter FAST to false.     
*
*     Contaminating parts of the image may be defined using an ARD file.
*
*     The initial estimate of the galaxy position may be improved by 
*     modifying the AUTOL option which calculate the centroid.
*     of the image area immediately surrounding the input value.

*  Implementation Status:
*     Under development

*  Authors:
*     GJP: Grant Privett (STARLINK)
*     {enter_new_authors_here}

*  History:
*     17-May-1992 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'NDF_PAR'               ! NDF_ public constant
      INCLUDE 'PRM_PAR'               ! PRIMDAT primitive data constants
      INCLUDE 'elp_par'               ! ELLPRO constants
      INCLUDE 'MSG_PAR'               ! MSG constants
      INCLUDE 'SUBPAR_PAR'            ! SUBPAR constants
         
*  Status:     
      INTEGER STATUS                  ! Global status

*  Local Variables:      
      CHARACTER *(256) COSYS          ! Option choice defining how the
                                      ! pixel data format to be input
      CHARACTER *(MSG__SZMSG) FILE    ! NDF file name
      LOGICAL ANGCON                  ! Position angle convention
      LOGICAL AUTOL                   ! Is an estimate of the galaxy centre
                                      ! position to be made?
      LOGICAL EXCLAIM                 ! Was an exclaimation mark given for
                                      ! an output file name?
      LOGICAL FAST                    ! Use fast method of profiling?
      LOGICAL FILINP                  ! Was a file name input?
      LOGICAL FRZORI                  ! Is the galaxy origin frozen?
      LOGICAL INOKAY                  ! Was the most recent input value okay
                                      ! scale length regression
      INTEGER ELEMS                   ! Total number of pixels in the NDF
      INTEGER FIOD                    ! Output FIO file descriptor
      INTEGER FIOID                   ! Input FIO file descriptor
      INTEGER I                       ! Loop variable
      INTEGER LBND(NDF__MXDIM)        ! Lower limit for image index
      INTEGER MINMOD                  ! Which residual to use in minimisation
      INTEGER NDF1                    ! Identifier for the source NDF  
      INTEGER NDIM                    ! Number of dimensions in the 
                                      ! image
      INTEGER NGALS                   ! Number of galaxy centres co-ordinate
                                      ! pairs found in the text file
      INTEGER POINT0(1)               ! Pointer to the data component of
                                      ! the source NDF
      INTEGER POINT1(1)               ! Pointer to the data component after
                                      ! its been mapped to dynamic memory
      INTEGER POINT3(1)               ! Pointer to ARD mask
      INTEGER PRANGE(2)               ! Length of the x and y axes
      INTEGER STLEN                   ! NDF file name length
      INTEGER UBND(NDF__MXDIM)        ! Upper limit for image index
      INTEGER VALIDP                  ! Number of radii for which
                                      ! a fit was obtained
      REAL ANGOFF                     ! Position angle offset
      REAL BACK                       ! Global background count value
      REAL BACKS(ELP__NGALS)          ! Local background values
      REAL FINE                       ! Determines how closely spaced the
                                      ! chosen radii values are
      REAL FRACT                      ! Limit to fraction of bad points in 
                                      ! an ellipse
      REAL LIM1                       ! Maximum permitted count increase factor
      REAL LIM2                       ! Lower limit on ellipse count
      REAL LIM3                       ! Radius at which the galaxy position
                                      ! angle, centre and ellipticity are
                                      ! frozen
      REAL PSIZE                      ! Size of the image pixels in arc sec
      REAL RESULT(ELP__NRES,ELP__RESUL)      ! Ellipse parameters
      REAL RLIM                       ! Maximum ellipse radius
      REAL SIGMA                      ! Std. dev. of the background value
      REAL XC(ELP__NGALS)             ! X co-ordinates of the galaxy positions
                                      ! found from the file
      REAL XCO                        ! X index of the galaxy origin
      REAL YC(ELP__NGALS)             ! Y co-ordinates of the galaxy positions
                                      ! found from the file
      REAL YCO                        ! Y index of the galaxy origin
      REAL ZEROP                      ! Zero point of the surface 
                                      ! brightness graphs
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Determine the input text file name.
      CALL FIO_ASSOC('INFILE','READ','LIST',80,FIOID,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999  
      IF (STATUS.EQ.SAI__OK) FILINP=.TRUE.
     
*   Begin an NDF context.                               
      CALL NDF_BEGIN
      IF (STATUS.NE.SAI__OK) GOTO 9999
      
*   Obtain an identifier for the NDF structure to be examined.       
      CALL NDF_ASSOC('IN','READ',NDF1,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999

*   Get the image bounds and also the size of the axes in pixels.
      CALL NDF_BOUND(NDF1,2,LBND,UBND,NDIM,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999 
      PRANGE(1)=UBND(1)-LBND(1)+1
      PRANGE(2)=UBND(2)-LBND(2)+1
                                       
*   Look at the command line value for ANGCON.
*   Otherwise, use the default.
      CALL PAR_STATE('ANGCON',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0L('ANGCON',ANGCON,STATUS)
         CALL MSG_OUT(' ','Command line ANGCON value used.',STATUS)
      ELSE
         ANGCON=.TRUE.
      END IF

*   Look at the command line value for ANGOFF.
*   Otherwise, use the default.
      CALL PAR_STATE('ANGOFF',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0R('ANGOFF',ANGOFF,STATUS)
         CALL MSG_OUT(' ','Command line ANGOFF value used.',STATUS)
      ELSE
         ANGOFF=0.0
      END IF

*   Get the co-ordinate system mode and convert to upper case.
      CALL PAR_GET0C('COSYS',COSYS,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999
      CALL CHR_UCASE(COSYS)

*   Determine whether or not the origin given is to be used throughout
*   the profiling.
      CALL PAR_GET0L('FRZORI',FRZORI,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999
      
*   Get the global background count value.
      CALL PAR_GET0R('BACK',BACK,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999
      
*   Get the background count std. dev. value.
      INOKAY=.FALSE.
      DO WHILE ((.NOT.INOKAY).AND.(STATUS.EQ.SAI__OK))
         CALL PAR_GET0R('SIGMA',SIGMA,STATUS)
         IF (SIGMA.LE.0.0) THEN
*         Display message and annul the parameter.
            CALL MSG_OUT(' ','Sigma supplied, is not '//
     :                   'feasible.',STATUS)
            CALL PAR_CANCL('SIGMA',STATUS)
         ELSE
            INOKAY=.TRUE.
         END IF
      END DO
      IF (STATUS.NE.SAI__OK) GOTO 9999 

*   Get the maximum profile radius.
      CALL PAR_GET0R('RLIM',RLIM,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF (RLIM.LE.PSIZE) RLIM=ELP__RLIM

*   Should the default radii settings be used.
*   Look on the command line for an input.
*   Otherwise, use the value specified in elp_par.
      CALL PAR_STATE('FINE',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0R('FINE',FINE,STATUS)
         CALL MSG_OUT(' ','Command line FINE value used.',STATUS)
      ELSE
         FINE=ELP__FINE
      END IF

*   Get the pixel size value.
      INOKAY=.FALSE.
      DO WHILE ((.NOT.INOKAY).AND.(STATUS.EQ.SAI__OK))
         CALL PAR_GET0R('PSIZE',PSIZE,STATUS)
         IF (PSIZE.LE.0.0) THEN
*         Display message and annul the parameter.
            CALL MSG_OUT(' ','The pixel size supplied, is not '//
     :                   'feasible.',STATUS)
            CALL PAR_CANCL('PSIZE',STATUS)
         ELSE
            INOKAY=.TRUE.
         END IF
      END DO
      IF (STATUS.NE.SAI__OK) GOTO 9999 
      
*   Get the zero point for the surface brightness scale/graphs.
      CALL PAR_GET0R('ZEROP',ZEROP,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999

*      Is the galaxy centre to be determined by a centroid around 
*      the coords provided? 
         CALL PAR_GET0L('AUTOL',AUTOL,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*   Calculate the profiles without using the bi-cubic spline at
*   low radii? Look on the command line for an input.
*   Otherwise, use the value specified in elp_par.
      CALL PAR_STATE('FAST',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0L('FAST',FAST,STATUS)
         CALL MSG_OUT(' ','Command line FAST value used.',STATUS)
      ELSE
         FAST=ELP__FAST
      END IF
     
*   Check the state of the parameter LIM1, to see if there is a
*   suggested value on the command line.
*   Otherwise, use the value specified in elp_par.
      CALL PAR_STATE('LIM1',I, STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0R('LIM1',LIM1,STATUS)
         CALL MSG_OUT(' ','Command line LIM1 value used.',STATUS)
      ELSE
         LIM1=ELP__LIM1
      END IF

*   Check the state of the parameter LIM2, to see if there is a
*   suggested value on the command line.
*   Otherwise, use the value specified in elp_par.
      CALL PAR_STATE('LIM2',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0R('LIM2',LIM2,STATUS)
         CALL MSG_OUT(' ','Command line LIM2 value used.',STATUS)
      ELSE
         LIM2=ELP__LIM2
      END IF

*   Check the state of the parameter LIM3, to see if there is a
*   suggested value on the command line.
*   Otherwise, use the value specified in elp_par.
      CALL PAR_STATE('LIM3',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0R('LIM3',LIM3,STATUS)
         CALL MSG_OUT(' ','Command line LIM3 value used.',STATUS)
      ELSE
         LIM3=ELP__LIM3
      END IF

*   Check the state of the parameter FRACT, to see if there is a
*   suggested value on the command line.
*   Otherwise, use the value specified in elp_par.
      CALL PAR_STATE('FRACT',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0R('FRACT',FRACT,STATUS)
         CALL MSG_OUT(' ','Command line FRACT value used.',STATUS)
      ELSE
         FRACT=ELP__FRACT
      END IF
      
*   Get the minimisation mode (which residual to use)
      CALL PAR_GET0I('MINMOD',MINMOD,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999
      
*   Obtain the co-ordinates of the galaxies required.
      CALL ELP1_FILER(FIOID,BACK,LBND,UBND,PRANGE,COSYS,
     :                NGALS,XC,YC,BACKS,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999
    
*   Abort if the number of galaxies is zero.
      IF (NGALS.EQ.0) THEN
         CALL MSG_BLANK(STATUS)
         CALL MSG_OUT(' ','No viable data points were found!!!',STATUS)
         CALL MSG_BLANK(STATUS)
         GOTO 9999
      END IF
      
*   Map the NDF data array as _REAL values for reading.
      CALL NDF_MAP(NDF1,'DATA','_REAL','READ',POINT0(1),
     :             ELEMS,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999
          
*   Get the name of the file being mapped.
      CALL NDF_MSG('FILE',NDF1)
      CALL MSG_LOAD(' ','^FILE',FILE,STLEN,STATUS)
      
*   Allocate dynamic memory on which to map the NDF.
      CALL PSX_CALLOC(ELEMS,'_REAL',POINT1(1),STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9998
     
*   Transfer values from the mapped NDF to the allocated memory.
      CALL ELP1_TRANS(ELEMS,%VAL(POINT0(1)),%VAL(POINT1(1)),STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9998
      
*   Un-map the source NDF. Helps to reduce the resources being used.
      CALL NDF_UNMAP(NDF1,'DATA',STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9998
                       
*   Allocate the memory needed for the logical mask array.
      CALL PSX_CALLOC(ELEMS,'_INTEGER',POINT3(1),STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9998
      
*   Transfer to the ARD driver control routine.
      NDIM=2
      CALL ESP_ARD_DRIVER(NDIM,ELEMS,LBND,UBND,POINT1,POINT3,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9998
      
*   Free the dynamic array space of the logical mask.
      CALL PSX_FREE(POINT3(1),STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9998
     
*   Open a file.
      CALL ELP1_TEXTO(1,NDF1,VALIDP,ZEROP,RESULT,XCO,YCO,BACK,
     :                SIGMA,PSIZE,LBND,FIOD,EXCLAIM,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9998                         

*   Look at each of the image location found in the text file.
      CALL MSG_BLANK(STATUS)
      DO 20 I=1,NGALS

*      Read the stored array values.
         XCO=XC(I)
         YCO=YC(I)

*      Display the current co-ordinates.
         CALL MSG_FMTR('X','F6.1',XCO)
         CALL MSG_FMTR('Y','F6.1',YCO)
         CALL MSG_OUT(' ','Working on data co-ordinates:^X ^Y',STATUS)

*      Look for a better (though crude) estimate of the galaxy core position.
         IF (AUTOL) CALL ELP1_AUTOL(BACK,ELEMS,PRANGE,
     :                              %VAL(POINT1(1)),XCO,YCO,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9998

*      Call the routine that profiles the galaxy and sets up the values
*      in the results arrays.
         CALL ELP1_PRO(0,MINMOD,ANGCON,ANGOFF,FRZORI,FINE,
     :                 LIM1,LIM2,LIM3,
     :                 FRACT,PSIZE,FAST,RLIM,BACKS(I),SIGMA,ELEMS,
     :                 POINT1,PRANGE,XCO,YCO,VALIDP,RESULT,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9998
        
*      Place in the opened file a heading, the co-ordinates of the galaxy being
*      considered and the profiling results.
         IF (.NOT.EXCLAIM) THEN
            CALL ELP1_TEXTO(2,NDF1,VALIDP,ZEROP,RESULT,XCO,YCO,
     :                      BACKS(I),SIGMA,PSIZE,LBND,FIOD,
     :                      EXCLAIM,STATUS)
            IF (STATUS.NE.SAI__OK) GOTO 9998                         
         END IF

*      Tell the user what happened.
         IF (VALIDP.LT.1) THEN 
            CALL MSG_OUT(' ','FAILED!!! No valid ellipses.',STATUS)
         ELSE
            IF (VALIDP.GT.0) THEN 
               CALL MSG_FMTI('FOUND','I4',VALIDP)
               CALL MSG_OUT(' ','^FOUND ellipses determined.',STATUS)
            END IF
         END IF

 20   CONTINUE
     
*   Close the opened file.
      IF (.NOT.EXCLAIM) THEN
        CALL ELP1_TEXTO(3,NDF1,VALIDP,ZEROP,RESULT,XCO,YCO,BACKS(I),
     :                  SIGMA,PSIZE,LBND,FIOD,EXCLAIM,STATUS)
        IF (STATUS.NE.SAI__OK) GOTO 9998                         
      END IF

*   An appropriate place to exit to if the dynamic memory has already
*   been allocated.

 9998 CONTINUE

*   De-allocate the dynamic memory used.
      CALL PSX_FREE(POINT1(1),STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999

 9999 CONTINUE

*   Close the file input ASCII files.
      CALL FIO_ANNUL(FIOID,STATUS)

*   End the NDF context.
      CALL NDF_END(STATUS)                              

      END



      SUBROUTINE ELP1_FOUR(NUMPOI,BACK,VALIDP,XR,YR,VA,XO,YO,
     :                     POSANG,ELLIP,RESULT,STATUS)
*+                  
*  Name:
*     ELP1_FOUR

*  Purpose:
*     Determines the values of the Fourier descriptors for the current 
*     ellipse parameters. 
   
*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_FOUR(NUMPOI,BACK,VALIDP,XR,YR,VA,XO,YO,POSANG,
*                    ELLIP,RESULT,STATUS)

*  Description:
*     Uses the ellipse parameters to normalise the fit ellipse pixel
*     positions to a unit circle. Then solves a set of simultaneous
*     equations to determine the amplitudes of sin/cos factors that would
*     be required to create the variations in pixel brightness 
*     found around the circle. These are converted to the values
*     you would get from contour analysis.

*  Arguments:
*     NUMPOI = INTEGER (Given)
*        Number of ellipse pixels.
*     BACK = REAL (Given)
*        Background count value for the image. Units counts.
*     VALIDP = INTEGER (Given)
*        The number of ellipses for which parameters have been found.
*     XO = REAL (Given) 
*        X co-ordinate of the galaxy centre, Units pixels.
*     XR(ELP__MXPOI) = REAL (Given)
*        Isophotal pixel X co-ordinates. Units pixels.
*     YR(ELP__MXPOI) = REAL (Given)
*        Isophotal pixel Y co-ordinates. Units pixels.
*     VA(ELP__MXPOI) = REAL (Given)
*        Pixel brightness. Units counts.
*     YO = REAL (Given) 
*        Y co-ordinate of the galaxy centre, Units pixels.
*     ELLIP = REAL (Given)
*        Ellipticity of the ellipse.
*     POSANG = REAL (Given)
*        Position angle of the ellipse.
*     RESULT(ELP__NRES,ELP__RESUL) = REAL (Returned)
*        Fitted ellipse parameters.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     27-AUG-1993 (GJP)
*     (Original version)
*     14-FEB-1996 (GJP)
*     Removed some NAG routines.
*     12-OCT-1996 (GJP)
*     Removed the last NAG routines. 
*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'elp_par'               ! ELLPRO constants

*  Status:
      INTEGER STATUS                  ! Global status

*  Arguments Given:
      INTEGER NUMPOI                  ! Number of pixels in the current
                                      ! ellipse and hence the number
                                      ! of equations to solve 
      INTEGER VALIDP                  ! Number of profiles for parameters
                                      ! has been determined
      REAL BACK                       ! Background count value
      REAL ELLIP                      ! Ellipticity of the fitted ellipse
      REAL VA(ELP__MXPOI)             ! Pixel brightness
      REAL POSANG                     ! Position angle of the ellipse
      REAL XR(ELP__MXPOI)             ! X/Y co-ords of the pixels
                                      ! in the fitted ellipse
      REAL YR(ELP__MXPOI)             ! X/Y co-ords of the pixels
                                      ! in the fitted ellipse
      REAL XO                         ! X co-ord of galaxy centre
      REAL YO                         ! Y co-ord of galaxy centre

*  Arguments Returned:
      REAL RESULT(ELP__NRES,ELP__RESUL)      ! Ellipse parameter results

*  Arguments Given and Returned:

*  Local variables:     
      DOUBLE PRECISION CONT(4)        ! Contributions from the previous
                                      ! Fourier descriptor orders
      DOUBLE PRECISION CONTR          ! Sum of contributions from the previous
                                      ! FD orders  
      DOUBLE PRECISION MEAN           ! Mean pixel count
      DOUBLE PRECISION C              ! Cosine amplitude
      DOUBLE PRECISION S              ! Sine amplitude
      DOUBLE PRECISION XV2(500)       ! Angle
      DOUBLE PRECISION YV2(500)       ! Brightness
      INTEGER I                       ! Loop variable
      INTEGER J                       ! Loop variable
      INTEGER K                       ! Array index storage
      INTEGER ORDER                   ! Fourier desc. order being calculated
      REAL ANG(ELP__MXPOI)            ! Transformed pixel angle
      REAL ANGLE                      ! Temporary storage
      REAL ANGLER                     ! Angle of pixel plus the position angle
      REAL DEGS                       ! Angle of pixel
      REAL RAD                        ! Distance of pixel from the origin
      REAL XV(ELP__MXPOI)             ! Transformed/rotated pixel co-ord
      REAL YV(ELP__MXPOI)             ! Transformed/rotated pixel co-ord
      REAL ZERO                       ! Zero value 
      
*.    

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Rotate the ellipse

*   Rotate each point in turn.
*   Also, calculate the mean pixel count value.
      ZERO=0.0
      MEAN=0.0D0
      DO 5 I=1,NUMPOI

*      Find the distance from the centre.
         RAD=SQRT((XR(I)-XO)*(XR(I)-XO)+(YR(I)-YO)*(YR(I)-YO))

*      Find the angle of the current pixel relative to the origin.
         CALL ELP1_ANGLES(XR(I),YR(I),XO,YO,DEGS,STATUS)

*      Calc the resultant angle between the point and the origin.
*      Then convert to radians.
         ANGLER=(DEGS-POSANG)*ELP__PI2360

*      Calculate the transformed/rotated co-ordinates where the origin
*      is now at 0,0.
         XV(I)=RAD*SIN(ANGLER)
         YV(I)=RAD*COS(ANGLER)

*      Increase the X component of the position to convert the 
*      ellipse into a circle.
         XV(I)=XV(I)/ELLIP

*      Recalculate the angles for the ellipse/circle transformation will
*      have modified these.

*      Find the angle of the current pixel relative to the origin.
         CALL ELP1_ANGLES(XV(I),YV(I),ZERO,ZERO,DEGS,STATUS)
         ANG(I)=DEGS*ELP__PI2360

*      Add to the mean summation.
         MEAN=VA(I)+MEAN

 5    CONTINUE
      MEAN=MEAN/REAL(NUMPOI)

*   Set up the equations of intensity versus angle that must be solved.
*   Work out the coefficients for each order in turn.

*   For each order in turn.
      DO 20 ORDER=1,4

*      For each of the pixels in turn set up a simultaneous equation.
         DO 30 I=1,NUMPOI

*         First, calculate the contribution from each preceeding order.
            DO 25 J=1,ORDER-1
               ANGLE=REAL(J)*ANG(I)
               K=(J-1)*2+10.
               CONT(J)=RESULT(K,VALIDP)*SIN(ANGLE)
     :                       +RESULT(K+1,VALIDP)*COS(ANGLE)
 25         CONTINUE

*         Sum the contributions from the preceeding orders.
*         Performed in this way to avoid rounding errors.
            IF (ORDER.EQ.1) CONTR=0.0D0 
            IF (ORDER.EQ.2) CONTR=CONT(1)
            IF (ORDER.EQ.3) CONTR=CONT(1)+CONT(2)
            IF (ORDER.EQ.4) CONTR=CONT(1)+CONT(2)+CONT(3)

*         Residual pixel count, sine factor and then cosine factor.
            XV2(I)=REAL(ORDER)*ANG(I)
            YV2(I)=VA(I)-MEAN-CONTR
 
 30      CONTINUE

*      Solve the equations using a shareware routine.
         CALL ELP1_SOLVE(NUMPOI,XV2,YV2,S,C,STATUS)
        
*      Store the un-normalised values.
         J=(ORDER-1)*2+10.
         RESULT(J,VALIDP)=  S
         RESULT(J+1,VALIDP)=C

 20   CONTINUE

*   Normalise the Fourier descriptors.
      DO 100 I=10,17

*      Only normalise them if it will not lead to a very large number.
         IF (ABS(MEAN-BACK).GT.ELP__VSMAL) 
     :      RESULT(I,VALIDP)=RESULT(I,VALIDP)/(MEAN-BACK)

100   CONTINUE

 9999 CONTINUE

      END
       
  

      SUBROUTINE ELP1_GENER(ELLIP,RADIUS,NUMPOI,ANGL,DIS,STATUS)
*+
*  Name:
*     ELP1_GENER

*  Purpose:
*     Generates the positions of the points making up an ellipse of the 
*     radius and ellipticity required. The angles generated are relative 
*     to an origin of 0,0.
*
*     The number of points generated is proportional to the radius of the
*     ellipse subject to a minimum of 32 and a maximum defined within the
*     INCLUDE file elp_par.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_GENER(ELLIP,RADIUS,NUMPOI,ANGL,DIS,STATUS)

*  Description:
*     A number (N) is generated determining how many ellipse points will
*     be found in a given ellipse quadrant. This is then used to derive an
*     angular increment that will separate points within a given quadrant.
*
*     Points are then generated at different angles within the quadrant.
*     To increase the speed of execution, these angles are also used to
*     create similar points in the other 3 quadrants.

*  Arguments:
*     ELLIP = REAL (Given)
*        The ellipse ellipticity.
*     RADIUS = REAL (Given)
*        Ellipse radius in pixels.
*     NUMPOI = INTEGER (Returned)
*        The number of 'fit' ellipse pixels generated.
*     ANGL(ELP__MXPOI) = REAL (Returned)
*        Position angle of the 'fit' ellipse points.
*     DIS(ELP__MXPOI) = REAL (Returned)
*        Distance of the 'fit' ellipse points from the ellipse origin.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     26-Mar-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'elp_par'               ! ELLPRO constants

*  Status:
      INTEGER STATUS                  ! Global status

*  Arguments Given:
      REAL ELLIP                      ! Ellipticity of the required ellipse
      REAL RADIUS                     ! Radius of the required ellipse

*  Arguments Returned:
      INTEGER NUMPOI                  ! Number of ellipse points generated
      REAL ANGL(ELP__MXPOI)           ! Angle of the untranslated ellipse
                                      ! points
      REAL DIS(ELP__MXPOI)            ! Distance of the untranslated ellipse
                                      ! points from the origin

*  Arguments Given and Returned:

*  Local variables:
      INTEGER I                       ! Loop variable
      INTEGER N                       ! Number of points within a quadrant
      REAL ANGLE                      ! Angle of a given point relative to
                                      ! the origin (Y axis)
      REAL DIST                       ! Ellipse origin-point distance
      REAL JUMP                       ! Angular increment used when
                                      ! calculating the values of angle for
                                      ! points within a quadrant (radians)
      REAL SEMRAD                     ! Distance across the narrow part of
                                      ! the ellipse  (semi-major axis)
      REAL X                          ! X co-ordinate of point
      REAL Y                          ! Y co-ordinate of point

*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Set the number of points generated to zero.
      NUMPOI=0

*   Calculate the number of points to be defined in a quadrant of the ellipse.
      N=NINT(2.*ELP__PIVAL*RADIUS/4.*2.0)
      IF (N.LT.6) N=6
      IF (N.GT.ELP__MXPOI/4.-1.) N=ELP__MXPOI/4.-1.

*   Calculate the angular increment required in radians.
      JUMP=90./REAL(N)*ELP__PI2360

*   Calculate the semi-minor radius.
      SEMRAD=ELLIP*RADIUS

*   Calculate the ellipse points.
      DO 10 I=1,N-1

*      Calculate angle and then X and Y co-ordinates.
         ANGLE=JUMP*I
         X=SEMRAD*SIN(ANGLE)
         Y=RADIUS*COS(ANGLE)

*      Calculate the origin/pixel distance.
         DIST=SQRT(X*X+Y*Y)

*      Determine the final angle in (degrees).
         CALL ELP1_ANGLES(X,Y,0.0,0.0,ANGLE,STATUS)
         ANGLE=ANGLE*ELP__PI2360

*      Quadrant 1.
         NUMPOI=NUMPOI+1
         ANGL(NUMPOI)=ANGLE
         DIS(NUMPOI)=DIST

*      Quadrant 2.
         NUMPOI=NUMPOI+1
         ANGL(NUMPOI)=ELP__PIVAL-ANGLE
         DIS(NUMPOI)=DIST

*      Quadrant 3.
         NUMPOI=NUMPOI+1
         ANGL(NUMPOI)=-ANGLE
         DIS(NUMPOI)=DIST

*      Quadrant 4.
         NUMPOI=NUMPOI+1
         ANGL(NUMPOI)=ELP__PIVAL+ANGLE
         DIS(NUMPOI)=DIST

 10   CONTINUE

 9999 CONTINUE

      END


      SUBROUTINE ELP1_GRAPH(PSIZE,ZEROP,RESULT,VALIDP,
     :                      STATUS)
*+                          
*  Name:
*     ELP1_GRAPH

*  Purpose:
*     Displays the graphs on the requested graphics device. 
*     radius values are displayed converted to equivalent radius.
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*      CALL ELP1_GRAPH(PSIZE,ZEROP,RESULT,VALIDP,STATUS)    
                      
*  Description:
*      Displays the graphical output from the program. This consists of
*      a graph showing the radius versus brightness.

*  Arguments:         
*     PSIZE = REAL (Given)
*        The pixel size in arcsecs.
*     ZEROP = REAL (Given)
*        Magnitude scale zero point.
*     RESULT(ELP__NRES,Ell__MXPOI) = REAL (Given)
*        The profiling results array.
*     VALIDP = INTEGER (Given)
*        Number of radii for which a 'fit' was obtained.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     02-Dec-1992 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'elp_par'               ! ELLPRO constants
      INCLUDE 'PRM_PAR'               ! PRIMDAT primitive data constants
      INCLUDE 'NDF_PAR'               ! NDF constants

*  Arguments Given:                              
      INTEGER VALIDP                  ! Number of radii for which
                                      ! a profile was determined
      REAL PSIZE                      ! Size of the pixels
      REAL RESULT(ELP__NRES,ELP__MXPOI)      ! Profiling results file
      REAL ZEROP                      ! Magnitude scale zero point

*  Arguments Given and Returned:           
                                           
*  Arguments Returned:

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      CHARACTER *(256) HEAD           ! Graph heading
      CHARACTER *(256) LABELX         ! Graph X axis heading
      CHARACTER *(256) LABELY         ! Graph Y axis heading
      INTEGER I                       ! Loop variable
      REAL LOW(2)                     ! The lowest parameter value 
      REAL HIGH(2)                    ! The highest parameter value
      REAL RAD(1)                     ! X axis value to display
      REAL TEMP                       ! Temporary value
      REAL VAL1(1)                    ! Y axis value to display
      REAL VAL2(1)                    ! Y axis value to display
      REAL X1                         ! Viewport limit     
      REAL X2                         ! Viewport limit     
      REAL Y1                         ! Viewport limit     
      REAL Y2                         ! Viewport limit     
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Set the minimum and maximum initial values.
      LOW(1)=VAL__MAXR
      HIGH(1)=VAL__MINR
      LOW(2)=VAL__MAXR
      HIGH(2)=VAL__MINR
         
*   Loop through all the data points.
      LOW(1)=0.0
      DO 30 I=1,VALIDP

*      Find the low and high values for the equivalent radius and value.

*      Equivalent radius. Maximum value only required.
         TEMP=PSIZE*SQRT(RESULT(4,I)*RESULT(4,I)*RESULT(3,I))
         IF (TEMP.GT.HIGH(1)) HIGH(1)=TEMP

*      Value. Check to ensure that the value obtained can
*      be converted to a logarithm.
         TEMP=RESULT(6,I)
         IF (TEMP.GT.0.0) THEN
            TEMP=ZEROP-2.5*LOG10(TEMP)
            IF (TEMP.LT.LOW(2)) LOW(2)=TEMP
            IF (TEMP.GT.HIGH(2)) HIGH(2)=TEMP
         END IF

 30   CONTINUE

*   Adjust for a more pleasing display.
      HIGH(2)=HIGH(2)+.2
      LOW(2)=LOW(2)-.2

*   Set up the display using the limits calculated.
      CALL PGWINDOW(LOW(1),HIGH(1),HIGH(2),LOW(2))

*   Inquire what the viewport size is.
      CALL PGQVP(1,X1,X2,Y1,Y2)

*   Reset the lettering size if necessary.
      IF (((Y2-Y1).LT.2.5).OR.((X2-X1).LT.2.5)) THEN
         IF ((Y2-Y1).LT.(X2-X1)) THEN 
            TEMP=(Y2-Y1)/2.
         ELSE
            TEMP=(X2-X1)/2.
         END IF
         CALL PGSCH(TEMP)
      END IF

*   Set up the labelling marks on the axes.
      CALL PGBOX('ABCGNST',0.0,0,'ABCGNST',0.0,0)
    
*   Set up values for and display the labels for the graph.
    
*   Set up the labels.
      IF (((Y2-Y1).LT.2.5).OR.((X2-X1).LT.2.5)) THEN
         LABELX='Radius * (arc secs)'
         LABELY='SB Zp-2.5Log(I-Back)'
      ELSE    
         LABELX='Radius * (arc seconds)'
         LABELY='Surface Brightness Zp-2.5Log(I-Back)'
      END IF

*   Main heading.        
      HEAD='ELLPRO PROFILE'

*   Display the labels of the graphs.
      CALL PGLABEL(LABELX,LABELY,HEAD)

*   Display the data points.
      DO 40 I=1,VALIDP
    
*      Get the radius and count values. 
         RAD(1)=PSIZE*SQRT(RESULT(4,I)*RESULT(4,I)*RESULT(3,I))
         TEMP=RESULT(6,I)

*      Only display on a log graph if the subtracted count is 
*      greater than zero.
         IF (TEMP.GT.0.0) THEN

*         Display the data point.
            VAL1(1)=ZEROP-2.5*LOG10(TEMP)
            CALL PGPOINT(1,RAD,VAL1,23)

*         Display its error bar. Must check that the count minus the 
*         error does not go below zero and if so, correct accordingly.
            VAL1(1)=ZEROP-2.5*LOG10(TEMP+RESULT(7,I))
            IF (TEMP-RESULT(7,I).GT.0.0) THEN
               VAL2(1)=ZEROP-2.5*LOG10(TEMP-RESULT(7,I))
            ELSE
               VAL2(1)=HIGH(2)
            END IF

            CALL PGERRY(1,RAD,VAL2,VAL1,1.)

         END IF

 40   CONTINUE

 9999 CONTINUE

      END 



      SUBROUTINE ELP1_GRBIT(MODE,COLOUR,CURSIZ,X,Y,RLIM,STATUS)
*+
*  Name:
*     ELP1_GRBIT

*  Purpose:
*     Generates the graphics required when the galaxy origin and maximum
*     permitted ellipse radius are specified by the user and when the 
*     quadrant to be used for the results graph is cleared. 
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_GRBIT(MODE,COLOUR,CURSIZ,X,Y,RLIM,STATUS)

*  Description:
*     Generates the graphics showing the gaaxy origin and the maximum
*     permitted ellipse radius as specified by the user. 
*     Employs SGS to do so.
*
*     The variable MODE defines what is to be drawn: ie
*        
*        MODE=0  Open file, save results and close file in one go
*        MODE=1  Draw the cross at the centre of the chosen sector
*        MODE=2  Draw the circle showing the radius limit for profiling
*        MODE=3  Draw the window within which the results graph will be
*                  displayed


*  Arguments:         
*     MODE = INTEGER (Given)
*        Indicates what sort of graphics output is to take place.
*     COLOUR = INTEGER (Given)
*        Colour of the pen used to draw the galaxy centre marker.
*     CURSIZ = REAL (Given)
*        The size of the cross to be drawn at the first point specified.
*     X(10) = REAL (Given)
*        X co-ordinates derived from the input cursor positions.
*     Y(10) = REAL (Given)
*        Y co-ordinates derived from the input cursor positions.
*     RLIM = REAL (Given)
*        Radius of largest permitted ellipse. Units pixels.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     06-Jan-1992 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'elp_par'               ! ELLPRO constants
      INCLUDE 'PRM_PAR'               ! PRIMDAT primitive data constants

*  Arguments Given:                                   
      INTEGER COLOUR                  ! Galaxy marker colour
      INTEGER MODE                    ! Which part of the sector drawing 
                                      ! is to take place.
      REAL CURSIZ                     ! Size of the cross to be drawn at 
                                      ! the first point specified.
      REAL RLIM                       ! Radius of the largest permitted ellipse
      REAL X(10)                      ! X co-ordinates for various parts of 
                                      ! the sector to be drawn.
      REAL Y(10)                      ! Y co-ordinates for various parts of 
                                      ! the sector to be drawn.

*  Arguments Given and Returned:        

*  Arguments Returned:

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      REAL TEMP1                      ! Temporary value
      REAL TEMP2                      ! Temporary value
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Draw the cross at the centre of the indicated galaxy.
      IF (MODE.EQ.1) THEN         
         CALL SGS_SPEN(COLOUR)
         CALL SGS_LINE(X(1)-CURSIZ,Y(1),X(1)+CURSIZ,Y(1))
         CALL SGS_LINE(X(1),Y(1)-CURSIZ,X(1),Y(1)+CURSIZ)
      END IF

*   Draw a circle defining the maximum radius required..
      IF (MODE.EQ.3) THEN
         TEMP1=0.0
         TEMP2=2.*ELP__PIVAL
         CALL SGS_SPEN(COLOUR)
         CALL SGS_ARC(X(1),Y(1),RLIM,TEMP1,TEMP2)
      END IF

*   Clear the quadrant of the window where the results will be displayed 
*   and then draw a border around it.
      IF (MODE.EQ.7) THEN
         CALL SGS_SPEN(1)
         CALL SGS_CLRBL(X(6),X(7),Y(6),Y(7))
         CALL SGS_BOX(X(6),X(7),Y(6),Y(7))
      END IF

*   Flush any SGS errors.
 9999 CALL SGS_FLUSH

      END 

    

      SUBROUTINE ELP1_GUESS(DMODE,ANGCON,ANGOFF,BACK,XCO,YCO,
     :                      ELEMS,ARRAY,PRANGE,POSANG,RADIUS,
     :                      ELLIP,STATUS)    
*+
*  Name:
*     ELP1_GUESS

*  Purpose:
*     Determines the initial estimate of ellipticity and position angle to
*     be employed when the search for an ellipse fit begins. It also provides
*     a value of radius at which profiling may begin where there may be a
*     reasonable signal strength.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_GUESS(DMODE,ANGCON,ANGOFF,BACK,XCO,YCO,ELEMS,
*                     ARRAY,PRANGE,POSANG,RADIUS,ELLIP,STATUS)    

*  Description:
*     Looks outward from the chosen origin location along lines separated by
*     45 degrees. Determines how far along each of these lines you must
*     look to reach a pixel count value below an arbitrary value. The
*     ratio of the distances in different directions provides some
*     approximation of the ellipticity value and the sums of diametrically
*     opposite lines gives an approximation to the position angle.
*
*     A value is also provided for a radius at which the profiling may begin
*     where the radius will allow accurate results to be quickly obtained ie
*     not too small to include very few points, but small enough for the
*     signal strength to be high.

*  Arguments:
*     DMODE = INTEGER (Given) 
*        Is a display to be generated? 0=No 1=Yes.
*     ANGCON = LOGICAL (Given)
*        Position angle convention. TRUE=clockwise is positive.
*     ANGOFF = REAL (Given)
*        Angular offset for the position angle. 
*     BACK = REAL (Given)
*        Image background count value. Units counts.
*     XCO = REAL (Given)
*        Suggested X co-ordinate for the galaxy centre.
*     YCO = REAL (Given)
*        Suggested Y co-ordinate for the galaxy centre.
*     ELEMS = INTEGER (Given)
*        Number of pixels in the image.
*     ARRAY(ELEMS) = REAL (Given)
*        The image array.
*     PRANGE(2) = INTEGE (Given)
*        Size of the image axes. Units pixels.
*     POSANG = REAL (Returned)
*        Position angle of the galaxy.
*     RADIUS = REAL (Returned)
*        First radius of the galaxy to try. Units pixels.
*     ELLIP = REAL (Returned)
*        Approximate ellipticity of the galaxy.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     4-Apr-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'PRM_PAR'               ! PRIMDAT primitive data constants
      INCLUDE 'elp_par'               ! ELLPRO constants

*  Status:
      INTEGER STATUS                  ! Global status

*  Arguments Given:
      LOGICAL ANGCON                  ! Position angle convention
      INTEGER DMODE                   ! Generate a display? 0=No 1=Yes
      INTEGER ELEMS                   ! Number of pixels in the image
      INTEGER PRANGE(2)               ! Size of the image
      REAL ANGOFF                     ! Position angle offset
      REAL ARRAY(ELEMS)               ! Image array
      REAL BACK                       ! Background count of the image
      REAL XCO                        ! X co-ord of the galaxy centre
      REAL YCO                        ! Y co-ord of the galaxy centre

*  Arguments Returned:
      REAL ELLIP                      ! Ellipticity estimate
      REAL POSANG                     ! Position angle estimate
      REAL RADIUS                     ! Radius estimate

*  Arguments Given and Returned:

*  Local variables:
      CHARACTER *(256) TOP            ! A heading
      INTEGER FAR                     ! Distance from X Y co-ords beyond
                                      ! which the image bounds must be
                                      ! exceeded
      INTEGER FOUND(10)               ! Was a distance value found
                                      ! for a given angle
      INTEGER I                       ! Temporary storage
      INTEGER J                       ! Temporary storage
      INTEGER LOW                     ! Index of the line with
                                      ! the smallest centre/threshold
                                      ! distance
      INTEGER HIGH                    ! Index of the line with
                                      ! the largest centre/threshold
                                      ! distance
      INTEGER MAXFOU                  ! Was a valid pixel found?
      INTEGER MEANC                   ! Counter
      INTEGER XI(8)                   ! X axis increment
      INTEGER YI(8)                   ! Y axis increment
      REAL ADD                        ! Array address
      REAL DIST(10)                   ! Distance from the galaxy centre
      REAL MAX                        ! Maximum temporary value
      REAL MEAN                       ! The mean pixel value found
      REAL MIN                        ! Minimum temporary value
      REAL POS1                       ! Temporary position angle storage
      REAL POS2                       ! Temporary position angle storage
      REAL TEMP                       ! Temporary storage
      REAL THRESH                     ! Threshold count value
      REAL VALUE                      ! Temporary storage
      REAL X                          ! Temporary X co-ordinate
      REAL Y                          ! Temporary Y co-ordinate
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Setup arrays containing the increments in X and Y for examining lines
*   of pixels outward from the proposed galaxy origin at angles of
*   0, 45, 90, 135, 180, 225, 270, 315 respectively.

*   X increments.
      XI(1)=0
      XI(2)=1
      XI(3)=1
      XI(4)=1
      XI(5)=0
      XI(6)=-1
      XI(7)=-1
      XI(8)=-1

*   Y increments.
      YI(1)=1
      YI(2)=1
      YI(3)=0
      YI(4)=-1
      YI(5)=-1
      YI(6)=-1
      YI(7)=0
      YI(8)=-1

*   Find an approximate value for the pixel count for near the
*   origin of the galaxy.
      MAX=BACK
      MIN=ELP__VBIG
      MAXFOU=0

*   Set mean initial values.
      MEAN=0.0
      MEANC=0

*   Look in a 13x13 box around the origin provided.
      DO 10 I=-6,6

*      Set the X co-ordinate.
         X=NINT(XCO)+I

         DO 20 J=-6,6

*          Set the Y co-ordinate.
             Y=NINT(YCO)+J

*          Check that the pixel is within the image.
             IF ((X.GE.1).AND.(X.LE.PRANGE(1)).AND.(Y.GE.1)
     :            .AND.(Y.LE.PRANGE(2))) THEN

*             Calculate the array address of the pixel required.
                ADD=(Y-1)*PRANGE(1)+X

*             Get the pixel value.
                VALUE=ARRAY(ADD)

*             Check that it was not a BAD pixel.
                IF (VALUE.NE.VAL__BADR) THEN

*                Add to the mean accumulator.
                   MEAN=MEAN+VALUE
                   MEANC=MEANC+1

*                Is it bigger than the highest value yet found?
                   IF (VALUE.GT.MAX) THEN
                      MAX=VALUE
                      MAXFOU=1
                   END IF

*                Is it smaller than the lowest value found.
                   IF (VALUE.LT.MIN) MIN=VALUE

                END IF

             END IF

 20      CONTINUE

 10   CONTINUE

*   Calculate the mean.
      IF (MEANC.GT.0) THEN
         MEAN=MEAN/REAL(MEANC)
      ELSE
         MEAN=(MAX+MIN)/2.
      END IF

*   Set a suitable threshold value.
      IF (MAXFOU.NE.0) THEN

*      Use the figures obtained.
         THRESH=( (MAX+MIN)/2.+ MEAN )/2.

      ELSE                             

*      Use guesses and return immediately to the calling routine.
         RADIUS=6.0
         ELLIP=1.0
         POSANG=0.0
         GOTO 9998

      END IF

*   Clear the arrays required.
      DO 30 I=1,8
         DIST(I)=0.0
         FOUND(I)=0.0
 30   CONTINUE

*   Determine how far out from the co-ordinates the search must start.
      FAR=NINT(SQRT(1.*PRANGE(1)*PRANGE(1)+1.*PRANGE(2)*PRANGE(2)))
    
*   Look along lines inward toward the centre of the galaxy to find out
*   at what distance the pixel count value drops below the threshold.
      DO 40 J=1,8

*      Look inward along the required lines.
         DO 50 I=FAR,1,-1

*         Calculate the pixel co-ordinate.
            X=NINT(XCO)+I*XI(J)
            Y=NINT(YCO)+I*YI(J)

*         Check that the pixel is within the image.
            IF ((X.GE.1).AND.(X.LE.PRANGE(1)).AND.(Y.GE.1)
     :           .AND.(Y.LE.PRANGE(2))) THEN

*            Find the array address of the pixel required.
               ADD=(Y-1)*PRANGE(1)+X

*            Get its value.
               VALUE=ARRAY(ADD)

*            Check that the value is not bad.
               IF (VALUE.NE.VAL__BADR) THEN

*               Only act if the value is still below the threshold
                  IF (VALUE.LT.THRESH) THEN

*                  Update the estimate of the distance away from the centre
*                  at which the threshold is crossed.
                     DIST(J)=I
                     FOUND(J)=1

                  END IF

               END IF

            END IF

 50      CONTINUE

 40   CONTINUE

*   Average estimates for 0/180 45/225 degrees etc. 
      DO 60 I=1,4

*      Average the result if a value was found for both lines.
         IF ((FOUND(I).GT.0).AND.(FOUND(I+4).GT.0)) THEN

            DIST(I)=(DIST(I)+DIST(I+4))/2.

         ELSE

*         Take the only value found if one of the pair did not have a value
*         assigned.
            IF ((FOUND(I).GT.0).OR.(FOUND(I+4).GT.0)) THEN
               DIST(I)=DIST(I)+DIST(I+4)
               FOUND(I)=1
            END IF

         END IF

*      Allow for the diagonal lines being root(2) longer.
         IF ((I.EQ.2).OR.(I.EQ.4)) DIST(I)=DIST(I)*SQRT(2.)
         
 60   CONTINUE

*   Look to see which line (0,45,90,135 degrees) has the highest value
*   and which the lowest value. These will be used to give a rough
*   estimate of ellipse axis lengths and the ellipticity
      MAX=-1E+20
      MIN=1E+20
      HIGH=0
      LOW=0
      DO 70 I=1,4

*      Check that a value was found for the current pair of diametrically
*      opposed lines outward from the origin. Uses the sum of pairs since
*      (for example) -45 and +135 are for these purposes the same thing.
*      pairs are used to reduce the influence of BAD areas.
         IF (FOUND(I).GT.0) THEN

*         If current value is biggest then keep it.
            IF (DIST(I).GT.MAX) THEN
               MAX=DIST(I)
               HIGH=I
            END IF

*         If current value is smallest then keep it.
            IF (DIST(I).LT.MIN) THEN
               MIN=DIST(I)
               LOW=I
            END IF

         END IF

 70   CONTINUE

*   If no radius was found use a approximate one.
*   Then exit from the routine.
      IF ((HIGH.EQ.0).OR.(LOW.EQ.0)) THEN
         RADIUS=6.0
         ELLIP=1.0
         POSANG=0.0
         GOTO 9998
      END IF
      
*   Set value for first radius to be profiled. Set lower limit of 4.0
      RADIUS=MAX
      IF (RADIUS.LT.4.) RADIUS=4.

*   Set a value for the ellipticity.
      ELLIP=.5
      IF ((FOUND(HIGH).NE.0).AND.(FOUND(MIN).LT.MAX)) THEN

*      Check that the minimum axis is less that the maximum.
         IF (MIN.LT.MAX) ELLIP=MIN/MAX

*      Ensure that for the first profile the centre is within
*      the ellipse.
         IF (ELLIP*RADIUS.LT.3.0) ELLIP=4.0/RADIUS
        
      END IF

*   Determine a first estimate of the position angle of the ellipse.
      POSANG=45.
      IF (LOW.LT.HIGH) THEN
        POS1=(HIGH-1)*45.
        POS2=(LOW+1)*45.
      ELSE
         POS1=(HIGH-1)*45.
         POS2=(LOW-3)*45.
      END IF
      POSANG=(POS1+POS2)/2.
     
*   Line to abort to if no figure for the first guess is easily available.
 9998 CONTINUE

*   Impose sensible limits on ellipticity and position angle.
      IF (ELLIP.GT.0.85) ELLIP=0.85
      IF (ELLIP.LT.0.1) ELLIP=0.1
      IF (POSANG.GT.90.) POSANG=POSANG-180.

*   Display the first guess generated (if required).
      IF (DMODE.GT.0) THEN

         CALL MSG_BLANK(STATUS)
         CALL MSG_OUT(' ','Initial parameter estimates',STATUS)
         CALL MSG_FMTR('RAD','F8.2',SQRT(RADIUS*RADIUS*ELLIP))
         IF (ANGCON) THEN
            TEMP=POSANG+ANGOFF
         ELSE
            TEMP=-POSANG+ANGOFF
         END IF
         CALL MSG_FMTR('POS','F6.1',TEMP)
         CALL MSG_FMTR('ELL','F4.3',ELLIP)
         CALL MSG_OUT(' ','Rad(*) ^RAD  Posang ^POS  Ellipt.  ^ELL',
     :                STATUS)

*      Heading for output.
         CALL MSG_BLANK(STATUS)
c         TOP='  X       Y      Points    Rad(*)    Count     PA   '//
c     :       '  Ellipt  Dev.   PPU  Statistic'
         TOP='  X       Y     Points   Rad(*)    Count     PA '//
     :       '  Ellipt  Dev.  PPU  Statistic'
         CALL MSG_OUT(' ',TOP,STATUS)

      END IF

 9999 CONTINUE

      END


      SUBROUTINE ELP1_KMODE(STATUS)
*+
*  Name:
*     ELP1_KMODE

*  Purpose:
*     The routine allows the user to input most of the information required
*     (position, background value etc) for the galaxy profile to be 
*     performed/displayed and then calls other routines as necessary. 
* 
*     Information such as pixel size, background count value and its
*     standard deviation are also input.
*
*     The routine operates using a combination of keyboard inputs.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_KMODE(STATUS)

*  Arguments:   
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description: 
*     Profiling is continued until the mean profile value is less than
*     a user defined number of standard deviations above sky (LIM2) or 
*     until the mean profile value increases by a user defined amount
*     compared to the previous profile (LIM1). The difference between the 
*     sizes of profile semi-major axis values is controlled using the 
*     FINE parameter.
*
*     When profiling an ellipse with a small radius one of two methods may
*     be employed to determine the values of points located around each
*     trial ellipse. These are are bi-linear interpolation or a surface
*     interpolation based on a 8x8 grid of surrounding pixels. The latter
*     method is slower but may yield better results at small radii. It 
*     is selected by setting the parameter FAST to false.     
*
*     The initial estimate of the galaxy position may be improved by 
*     selecting the AUTOL option which performs a centroid 
*     analysis of the image area immediately surrounding the input value.
*
*     Contaminating parts of the image may be defined using an ARD file.

*  Implementation Status:
*     Under development

*  Authors:
*     GJP: Grant Privett (STARLINK)
*     {enter_new_authors_here}

*  History:
*     16-MAR-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'NDF_PAR'               ! NDF_ public constant
      INCLUDE 'PRM_PAR'               ! PRIMDAT primitive data constants
      INCLUDE 'elp_par'               ! ELLPRO constants
      INCLUDE 'MSG_PAR'               ! MSG constants
      INCLUDE 'SUBPAR_PAR'            ! SUBPAR constants
         
*  Status:     
      INTEGER STATUS                  ! Global status

*  Local Variables:      
      CHARACTER *(256) COSYS          ! Option choice defining how the
                                      ! pixel data format to be input
      CHARACTER *(MSG__SZMSG) FILE    ! NDF file name
      LOGICAL AGAIN                   ! Look at another part of the image?
      LOGICAL ANGCON                  ! Position angle convention
      LOGICAL AUTOL                   ! Is an estimate of the galaxy centre
                                      ! position to be made?
      LOGICAL EXCLAIM                 ! Was an exclaimation mark given for
                                      ! an output file name?
      LOGICAL FAST                    ! Use fast method of profiling?
      LOGICAL FRZORI                  ! Is the galaxy origin frozen?
      LOGICAL GRAPH                   ! Is a graph to be plotted
      LOGICAL INOKAY                  ! Was the most recent input value okay
      INTEGER AGIID                   ! AGI identifier
      INTEGER ELEMS                   ! Total number of pixels in the NDF
      INTEGER FIOD                    ! FIO file descriptor
      INTEGER I                       ! Loop variable
      INTEGER IND                     ! The number of origin indices to
                                      ! be input at one go i.e. 2
      INTEGER IND2                    ! Number of indices returned
      INTEGER LBND(NDF__MXDIM)        ! Lower limit for image index
      INTEGER MINMOD                  ! Which residual to use in minimisation
      INTEGER NDF1                    ! Identifier for the source NDF  
      INTEGER NDIM                    ! Number of dimensions in the 
                                      ! image
      INTEGER POINT0(1)               ! Pointer to the data component of
                                      ! the source NDF
      INTEGER POINT1(1)               ! Pointer to the data component after
                                      ! its been mapped to dynamic memory
      INTEGER POINT3(1)               ! Pointer to the ARD mask
      INTEGER PRANGE(2)               ! Length of the x and y axes
      INTEGER STLEN                   ! NDF file name length
      INTEGER UBND(NDF__MXDIM)        ! Upper limit for image index
      INTEGER VALIDP                  ! Number of radii for which
                                      ! a fit was obtained
      REAL ANGOFF                     ! Position angle offset
      REAL BACK                       ! Background count value
      REAL FINE                       ! Determines how closely spaced the
                                      ! chosen radii values are
      REAL FRACT                      ! Fraction of the ellipse points that
                                      ! must be available for the profile 
                                      ! at a given radius to be kept
      REAL INP(2)                     ! Value input by the user
      REAL LIM1                       ! Maximum permitted count increase factor
      REAL LIM2                       ! Lower limit on ellipse count
      REAL LIM3                       ! Radius value beyond which the
                                      ! position angle, origin and ellipticity
                                      ! are no longer adjusted
      REAL PSIZE                      ! Size of the image pixels in arc sec
      REAL RESULT(ELP__NRES,ELP__RESUL)      ! Ellipse parameters
      REAL RLIM                       ! Maximum ellipse radius
      REAL SIGMA                      ! Std. dev. of the background value
      REAL XCO                        ! X index of the galaxy origin
      REAL YCO                        ! Y index of the galxay origin
      REAL ZEROP                      ! Zero point of the surface 
                                      ! brightness graphs
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Begin an NDF context.                               
      CALL NDF_BEGIN
      IF (STATUS.NE.SAI__OK) GOTO 9999
      
*   Obtain an identifier for the NDF structure to be examined.       
      CALL NDF_ASSOC('IN','READ',NDF1,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999

*   Get the image bounds and also the size of the axes in pixels.
      CALL NDF_BOUND(NDF1,2,LBND,UBND,NDIM,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999 
      PRANGE(1)=UBND(1)-LBND(1)+1
      PRANGE(2)=UBND(2)-LBND(2)+1
                                       
*   Get the co-ordinate system mode and convert to upper case.
      CALL PAR_GET0C('COSYS',COSYS,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999
      CALL CHR_UCASE(COSYS)

*   Look at the command line value for ANGCON.
*   Otherwise, use the default.
      CALL PAR_STATE('ANGCON',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0L('ANGCON',ANGCON,STATUS)
         CALL MSG_OUT(' ','Command line ANGCON value used.',STATUS)
      ELSE
         ANGCON=.TRUE.
      END IF

*   Look at the command line value for ANGOFF.
*   Otherwise, use the default.
      CALL PAR_STATE('ANGOFF',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0R('ANGOFF',ANGOFF,STATUS)
         CALL MSG_OUT(' ','Command line ANGOFF value used.',STATUS)
      ELSE
         ANGOFF=0.0
      END IF

*   Look at another location on the image.
      AGAIN=.TRUE.
      DO WHILE ((AGAIN).AND.(STATUS.EQ.SAI__OK))

*      Get the pixel to be used as the galaxy centre.
         IND=2
         IND2=2
         INOKAY=.FALSE.
         DO WHILE ((.NOT.INOKAY).AND.(STATUS.EQ.SAI__OK))

*         Get the input.
            CALL PAR_GET1R('ORIGIN',IND,INP,IND2,STATUS)
            XCO=INP(1)
            YCO=INP(2)

*         Check that the co-ordinate values input are legal.
            IF (COSYS.EQ.'W') THEN
               IF ((XCO.GE.LBND(1)).AND.(XCO.LE.UBND(1))
     :            .AND.(YCO.GE.LBND(2)).AND.(YCO.LE.UBND(2))) 
     :            INOKAY=.TRUE.
               XCO=XCO-LBND(1)+1
               YCO=YCO-LBND(2)+1
            ELSE
               IF ((XCO.GE.1.0).AND.(XCO.LE.PRANGE(1))
     :            .AND.(YCO.GE.1.0).AND.(YCO.LE.PRANGE(2))) 
     :            INOKAY=.TRUE.
            END IF

            IF (.NOT.INOKAY) THEN
               CALL MSG_OUT(' ','The position supplied, is not '//
     :                      'within the image.',STATUS)
               CALL PAR_CANCL('ORIGIN',STATUS)
            END IF

         END DO
         IF (STATUS.NE.SAI__OK) GOTO 9999 

*      Determine whether or not the origin given is to be used throughout
*      the profiling.
         CALL PAR_GET0L('FRZORI',FRZORI,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Get the background count value.
         CALL PAR_GET0R('BACK',BACK,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Get the background count standard deviation value.
         INOKAY=.FALSE.
         DO WHILE ((.NOT.INOKAY).AND.(STATUS.EQ.SAI__OK))
            CALL PAR_GET0R('SIGMA',SIGMA,STATUS)
            IF (SIGMA.LE.0.0) THEN
*            Display message and annul the parameter.
               CALL MSG_OUT(' ','Sigma supplied, is not '//
     :                      'feasible.',STATUS)
               CALL PAR_CANCL('SIGMA',STATUS)
            ELSE
               INOKAY=.TRUE.
            END IF
         END DO
         IF (STATUS.NE.SAI__OK) GOTO 9999 

*      Get the maximum profile radius.
         CALL PAR_GET0R('RLIM',RLIM,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999
         IF (RLIM.LE.PSIZE) RLIM=ELP__RLIM

*      Use the default radii separation. 
*      Look on the command line for an output.
*      Otherwise, use the value specified in elp_par.
         CALL PAR_STATE('FINE',I,STATUS )
         IF (STATUS.NE.SAI__OK) GOTO 9999
         IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
            CALL PAR_GET0R('FINE',FINE,STATUS)
            CALL MSG_OUT(' ','Command line FINE value used.',STATUS)
         ELSE
            FINE=ELP__FINE
         END IF

*      Get the pixel size value.
         INOKAY=.FALSE.
         DO WHILE ((.NOT.INOKAY).AND.(STATUS.EQ.SAI__OK))
            CALL PAR_GET0R('PSIZE',PSIZE,STATUS)
            IF (PSIZE.LE.0.0) THEN
*            Display message and annul the parameter.
               CALL MSG_OUT(' ','The pixel size supplied, is not '//
     :                      'feasible.',STATUS)
               CALL PAR_CANCL('PSIZE',STATUS)
            ELSE
               INOKAY=.TRUE.
            END IF
         END DO
         IF (STATUS.NE.SAI__OK) GOTO 9999 

*      Get the zero point for the surface brightness scale/graphs.
         CALL PAR_GET0R('ZEROP',ZEROP,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Is the galaxy centre to be determined by a centroid around 
*      the coords provided?
         CALL PAR_GET0L('AUTOL',AUTOL,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Get the minimisation mode (which residual to use)
         CALL PAR_GET0I('MINMOD',MINMOD,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Calculate the profiles without using the bi-cubic spline at
*      low radii? Look on the command line for an input.
*      Otherwise, use the value specified in elp_par.
         CALL PAR_STATE('FAST',I,STATUS )
         IF (STATUS.NE.SAI__OK) GOTO 9999
         IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
            CALL PAR_GET0L('FAST',FAST,STATUS)
            CALL MSG_OUT(' ','Command line FAST value used.',STATUS)
         ELSE
            FAST=ELP__FAST
         END IF

*      Check the state of the parameter LIM1, to see if there is a
*      suggested value on the command line.
*      Otherwise, use the value specified in elp_par.
         CALL PAR_STATE('LIM1',I, STATUS )
         IF (STATUS.NE.SAI__OK) GOTO 9999
         IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
            CALL PAR_GET0R('LIM1',LIM1,STATUS)
            CALL MSG_OUT(' ','Command line LIM1 value used.',STATUS)
         ELSE
            LIM1=ELP__LIM1
         END IF

*      Check the state of the parameter LIM2, to see if there is a
*      suggested value on the command line.
*      Otherwise, use the value specified in elp_par.
         CALL PAR_STATE('LIM2',I,STATUS )
         IF (STATUS.NE.SAI__OK) GOTO 9999
         IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
            CALL PAR_GET0R('LIM2',LIM2,STATUS)
            CALL MSG_OUT(' ','Command line LIM2 value used.',STATUS)
         ELSE                           
            LIM2=ELP__LIM2
         END IF

*      Check the state of the parameter LIM3, to see if there is a
*      suggested value on the command line.
*      Otherwise, use the value specified in elp_par.
         CALL PAR_STATE('LIM3',I,STATUS )
         IF (STATUS.NE.SAI__OK) GOTO 9999
         IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
            CALL PAR_GET0R('LIM3',LIM3,STATUS)
            CALL MSG_OUT(' ','Command line LIM3 value used.',STATUS)
         ELSE
            LIM3=ELP__LIM3
         END IF

*      Check the state of the parameter FRACT, to see if there is a
*      suggested value on the command line.
*      Otherwise, use the value specified in elp_par.
         CALL PAR_STATE('FRACT',I,STATUS )
         IF (STATUS.NE.SAI__OK) GOTO 9999
         IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN     
            CALL PAR_GET0R('FRACT',FRACT,STATUS)
            CALL MSG_OUT(' ','Command line FRACT value used.',STATUS)
         ELSE
            FRACT=ELP__FRACT
         END IF

*      Map the NDF data array as _REAL values for reading.
         CALL NDF_MAP(NDF1,'DATA','_REAL','READ',POINT0(1),
     :                ELEMS,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999
            
*      Get the name of the file being mapped.
         CALL NDF_MSG('FILE',NDF1)
         CALL MSG_LOAD(' ','^FILE',FILE,STLEN,STATUS)

*      Allocate dynamic memory on which to map the NDF.
         CALL PSX_CALLOC(ELEMS,'_REAL',POINT1(1),STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9998

*      Transfer values from the mapped NDF to the allocated memory.
         CALL ELP1_TRANS(ELEMS,%VAL(POINT0(1)),%VAL(POINT1(1)),STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9998

*      Un-map the source NDF. Helps to reduce the resources being used.
         CALL NDF_UNMAP(NDF1,'DATA',STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9998
                         
*      Allocate the memory needed for the logical mask array.
         CALL PSX_CALLOC(ELEMS,'_INTEGER',POINT3(1),STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9998
 
*      Transfer to the ARD driver control routine.
         NDIM=2
         CALL ESP_ARD_DRIVER(NDIM,ELEMS,LBND,UBND,POINT1,POINT3,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9998
 
*      Free the dynamic array space of the logical mask.
         CALL PSX_FREE(POINT3(1),STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9998

*      Look for a better (though crude) estimate of the galaxy core position.
         IF (AUTOL) CALL ELP1_AUTOL(BACK,ELEMS,PRANGE,
     :                   %VAL(POINT1(1)),XCO,YCO,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9998

*      Call the routine that profiles the galaxy and sets up the values
*      in the results arrays.
         CALL ELP1_PRO(1,MINMOD,ANGCON,ANGOFF,FRZORI,FINE,
     :             LIM1,LIM2,LIM3,
     :             FRACT,PSIZE,FAST,RLIM,BACK,SIGMA,ELEMS,POINT1,
     :             PRANGE,XCO,YCO,VALIDP,RESULT,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9998

*      Only allow graphical output if VALIDP is greater than 1. Since
*      otherwise there are too few points.
         IF (VALIDP.GT.1) THEN

*         Ask user for device name.
            AGIID=0
            GRAPH=.TRUE.
            CALL ERR_MARK
            CALL ELP1_AGICO(0,0,0,AGIID,STATUS)
            IF (STATUS.NE.SAI__OK) THEN
               GRAPH=.FALSE.
               CALL ERR_ANNUL(STATUS)
            END IF
            CALL ERR_RLSE

*         Display the un-analysed data as a graphical plot of radius (in 
*         pixels) versus intensity.
            IF (GRAPH) THEN      

               CALL ELP1_GRAPH(PSIZE,ZEROP,RESULT,VALIDP,
     :                        STATUS)  
               IF (STATUS.NE.SAI__OK) GOTO 9998

*            Turn off the AGI/PGPLOT interface.
               CALL ELP1_AGICO(1,0,0,AGIID,STATUS)

            END IF


         END IF

*      Create a text file containing the latest profile/fit results 
*      (if required).
         CALL ELP1_TEXTO(0,NDF1,VALIDP,ZEROP,RESULT,XCO,YCO,BACK,SIGMA,
     :                   PSIZE,LBND,FIOD,EXCLAIM,STATUS)

*      An appropriate place to exit to if the dynamic memory has already
*      been allocated.
 9998    CONTINUE

*      De-allocate the dynamic memory used.
         CALL PSX_FREE(POINT1(1),STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Get the user selection of preparing a galaxy profile 
*      or not.
         CALL PAR_GET0L('AGAIN',AGAIN,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

         IF (AGAIN) THEN

*         Spacing to make things tidy.
            CALL MSG_BLANK(STATUS)

*         Cancel the parameters so that they must be reinput when
*         looping round.
            CALL ELP1_CANCL(1,STATUS)

         END IF

      END DO

 9999 CONTINUE

*   End the NDF context.
      CALL NDF_END(STATUS)                              

      END   



      SUBROUTINE ELP1_MESSG(POINT,TERMES,IMGMES,NTERMS,NIMGMS,STATUS)
*+
*  Name:
*     ELP1_MESSG

*  Purpose:
*     Sets up the messages that are to be displayed with the cursor to
*     tell the user how to operate it and what input is currently being 
*     requested.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_MESSG(POINT,TERMES,IMGMES,NTERMS,NIMGMS,STATUS)


*  Description:
*     Depending on the value of POINT the routine assigns values to two 
*     character arrays. These are then used by subroutine ELP1_PRPCUR to
*     inform the user what is required. Also assigns value to NITERMS and
*     NIMGMS to define how many lines of text there are in each message.

*  Arguments:
*     POINT = INTEGER (Given)
*        Defines which of the messages is required.
*     TERMES(4) = CHARACTER*80 (Returned)
*        Messages if device is a terminal.
*     IMGMES(4) = CHARACTER*80 (Returned)
*        Messages if device is an image display. 
*     NTERMS = INTEGER (Returned)
*        Number of lines of terminal text.
*     NIMGMS = INTEGER (Returned)
*        Number of lines of image-display text.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     15-Feb-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
                     
*  Arguments Given:
      INTEGER POINT                   ! Defines which message is required

*  Arguments Returned:
      CHARACTER *80 IMGMES(4)         ! Informational messages if device is
                                      ! an image display
      CHARACTER *80 TERMES(4)         ! Informational messages if device is
                                      ! a terminal

      INTEGER NIMGMS                  ! Number of lines of image-display
                                      ! messages
      INTEGER NTERMS                  ! Number of lines of terminal messages

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local Variables:                                               

*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Selecting the galaxy centre centre.
      IF ((POINT.EQ.1).OR.(POINT.EQ.0)) THEN

         TERMES(1)='Select the centre of the galaxy to be profiled.'
         IMGMES(1)=TERMES(1)

         TERMES(2)='Keyboard "2" key:   Quit the program.'
         IMGMES(2)=TERMES(2)

         TERMES(3)='Keyboard "." key:   Select the galaxy.' 
         IMGMES(3)=TERMES(3)

         TERMES(4)='Keyboard "1" key:   Show the cursor co-ordinates.'
         IMGMES(4)='Mouse left button:  Show the cursor co-ordinates.'

      END IF

*   Select a point defining the maximum permitted radius.
      IF (POINT.EQ.2) THEN

         TERMES(1)='Indicate the outer limit of the galaxy.'
         IMGMES(1)=TERMES(1)

         TERMES(2)='Keyboard "2" key:   Quit the program.'
         IMGMES(2)=TERMES(2)

         TERMES(3)='Keyboard "." key:   Select the outer limit of the'/
     :             /' galaxy.'
         IMGMES(3)=TERMES(3)

         TERMES(4)='Keyboard "1" key:   Show the cursor co-ordinates.'
         IMGMES(4)='Mouse left button:  Show the cursor co-ordinates.'

      END IF

*   Select a point defining the quadrant in which a graph should be 
*   displayed.
      IF (POINT.EQ.6) THEN

         TERMES(1)='Select a point defining the quadrant of the window'/
     :             /' in which to plot.'
         IMGMES(1)=TERMES(1)

         TERMES(2)='Keyboard "2" key:   Quit the program.'
         IMGMES(2)=TERMES(2)

         TERMES(3)='Keyboard "." key:   Select the quadrant.'
         IMGMES(3)=TERMES(3)

         TERMES(4)=' '
         IMGMES(4)=' '

      END IF

      NTERMS=4
      NIMGMS=4

      END


      SUBROUTINE ELP1_PRO(DMODE,MINMOD,ANGCON,ANGOFF,FRZORI,FINE,
     :     LIM1,LIM2,LIM3,FRACT,PSIZE,FAST,RLIM,BACK,SIGMA,
     :     ELEMS,ARRP,PRANGE,XCO,YCO,VALIDP,
     :     RESULT,STATUS)
*+              
*  Name:
*     ELP1_PRO

*  Purpose:
*     Routine wherein the ellipse parameters and Fourier descriptors
*     are determined.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_PRO(DMODE,MINMOD,ANGCON,ANGOFF,FRZORI,FINE,LIM1,LIM2,LIM3,
*                   FRACT,PSIZE,FAST,RLIM,BACKS,DEV,ELEMS,ARRP,PRANGE,
*                   XCO,YCO,VALIDP,RESULT,STATUS)

*  Description:
*     The routine works by examining the intensity variation of pixels
*     around a theoretical ellipse. A minimisation method where 
*     ellipse ellipticity, origin and position angle are varied is employed 
*     to determine what values of these parameters lead to the to the
*     minimum variation in intensity around the ellipse. Care is taken
*     to ensure this isnt acheived by merely moving the ellipse away
*     from the galaxy centre and down into the noise. The ellipse
*     parameters are varied over a wide range to ensure that local minima
*     are avoided if possible.
* 
*     Pixel brightness values are obtained by bi-linear interpolation or 
*     (FAST=FALSE) bi-cubic spline.
*     
*     Once the ellipse parameters have been determined these are used
*     to normalise the pixel positions to a unit circle. The brightness
*     variations around the circle are analysed to determine the
*     Fourier descriptors.

*  Arguments:
*     DMODE = INTEGER (Given)
*        Is a display to be generated? 0=No 1=Yes.
*     MINMOD = INTEGER (Given)
*        Which type of ellipse-residual minimisation is to be used (see
*        elp1_stats)
*     FRZORI = LOGICAL (Given)
*        Is the galaxy centre given to be used unchanged or is it
*        allowed to be modified?
*     FINE = REAL (Given) 
*        Determines how closely spaced the radii are to be.
*     LIM1 = REAL (Given)
*        Defines how large an upward fluctuation in the ellipse mean count
*        value may be tolerated between adjacent radii.
*     LIM2 = REAL (Given)
*        Defines a lower limit of ellipse mean count value at which point the
*        ellipse fitting is terminated.        
*     LIM3 = REAL (Given)
*        The ellipse radius value at which the position angle, ellipticity
*        and origin are frozen. If the value is less than or equal to zero
*        not such cutoff is applied. Units pixels.
*     FRACT = REAL (Given)
*        Proportion of points within an ellipse that must be valid for 
*        the result for that radius to be retained.
*     PSIZE = REAL (Given)
*        The pixel size. Units arc secs.
*     FAST = LOGICAL (Given)
*        Use the faster method of interpolating data points at low radii?
*     RLIM = REAL (Given)
*        The maximum distance from the origin at which profiling 
*        takes place.
*     BACK = REAL (Given)
*        The background count for the image. Units counts.
*     SIGMA = REAL (Given)
*        Standard deviation value of BACK. Units counts.
*     ELEMS = INTEGER (Given)
*        Number of elements/pixels in the image array. Units pixels.
*     ARRP(1) = INTEGER (Given)
*        Pointer to the image array.
*     PRANGE(2) = INTEGER (Given)
*        Length of the X and Y axes of the image. Units pixels.
*     XCO = REAL (Given)
*        X index of the galaxy centre/origin supplied by the user.
*        Units pixels.
*     YCO = REAL (Given)
*        Y index of the galaxy centre/origin supplied by the user.
*        Units pixels.
*     VALIDP = INTEGER (Returned)
*        Number of valid radius fits stored.
*     RESULT(ELP__NRES,ELP__RESUL) = REAL (Returned)
*        Fitted ellipse parameters.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)
*     NG: Norman Gray (Starlink, Glasgow)

*  History:
*     20-Mar-1993 (GJP)
*     (Original version)
*     20-FEB-1997 (GJP)
*     Removed improper use of INTEGER as LOGICAL.
*     18 Aug 1998 (NG)
*     Changed calls to elp1_stats to use newer version.

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'elp_par'               ! ELLPRO constants

*  Status:
      INTEGER STATUS                  ! Global status

*  Arguments Given:
      INTEGER ARRP(1)                 ! The image array pointer
      INTEGER DMODE                   ! Is a display to be generated
      INTEGER MINMOD                  ! Which minimisation statistic to use
      LOGICAL ANGCON                  ! Angular rotation convention
      LOGICAL FAST                    ! Use fast method of profiling?
      LOGICAL FRZORI                  ! Frozen galaxy origin?
      LOGICAL STOP                    ! Should the profiling stop
      INTEGER ELEMS                   ! Number of pixels in the image
      INTEGER PRANGE(2)               ! Image size
      REAL ANGOFF                     ! Angular offset for output
                                      ! position angles
      REAL BACK                       ! Background count value
      REAL FINE                       ! Radii separation factor
      REAL FRACT                      ! Proportion of points in an
                                      ! ellipse that must be valid for the
                                      ! result to be retained
      REAL LIM1                       ! Count increase limit factor
      REAL LIM2                       ! Determines lower count limit
      REAL LIM3                       ! Radius at which the parameters 
                                      ! are frozen
      REAL PSIZE                      ! Pixel size
      REAL RLIM                       ! Maximum ellipse radius used
      REAL SIGMA                      ! Std. dev. of BACK
      REAL XCO                        ! X co-ordinate of the object
      REAL YCO                        ! Y co-ordinate of the object

*  Arguments Returned:
      INTEGER VALIDP                  ! Number of valid radius fits
      REAL RESULT(ELP__NRES,ELP__RESUL)      ! Ellipse parameters

*  Arguments Given and Returned:

*  Local variables:
      LOGICAL FIRST                   ! Is this the first profile?
      LOGICAL ONCE                    ! Permit a reduction in radius only once
      CHARACTER *(80) TEXT            ! An output message token
      INTEGER CHANGE                  ! Was a parameter changed at all?
      INTEGER FLAG                    ! Was the interpolation successful?
      INTEGER FOUND                   ! Number of ellipse points for
                                      ! which a value was found
      INTEGER I                       ! Miscellaneous loop
      INTEGER J                       ! Miscellaneous counter
      INTEGER K                       ! Miscellaneous counter
      INTEGER LOOPMAX                 ! The maximum number of attempts
                                      ! to fit a given radius
      INTEGER NUMPOI                  ! Number of pixels in the current
                                      ! 'fit' ellipse
      INTEGER TRYS                    ! Number of times a fit parameter
                                      ! is changed before the next
                                      ! parameter is considered
      INTEGER STRYS                   ! Above but only counting those
                                      ! occasions on which a sensible fit
                                      ! was obtained
      INTEGER USED(ELP__MXPOI)        ! Was an ellipse point used
      REAL ANGL(ELP__MXPOI)           ! Position angle of each ellipse point
      REAL ANGLE                      ! Current position angle
      REAL CURX                       ! Current X co-ord
      REAL CURY                       ! Current Y co-ord
      REAL DIS(ELP__MXPOI)            ! Distance of each ellipse point from
                                      ! the ellipse origin
      REAL EGUESS                     ! Initial ellipticity value
      REAL ELL                        ! Temporary ellipticity value
      REAL ELLIP                      ! Current ellipticity value
      REAL FACT                       ! Multiplying factor
      REAL HIGH                       ! Highest residual value found for
                                      ! the 'fit' loop
      REAL LOOPS                      ! Loops counter for the number of
                                      ! iterations at a given radius
      REAL MEAN                       ! Mean pixel count for current ellipse
      REAL MINANG                     ! Lower limit of the position angle rang
      REAL MINELL                     ! Minimum ellipticity permitted
      REAL MAXELL                     ! Maximum ellipticty permitted
      REAL MAX                        ! A temporary value
      REAL MIN                        ! A temporary value
      REAL MAXANG                     ! Upper limit of the position angle rang
      REAL PAR(20)                    ! Latest values for a given parameter
      REAL PAR2(20)                   ! Latest values for a given parameter
      REAL PGUESS                     ! Initial position angle value
      REAL POSANG                     ! Position angle of the object
      REAL RADIUS                     ! Ellipse radius currently in use
      REAL RANGE                      ! Temporary value
      REAL RES(20)                    ! Residuals at parameter values given
                                      ! by PAR
      REAL RESID                      ! Ellipse 'fit' residuals
      REAL RND                        ! A random number
      REAL SDP                        ! Standard deviation of the points on
                                      ! the 'fit' ellipse
      REAL STAT                       ! Statistic returned from elp1_stats
      REAL TEMP                       ! Temporary value
      REAL VA(ELP__MXPOI)             ! Interpolated values of the pixels
                                      ! at the required points of the 'fit'
                                      ! ellipse
      REAL X                          ! Current X co-ordinate
      REAL XCH                        ! Amount by which X co-ord may
                                      ! be varied
      REAL XR(ELP__MXPOI)             ! X co-ord for the translated ellipse
      REAL XCHS                       ! Initial value of XCH
      REAL Y                          ! Current Y co-ordinate
      REAL YCH                        ! Amount by which Y co-ord may
                                      ! be varied
      REAL YCHS                       ! Initial value of YCH
      REAL YR(ELP__MXPOI)             ! X co-ord for the translated ellipse
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Initialize housekeeping variables.
      VALIDP=0
      LOOPMAX=75
      STOP=.FALSE.
      
*   Set the once only radius reduction flag. 
      ONCE=.TRUE.

*   Set up the initial X and Y ellipse origin.
      X=XCO
      Y=YCO
     
*   Get an estimate for the first position angle, radius and
*   ellipticity values to try. retain the initial value of radius
*   for later use.
      CALL ELP1_GUESS(DMODE,ANGCON,SIGMA,BACK,X,Y,ELEMS,
     :                %VAL(ARRP(1)),PRANGE,POSANG,RADIUS,ELLIP,STATUS)
      EGUESS=ELLIP
      PGUESS=POSANG
     
*   Loop round until the radius has become too large or the outer edge
*   of the galaxy has been detected.
      FIRST=.TRUE.
      DO WHILE (((RADIUS.LT.RLIM).OR.(FIRST)).AND.(.NOT.STOP))

*      Clear the first profile flag.
         FIRST=.FALSE.

*      Initialize loop counter.
         LOOPS=0

*      Set up the initial parameter values. Use previous values as a guide.
         IF (VALIDP.GT.1) THEN

            IF (RESULT(4,VALIDP-1).GT.RESULT(4,1)) THEN

*            For radii larger than the first.    
               X=(RESULT(1,VALIDP)+RESULT(1,VALIDP-1))/2.
               Y=(RESULT(2,VALIDP)+RESULT(2,VALIDP-1))/2.

               IF(RESULT(4,VALIDP).LT.RESULT(4,1)) THEN
                  ELLIP=(EGUESS+RESULT(3,VALIDP-1)+ELLIP)/3.
                  POSANG=(PGUESS+RESULT(5,VALIDP-1)+POSANG)/3.
               ELSE
                  ELLIP=(RESULT(3,VALIDP-1)+ELLIP)/2.
                  POSANG=(RESULT(5,VALIDP-1)+POSANG)/2.
              END IF

            ELSE

*            For radii smaller than the first.    
               X=RESULT(1,1)
               Y=RESULT(2,1)
               ELLIP=(RESULT(3,1)+EGUESS)/2.
               POSANG=(RESULT(5,1)+PGUESS)/2.

            END IF

         END IF

*      Set sensible ellipticity limits.
         IF (ELLIP.LT.0.1) ELLIP=0.1
         IF (ELLIP.GT.0.9) ELLIP=0.9
  
*      Assign the current values of the parameters and skip the iterative
*      search if the radius has exceeded the value at which position angle,
*      centre and ellipticity are no longer changed.
         IF ((RADIUS.GE.LIM3).AND.(LIM3.GT.ELP__VSMAL)) THEN 

            CHANGE=1

         ELSE

*         Perform the iterative search for a minimum value for the scatter
*         of the pixel points found around the ellipse.

*         Initialise the number of angles etc that will be tried per loop,
*         the number of loops that will be allowed at a given radius, the
*         angular range over which position may vary and the permitted
*         initial spread of values permitted for the variation of ellipticity,
*         X and Y.
            IF (VALIDP.EQ.0) THEN

*            First profile generated at a given radius.
               TRYS=20
               LOOPMAX=60
               MINANG=POSANG-22.5
               MAXANG=POSANG+22.5
               MINELL=ELLIP-.25
               MAXELL=ELLIP+.25
               XCHS=.5
               YCHS=.5

            ELSE

*            Subsequent profiles at the current radius.
               TRYS=10
               LOOPMAX=10
               MINANG=POSANG-5.
               MAXANG=POSANG+5.
               MINELL=ELLIP-.1
               MAXELL=ELLIP+.1
               XCHS=.1
               YCHS=.1

            END IF

*         Generate the the points on an untransformed
*         un/rotated version of the current 'fit' ellipse.
            CALL ELP1_GENER(ELLIP,RADIUS,NUMPOI,ANGL,DIS,STATUS)

*         Set a flag to show that during the loops one of the
*         parameters did change.
            CHANGE=0

            DO WHILE (LOOPS.LT.LOOPMAX)
           
*            Set up the current amounts by which fit parameters
*            may be adjusted.
               FACT=(1.-.5*REAL(LOOPS)/REAL(LOOPMAX))
               XCH=XCHS*FACT
               YCH=YCHS*FACT

*            Ensure the ellipticity range is within .01 to .99
               IF (MINELL.LT.0.01) MINELL=.01
               IF (MINELL.GT.0.98) MINELL=.98
               IF (MAXELL.GT.0.99) MAXELL=.99
               IF (MAXELL.LT.0.02) MAXELL=.02       

*            VARY THE POSITION ANGLE

*            Translate/rotate the raw 'fit' ellipse co-ordinates to generate 
*            their positions on the image. Then examine the 
*            pixel count value at each and determine some measure of their 
*            variation. Repeat varying position angle.
               STRYS=0
               DO 40 I=1,TRYS

*               Generate an angle value within the allowed range.
                  ANGLE=MINANG+(I-1)*(MAXANG-MINANG)/(TRYS-1)
                  CALL ELP1_ROTAT(X,Y,DIS,ANGL,ANGLE,NUMPOI,
     :                            XR,YR,STATUS)
                  CALL ELP1_STATS(FAST,MINMOD,
     :                 RADIUS,ELEMS,ARRP,XR,YR,NUMPOI,
     :                 FRACT,PRANGE,USED,MEAN,SDP,RESID,FLAG,
     :                 VA,FOUND,STAT,STATUS)
                  
*               Update the residuals record if required.
                  IF (FLAG.EQ.0) THEN
                     STRYS=STRYS+1
                     PAR(STRYS)=ANGLE
                     RES(STRYS)=RESID
                  END IF

 40            CONTINUE

*            Look at the residuals of the fit attempts made by varying
*            position angle and choose the best value to discard.
               IF (STRYS.GT.5) THEN

                  CHANGE=1
                  J=0
                  MAX=-ELP__VBIG
                  K=0
                  MIN=ELP__VBIG
                  DO 45 I=2,STRYS-1

*                  Find the largest and smallest residuals.
                     TEMP=RES(I-1)+RES(I)+RES(I+1)
                     IF (TEMP.GT.MAX) THEN
                        MAX=TEMP
                        J=I
                     END IF
                     IF (TEMP.LT.MIN) THEN
                        MIN=TEMP
                        K=I
                     END IF
                  
 45               CONTINUE

*               Modify the bounds within which position angle will
*               be varied in future.
                  IF (J.NE.0) THEN
                     IF (PAR(J).GE.POSANG) THEN
                        MAXANG=(PAR(STRYS-1)+PAR(STRYS))/2.
                     ELSE
                        MINANG=(PAR(1)+PAR(2))/2.
                     END IF
                     RANGE=MAXANG-MINANG
                  END IF
                  IF (K.NE.0) POSANG=(PAR(K)+POSANG)/2.
                  MINANG=POSANG-RANGE/2.
                  MAXANG=POSANG+RANGE/2.
               
               END IF

*            VARY THE X AND Y CO_ORDINATES
*            Only performed if the galaxy origin has not been frozen
*            via input parameter FRZORI.

               IF (.NOT.FRZORI) THEN

*               Translate/rotate the raw 'fit' ellipse co-ordinates to 
*               generate the actual positions of ellipse points on the image. 
*               Then examine the pixel count value at each and determine 
*               some measure of their variation. Repeat varying x and y.
                  STRYS=0
                  DO 20 I=1,TRYS

*                  Make sure the previous best guess is considered.
                     IF (I.EQ.1) THEN

*                     Previous X/Y values.
                        CURX=X
                        CURY=Y

                     ELSE

*                     Generate an X/Y value within the allowed range.
                        CALL ELP1_RAND(1,0,RND,STATUS)
                        CURX=X+(RND-.5)*XCH
                        CALL ELP1_RAND(1,0,RND,STATUS)
                        CURY=Y+(RND-.5)*YCHS

                     END IF

                     CALL ELP1_ROTAT(CURX,CURY,DIS,ANGL,ANGLE,NUMPOI,
     :                               XR,YR,STATUS)
                     CALL ELP1_STATS(FAST,MINMOD,
     :                    RADIUS,ELEMS,ARRP,XR,YR,
     :                    NUMPOI,FRACT,PRANGE,USED,MEAN,SDP,
     :                    RESID,FLAG,VA,FOUND,STAT,STATUS)

*                  Update the residuals record if required.
                     IF (FLAG.EQ.0) THEN
                        STRYS=STRYS+1
                        PAR(STRYS)=CURX
                        PAR2(STRYS)=CURY
                        RES(STRYS)=RESID
                     END IF

 20               CONTINUE

*               Look at the residuals of the fit attempts made by varying
*               x/y co-ordinate and choose the best value to retain.
                  IF (STRYS.GT.5) THEN

                     CHANGE=1
                     J=0
                     HIGH=ELP__VBIG
                     DO 25 I=1,STRYS

*                     Find the smallest residual.
                        IF (RES(I).LT.HIGH) THEN
                           J=I
                           HIGH=RES(I)
                        END IF

 25                  CONTINUE
                     IF (J.NE.0) THEN
                        X=PAR(J)
                        Y=PAR2(J)
                     END IF

                  END IF

               END IF

*            VARY THE ELLIPTICITY

*            Generate the co-ordinates of points of a 'raw' ellipse. Then
*            rotate/translate the co-ordinates to generate the position of  
*            the points on the image. Examine the pixel count value at each
*            and determine their variation. Repeat varying ellipticity.
               STRYS=0
               DO 10 I=1,TRYS

*               Generate an angle value within the allowed range.
                  ELL=MINELL+(I-1)*(MAXELL-MINELL)/(TRYS-1)

                  CALL ELP1_GENER(ELL,RADIUS,NUMPOI,ANGL,
     :                            DIS,STATUS)
                  CALL ELP1_ROTAT(X,Y,DIS,ANGL,POSANG,NUMPOI,
     :                            XR,YR,STATUS)
                  CALL ELP1_STATS(FAST,MINMOD,
     :                 RADIUS,ELEMS,ARRP,XR,YR,NUMPOI,
     :                 FRACT,PRANGE,USED,MEAN,SDP,RESID,FLAG,
     :                 VA,FOUND,STAT,STATUS)

*               Update the residuals record if required.
                  IF (FLAG.EQ.0) THEN
                     STRYS=STRYS+1
                     PAR(STRYS)=ELL
                     RES(STRYS)=RESID
                  END IF

 10            CONTINUE

*            Look at the residuals of the fit attempts made by varying
*            ellipticity and choose the best value to discard.
               IF (STRYS.GT.5) THEN

                  J=0
                  MAX=-ELP__VBIG
                  K=0
                  MIN=ELP__VBIG
                  DO 55 I=2,STRYS-1

*                  Find the largest and smallest residuals.
                     TEMP=RES(I-1)+RES(I)+RES(I+1)
                     IF (TEMP.GT.MAX) THEN
                        MAX=TEMP
                        J=I
                     END IF
                     IF (TEMP.LT.MIN) THEN
                        MIN=TEMP
                        K=I
                     END IF
                 
 55               CONTINUE

*               Modify the bounds within which ellipticity will
*               be varied in future.
                  IF (J.NE.0) THEN
                     CHANGE=1
                     IF (PAR(J).GE.ELLIP) THEN
                        MAXELL=(PAR(STRYS-1)+PAR(STRYS))/2.
                        IF (K.EQ.2) MINELL=MINELL-(PAR(2)-PAR(1))
                     ELSE
                        MINELL=(PAR(1)+PAR(2))/2.
                        IF (K.EQ.STRYS-1) MAXELL=MAXELL+(PAR(2)-PAR(1))
                     END IF
                     RANGE=MAXELL-MINELL
                  END IF
                  IF (K.NE.0) ELLIP=(PAR(K)+ELLIP)/2.
                  MINELL=ELLIP-RANGE/2.
                  MAXELL=ELLIP+RANGE/2.
               
               END IF

               LOOPS=LOOPS+1

            END DO

         END IF

*      Generate the positions of all the points on an untransformed
*      /unrotated version of the current 'fit' ellipse.
         CALL ELP1_GENER(ELLIP,RADIUS,NUMPOI,ANGL,DIS,STATUS)
         CALL ELP1_ROTAT(X,Y,DIS,ANGL,POSANG,NUMPOI,XR,YR,STATUS)
         CALL ELP1_STATS(FAST,MINMOD,RADIUS,ELEMS,ARRP,XR,YR,NUMPOI,
     :                   FRACT,PRANGE,USED,MEAN,SDP,RESID,FLAG,
     :                   VA,FOUND,STAT,STATUS)

*      Store the results for the current radius value. Should not be done if
*      nothing changed. Not likely in the real world except when LIM3 is being
*      used i.e. parameter modification being turned off at large radii.
         IF ((CHANGE.NE.0).AND.(MEAN-BACK.GT.0.0)
     :                    .AND.(FLAG.EQ.0)) THEN

*         Increment valid fit counter.
            VALIDP=VALIDP+1

*       Determine the Fourier descriptors.
            CALL ELP1_FOUR(NUMPOI,BACK,VALIDP,XR,YR,VA,X,Y,
     :                     POSANG,ELLIP,RESULT,STATUS)

*         Assign results values.
            RESULT(1,VALIDP)=X
            RESULT(2,VALIDP)=Y
            RESULT(3,VALIDP)=ELLIP
            RESULT(4,VALIDP)=RADIUS
            RESULT(5,VALIDP)=POSANG
            RESULT(6,VALIDP)=MEAN-BACK
            RESULT(7,VALIDP)=SDP
            RESULT(8,VALIDP)=REAL(NUMPOI)
            RESULT(9,VALIDP)=100.*REAL(FOUND)/REAL(NUMPOI)
            RESULT(ELP__STAT,VALIDP)=STAT
            
*         Display the results in suitably formatted form (if required).
*         Graphics screen display radii values are equivalent radii.
            IF (DMODE.GT.0) THEN
               CALL MSG_FMTR('X','F6.1',X)
               CALL MSG_FMTR('Y','F6.1',Y)
               CALL MSG_FMTI('N','I3',NUMPOI)
               TEMP=PSIZE*SQRT(RADIUS*RADIUS*ELLIP)
               CALL MSG_FMTR('RAD','F8.2',TEMP)
               CALL MSG_FMTR('VAL','F9.1',MEAN-BACK)
               IF (ANGCON) THEN
                  TEMP=POSANG+ANGOFF
               ELSE
                  TEMP=-POSANG+ANGOFF
               END IF
               CALL MSG_FMTR('POS','F6.1',TEMP)
               CALL MSG_FMTR('ELL','F5.3',ELLIP)
               CALL MSG_FMTR('DEV','F7.1',SDP)
               CALL MSG_FMTR('POI','F4.0',RESULT(9,VALIDP))
               CALL MSG_FMTR('STAT','E9.2',STAT)
c               TEXT='^X  ^Y    ^N   ^RAD  ^VAL ^POS    ^ELL'//
c     :              '^DEV   ^POI  ^STAT'
               TEXT='^X  ^Y   ^N  ^RAD  ^VAL ^POS  ^ELL'//
     :              '^DEV  ^POI ^STAT'
               CALL MSG_OUT(' ',TEXT,STATUS)
            END IF
         
         END IF

*      After the first radius has been examined successfully, go to
*      smaller radii. Also, allow for second point to be duff.
         IF ((VALIDP.EQ.1).AND.(CHANGE.NE.0).AND.(RADIUS.GT.0.501)
     :        .AND.(ONCE)) THEN 
            RADIUS=0.5
            ONCE=.FALSE.
         ELSE
*         Increase the ellipse radius.
            TEMP=0.25
            IF (RADIUS.GT.1.0) TEMP=0.5
            IF (RADIUS.GT.2.0) TEMP=1.0 
            IF (RADIUS.GT.10.0) TEMP=1.5 
            IF (RADIUS.GT.20.0) TEMP=2.0
            IF (RADIUS.GT.30.0) TEMP=2.5
            RADIUS=RADIUS+TEMP*FINE


*         Decrease the ellipse radius if it has not been previously tried.
*         Otherwise abort.
            IF(RADIUS.GE.RLIM) THEN 
               IF(ONCE)THEN
                  RADIUS=0.5
                  ONCE=.FALSE.
               ELSE
                  STOP=.TRUE.
               END IF              
            ENDIF
         END IF
            

*      Test to see if the profiling should stop.
         IF (VALIDP.GT.4) THEN
             
            IF ((MEAN.LE.BACK).AND.(FLAG.EQ.0)) THEN

*           Mean count for the ellipse is below sky.
               STOP=.TRUE.
               VALIDP=VALIDP-1
               IF (DMODE.GT.0) THEN
                  CALL MSG_BLANK(STATUS)
                  CALL MSG_OUT(' ',
     :                 'Mean count below background.',STATUS)
                  CALL MSG_BLANK(STATUS)
               END IF

            ELSE

              TEMP=(RESULT(6,VALIDP-1)+RESULT(6,VALIDP-2))/2.
              IF (((MEAN-BACK)/TEMP.GT.LIM1).AND.(FLAG.EQ.0)) THEN

*              Mean count has risen too quickly.
                 STOP=.TRUE.
                 IF (DMODE.GT.0) THEN
                    CALL MSG_BLANK(STATUS)
                    CALL MSG_OUT(' ',
     :                   'Mean count varying beyond LIM1.',STATUS)
                    CALL MSG_BLANK(STATUS)
                 END IF

              END IF

              IF ((MEAN-BACK.LT.SIGMA*LIM2).AND.(FLAG.EQ.0)) THEN

*              Mean count level below LIM2 threshold.
                  STOP=.TRUE. 
                  IF (DMODE.GT.0) THEN
                     CALL MSG_BLANK(STATUS)
                     CALL MSG_OUT(' ',
     :                    'Mean count below threshold LIM2.',STATUS)
                     CALL MSG_BLANK(STATUS)
                  END IF
              END IF      
            END IF
            
         END IF

      END DO

      IF (DMODE.GT.0) CALL MSG_BLANK(STATUS)

 9999 CONTINUE

      END


      SUBROUTINE ELP1_PRPCUR ( MNCHOI, SWCHOI, TERMES, NTERMS, IMGMES,
     :                    NIMGMS, BUTTNS, CURSOR, IMGDIS, STATUS )
*+
*    Description :
*
*     This determines whether a cursor with a suitable number of choices
*     is available on the current graphics device.  Messages are given
*     describing which buttons to press if the device is a terminal or
*     an image display.  The messages has parameters CHOICETERMn or
*     CHOICEIDn, where n is number of the message starting from 1.
*
*    Invocation :
*
*     CALL ELP1_PRPCUR( MNCHOI, SWCHOI, TERMES, NTERMS, IMGMES,
*    :             NIMGMS, BUTTNS, CURSOR, IMGDIS, STATUS )
*
*    Parameters :
*
*     MNCHOI=INTEGER (Given)
*        The minimum number of choices required by the calling
*          application.  It must be positive.
*     SWCHOI=INTEGER (Given)
*        The maximum number of choices for the graphics-device to be an
*          image display. It must be at least %MNCHOI.
*     TERMES( NTERMS )=CHARACTER (Given)
*        Description of which terminal buttons to press to obtain the
*          various choices, to be reported to the user if the device
*          is nominally a terminal, i.e. its number of choices exceeds
*          %SWCHOI.
*     NTERMS=INTEGER (Given)
*        Number of lines describing the action of the terminal choices.
*     IMGMES( NIMGMS )=CHARACTER (Given)
*        Description of the action of the mouse or trackerball buttons
*          to be reported to the user if the device is nominally an
*          image display, i.e. its number of choices is less than or
*          equal to %SWCHOI.
*     NIMGMS=INTEGER (Given)
*        Number of lines describing the action of the image-display
*          choices.
*     BUTTNS=CHARACTER (Given)
*        The terminal buttons to be pressed to obtain the different
*          choices, e.g. '1A.' would mean '1' would give the first
*          choice, 'A' would the second and '.' to exit. A fullstop
*          is the recommended Starlink method for terminating such an
*          interaction.  The last character is assumed to be the exit
*          choice in cases where this string is longer than the number
*          of choices plus one (the exit). 
*          characters.  There must be at least %MNCHOI+1 characters.
*          This string is ignored if the device is an image display.
*     CURSOR=LOGICAL (Returned)
*        If true there is a suitable cursor and number of choices.
*     IMGDIS=LOGICAL (Returned)
*        If true the choice device is an image-display mouse or
*          trackerball
*     DEVICE=DEVICE (Given)
*        The graphics workstation.
*
*    Arguments :
*
*     STATUS=INTEGER (Given and Returned)
*        The global status.
*
*    Method :
*
*     If status is bad then exit
*     Validate input data
*     Determine the number of options on the workstation's choice device
*     If the number of choices is less than specified minimum then
*       report error context and abort
*     Activate the cursor and specify the options depending on the
*       number of choices and set cursor-ready flag
*     End
*
*    Bugs :
*
*     None known. 
*
*    Authors :
*
*     Malcolm J. Currie  STARLINK  (RAL::CUR)
*                     
*    History :
*
*     1989 Nov 10: Original version (RAL::CUR).
*
*    Type definitions :
      IMPLICIT NONE              ! No implicit typing

*    Global Constants :
      INCLUDE 'SAE_PAR'          ! Standard SAE constants

*    Import :
      INTEGER MNCHOI             ! Minimum number of choices
      INTEGER SWCHOI             ! Maximum number fo choices if the
                                 ! device is to be classed as an image
                                 ! display
      INTEGER NTERMS             ! Number of lines of terminal messages
      INTEGER NIMGMS             ! Number of lines of image-display
                                 ! messages

      CHARACTER *(*) TERMES( NTERMS )
                                 ! Informational messages if device is
                                 ! a terminal
      CHARACTER *(*) IMGMES( NTERMS )
                                 ! Informational messages if device is
                                 ! an image display
      CHARACTER *(*) BUTTNS      ! Choices buttons for a terminal.

*    Export :
      LOGICAL CURSOR             ! Device has a sutiable cursor and
                                 ! choices
      LOGICAL IMGDIS             ! Device is an image-display for the
                                 ! purpose of using the cursor

*    Status :
      INTEGER STATUS             ! Global status

*    External references :
      INTEGER
     :  CHR_LEN

*    Local variables :
      CHARACTER*80 BUTLST        ! List of buttons which may be a
                                 ! trimmed version of the input list
      CHARACTER DATREC(10)*80    ! Data record return by GKS inquiry

      INTEGER CONID              ! Connection identifier
      INTEGER GSTAT              ! Graphics status
      INTEGER I                  ! Loop index
      CHARACTER*4 IC             ! Message counter
      CHARACTER*14 LABEL         ! Informational-message parameter
      INTEGER LDR                ! Length of data record returned by
                                 ! GKS inquiry
      INTEGER MALT               ! Number of alternatives for choice
                                 ! input on graphics device
      INTEGER NC                 ! Number of characters in a string
      INTEGER OL                 ! Number of available prompt/echo types
                                 ! for graphics device
      INTEGER PET                ! Element of prompt/echo types of
                                 ! device returned by GKS inquiry
      INTEGER WKID               ! GKS workstation identifier
      INTEGER WTYPE              ! Workstation type

      REAL EAREA( 4 )            ! Graphics device echo area

                                 ! True if:
      LOGICAL CURAVA             ! A cursor is available

*-

*    Check inherited global status.

      IF ( STATUS .NE. SAI__OK ) RETURN

      CURSOR=.FALSE.
      IMGDIS=.FALSE.
      
*    Validate input data.

      IF ( MNCHOI .LT. 1 .OR. SWCHOI .LT. MNCHOI ) THEN
         STATUS=SAI__ERROR
         CALL ERR_REP( 'PRPCUR__PROG',
     :     'PRPCUR: Programmer error.  Check calling arguments',
     :      STATUS )
         GOTO 999
      END IF
 
*    Put out a blank line to ensure the commentary appears on the alpha
*    plane of the terminal.

      CALL MSG_OUT( 'BLANK', ' ', STATUS )

*    Is there a cursor?

      CURAVA=.FALSE.
      CALL SGS_ICUAV( CURAVA )

      IF ( .NOT. CURAVA ) THEN
         STATUS=SAI__ERROR
         CALL ERR_REP( 'PRPCUR__NOCUR',
     :     'PRPCUR: Chosen workstation does not have a cursor.',
     :     STATUS )

         GOTO 999
      END IF

      CALL SGS_ICURW( WKID )

*    Find workstation type

      CALL GQWKC( WKID, GSTAT, CONID, WTYPE )

*    Find number of options on choice device

      CALL GQDCH( WTYPE, 1, 1, 10, GSTAT, MALT, OL, PET, EAREA, LDR,
     :            DATREC )

*    At least one choice required

      IF ( MALT .LT. MNCHOI ) THEN
         STATUS=SAI__ERROR
         CALL ERR_REP( 'PRPCUR__WDV',
     :     'PRPCUR: Graphics device chosen has unsuitable choice '/
     :     /'device (e.g. mouse or trackerball) for this application.',
     :     STATUS )

         GOTO 999

*       Tell the user what to do...

      ELSE IF ( MALT .LE. SWCHOI ) THEN

*       first for an image display with a few buttons, and...

         DO  I=1, NIMGMS
            CALL MSG_SETC( 'IMGMSG', IMGMES( I ) )
            CALL CHR_ITOC( I, IC, NC )
            LABEL='CHOICEID'//IC( :NC )

            CALL MSG_OUT( LABEL, '^IMGMSG', STATUS )
         END DO

*       Set the flag to say the cursor is ready for use.

         CURSOR=.TRUE.

*       Nominally an image display.

         IMGDIS=.FALSE.
      ELSE

*       a terminal with many choices.

*       First validate list of buttons.

         NC=CHR_LEN( BUTTNS )
         IF ( NC .LT. MNCHOI ) THEN
            STATUS=SAI__ERROR
            CALL ERR_REP( 'PRPCUR__PROG',
     :        'PRPCUR: Programmer error.  Check calling arguments',
     :         STATUS )
            GOTO 999
         END IF
 
*       Trim the button list if necessary.

         IF ( NC .GT. MALT + 1 ) THEN
            BUTLST=BUTTNS( :MNCHOI ) //BUTTNS( NC:NC )
         ELSE
            BUTLST=BUTTNS
         END IF

*       Ensure that the messages below appear before activating the
*       cursor, otherwise they may appear on the graphics plane instead
*       of the alpha plane. This is a two-part operation. First we
*       need to give time to switch to the alpha plane.
      
         CALL MSG_SYNC( STATUS )

         DO  I=1, NTERMS
            CALL MSG_SETC( 'TERMSG', TERMES( I ) )
            CALL CHR_ITOC( I, IC, NC )
            LABEL='CHOICETERM'//IC( :NC )

            CALL MSG_OUT( LABEL, '^TERMSG', STATUS )
         END DO

*       The part is to wait for the messages to appear before returning
*       to graphics plane.
      
         CALL MSG_SYNC( STATUS )

*       Activate the cursor

         CALL SGS_CUVIS( .TRUE. )
         CALL SGS_SELCH( 0 )
         CALL SGS_DEFCH( BUTLST )

*       Set the flag to say the cursor is ready for use.

         CURSOR=.TRUE.
      END IF

 999  CONTINUE

      END


      SUBROUTINE ELP1_ROTAT(X,Y,DIS,ANGL,POSANG,NUMPOI,
     :                      XR,YR,STATUS)
*+
*  Name:
*     ELP1_ROTAT

*  Purpose:
*     Takes the angle/and distance values provided and generates co-ordinates
*     for an ellipse of the same size/ellipticity if it had been
*     rotated about its origin and then translated away from a 0,0
*     origin to that required on the image.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_ROTAT(X,Y,DIS,ANGL,POSANG,NUMPOI,XR,YR,STATUS)

*  Description:
*     For each of the ellipse points in turn it determines the new angle of 
*     the point relative to the origin. This and the distance
*     from the origin, are employed to calculate the new position of the point
*     when translated/rotated about the new origin.

*  Arguments:
*     X = REAL (Given)
*        X co-ordinate of the required ellipse centre. Units pixels.
*     Y = REAL (Given)
*        Y co-ordinate of the required ellipse centre. Units pixels.
*     DIS(ELP__MXPOI) = REAL (Given)
*        Distance of the ellipse points from the origin.
*     ANGL(ELP__MXPOI) = REAL (Given)
*        Position angle of each of the ellipse points.
*     POSANG = REAL (Given)
*        Position angle of the ellipse required.
*     NUMPOI = INTEGER (Given)
*        Number of points in the 'fit' ellipse.
*     XR(ELP__MXPOI) = REAL (Returned)
*        X co-ordinate of the ellipse points after rotation/translation.
*     YR(ELP__MXPOI) = REAL (Returned)
*        Y co-ordinate of the ellipse points after rotation/translation.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     26-Mar-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'elp_par'               ! ELLPRO constants

*  Status:
      INTEGER STATUS                  ! Global status

*  Arguments Given:
      INTEGER NUMPOI                  ! The number of points in the current
                                      ! 'fit' ellipse
      REAL ANGL(ELP__MXPOI)           ! Angle of the ellipse points  
                                      ! before rotation
      REAL DIS(ELP__MXPOI)            ! Distance from the ellipse centre
      REAL POSANG                     ! Position angle required for the
                                      ! ellipse
      REAL X                          ! X co-ordinate to which the ellipse
                                      ! origin is to be shifted
      REAL Y                          ! Y co-ordinate to which the ellipse
                                      ! origin is to be shifted

*  Arguments Returned:
      REAL XR(ELP__MXPOI)             ! X co-ord for the translated ellipse
      REAL YR(ELP__MXPOI)             ! Y co-ord for the translated ellipse

*  Arguments Given and Returned:

*  Local variables:
      INTEGER I                       ! Loop variable
      REAL ANGLER                     ! Angle of the point relative to
                                      ! origin after rotation
      REAL CURANG                     ! The position angle expressed in
                                      ! radians
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Setup useful constants.
      CURANG=POSANG*ELP__PI2360

*   For all the ellipse points in turn.
      DO 10 I=1,NUMPOI

*      Calculate the resultant angle.
         ANGLER=ANGL(I)+CURANG

*      Translate and apply rotation to the current point.
*      Save the result.
         XR(I)=X+DIS(I)*SIN(ANGLER)
         YR(I)=Y+DIS(I)*COS(ANGLER)

 10   CONTINUE

 9999 CONTINUE

      END


      SUBROUTINE ELP1_STATS(FAST,RTYPE,RADIUS,ELEMS,ARRP,XR,YR,NUMPOI,
     :                      FRACT,PRANGE,USED,MEAN,SDP,RESID,FLAG,
     :                      VA,FOUND,STAT,STATUS)
*+
*  Name:
*     ELP1_STATS

*  Purpose:
*     Looks at the co-ordinates of the ellipse currently being considered and
*     determines what the image pixel value is associated with each image
*     location.
*
*     The values found are used to determine the standard deviation of
*     the ellipse points (ideally should be zero). This and the residual
*     value may be used to determine whether the current ellipse parameters
*     yield a better fit (lower resiudual) than those used previously.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_STATS(FAST,RTYPE,RADIUS,ELEMS,ARRP,XR,YR,NUMPOI,
*                     FRACT,PRANGE,USED,MEAN,SDP,RESID,FLAG,
*                     VA,FOUND,STAT,STATUS

*  Description:
*     Using interpolation, the values associated with all the
*     ellipse fit points (contained in arrays XR and YR) are obtained.
*
*     If the FAST parameter has been passed with a TRUE value then all 
*     pixel count values are obtained by bi-linear interpolation.
*     Otherwise, for small radii (radius <= 3 pixels) two routines are
*     used to model the surface of the image. One requires a full 8x8 
*     mesh, the other as many points as possible from the mesh. The mesh is
*     centred on the object of interest. These methods are substantially
*     slower. The second is only used if the first failed to find a complete
*     set of mesh points due to bad points or the object being near the 
*     edge of the image.
*
*     These are then used to calculate an estimate of the mean pixel
*     count in the ellipse (returned in MEAN), the standard deviation
*     thereof and some weighted measure of the overall fit residuals.
*
*     The type of residual to be calculated is specified by RTYPE, which
*     should be one of ELP__RESxxx specified in elp_par.  This also
*     controls which type of statistic is returned in STAT.  Having said
*     that, it's really not clear what is the best type of residual to
*     use.  The original one - a weighted standard error - is rational,
*     but not obviously ideal.  I've added here the range and the
*     squared-differences as alternatives, selectable by
*     RTYPE=elp__resmedian and elp__lsq respectively.  (Also, this
*     really shouldn't be called a `residual' - it's a statistic, but it
*     would be dangerous to try changing variable names).
*
*     An error message is returned if the values for too many points could
*     not be determined.
*
*
*     CALL ELP1_STATS(FAST,RTYPE,RADIUS,ELEMS,ARRP,XR,YR,NUMPOI,
*                     FRACT,PRANGE,USED,MEAN,SDP,RESID,FLAG,
*                     VA,FOUND,STAT,STATUS
*  Arguments:
*     FAST = LOGICAL (Given)
*        Is the faster method of interpolation to be employed?
*     RTYPE = INTEGER (Given)
*        Which RESID and STAT is the routine to calculate.
*     RADIUS = REAL (Given)
*        The radius of the ellipse. Units pixels.
*     ELEMS = INTEGER (Given)
*        Number of pixels in the image.
*     ARRP(1) = INTEGER (Given)
*        Pointer to the beginning of the image array.
*     XR(ELP__MXPOI) = REAL (Given)
*        X co-ordinates of the 'fit' ellipse points.
*     YR(ELP__MXPOI) = REAL (Given)
*        Y co-ordinates of the 'fit' ellipse points.
*     NUMPOI = INTEGER (Given)
*        Number of ellipse points for which co-ordinates have been calculated.
*     FRACT = REAL (Given)
*        Fraction of all of the ellipse points for which an interpolated value
*        must be derived if an ellipse is to be acceptable.
*     PRANGE(2) = INTEGER (Given)
*        Size of the image. Units pixels.
*     USED(ELP__MXPOI) = INTEGER (Returned)
*        Was a sensible value obtained for a given ellipse point via
*        interpolation?
*     MEAN = REAL (Returned)
*        Mean pixel value found around the ellipse. Units counts.
*     SDP = REAL (Returned)
*        Standard deviation of the MEAN. Units counts.
*     RESID = REAL (Returned)
*        A measure of the variation in pixel value around the ellipse.
*     FLAG = INTEGER (Returned)
*        Were pixel count values found for enough of the ellipse points.
*     VA(ELP__MXPOI) = REAL (Returned)
*        The values of image pixel count at the x/y co-ordinates of
*        the ellipse points defined by arrays XR() and YR().
*     FOUND = INTEGER (Returned)
*        The number of ellipse points used.
*     STAT = REAL (Returned)
*        Statistic appropriate to the type of residual.  See below.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)
*     NG: Norman Gray (Starlink, Glasgow)

*  History:
*     26-Mar-1993 (GJP)
*     (Original version)
*     18 Aug 1998 (NG)
*     Modified to calculate median as well as mean.  Also
*     altered calculation of sample SD, to avoid roundoff error
*     (probably not a big issue, but easy and safe)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'elp_par'               ! ELLPRO constants

*  Status:
      INTEGER STATUS                  ! Global status

*  Arguments Given:
      LOGICAL FAST                    ! Use the faster interpolation method
                                      ! throughout
      INTEGER RTYPE                   ! Which type of residual to calculate
      INTEGER ARRP(1)                 ! Image array pointer
      INTEGER ELEMS                   ! Number of pixels in the image
      INTEGER NUMPOI                  ! Number of points on the ellipse
      INTEGER PRANGE(2)               ! Size of the image
      INTEGER USED(ELP__MXPOI)        ! Was an ellipse point used
      REAL FRACT                      ! Fraction of the ellipse points
                                      ! that must be present for an
                                      ! acceptable fit
      REAL RADIUS                     ! Radius of the ellipse
      REAL XR(ELP__MXPOI)             ! X co-ord for the translated ellipse
      REAL YR(ELP__MXPOI)             ! Y co-ord for the translated ellipse

*  Arguments Returned:
      INTEGER FLAG                    ! Was a sensible residual obtained
      INTEGER FOUND                   ! Number of ellipse points for which
                                      ! a pixel count value was derived
      REAL MEAN                       ! Mean value of pixels around the
                                      ! 'fit' ellipse
      REAL STAT                       ! Statistic returned
      REAL RESID                      ! A weighted residuals value for
                                      ! fit
      REAL VA(ELP__MXPOI)             ! Pixel values at each of the required
                                      ! points on the 'fit' ellipse
      REAL SDP                        ! Standard deviation of MEAN

*  Arguments Given and Returned:

*  Local variables:
      INTEGER I                 ! Loop variable
      REAL SUMSQ                ! Sum of squares of deviation
      REAL SUMV                 ! sum of values
      REAL N                    ! =REAL(FOUND)
      REAL SQD                  ! Squared-difference

      INTEGER WS                ! The workspace
      INTEGER WSSIZE            ! Size of workspace given to elp1_median
      SAVE WS, WSSIZE
      DATA WSSIZE/-1/
      
*   Function
      REAL ELP1_MEDIAN          ! Returns median

*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Set the 'residuals not found' flag
      FLAG=1

*   Clear the pixel assigned a value flag.
      DO 5 I=1,NUMPOI
         USED(I)=0
 5    CONTINUE

*   Use spline  routines to construct a 2D surface and use that for
*   interpolating at small radii. Other wise use bi-linear interpolation.
      IF ((RADIUS.LE.3.26).AND.(.NOT.FAST)) THEN

*      Call the first interpolation system. Employs
*      pixels around that required. Full grid must be present
*      to suceed.
         CALL ELP1_INTER(ELEMS,%VAL(ARRP(1)),NUMPOI,XR,YR,PRANGE,USED,
     :                    VA,STATUS)

      ELSE
                   
*        Use bi-linear interpolation.
         CALL ELP1_INTER0(ELEMS,%VAL(ARRP(1)),NUMPOI,XR,YR,PRANGE,USED,
     :                    VA,STATUS)

      END IF

*   Calculate the mean pixel value around the ellipse and also the
*   number of points for which a value was interpolated successfully.
      FOUND=0
      SUMV=0.0
      SUMSQ=0.0
      DO 10 I=1,NUMPOI
         IF (USED(I).NE.0) THEN
*         Calculate the sum of VA and VA^2
            FOUND=FOUND+1
            SUMV=SUMV+VA(I)
            SUMSQ=SUMSQ+VA(I)**2
         END IF
 10   CONTINUE
      
      N = REAL(FOUND)

*   Only continue if enough 'fit' ellipse pixels have been assigned
*   interpolated count values.
      IF (N.GE.FRACT*NUMPOI/100.) THEN

*      Set enough points found flag.
         FLAG=0

*      Determine the mean value.
         MEAN=SUMV/N

*      Calculate the sample standard deviation (as distinct from the
*      distribution sd) using 
*      $S^2=\frac{n\sum^n X_i^2 - (\sum^n X_i)^2}{n(n-1)}$.  This is
*      equivalent to the definition $S^2=(\sum^n (X_i-\bar X)^2)/(n-1)$
*      but with less roundoff error.
         SQD = (N*SUMSQ-SUMV**2)/N
         SDP = SQRT (SQD/(N-1.))
*         SDP = SQRT( (N*SUMSQ-SUMV**2)/(N*(N-1.)))

*      Calculate the standard error in the mean ($S_{\bar X}=S/\sqrt n$).  
*      OK - we should use the t-distribution for this, but this'll be
*      accurate enough as long as N >~ 30 or so.
         SDP=SDP/SQRT(N)

*      Just before going in to calculate the residual, shove out a 
*      one-time message confirming which residual we're going to
*      calculate.  WSSIZE = -1 is the initial value - the test in
*      ELP__RESMD below depends simply on it being initialised negative.
         IF (WSSIZE .EQ. -1) THEN
            CALL MSG_BLANK (STATUS)
            IF (RTYPE .EQ. ELP__RESMN) THEN
               CALL MSG_OUT (' ','Residual calculation: weighted SD', 
     :              STATUS)
            ELSEIF (RTYPE .EQ. ELP__RESMD) THEN
               CALL MSG_OUT (' ','Residual calculation: absolute diffs', 
     :              STATUS)
            ELSEIF (RTYPE .EQ. ELP__RESLS) THEN
               CALL MSG_OUT (' ','Residual calculation: '//
     :              'unweighted least-squares', STATUS)
            ELSE
               CALL ERR_REP (' ','ELP1_STATS: unrecognised rtype',
     :              STATUS)
               STATUS = SAI__ERROR
               GOTO 9999
            ENDIF
            WSSIZE = -2! So we don't come here again
         ENDIF

         IF (RTYPE .EQ. ELP__RESMN) THEN
*         Calculate the residual used in the original version of ELLPRO -
*         the standard error, biased to weight more heavily ellipses
*         with higher means.
            RESID=SDP/(1.+ABS(MEAN))
            STAT = MEAN

         ELSE IF (RTYPE .EQ. ELP__RESMD) THEN
*         First calculate the median, and put it in STAT

*         First make sure that we have a workspace as least as big as
*         NUMPOI to pass to elp1_median.
            IF (WSSIZE .LT. NUMPOI) THEN
               IF (WSSIZE .GT. 0) THEN
*               Deallocate old workspace
                  CALL PSX_FREE (WS, STATUS)
               ENDIF
*            Allocate new workspace
               CALL PSX_CALLOC (NUMPOI, '_REAL', WS, STATUS)
               WSSIZE = NUMPOI
               IF (STATUS .NE. SAI__OK) GOTO 9999
            ENDIF
            STAT = ELP1_MEDIAN(VA,USED,NUMPOI,%VAL(WS),STATUS)
            
*         Use the sum of the absolute differences as the `residual'.
*         I've no detailed justification for this, but it `matches' the
*         use of the median as an estimator (mumble, bluff...)
            RESID=0.0
            DO I=1,NUMPOI
               IF (USED(I).NE.0) RESID=RESID+ABS(VA(I)-STAT)
            ENDDO
            
         ELSE IF (RTYPE .EQ. ELP__RESLS) THEN
*         A simple least-squares residual
            RESID = SQD
            STAT = MEAN

         ELSE 
*         Unrecognised RTYPE
            CALL ERR_REP (' ','ELP1_STATS: unrecognised rtype', STATUS)
            STATUS = SAI__ERROR
            GOTO 9999

         ENDIF

      ELSE

*      Set flag due to the low number of pixels for which values
*      were determined.
         FLAG=1
         GOTO 9999

      END IF

 9999 CONTINUE

      END



      REAL FUNCTION ELP1_MEDIAN(V,GOOD,N,WS,STATUS)
*+
*   Name:
*     ELP1_MEDIAN
*
*   Purpose:
*     Calculate the median of the good pixels of the array V(N).
*     Non-destructive - ie, it does not reorder V.
*
*   Language:
*     Fortran 77
*
*   Invocation:
*     MEDIAN = ELP1_MEDIAN (V, GOOD, N, %VAL(WS), STATUS)
*
*   Description:
*     Uses a destructive selection algorithm to find the median element
*     in V after copying it to a workspace WS, which the caller
*     guarantees is at least N elements in size. The algorithm is based
*     on that described in Numerical Recipes (in C), without using any
*     actual code from there.
*
*   Errors:
*     Sets STATUS to be sai__error and returns 0.0 if there are no
*     good pixels, or if either of the sanity-check assertions at the
*     end fails.
*
*   Arguments:
*     V(N) = REAL (Given)
*       The array we're to find the median of
*     GOOD(N) = INTEGER (Given)
*       GOOD(i) is non-zero if we are to use the element V(i).
*     N = INTEGER (Given)
*       The size of the arrays V and GOOD
*     WS(N) = REAL (Given)
*       A workspace, into which we may temporarily copy V.  The actual
*       workspace will be at least N in length.
*     STATUS = INTEGER (Given and returned)
*       Inherited status
*
*   Authors:
*     NG: Norman Gray (Starlink, Glasgow)
*
*   History:
*     18 Aug 1998
*       (Original version)
*
*   Bugs:
*     None known at present.
*-

*   No implicit typing
      implicit none

*   Arguments:
      real v(n)                 ! Array we want the median of
      integer good(n)           ! Only examine v(i) when good(i)>0
      integer n                 ! Size of the arrays
      real ws(n)                ! Workspace
      integer status            ! Inherited status

*   Local variables
      integer i,j               ! loop counter
      integer l                 ! Number of `good' elements
      integer medind            ! middle index - location of median in
                                ! order
      integer hi,lo,pei
      real pe                   ! Value of partitioning element
      real temp
      
*   Global symbols
      include 'SAE_PAR'
      
      
      if (status .ne. sai__ok) return
      
*   First, copy the good elements of the array to the workspace
      l = 0
      do i=1,n
         if (good(i) .gt. 0) then
            l = l+1
            ws(l) = v(i)
         endif
      enddo
      if (l .eq. 0) then
*      We don't have _any_ good pixels?!
         call err_rep (' ','elp1_median: no good pixels', status)
         status = sai__error
         elp1_median = 0.0
         goto 9999
      endif
      
*   Get middle index - median should be (v(l/2)+v(l/2+1))/2 if l is odd, 
*   but this makes little difference as long as l >~ 100 or so.
      medind = (l+1)/2

      lo = 1
      hi = l

      do while (hi-lo .gt. 1)
         
         pei = (lo+hi)/2        ! Index of pe in middle (more efficient 
                                ! if array already partly ordered?)
         pe = ws(pei)

*      `Remove ws(pei) from the array' by overwriting it with ws(lo).  
*      Now deal only with array ws(lo+1..hi), which has pe missing.
         ws(pei) = ws(lo)

*      Make sure ws(lo+1) <= pe <= ws(hi), to ensure `i+1' and `j-1'
*      loops below must terminate.
         if (ws(lo+1) .gt. ws(hi)) then
            temp = ws(lo+1)
            ws(lo+1) = ws(hi)
            ws(hi) = temp
         endif
         if (pe .gt. ws(hi)) then
            temp = pe
            pe = ws(hi)
            ws(hi) = temp
         endif
         if (ws(lo+1) .gt. pe) then
            temp = pe
            pe = ws(lo+1)
            ws(lo+1) = temp
         endif

         i = lo+1
         j = hi
*      Inner loop
         do while (.true.)
*         Find a ws(i) >= pe
            i = i+1
            do while (ws(i) .lt. pe)
               i = i+1
            enddo
*         Find a ws(j) <= pe
            j = j-1
            do while (ws(j) .gt. pe)
               j = j-1
            enddo
*Assert: ws(i)>=pe, ws(j)<=pe, i>lo+1, j<hi
*         As long as i<j we have found a pair of elements on the wrong
*         side of the partitioning element, which should be swapped before
*         trying again (i==j can only happen if there's an even number
*         in the subarray, and ws(j)==pe).
            if (i .ge. j) goto 100 ! LEAP OUT 
*         Swap them
            temp = ws(i)
            ws(i) = ws(j)
            ws(j) = temp
         enddo
 100     continue

*      The partitioning element is notionally located _between_ ws(j)
*      and ws(j+1).  Reinsert it by pushing ws(j) to ws(lo) and putting 
*      ws(j)=pe
         ws(lo) = ws(j)
         ws(j) = pe
*Assert: ws(lo..j-1) <= ws(j) <= ws(j+1..hi)
*Assert: ...which implies ws(1..j-1) <= ws(j) <= ws(j+1..l)
      
*      Now concentrate on the partition which contains medind
         if (medind .le. j) hi = j
         if (j .le. medind) lo = j

      enddo

*   Either hi=lo(=medind) (and we're finished), or else hi=lo+1,
*   and the result is the median of this two element array after
*   `sorting'.
      if (hi .eq. lo) then
         if (hi .ne. medind) then
            call err_rep (' ',
     :           'elp1_median: assertion failed: hi.ne.medind', 
     :           status)
            status = sai__error
            elp1_median = 0.0
            goto 9999
         endif
         elp1_median = ws(lo)
      elseif (hi .eq. lo+1) then
         if (ws(lo) .le. ws(hi)) then
            elp1_median = ws(lo)
         else
            elp1_median = ws(hi)
         endif
      else
         call err_rep (' ',
     :        'elp1_median: assertion failed: hi.ne.lo+1', 
     :        status)
         status = sai__error
         elp1_median = 0.0
         goto 9999
      endif

 9999 continue
      
      end




      SUBROUTINE ELP1_TEXTO(MODE,NDF1,VALIDP,ZEROP,
     :                      RESULT,XCO,YCO,BACK,SIGMA,PSIZE,LBND,
     :                      FIOD,EXCLAIM,STATUS)
*+
*  Name:
*     ELP1_TEXTO

*  Purpose:
*     Puts the most recent galaxy 'fit' results into a text format 
*     ASCII output file.
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*      CALL ELP1_TEXTO(MODE,NDF1,VALIDP,ZEROP,RESULT,
*                      XCO,YCO,BACK,SIGMA,PSIZE,LBND,FIOD,EXCLAIM,STATUS)    

*  Description:
*     Creates a text file (if required) and places in it data from the
*     most recent galaxy profile/fit generated.
*
*     The parameter MODE is used as follows:
*         MODE=0  Do the actions described below.
*         MODE=1  Open file
*         MODE=2  Save headings, save data  and close the file.
*         MODE=3  Close the file.
*
*     All radii values output are measured in pixels.

*  Arguments:               
*     MODE = INTEGER (Given)
*        Used to show which part of the text file is to be created. 
*     NDF1 = INTEGER (Given)
*        NDF identifier for the image.
*     VALIDP = INTEGER (Given)
*        Number of ellipse radii fitted successfully
*     ZEROP = REAL (Given)
*        The magnitude scale zero point. Units magnitudes.
*     RESULT(ELP__NRES,ELP__MXPOI) = REAL (Given)
*        Array containing the results.
*     XCO = REAL (Given)
*        The X index of the origin used. Units pixels.
*     YCO = REAL (Given)
*        The Y index of the origin used. Units pixels.
*     BACK = REAL (Given)
*        Image background value employed. Units counts.
*     SIGMA = REAL (Given)
*        Standard deviation of the background value. Units counts.
*     PSIZE = REAL (Given)
*        The image pixels size. Units arc secs.
*     LBND(10) = INTEGER (Given)
*        Lower limits of the image world co-ordinate system.
*     FIOD = INTEGER (Given and Returned)
*        Output file FIO descriptor.
*     EXCLAIM = LOGICAL (Returned)
*        An exclaimation mark was returned for the file name.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     12-MAR-1993 (GJP)
*     (Original version)
*     20-FEB-1997 (GJP)
*     Output format modified.
 
*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'elp_par'               ! ELLPRO constants
      INCLUDE 'MSG_PAR'               ! Parameter system constants
      INCLUDE 'NDF_PAR'               ! NDF public constants

*  Arguments Given:                              
      INTEGER LBND(NDF__MXDIM)        ! Lower limits of image world
                                      ! co-ordinate system
      INTEGER MODE                    ! Defines which part of the file saving
                                      ! is to be performed.
      INTEGER NDF1                    ! NDF indentifier
      INTEGER VALIDP                  ! Number of radii fitted successfully
      REAL BACK                       ! Background count value
      REAL PSIZE                      ! The size of each pixel in
                                      ! arc seconds
      REAL RESULT(ELP__NRES,ELP__MXPOI)      ! Array containing the profiling results
      REAL SIGMA                      ! Standard deviation of the background
      REAL XCO                        ! X index of the origin
      REAL YCO                        ! Y index of the origin
      REAL ZEROP                      ! Magnitude scale zero point

*  Arguments Given and Returned:
      LOGICAL EXCLAIM                 ! Was an exclaimation mark given 
                                      ! for the file name?
      INTEGER FIOD                    ! Output file FIO descriptor
      
*  Status:     
      INTEGER STATUS                  ! Global status

*   Local constants:
      INTEGER LINSIZ            ! Maximum line size
      PARAMETER (LINSIZ=95)

*  Local variables:
      CHARACTER *(LINSIZ) TEXT        ! The heading
      CHARACTER *(LINSIZ) LINE        ! FIO line output length
      CHARACTER *(MSG__SZMSG) NAME    ! NDF name
      LOGICAL OPENF                   ! Was the output file opened?
      INTEGER I                       ! Temporary variable
      INTEGER J                       ! Temporary variable
      INTEGER NCHAR                   ! Length of output string

*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Open the FIO file.
      IF ((MODE.EQ.0).OR.(MODE.EQ.1)) THEN

*      Determine the output text file name. If the file name chosen fails, 
*      the user is reprompted
         IF (MODE.EQ.0) CALL MSG_BLANK(STATUS)
         OPENF=.FALSE.             
         EXCLAIM=.FALSE.   
         CALL ERR_MARK
         DO WHILE((.NOT.OPENF).AND.(.NOT.EXCLAIM)
     :             .AND.(STATUS.EQ.SAI__OK))
            CALL ELP1_AIF_ASFIO('OUT','WRITE','LIST',LINSIZ,FIOD,OPENF,
     :                          EXCLAIM,STATUS)
            IF ((.NOT.OPENF).AND.(.NOT.EXCLAIM)) THEN
               CALL ERR_REP(' ','Bad file name.',STATUS)
               CALL ERR_REP(' ','For no file, type !',STATUS)
               CALL ERR_ANNUL(STATUS)
            END IF
         END DO
         CALL ERR_RLSE
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Inform the user if a difficulty was encountered and that an
*      an output file will not be used. 
         IF (EXCLAIM) THEN  
            CALL MSG_BLANK(STATUS)
            CALL MSG_OUT(' ','WARNING!!!',STATUS)
            CALL MSG_OUT(' ','No output text file created.',STATUS)
            CALL MSG_BLANK(STATUS)
            GOTO 9999
         END IF

      END IF

*   Output the heading, galaxy co-ordinates used and the profiling results.
      IF ((MODE.EQ.0).OR.(MODE.EQ.2)) THEN

*      Output a heading.
         NCHAR=0
         CALL CHR_PUTC('## ESP ELLPRO V1.0 OUTPUT FILE',LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)
         NCHAR=0
         CALL CHR_PUTC('##',LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)

*      Output the file name.
         NCHAR=0
         CALL CHR_PUTC('## Filename: ',LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)
         NCHAR=0
         CALL NDF_MSG('NAME',NDF1)
         CALL MSG_LOAD(' ','^NAME',NAME,I,STATUS)
         NAME=NAME(1:I)
         CALL CHR_CLEAN(NAME)
         CALL CHR_PUTC(NAME,LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)

*      Output the standard deviation value that was used.
         NCHAR=0

         CALL CHR_PUTC('## Sigma (counts): ',LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)
         NCHAR=0
         CALL CHR_PUTR(SIGMA,LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)

*      Output the image pixel size.
         NCHAR=0
         CALL CHR_PUTC('## Pixel size (arc secs): ',LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)
         NCHAR=0
         CALL CHR_PUTR(PSIZE,LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)

*      Output X and Y data co-ordinates.
         NCHAR=0
         CALL CHR_PUTC('## X/Y co-ordinates (data):',
     :                 LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(1:NCHAR),STATUS)
         NCHAR=0
         CALL CHR_PUTR(XCO,LINE,NCHAR)
         CALL CHR_PUTC(' ',LINE,NCHAR)
         CALL CHR_PUTR(YCO,LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)

*      Output X and Y world co-ordinates.
         NCHAR=0
         CALL CHR_PUTC('## X/Y co-ordinates (world):',
     :                 LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(1:NCHAR),STATUS)
         NCHAR=0
         CALL CHR_PUTR(XCO+LBND(1)-1,LINE,NCHAR)
         CALL CHR_PUTC(' ',LINE,NCHAR)
         CALL CHR_PUTR(YCO+LBND(2)-1,LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)

*      Output the background value that was used.
         NCHAR=0
         CALL CHR_PUTC('## Background (counts): ',LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)
         NCHAR=0
         CALL CHR_PUTR(BACK,LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)

*      Output the magnitude zero point.
         NCHAR=0
         CALL CHR_PUTC('## Zero point of magnitude:',LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)
         NCHAR=0
         CALL CHR_PUTR(ZEROP,LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)

*      Output the number of points determined.
         NCHAR=0
         CALL CHR_PUTC('## Number of points:',LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)
         NCHAR=0
         CALL CHR_PUTI(VALIDP,LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)

*      Output the an ellipse parameters heading.
         NCHAR=0
         CALL CHR_PUTC('## Ellipse Parameters:',LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)

*      Output a data description.
         NCHAR=0
         TEXT='X       Y     Points    Rad(a)            Count  '//
     :        '        PA     Ellipt     Dev   PPU'
C         TEXT='X       Y     Points    Rad(a)     Count     '//
C     :    'PA     Ellipt     Dev   PPU'
         CALL CHR_PUTC('!! '//TEXT,LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(1:NCHAR),STATUS)
         NCHAR=0
         TEXT='                                     Mean    Statistic'
         CALL CHR_PUTC('!! '//TEXT,LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(1:NCHAR),STATUS)

*      Output the actual values.
         DO 400 I=1,VALIDP

*         Create an appropriately formatted output string.
            CALL MSG_FMTR('X','F6.1',RESULT(1,I))
            CALL MSG_FMTR('Y','F6.1',RESULT(2,I))
            CALL MSG_FMTI('N','I3',INT(RESULT(8,I)))
            CALL MSG_FMTR('RAD','F8.2',RESULT(4,I))
            CALL MSG_FMTR('VAL','F10.1',RESULT(6,I))
            CALL MSG_FMTR('MEDN','F10.1',RESULT(ELP__STAT,I))
            CALL MSG_FMTR('POS','F6.1',RESULT(5,I))
            CALL MSG_FMTR('ELL','F5.3',RESULT(3,I))
            CALL MSG_FMTR('DEV','F8.1',RESULT(7,I))
            CALL MSG_FMTR('POI','F4.0',RESULT(9,I))
            TEXT='^X  ^Y    ^N   ^RAD  ^VAL  ^MEDN  ^POS   ^ELL'//
     :           '  ^DEV  ^POI '

*         Output the results in suitably formatted form.
            NCHAR=0
            CALL MSG_LOAD(' ',TEXT,NAME,J,STATUS)
            NAME=NAME(1:J)
            CALL CHR_CLEAN(NAME)
            CALL CHR_PUTC(NAME,LINE,NCHAR)
            CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)

 400     CONTINUE

*      Output the a Fourier descriptor heading.
         NCHAR=0
         CALL CHR_PUTC('## Fourier Descriptors:',LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)

*      Output a data description.
         NCHAR=0
         TEXT='Rad(a)   1xSin   1xCos   2xSin   2xCos'//
     :        '   3xSin   3xCos   4xSin   4xCos'
         CALL CHR_PUTC('!! '//TEXT,LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(1:NCHAR),STATUS)

*      Output the actual values.
         DO 500 I=1,VALIDP

*         Create an appropriately formatted output string.
            CALL MSG_FMTR('RAD','F8.2',RESULT(4,I))
            CALL MSG_FMTR('FDS1','F6.3',RESULT(10,I))
            CALL MSG_FMTR('FDC1','F6.3',RESULT(11,I))
            CALL MSG_FMTR('FDS2','F6.3',RESULT(12,I))
            CALL MSG_FMTR('FDC2','F6.3',RESULT(13,I))
            CALL MSG_FMTR('FDS3','F6.3',RESULT(14,I))
            CALL MSG_FMTR('FDC3','F6.3',RESULT(15,I))
            CALL MSG_FMTR('FDS4','F6.3',RESULT(16,I))
            CALL MSG_FMTR('FDC4','F6.3',RESULT(17,I))
            TEXT=' ^RAD   ^FDS1  ^FDC1  ^FDS2  ^FDC2'// 
     :           '  ^FDS3  ^FDC3  ^FDS4  ^FDC4'
 
*         Output the results in suitably formatted form.
            NCHAR=0
            CALL MSG_LOAD(' ',TEXT,NAME,J,STATUS)
            NAME=NAME(1:J)
            CALL CHR_CLEAN(NAME)
            CALL CHR_PUTC(NAME,LINE,NCHAR)
            CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)

 500     CONTINUE

*      Add message describing storage units for radius.
         NCHAR=0
         TEXT='!! NOTE: Radii values are stored on file as semi-'/
     :        /'major axis length' 
         CALL CHR_PUTC(TEXT,LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)
         NCHAR=0
         TEXT='!!       measured in pixels but on screen as '/
     :        /'equivalent radii in arc secs.' 
         CALL CHR_PUTC(TEXT,LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)

*      Add message describing position angle.
         NCHAR=0
         TEXT='!! NOTE: Position angles are stored on file with'/
     :        /' origin upward and clockwise rotation positive.' 
         CALL CHR_PUTC(TEXT,LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)

*      Add file terminator.
         NCHAR=0
         TEXT='## END'
         CALL CHR_PUTC(TEXT,LINE,NCHAR)
         CALL FIO_WRITE(FIOD,LINE(:NCHAR),STATUS)

      END IF

*  Close down the file output.
      IF ((MODE.EQ.0).OR.(MODE.EQ.3)) CALL FIO_CLOSE(FIOD,STATUS)

 9999 CONTINUE

      END 


      SUBROUTINE ELP1_TRANS(ELEMS,ARRAY0,ARRAY1,STATUS)    
*+
*  Name:
*     ELP1_TRANS

*  Purpose:
*     Transfer data from the mapped NDF to a dynamic memory array.
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*      CALL ELP1_TRANS(ELEMS,ARRAY0,ARRAY1,STATUS)    

*  Description:
*      Copies data from the currently mapped source NDF 'DATA' array and 
*      transfers it into the PSX dynamic memory allocated for temporary
*      storage. All manipulation is then carried out on that. The routine
*      allows it to be refreshed whenever a new profile is required. 
*      

*  Arguments:               
*     ELEMS = INTEGER (Given)
*        Number of elements in the data NDF.                  
*     ARRAY0(ELEMS) = REAL (Given)
*        Array containing the mapped NDF data region..
*     ARRAY1(ELEMS) = REAL (Returned)
*        Array into which the mapped NDF will be transfered.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     22-FEB-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:                              
      INTEGER ELEMS                   ! Number of pixels in the NDF array
      REAL ARRAY0(ELEMS)              ! The mapped NDF data array

*  Arguments Returned:
      REAL ARRAY1(ELEMS)              ! Dynamic array into which the 
                                      ! mapped NDF data region is copied 

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      INTEGER I                       ! Temporary loop variable
*.
      
*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Transfer data from the mapped NDF array to the dynamic memory array.
      DO 10 I=1,ELEMS
         ARRAY1(I)=ARRAY0(I)
 10   CONTINUE

 9999 CONTINUE

      END


      SUBROUTINE ELP1_RAND(TYPE,SEED,VALUE,STATUS)                                           
 
*+
*  Name:
*     ELP1_RAND

*  Purpose:
*     Provide random numbers in the range 0-1.
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*      CALL ELP1_RAND(TYPE,SEED,VALUE,STATUS)    

*  Description:
*      Crude and simple random number generator based
*      upon a NIST routine supplied by Malcolm Currie.

*  Arguments:               
*     TYPE = INTEGER (Given)
*        Seed or request?                  
*     SEED = INTEGER (Given)
*        Random number seed.
*     VALUE = REAL (Returned)
*        Random number created.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     12-Oct-1996 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:                              
      INTEGER TYPE                    ! Seed or request?
      INTEGER SEED                    ! Seed value.

*  Arguments Returned:
      REAL VALUE                      ! RAndom number

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      DOUBLE PRECISION R
      DOUBLE PRECISION FACTOR
      DOUBLE PRECISION TWO28
 
      DATA FACTOR /41475557.0D0/, TWO28 /268435456.0D0/
      SAVE R
*.

           

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   First value only.
      IF(TYPE.EQ.0) R=DBLE(FLOAT(SEED))/TWO28
          
*   Evaluate.
      R=DMOD(R*FACTOR,1.0D0)
      VALUE=SNGL(R)
 
      END 
 


**************************************
* Modified version of CMLIB BD2INK   *
*                                    *
* All names modified so that they    *
* will not cause double declaration  *
* errors when the routines appear in *
* PDA library.                       *
*                                    *
**************************************


      SUBROUTINE GJP_DB2INK(X,NX,Y,NY,FCN,LDF,
     :                      KX,KY,TX,TY,BCOEF,
     :                      WORK,IFLAG,STATUS)

C***BEGIN PROLOGUE  DB2INK
C***DATE WRITTEN   25 MAY 1982
C***REVISION DATE  25 MAY 1982
C***CATEGORY NO.  E1A
C***KEYWORDS  INTERPOLATION, TWO-DIMENSIONS, GRIDDED DATA, SPLINES,
C             PIECEWISE POLYNOMIALS
C***AUTHOR  BOISVERT, RONALD, NBS
C             SCIENTIFIC COMPUTING DIVISION
C             NATIONAL BUREAU OF STANDARDS
C             WASHINGTON, DC 20234
C***PURPOSE  DOUBLE PRECISION VERSION OF B2INK.
C            DB2INK DETERMINES A PIECEWISE POLYNOMIAL FUNCTION THAT
C            INTERPOLATES TWO-DIMENSIONAL GRIDDED DATA. USERS SPECIFY
C            THE POLYNOMIAL ORDER (DEGREE+1) OF THE INTERPOLANT AND
C            (OPTIONALLY) THE KNOT SEQUENCE.
C***DESCRIPTION
C
C   DB2INK determines the parameters of a  function  that  interpolates
C   the two-dimensional gridded data (X(i),Y(j),FCN(i,j)) for i=1,..,NX
C   and j=1,..,NY. The interpolating function and its  derivatives  may
C   subsequently be evaluated by the function DB2VAL.
C
C   The interpolating  function  is  a  piecewise  polynomial  function
C   represented as a tensor product of one-dimensional  B-splines.  The
C   form of this function is
C
C                          NX   NY
C              S(x,y)  =  SUM  SUM  a   U (x) V (y)
C                         i=1  j=1   ij  i     j
C
C   where the functions U(i)  and  V(j)  are  one-dimensional  B-spline
C   basis functions. The coefficients a(i,j) are chosen so that
C
C         S(X(i),Y(j)) = FCN(i,j)   for i=1,..,NX and j=1,..,NY
C
C   Note that  for  each  fixed  value  of  y  S(x,y)  is  a  piecewise
C   polynomial function of x alone, and for each fixed value of x  S(x,
C   y) is a piecewise polynomial function of y alone. In one  dimension
C   a piecewise polynomial may  be  created  by  partitioning  a  given
C   interval into subintervals and defining a distinct polynomial piece
C   on each one. The points where adjacent subintervals meet are called
C   knots. Each of the functions U(i) and V(j)  above  is  a  piecewise
C   polynomial.
C
C   Users of DB2INK choose  the  order  (degree+1)  of  the  polynomial
C   pieces used to define the piecewise polynomial in each of the x and
C   y directions (KX and KY). Users also  may  define  their  own  knot
C   sequence in x and y separately (TX and TY).  If  IFLAG=0,  however,
C   DB2INK will choose sequences of knots that result  in  a  piecewise
C   polynomial interpolant with KX-2 continuous partial derivatives  in
C   x and KY-2 continuous partial derivatives in y. (KX knots are taken
C   near each endpoint in the x direction,  not-a-knot  end  conditions
C   are used, and the remaining knots are placed at data points  if  KX
C   is even or at midpoints between data points if KX  is  odd.  The  y
C   direction is treated similarly.)
C
C   After a call to DB2INK, all information  necessary  to  define  the
C   interpolating function are contained in the parameters NX, NY,  KX,
C   KY, TX, TY, and BCOEF. These quantities should not be altered until
C   after the last call of the evaluation routine DB2VAL.
C
C
C   I N P U T
C   ---------
C
C   X       Double precision 1D array (size NX)
C           Array of x abcissae. Must be strictly increasing.
C
C   NX      Integer scalar (.GE. 3)
C           Number of x abcissae.
C
C   Y       Double precision 1D array (size NY)
C           Array of y abcissae. Must be strictly increasing.
C
C   NY      Integer scalar (.GE. 3)
C           Number of y abcissae.
C
C   FCN     Double precision 2D array (size LDF by NY)
C           Array of function values to interpolate. FCN(I,J) should
C           contain the function value at the point (X(I),Y(J))
C
C   LDF     Integer scalar (.GE. NX)
C           The actual leading dimension of FCN used in the calling
C           calling program.
C
C   KX      Integer scalar (.GE. 2, .LT. NX)
C           The order of spline pieces in x.
C           (Order = polynomial degree + 1)
C
C   KY      Integer scalar (.GE. 2, .LT. NY)
C           The order of spline pieces in y.
C           (Order = polynomial degree + 1)
C
C
C   I N P U T   O R   O U T P U T
C   -----------------------------
C
C   TX      Double precision 1D array (size NX+KX)
C           The knots in the x direction for the spline interpolant.
C           If IFLAG=0 these are chosen by DB2INK.
C           If IFLAG=1 these are specified by the user.
C                      (Must be non-decreasing.)
C
C   TY      Double precision 1D array (size NY+KY)
C           The knots in the y direction for the spline interpolant.
C           If IFLAG=0 these are chosen by DB2INK.
C           If IFLAG=1 these are specified by the user.
C                      (Must be non-decreasing.)
C
C
C   O U T P U T
C   -----------
C
C   BCOEF   Double precision 2D array (size NX by NY)
C           Array of coefficients of the B-spline interpolant.
C           This may be the same array as FCN.
C
C
C   M I S C E L L A N E O U S
C   -------------------------
C
C   WORK    Double precision 1D array (size NX*NY + max( 2*KX*(NX+1),
C                                             2*KY*(NY+1) ))
C           Array of working storage.
C
C   IFLAG   Integer scalar.
C           On input:  0 == knot sequence chosen by DB2INK
C                      1 == knot sequence chosen by user.
C           On output: 1 == successful execution - Starlink modification
C                      2 == IFLAG out of range
C                      3 == NX out of range
C                      4 == KX out of range
C                      5 == X not strictly increasing
C                      6 == TX not non-decreasing
C                      7 == NY out of range
C                      8 == KY out of range
C                      9 == Y not strictly increasing
C                     10 == TY not non-decreasing
C    
C   STATUS   Integer. Starlink error status. 
C  
C***REFERENCES  CARL DE BOOR, A PRACTICAL GUIDE TO SPLINES,
C                 SPRINGER-VERLAG, NEW YORK, 1978.
C               CARL DE BOOR, EFFICIENT COMPUTER MANIPULATION OF TENSOR
C                 PRODUCTS, ACM TRANSACTIONS ON MATHEMATICAL SOFTWARE,
C                 VOL. 5 (1979), PP. 173-182.
C***ROUTINES CALLED  DBTPCF,DBKNOT
C***END PROLOGUE  DB2INK
C
C  ------------
C  DECLARATIONS
C  ------------

C  Starlink error status.
      INTEGER STATUS

C
C  PARAMETERS
C

      INTEGER NX, NY, LDF, KX, KY, IFLAG
      DOUBLE PRECISION X(NX), Y(NY), FCN(LDF,NY), TX(1), TY(1) 
      DOUBLE PRECISION BCOEF(NX,NY),WORK(1)
C
C  LOCAL VARIABLES
C
      INTEGER I, IW, NPK
C
C  -----------------------
C  CHECK VALIDITY OF INPUT
C  -----------------------
C
C***FIRST EXECUTABLE STATEMENT

*   Check the inherited global status.
      IF (STATUS.NE.0) RETURN   

      IF ((IFLAG .LT. 0) .OR. (IFLAG .GT. 1))  GO TO 920
      IF (NX .LT. 3)  GO TO 930
      IF (NY .LT. 3)  GO TO 970
      IF ((KX .LT. 2) .OR. (KX .GE. NX))  GO TO 940
      IF ((KY .LT. 2) .OR. (KY .GE. NY))  GO TO 980
      DO 10 I=2,NX
         IF (X(I) .LE. X(I-1))  GO TO 950
   10 CONTINUE
      DO 20 I=2,NY
         IF (Y(I) .LE. Y(I-1))  GO TO 990
   20 CONTINUE
      IF (IFLAG .EQ. 0)  GO TO 50
         NPK = NX + KX
         DO 30 I=2,NPK
            IF (TX(I) .LT. TX(I-1))  GO TO 960
   30    CONTINUE
         NPK = NY + KY
         DO 40 I=2,NPK
            IF (TY(I) .LT. TY(I-1))  GO TO 1000
   40    CONTINUE
   50 CONTINUE
C
C  ------------
C  CHOOSE KNOTS
C  ------------
C
      IF (IFLAG .NE. 0)  GO TO 100
         CALL GJP_DBKNOT(X,NX,KX,TX,IFLAG)
         CALL GJP_DBKNOT(Y,NY,KY,TY,IFLAG)
  100 CONTINUE
C
C  -------------------------------
C  CONSTRUCT B-SPLINE COEFFICIENTS
C  -------------------------------
C
      IFLAG = 1
      IW = NX*NY + 1
      CALL GJP_DBTPCF(X,NX,FCN,LDF,NY,TX,KX,WORK,WORK(IW),IFLAG)
      CALL GJP_DBTPCF(Y,NY,WORK,NY,NX,TY,KY,BCOEF,WORK(IW),IFLAG)

*****************************
*   Starlink modification   *
*                           *
*   Ensures STATUS okay     *
*    when routine ends      *
*                           *
*****************************
      IF (IFLAG.NE.1) STATUS=1
      GO TO 9999

C
C  -----
C  EXITS
C  -----
C
  920 CONTINUE
      IFLAG = 2
      STATUS=1
      GO TO 9999
C
  930 CONTINUE
      IFLAG = 3
      STATUS=1
      GO TO 9999
C
  940 CONTINUE
      IFLAG = 4
      STATUS=1
      GO TO 9999
C
  950 CONTINUE
      IFLAG = 5
      STATUS=1
      GO TO 9999
C
  960 CONTINUE
      IFLAG = 6
      STATUS=1
      GO TO 9999
C
  970 CONTINUE
      IFLAG = 7
      STATUS=1
      GO TO 9999
C
  980 CONTINUE
      IFLAG = 8
      STATUS=1
      GO TO 9999
C
  990 CONTINUE
      IFLAG = 9
      STATUS=1
      GO TO 9999
C
 1000 CONTINUE
      IFLAG = 10
      STATUS=1
      GO TO 9999
C
 9999 CONTINUE

      END


      SUBROUTINE GJP_DBKNOT(X,N,K,T,IFLAG)

C***BEGIN PROLOGUE  DBKNOT
C***REFER TO  DB2INK,DB3INK
C***ROUTINES CALLED  (NONE)
C***END PROLOGUE  DBKNOT
C
C  --------------------------------------------------------------------
C  DBKNOT CHOOSES A KNOT SEQUENCE FOR INTERPOLATION OF ORDER K AT THE
C  DATA POINTS X(I), I=1,..,N.  THE N+K KNOTS ARE PLACED IN THE ARRAY
C  T.  K KNOTS ARE PLACED AT EACH ENDPOINT AND NOT-A-KNOT END
C  CONDITIONS ARE USED.  THE REMAINING KNOTS ARE PLACED AT DATA POINTS
C  IF N IS EVEN AND BETWEEN DATA POINTS IF N IS ODD.  THE RIGHTMOST
C  KNOT IS SHIFTED SLIGHTLY TO THE RIGHT TO INSURE PROPER INTERPOLATION
C  AT X(N) (SEE PAGE 350 OF THE REFERENCE).
C  DOUBLE PRECISION VERSION OF BKNOT.
C  --------------------------------------------------------------------
C
C  ------------
C  DECLARATIONS
C  ------------
C
C  PARAMETERS
C
      INTEGER
     *        N, K
      DOUBLE PRECISION
     *     X(N), T(1)
C
C  LOCAL VARIABLES
C
      INTEGER
     *        I, J, IPJ, NPJ, IP1, JSTRT
      INTEGER IFLAG
      DOUBLE PRECISION
     *     RNOT
C
C
C  ----------------------------
C  PUT K KNOTS AT EACH ENDPOINT
C  ----------------------------
C
C     (SHIFT RIGHT ENPOINTS SLIGHTLY -- SEE PG 350 OF REFERENCE)
      RNOT = X(N) + 0.10D0*( X(N)-X(N-1) )
      DO 110 J=1,K
         T(J) = X(1)
         NPJ = N + J
         T(NPJ) = RNOT
  110 CONTINUE
C
C  --------------------------
C  DISTRIBUTE REMAINING KNOTS
C  --------------------------
C
      IF (MOD(K,2) .EQ. 1)  GO TO 150
C
C     CASE OF EVEN K --  KNOTS AT DATA POINTS
C
      I = (K/2) - K
      JSTRT = K+1
      DO 120 J=JSTRT,N
         IPJ = I + J
         T(J) = X(IPJ)
  120 CONTINUE
      GO TO 200
C
C     CASE OF ODD K --  KNOTS BETWEEN DATA POINTS
C
  150 CONTINUE
      I = (K-1)/2 - K
      IP1 = I + 1
      JSTRT = K + 1
      DO 160 J=JSTRT,N
         IPJ = I + J
         T(J) = 0.50D0*( X(IPJ) + X(IPJ+1) )
  160 CONTINUE
  200 CONTINUE
C
      RETURN
      END


      SUBROUTINE GJP_DBTPCF(X,N,FCN,LDF,NF,T,K,BCOEF,WORK,IFLAG)

C***BEGIN PROLOGUE  DBTPCF
C***REFER TO  DB2INK,DB3INK
C***ROUTINES CALLED  DBINTK,DBNSLV
C***END PROLOGUE  DBTPCF
C
C  -----------------------------------------------------------------
C  DBTPCF COMPUTES B-SPLINE INTERPOLATION COEFFICIENTS FOR NF SETS
C  OF DATA STORED IN THE COLUMNS OF THE ARRAY FCN. THE B-SPLINE
C  COEFFICIENTS ARE STORED IN THE ROWS OF BCOEF HOWEVER.
C  EACH INTERPOLATION IS BASED ON THE N ABCISSA STORED IN THE
C  ARRAY X, AND THE N+K KNOTS STORED IN THE ARRAY T. THE ORDER
C  OF EACH INTERPOLATION IS K. THE WORK ARRAY MUST BE OF LENGTH
C  AT LEAST 2*K*(N+1).
C  DOUBLE PRECISION VERSION OF BTPCF.
C  -----------------------------------------------------------------
C
C  ------------
C  DECLARATIONS
C  ------------
C
C  PARAMETERS
C
      INTEGER
     *        N, LDF, K,NF
      INTEGER IFLAG
      DOUBLE PRECISION
     *     X(N), FCN(LDF,NF), T(1), BCOEF(NF,N), WORK(1)
C
C  LOCAL VARIABLES
C
      INTEGER
     *        I, J, K1, K2, IQ, IW
C
C  ---------------------------------------------
C  CHECK FOR NULL INPUT AND PARTITION WORK ARRAY
C  ---------------------------------------------
C
C***FIRST EXECUTABLE STATEMENT
      IF (NF .LE. 0)  GO TO 500
      K1 = K - 1
      K2 = K1 + K
      IQ = 1 + N
      IW = IQ + K2*N+1
C
C  -----------------------------
C  COMPUTE B-SPLINE COEFFICIENTS
C  -----------------------------
C
C
C   FIRST DATA SET
C
      CALL PDA_DBINTK(X,FCN,T,N,K,WORK,WORK(IQ),WORK(IW),IFLAG)
      DO 20 I=1,N
         BCOEF(1,I) = WORK(I)
   20 CONTINUE
C
C  ALL REMAINING DATA SETS BY BACK-SUBSTITUTION
C
      IF (NF .EQ. 1)  GO TO 500
      DO 100 J=2,NF
         DO 50 I=1,N
            WORK(I) = FCN(I,J)
   50    CONTINUE
         CALL PDA_DBNSLV(WORK(IQ),K2,N,K1,K1,WORK)
         DO 60 I=1,N
            BCOEF(J,I) = WORK(I)
   60    CONTINUE
  100 CONTINUE
C
C  ----
C  EXIT
C  ----
C
  500 CONTINUE
      RETURN

      END




      SUBROUTINE GJP_DB2VAL(XVAL,YVAL,IDX,IDY,TX,TY,
     :                      NX,NY,KX,KY,BCOEF,WORK,
     :                      RVALUE,IFAIL,STATUS)
C***BEGIN PROLOGUE  DB2VAL
C***DATE WRITTEN   25 MAY 1982
C***REVISION DATE  25 MAY 1982
C***CATEGORY NO.  E1A
C***KEYWORDS  INTERPOLATION, TWO-DIMENSIONS, GRIDDED DATA, SPLINES,
C             PIECEWISE POLYNOMIALS
C***AUTHOR  BOISVERT, RONALD, NBS
C             SCIENTIFIC COMPUTING DIVISION
C             NATIONAL BUREAU OF STANDARDS
C             WASHINGTON, DC 20234
C***PURPOSE  DB2VAL EVALUATES THE PIECEWISE POLYNOMIAL INTERPOLATING
C            FUNCTION CONSTRUCTED BY THE ROUTINE DB2INK OR ONE OF ITS
C            PARTIAL DERIVATIVES.
C            DOUBLE PRECISION VERSION OF B2VAL.
C***DESCRIPTION
C
C   DB2VAL  evaluates   the   tensor   product   piecewise   polynomial
C   interpolant constructed  by  the  routine  DB2INK  or  one  of  its
C   derivatives at the point (XVAL,YVAL). To evaluate  the  interpolant
C   itself, set IDX=IDY=0, to evaluate the first partial  with  respect
C   to x, set IDX=1,IDY=0, and so on.
C
C   DB2VAL returns 0.0E0 if (XVAL,YVAL) is out of range. That is, if
C            XVAL.LT.TX(1) .OR. XVAL.GT.TX(NX+KX) .OR.
C            YVAL.LT.TY(1) .OR. YVAL.GT.TY(NY+NY)
C   If the knots TX  and  TY  were  chosen  by  DB2INK,  then  this  is
C   equivalent to
C            XVAL.LT.X(1) .OR. XVAL.GT.X(NX)+EPSX .OR.
C            YVAL.LT.Y(1) .OR. YVAL.GT.Y(NY)+EPSY
C   where EPSX = 0.1*(X(NX)-X(NX-1)) and EPSY = 0.1*(Y(NY)-Y(NY-1)).
C
C   The input quantities TX, TY, NX, NY, KX, KY, and  BCOEF  should  be
C   unchanged since the last call of DB2INK.
C
C
C   I N P U T
C   ---------
C
C   XVAL    Double precision scalar
C           X coordinate of evaluation point.
C
C   YVAL    Double precision scalar
C           Y coordinate of evaluation point.
C
C   IDX     Integer scalar
C           X derivative of piecewise polynomial to evaluate.
C
C   IDY     Integer scalar
C           Y derivative of piecewise polynomial to evaluate.
C
C   TX      Double precision 1D array (size NX+KX)
C           Sequence of knots defining the piecewise polynomial in
C           the x direction.  (Same as in last call to DB2INK.)
C
C   TY      Double precision 1D array (size NY+KY)
C           Sequence of knots defining the piecewise polynomial in
C           the y direction.  (Same as in last call to DB2INK.)
C
C   NX      Integer scalar
C           The number of interpolation points in x.
C           (Same as in last call to DB2INK.)
C
C   NY      Integer scalar
C           The number of interpolation points in y.
C           (Same as in last call to DB2INK.)
C
C   KX      Integer scalar
C           Order of polynomial pieces in x.
C           (Same as in last call to DB2INK.)
C
C   KY      Integer scalar
C           Order of polynomial pieces in y.
C           (Same as in last call to DB2INK.)
C
C   BCOEF   Double precision 2D array (size NX by NY)
C           The B-spline coefficients computed by DB2INK.
C
C   WORK    Double precision 1D array (size 3*max(KX,KY) + KY)
C           A working storage array.
C
C   IFAIL   A returned error value.
C   
C   RVALUE  The interpolated value.
C
C   STATUS  Integer. Starlink status report.
C
C***REFERENCES  CARL DE BOOR, A PRACTICAL GUIDE TO SPLINES,
C                 SPRINGER-VERLAG, NEW YORK, 1978.
C***ROUTINES CALLED  DINTRV,DBVAL2
C***END PROLOGUE  DB2VAL
C
C  ------------
C  DECLARATIONS
C  ------------

C  Starlink error status.
      INTEGER STATUS

C
C  PARAMETERS
C
      INTEGER          IFAIL
      DOUBLE PRECISION RVALUE,VALUE

      INTEGER          IDX,IDY,NX,NY,KX,KY
      DOUBLE PRECISION XVAL,YVAL,TX(1),TY(1),BCOEF(NX,NY),WORK(1)

C
C  LOCAL VARIABLES
C
      INTEGER         ILOY,INBVX,INBV,K,LEFTY,MFLAG,KCOL,IW
C
      DATA ILOY /1/,  INBVX /1/
C     SAVE ILOY    ,  INBVX
C
C
C***FIRST EXECUTABLE STATEMENT
      
*   Check the inherited global status.
      IF (STATUS.NE.0) RETURN   

*   Clear interpolated value.
      RVALUE=0.0D0

      CALL PDA_DINTRV(TY,NY+KY,YVAL,ILOY,LEFTY,MFLAG)

      IF (MFLAG .NE. 0) GO TO 100
         IW = KY + 1
         KCOL = LEFTY - KY
         DO 50 K=1,KY
            KCOL = KCOL + 1
            CALL GJP_DBVAL2(TX,BCOEF(1,KCOL),NX,
     :                      KX,IDX,XVAL,INBVX,
     :                      WORK(IW),VALUE,IFAIL)
            WORK(K)=VALUE
  50     CONTINUE
         INBV = 1
         KCOL = LEFTY - KY + 1
         CALL GJP_DBVAL2(TY(KCOL),WORK,KY,KY,IDY,
     :                      YVAL,INBV,WORK(IW),VALUE,IFAIL)
         RVALUE=VALUE
  100 CONTINUE

*   Set up the status value.
      IF (IFAIL.NE.0) STATUS=1
      
      END


      SUBROUTINE GJP_DBVAL2(T,A,N,K,IDERIV,X,
     :                      INBV,WORK,VALUE,IFAIL)
C***BEGIN PROLOGUE  DBVAL2
C***DATE WRITTEN   800901   (YYMMDD)
C***REVISION DATE  820801   (YYMMDD)
C***CATEGORY NO.  E3,K6
C***KEYWORDS  B-SPLINE,DATA FITTING,DOUBLE PRECISION,INTERPOLATION,
C             SPLINE
C***AUTHOR  AMOS, D. E., (SNLA)
C***PURPOSE  Evaluates the B-representation of a B-spline at X for the
C            function value or any of its derivatives.
C***DESCRIPTION
C
C     Written by Carl de Boor and modified by D. E. Amos
C
C     Reference
C         SIAM J. Numerical Analysis, 14, No. 3, June, 1977, pp.441-472.
C
C     Abstract   **** a double precision subroutine ****
C         DBVAL2 is the BVALUE function of the reference.
C
C         DBVAL2 evaluates the B-representation (T,A,N,K) of a B-spline
C         at X for the function value on IDERIV=0 or any of its
C         derivatives on IDERIV=1,2,...,K-1.  Right limiting values
C         (right derivatives) are returned except at the right end
C         point X=T(N+1) where left limiting values are computed.  The
C         spline is defined on T(K) .LE. X .LE. T(N+1).  DBVAL2 returns
C         a fatal error message when X is outside of this interval.
C
C         To compute left derivatives or left limiting values at a
C         knot T(I), replace N by I-1 and set X=T(I), I=K+1,N+1.
C
C         DBVAL2 calls DINTRV
C
C     Description of Arguments
C
C         Input      T,A,X are double precision
C          T       - knot vector of length N+K
C          A       - B-spline coefficient vector of length N
C          N       - number of B-spline coefficients
C                    N = sum of knot multiplicities-K
C          K       - order of the B-spline, K .GE. 1
C          IDERIV  - order of the derivative, 0 .LE. IDERIV .LE. K-1
C                    IDERIV = 0 returns the B-spline value
C          X       - argument, T(K) .LE. X .LE. T(N+1)
C          INBV    - an initialization parameter which must be set
C                    to 1 the first time DBVAL2 is called.
C
C         Output     WORK,DBVAL2 are double precision
C          INBV    - INBV contains information for efficient process-
C                    ing after the initial call and INBV must not
C                    be changed by the user.  Distinct splines require
C                    distinct INBV parameters.
C          WORK    - work vector of length 3*K.
C          DBVAL2  - value of the IDERIV-th derivative at X
C
C     Error Conditions
C         An improper input is a fatal error
C***REFERENCES  C. DE BOOR, *PACKAGE FOR CALCULATING WITH B-SPLINES*,
C                 SIAM JOURNAL ON NUMERICAL ANALYSIS, VOLUME 14, NO. 3,
C                 JUNE 1977, PP. 441-472.
C***ROUTINES CALLED  DINTRV,XERROR
C***END PROLOGUE  DBVAL2
C
C
      INTEGER IFAIL
      DOUBLE PRECISION VALUE
      INTEGER I,IDERIV,IDERP1,IHI,IHMKMJ,ILO,IMK,IMKPJ, INBV, IPJ,
     1 IP1, IP1MJ, J, JJ, J1, J2, K, KMIDER, KMJ, KM1, KPK, MFLAG, N
      DOUBLE PRECISION A, FKMJ, T, WORK, X
      DIMENSION T(1), A(N), WORK(1)
C***FIRST EXECUTABLE STATEMENT  DBVAL2

      VALUE = 0.0D0
      IF(K.LT.1) GO TO 102
      IF(N.LT.K) GO TO 101
      IF(IDERIV.LT.0 .OR. IDERIV.GE.K) GO TO 110
      KMIDER = K - IDERIV
C
C *** FIND *I* IN (K,N) SUCH THAT T(I) .LE. X .LT. T(I+1)
C     (OR, .LE. T(I+1) IF T(I) .LT. T(I+1) = T(N+1)).
      KM1 = K - 1
      CALL PDA_DINTRV(T, N+1, X, INBV, I, MFLAG)
      IF (X.LT.T(K)) GO TO 120
      IF (MFLAG.EQ.0) GO TO 20
      IF (X.GT.T(I)) GO TO 130
   10 IF (I.EQ.K) GO TO 140
      I = I - 1
      IF (X.EQ.T(I)) GO TO 10
C
C *** DIFFERENCE THE COEFFICIENTS *IDERIV* TIMES
C     WORK(I) = AJ(I), WORK(K+I) = DP(I), WORK(K+K+I) = DM(I), I=1.K
C
   20 IMK = I - K
      DO 30 J=1,K
        IMKPJ = IMK + J
        WORK(J) = A(IMKPJ)
   30 CONTINUE
      IF (IDERIV.EQ.0) GO TO 60
      DO 50 J=1,IDERIV
        KMJ = K - J
        FKMJ = DBLE(REAL(KMJ))
        DO 40 JJ=1,KMJ
          IHI = I + JJ
          IHMKMJ = IHI - KMJ
          WORK(JJ) = (WORK(JJ+1)-WORK(JJ))/(T(IHI)-T(IHMKMJ))*FKMJ
   40   CONTINUE
   50 CONTINUE
C
C *** COMPUTE VALUE AT *X* IN (T(I),(T(I+1)) OF IDERIV-TH DERIVATIVE,
C     GIVEN ITS RELEVANT B-SPLINE COEFF. IN AJ(1),...,AJ(K-IDERIV).
   60 IF (IDERIV.EQ.KM1) GO TO 100
      IP1 = I + 1
      KPK = K + K
      J1 = K + 1
      J2 = KPK + 1
      DO 70 J=1,KMIDER
        IPJ = I + J
        WORK(J1) = T(IPJ) - X
        IP1MJ = IP1 - J
        WORK(J2) = X - T(IP1MJ)
        J1 = J1 + 1
        J2 = J2 + 1
   70 CONTINUE
      IDERP1 = IDERIV + 1
      DO 90 J=IDERP1,KM1
        KMJ = K - J
        ILO = KMJ
        DO 80 JJ=1,KMJ
          WORK(JJ) = (WORK(JJ+1)*WORK(KPK+ILO)+WORK(JJ)
     1              *WORK(K+JJ))/(WORK(KPK+ILO)+WORK(K+JJ))
          ILO = ILO - 1
   80   CONTINUE
   90 CONTINUE

  100 VALUE = WORK(1)

      RETURN
C
C
  101 CONTINUE
c      CALL XERROR( ' DBVAL2,  N DOES NOT SATISFY N.GE.K',35,2,1)
      IFAIL=13
      RETURN

  102 CONTINUE
c      CALL XERROR( ' DBVAL2,  K DOES NOT SATISFY K.GE.1',35,2,1)
      IFAIL=14
      RETURN

  110 CONTINUE
c      CALL XERROR( ' DBVAL2,  IDERIV DOES NOT SATISFY 0.LE.IDERIV.LT.K',1 50, 2, 1)
      IFAIL=15
      RETURN

  120 CONTINUE
c      CALL XERROR( ' DBVAL2,  X IS N0T GREATER THAN OR EQUAL TO T(K)',1 48, 2, 1)
      IFAIL=16
      RETURN

  130 CONTINUE
c      CALL XERROR( ' DBVAL2,  X IS NOT LESS THAN OR EQUAL TO T(N+1)',1 47, 2, 1)
      IFAIL=17
      RETURN

  140 CONTINUE
c      CALL XERROR( ' DBVAL2,  A LEFT LIMITING VALUE CANN0T BE OBTAINED A1T T(K)',    58, 2, 1)
      IFAIL=18
      RETURN

      END


      SUBROUTINE GJP_IDBVIP(md,ncp,ndp,xd,yd,zd,nip,xi,yi,zi,iwk, 
     :                      wk,istat,status)
 
c this subroutine performs bivariate interpolation when the pro-
c jections of the data points in the x-y plane are irregularly
c distributed in the plane.
 
c the input parameters are
c     md  = mode of computation (must be 1, 2, or 3),
c         = 1 for new ncp and/or new xd-yd,
c         = 2 for old ncp, old xd-yd, new xi-yi,
c         = 3 for old ncp, old xd-yd, old xi-yi,
c     ncp = number of additional data points used for esti-
c           mating partial derivatives at each data point
c           (must be 2 or greater, but smaller than ndp),
c     ndp = number of data points (must be 4 or greater),
c     xd  = array of dimension ndp containing the x
c           coordinates of the data points,
c     yd  = array of dimension ndp containing the y
c           coordinates of the data points,
c     zd  = array of dimension ndp containing the z
c           coordinates of the data points,
c     nip = number of output points at which interpolation
c           is to be performed (must be 1 or greater),
c     xi  = array of dimension nip containing the x
c           coordinates of the output points,
c     yi  = array of dimension nip containing the y
c           coordinates of the output points.
 
c the output parameter is
c     zi  = array of dimension nip where interpolated z
c           values are to be stored.
c     istat = error message.
c     status= Starlink error status
 
c the other parameters are
c     iwk = integer array of dimension
c              max0(31,27+ncp)*ndp+nip
c           used internally as a work area,
c     wk  = array of dimension 8*ndp used internally as a
c           work area.
 
c the very first call to this subroutine and the call with a new
c ncp value, a new ndp value, and/or new contents of the xd and
c yd arrays must be made with md=1.  the call with md=2 must be
c preceded by another call with the same ncp and ndp values and
c with the same contents of the xd and yd arrays.  the call with
c md=3 must be preceded by another call with the same ncp, ndp,
c and nip values and with the same contents of the xd, yd, xi,
c and yi arrays.  between the call with md=2 or md=3 and its
c preceding call, the iwk and wk arrays must not be disturbed.
c use of a value between 3 and 5 (inclusive) for ncp is recom-
c mended unless there are evidences that dictate otherwise.
 
c this subroutine calls the idcldp, idlctn, idpdrv, idptip, and
c idtang subroutines.
  
C  Starlink Status.     
      INTEGER STATUS                  ! Global status

c declaration statements
      dimension xd(100), yd(100), zd(100), xi(1000), yi(1000), 
     :          zi(1000), iwk(4100), wk(800)
      common /idlc  / nit
      common /idpi  / itpv
      integer istat
 
c   Check the inherited global status.
      IF (STATUS.NE.0) RETURN   
 
c setting of some input parameters to local variables.
c (for md=1,2,3)
      md0 = md
      ncp0 = ncp
      ndp0 = ndp
      nip0 = nip
 
c error check.  (for md=1,2,3)
      if ( md0.ge.1 .and. md0.le.3 ) then
         if ( ncp0.ge.2 .and. ncp0.lt.ndp0 ) then
            if ( ndp0.ge.4 ) then
               if ( nip0.ge.1 ) then
                  if ( md0.ge.2 ) then
                     ncppv = iwk(1)
                     ndppv = iwk(2)
                     if ( ncp0.ne.ncppv ) go to 100
                     if ( ndp0.ne.ndppv ) go to 100
                  else
                     iwk(1) = ncp0
                     iwk(2) = ndp0
                  end if
                  if ( md0.ge.3 ) then
                     nippv = iwk(3)
                     if ( nip0.ne.nippv ) go to 100
                  else
                     iwk(3) = nip
                  end if
 
c allocation of storage areas in the iwk array.  (for md=1,2,3)
                  jwipt = 16
                  jwiwl = 6*ndp0 + 1
                  jwiwk = jwiwl
                  jwipl = 24*ndp0 + 1
                  jwiwp = 30*ndp0 + 1
                  jwipc = 27*ndp0 + 1
                  jwit0 = max0(31, 27+ncp0)*ndp0
 
c triangulates the x-y plane.  (for md=1)
                  if ( md0.le.1 ) then
                     call GJP_IDTANG(ndp0,xd,yd,nt,iwk(jwipt),nl, 
     :                               iwk(jwipl),iwk(jwiwl),
     :                               iwk(jwiwp),wk,istat)
                     iwk(5) = nt
                     iwk(6) = nl
                     if ( nt.eq.0 ) then
                        if(istat.ne.0) status=1
                        return
                     end if
                  end if
 
c determines ncp points closest to each data point.  (for md=1)
                  if ( md0.le.1 ) then
                     call GJP_IDCLDP(ndp0,xd,yd,ncp0,
     :                               iwk(jwipc),istat)
                     if ( iwk(jwipc).eq.0 ) then
                        if(istat.ne.0) status=1
                        return
                     end if
                  end if
 
c locates all points at which interpolation is to be performed.
c (for md=1,2)
                  if ( md0.ne.3 ) then
                     nit = 0
                     jwit = jwit0
                     do 2 iip = 1, nip0
                        jwit = jwit + 1
                        call GJP_IDLCTN(ndp0,xd,yd,nt,iwk(jwipt),nl, 
     :                                  iwk(jwipl),xi(iip),yi(iip), 
     :                                  iwk(jwit),iwk(jwiwk),wk,
     :                                  istat)
 2                   continue
                  end if
 
c estimates partial derivatives at all data points.
c (for md=1,2,3)
                  call GJP_IDPDRV(ndp0,xd,yd,zd,ncp0,iwk(jwipc),wk, 
     :                            istat)
 
c interpolates the zi values.  (for md=1,2,3)
                  itpv = 0
                  jwit = jwit0
                  do 5 iip = 1, nip0
                     jwit = jwit + 1
                     call GJP_IDPTIP(xd,yd,zd,nt,iwk(jwipt),nl, 
     :                               iwk(jwipl),wk,iwk(jwit),
     :                               xi(iip),yi(iip),zi(iip),
     :                               istat)
 5                continue
                  if(istat.ne.0) status=1
                  return

               end if
            end if
         end if
      end if
 
c error exit
 
 100  continue
      istat = 1

*   Setup Starlink status.
      STATUS=1
 
      end
 
 
      SUBROUTINE GJP_IDCLDP(ndp,xd,yd,ncp,ipc,istat)
 
c this subroutine selects several data points that are closest
c to each of the data point.
 
c the input parameters are
c     ndp = number of data points,
c     xd,yd = arrays of dimension ndp containing the x and y
c           coordinates of the data points,
c     ncp = number of data points closest to each data
c           points.
 
c the output parameter is
c     ipc = integer array of dimension ncp*ndp, where the
c           point numbers of ncp data points closest to
c           each of the ndp data points are to be stored.
*     istat = starlink error message.
 
c this subroutine arbitrarily sets a restriction that ncp must
c not exceed 25.
 
c declaration statements
      dimension xd(100), yd(100), ipc(400)
      dimension dsq0(25), ipc0(25)
      data ncpmx/25/
      integer istat
 
*   check the inherited error status.
      if ( istat.ne.0 ) return
 
c preliminary processing
      ndp0 = ndp
      ncp0 = ncp
      if ( ndp0.ge.2 ) then
         if ( ncp0.ge.1 .and. ncp0.le.ncpmx .and. ncp0.lt.ndp0 ) then
 
c calculation
            do 80 ip1 = 1, ndp0
 
c - selects ncp points.
               x1 = xd(ip1)
               y1 = yd(ip1)
               j1 = 0
               dsqmx = 0.0
               do 10 ip2 = 1, ndp0
                  if ( ip2.ne.ip1 ) then
                     dsqi = GJP_DSQF(x1,y1,xd(ip2),yd(ip2))
                     j1 = j1 + 1
                     dsq0(j1) = dsqi
                     ipc0(j1) = ip2
                     if ( dsqi.gt.dsqmx ) then
                        dsqmx = dsqi
                        jmx = j1
                     end if
                     if ( j1.ge.ncp0 ) go to 20
                  end if
 10            continue
 20            continue
               ip2mn = ip2 + 1
               if ( ip2mn.le.ndp0 ) then
                  do 25 ip2 = ip2mn, ndp0
                     if ( ip2.ne.ip1 ) then
                        dsqi = GJP_DSQF(x1,y1,xd(ip2),yd(ip2))
                        if ( dsqi.lt.dsqmx ) then
                           dsq0(jmx) = dsqi
                           ipc0(jmx) = ip2
                           dsqmx = 0.0
                           do 22 j1 = 1, ncp0
                              if ( dsq0(j1).gt.dsqmx ) then
                                 dsqmx = dsq0(j1)
                                 jmx = j1
                              end if
 22                        continue
                        end if
                     end if
 25               continue
               end if
 
c - checks if all the ncp+1 points are collinear.
               ip2 = ipc0(1)
               dx12 = xd(ip2) - x1
               dy12 = yd(ip2) - y1
               do 30 j3 = 2, ncp0
                  ip3 = ipc0(j3)
                  dx13 = xd(ip3) - x1
                  dy13 = yd(ip3) - y1
                  if ( (dy13*dx12-dx13*dy12).ne.0.0 ) go to 50
 30            continue
 
c - searches for the closest noncollinear point.
               nclpt = 0
               do 40 ip3 = 1, ndp0
                  if ( ip3.ne.ip1 ) then
                     do 32 j4 = 1, ncp0
                        if ( ip3.eq.ipc0(j4) ) go to 40
 32                  continue
                     dx13 = xd(ip3) - x1
                     dy13 = yd(ip3) - y1
                     if ( (dy13*dx12-dx13*dy12).ne.0.0 ) then
                        dsqi = GJP_DSQF(x1,y1,xd(ip3),yd(ip3))
                        if ( nclpt.ne.0 ) then
                           if ( dsqi.ge.dsqmn ) go to 40
                        end if
                        nclpt = 1
                        dsqmn = dsqi
                        ip3mn = ip3
                     end if
                  end if
 40            continue
               if ( nclpt.eq.0 ) go to 100
               dsqmx = dsqmn
               ipc0(jmx) = ip3mn
 
c - replaces the local array for the output array.
 50            continue
               j1 = (ip1-1)*ncp0
               do 60 j2 = 1, ncp0
                  j1 = j1 + 1
                  ipc(j1) = ipc0(j2)
 60            continue
 80         continue
            return
         end if
      end if
 
c error exit
      istat = 2
      ipc(1) = 0
      return
 
 100  continue
      istat = 3
      ipc(1) = 0
 
 
      end
 
 
      SUBROUTINE GJP_IDGRID(xd,yd,nt,ipt,nl,ipl,nxi,nyi,xi,yi,ngp, 
     :                      igp,istat)
 
c this subroutine organizes grid points for surface fitting by
c sorting them in ascending order of triangle numbers and of the
c border line segment number.
 
c the input parameters are
c     xd,yd = arrays of dimension ndp containing the x and y
c           coordinates of the data points, where ndp is the
c           number of the data points,
c     nt  = number of triangles,
c     ipt = integer array of dimension 3*nt containing the
c           point numbers of the vertices of the triangles,
c     nl  = number of border line segments,
c     ipl = integer array of dimension 3*nl containing the
c           point numbers of the end points of the border
c           line segments and their respective triangle
c           numbers,
c     nxi = number of grid points in the x coordinate,
c     nyi = number of grid points in the y coordinate,
c     xi,yi = arrays of dimension nxi and nyi containing
c           the x and y coordinates of the grid points,
c           respectively.
 
c the output parameters are
c     ngp = integer array of dimension 2*(nt+2*nl) where the
c           number of grid points that belong to each of the
c           triangles or of the border line segments are to
c           be stored,
c     igp = integer array of dimension nxi*nyi where the
c           grid point numbers are to be stored in ascending
c           order of the triangle number and the border line
c           segment number.
*     istat = starlink error message.
 
 
c declaration statements
      dimension xd(100), yd(100), ipt(585), ipl(300), xi(101), yi(101), 
     :          ngp(800), igp(10201)
      integer istat
 
*   check the inherited error status.
      if ( istat.ne.0 ) return
 
c preliminary processing
      nt0 = nt
      nl0 = nl
      nxi0 = nxi
      nyi0 = nyi
      nxinyi = nxi0*nyi0
      ximn = amin1(xi(1), xi(nxi0))
      ximx = amax1(xi(1), xi(nxi0))
      yimn = amin1(yi(1), yi(nyi0))
      yimx = amax1(yi(1), yi(nyi0))
 
c determines grid points inside the data area.
      jngp0 = 0
      jngp1 = 2*(nt0+2*nl0) + 1
      jigp0 = 0
      jigp1 = nxinyi + 1
      do 300 it0 = 1, nt0
         ngp0 = 0
         ngp1 = 0
         it0t3 = it0*3
         ip1 = ipt(it0t3-2)
         ip2 = ipt(it0t3-1)
         ip3 = ipt(it0t3)
         x1 = xd(ip1)
         y1 = yd(ip1)
         x2 = xd(ip2)
         y2 = yd(ip2)
         x3 = xd(ip3)
         y3 = yd(ip3)
         xmn = amin1(x1, x2, x3)
         xmx = amax1(x1, x2, x3)
         ymn = amin1(y1, y2, y3)
         ymx = amax1(y1, y2, y3)
         insd = 0
         do 50 ixi = 1, nxi0
            if ( xi(ixi).ge.xmn .and. xi(ixi).le.xmx ) then
               if ( insd.ne.1 ) then
                  insd = 1
                  iximn = ixi
               end if
            else if ( insd.ne.0 ) then
               iximx = ixi - 1
               go to 100
            end if
 50      continue
         if ( insd.eq.0 ) go to 200
         iximx = nxi0
 100     continue
         do 150 iyi = 1, nyi0
            yii = yi(iyi)
            if ( yii.ge.ymn .and. yii.le.ymx ) then
               do 110 ixi = iximn, iximx
                  xii = xi(ixi)
                  l = 0
                  if (GJP_SIDE(x1,y1,x2,y2,xii,yii).lt.0) go to 110
                  if (GJP_SIDE(x1,y1,x2,y2,xii,yii).eq.0) l = 1
                  if (GJP_SIDE(x2,y2,x3,y3,xii,yii).lt.0) go to 110
                  if (GJP_SIDE(x2,y2,x3,y3,xii,yii).eq.0) l = 1
                  if (GJP_SIDE(x3,y3,x1,y1,xii,yii).lt.0) go to 110
                  if (GJP_SIDE(x3,y3,x1,y1,xii,yii).eq.0) l = 1
                  izi = nxi0*(iyi-1) + ixi
                  if ( l.eq.1 ) then
                     if ( jigp1.le.nxinyi ) then
                        do 102 jigp1i = jigp1, nxinyi
                           if ( izi.eq.igp(jigp1i) ) go to 110
 102                    continue
                     end if
                     ngp1 = ngp1 + 1
                     jigp1 = jigp1 - 1
                     igp(jigp1) = izi
                  else
                     ngp0 = ngp0 + 1
                     jigp0 = jigp0 + 1
                     igp(jigp0) = izi
                  end if
 110           continue
            end if
 150     continue
 200     continue
         jngp0 = jngp0 + 1
         ngp(jngp0) = ngp0
         jngp1 = jngp1 - 1
         ngp(jngp1) = ngp1
 300  continue
 
c determines grid points outside the data area.
c - in semi-infinite rectangular area.
      do 800 il0 = 1, nl0
         ngp0 = 0
         ngp1 = 0
         il0t3 = il0*3
         ip1 = ipl(il0t3-2)
         ip2 = ipl(il0t3-1)
         x1 = xd(ip1)
         y1 = yd(ip1)
         x2 = xd(ip2)
         y2 = yd(ip2)
         xmn = ximn
         xmx = ximx
         ymn = yimn
         ymx = yimx
         if ( y2.ge.y1 ) xmn = amin1(x1, x2)
         if ( y2.le.y1 ) xmx = amax1(x1, x2)
         if ( x2.le.x1 ) ymn = amin1(y1, y2)
         if ( x2.ge.x1 ) ymx = amax1(y1, y2)
         insd = 0
         do 350 ixi = 1, nxi0
            if ( xi(ixi).ge.xmn .and. xi(ixi).le.xmx ) then
               if ( insd.ne.1 ) then
                  insd = 1
                  iximn = ixi
               end if
            else if ( insd.ne.0 ) then
               iximx = ixi - 1
               go to 400
            end if
 350     continue
         if ( insd.eq.0 ) go to 500
         iximx = nxi0
 400     continue
         do 450 iyi = 1, nyi0
            yii = yi(iyi)
            if ( yii.ge.ymn .and. yii.le.ymx ) then
               do 410 ixi = iximn, iximx
                  xii = xi(ixi)
                  l = 0
                  if (GJP_SIDE(x1,y1,x2,y2,xii,yii).lt.0) then
                  else if (GJP_SIDE(x1,y1,x2,y2,xii,yii).eq.0) then
                     l = 1
                  else
                     go to 410
                  end if
                  if (GJP_SPDT(x2,y2,x1,y1,xii,yii).lt.0) go to 410
                  if (GJP_SPDT(x2,y2,x1,y1,xii,yii).eq.0) l = 1
                  if (GJP_SPDT(x1,y1,x2,y2,xii,yii).lt.0) go to 410
                  if (GJP_SPDT(x1,y1,x2,y2,xii,yii).eq.0) l = 1
                  izi = nxi0*(iyi-1) + ixi
                  if ( l.eq.1 ) then
                     if ( jigp1.le.nxinyi ) then
                        do 402 jigp1i = jigp1, nxinyi
                           if ( izi.eq.igp(jigp1i) ) go to 410
 402                    continue
                     end if
                     ngp1 = ngp1 + 1
                     jigp1 = jigp1 - 1
                     igp(jigp1) = izi
                  else
                     ngp0 = ngp0 + 1
                     jigp0 = jigp0 + 1
                     igp(jigp0) = izi
                  end if
 410           continue
            end if
 450     continue
 500     continue
         jngp0 = jngp0 + 1
         ngp(jngp0) = ngp0
         jngp1 = jngp1 - 1
         ngp(jngp1) = ngp1
 
c - in semi-infinite triangular area.
         ngp0 = 0
         ngp1 = 0
         ilp1 = mod(il0, nl0) + 1
         ilp1t3 = ilp1*3
         ip3 = ipl(ilp1t3-1)
         x3 = xd(ip3)
         y3 = yd(ip3)
         xmn = ximn
         xmx = ximx
         ymn = yimn
         ymx = yimx
         if ( y3.ge.y2 .and. y2.ge.y1 ) xmn = x2
         if ( y3.le.y2 .and. y2.le.y1 ) xmx = x2
         if ( x3.le.x2 .and. x2.le.x1 ) ymn = y2
         if ( x3.ge.x2 .and. x2.ge.x1 ) ymx = y2
         insd = 0
         do 550 ixi = 1, nxi0
            if ( xi(ixi).ge.xmn .and. xi(ixi).le.xmx ) then
               if ( insd.ne.1 ) then
                  insd = 1
                  iximn = ixi
               end if
            else if ( insd.ne.0 ) then
               iximx = ixi - 1
               go to 600
            end if
 550     continue
         if ( insd.eq.0 ) go to 700
         iximx = nxi0
 600     continue
         do 650 iyi = 1, nyi0
            yii = yi(iyi)
            if ( yii.ge.ymn .and. yii.le.ymx ) then
               do 610 ixi = iximn, iximx
                  xii = xi(ixi)
                  l = 0
                  if (GJP_SPDT(x1,y1,x2,y2,xii,yii).lt.0) then
                  else if (GJP_SPDT(x1,y1,x2,y2,xii,yii).eq.0) then
                     l = 1
                  else
                     go to 610
                  end if
                  if (GJP_SPDT(x3,y3,x2,y2,xii,yii).lt.0) then
                  else if (GJP_SPDT(x3,y3,x2,y2,xii,yii).eq.0) then
                     l = 1
                  else
                     go to 610
                  end if
                  izi = nxi0*(iyi-1) + ixi
                  if ( l.eq.1 ) then
                     if ( jigp1.le.nxinyi ) then
                        do 602 jigp1i = jigp1, nxinyi
                           if ( izi.eq.igp(jigp1i) ) go to 610
 602                    continue
                     end if
                     ngp1 = ngp1 + 1
                     jigp1 = jigp1 - 1
                     igp(jigp1) = izi
                  else
                     ngp0 = ngp0 + 1
                     jigp0 = jigp0 + 1
                     igp(jigp0) = izi
                  end if
 610           continue
            end if
 650     continue
 700     continue
         jngp0 = jngp0 + 1
         ngp(jngp0) = ngp0
         jngp1 = jngp1 - 1
         ngp(jngp1) = ngp1
 800  continue
      return
      end
 
 
      SUBROUTINE GJP_IDLCTN(ndp,xd,yd,nt,ipt,nl,ipl,xii,yii,iti, 
     :                      iwk,wk,istat)
 
c this subroutine locates a point, i.e., determines to what tri-
c angle a given point (xii,yii) belongs.  when the given point
c does not lie inside the data area, this subroutine determines
c the border line segment when the point lies in an outside
c rectangular area, and two border line segments when the point
c lies in an outside triangular area.
 
c the input parameters are
c     ndp = number of data points,
c     xd,yd = arrays of dimension ndp containing the x and y
c           coordinates of the data points,
c     nt  = number of triangles,
c     ipt = integer array of dimension 3*nt containing the
c           point numbers of the vertices of the triangles,
c     nl  = number of border line segments,
c     ipl = integer array of dimension 3*nl containing the
c           point numbers of the end points of the border
c           line segments and their respective triangle
c           numbers,
c     xii,yii = x and y coordinates of the point to be
c           located.
 
c the output parameter is
c     iti = triangle number, when the point is inside the
c           data area, or
c           two border line segment numbers, il1 and il2,
c           coded to il1*(nt+nl)+il2, when the point is
c           outside the data area.
*     istat = starlink error message.
 
c the other parameters are
c     iwk = integer array of dimension 18*ndp used inter-
c           nally as a work area,
c     wk  = array of dimension 8*ndp used internally as a
c           work area.
 
c declaration statements
      dimension xd(100), yd(100), ipt(585), ipl(300), iwk(1800), wk(800)
      dimension ntsc(9), idsc(9)
      common /idlc  / nit
      integer istat
 
*   check the inherited error status.
      if ( istat.ne.0 ) return
 
c preliminary processing
      ndp0 = ndp
      nt0 = nt
      nl0 = nl
      ntl = nt0 + nl0
      x0 = xii
      y0 = yii
 
c processing for a new set of data points
      if ( nit.ne.0 ) then
 
c checks if in the same triangle as previous.
         it0 = itipv
         if ( it0.gt.nt0 ) then
 
c checks if on the same border line segment.
            il1 = it0/ntl
            il2 = it0 - il1*ntl
            il1t3 = il1*3
            ip1 = ipl(il1t3-2)
            x1 = xd(ip1)
            y1 = yd(ip1)
            ip2 = ipl(il1t3-1)
            x2 = xd(ip2)
            y2 = yd(ip2)
            if ( il2.ne.il1 ) then
 
c checks if between the same two border line segments.
               if (GJP_SPDT(x1,y1,x2,y2,x0,y0).le.0.0) then
                  ip3 = ipl(3*il2-1)
                  x3 = xd(ip3)
                  y3 = yd(ip3)
                  if (GJP_SPDT(x3,y3,x2,y2,x0,y0).le.0.0) go to 500
               end if
            else if (GJP_SPDT(x1,y1,x2,y2,x0,y0).ge.0.0) then
               if (GJP_SPDT(x2,y2,x1,y1,x0,y0).ge.0.0) then
                  if (GJP_SIDE(x1,y1,x2,y2,x0,y0).le.0.0) go to 500
               end if
            end if
         else
            it0t3 = it0*3
            ip1 = ipt(it0t3-2)
            x1 = xd(ip1)
            y1 = yd(ip1)
            ip2 = ipt(it0t3-1)
            x2 = xd(ip2)
            y2 = yd(ip2)
            if (GJP_SIDE(x1,y1,x2,y2,x0,y0).ge.0.0) then
               ip3 = ipt(it0t3)
               x3 = xd(ip3)
               y3 = yd(ip3)
               if (GJP_SIDE(x2,y2,x3,y3,x0,y0).ge.0.0) then
                  if (GJP_SIDE(x3,y3,x1,y1,x0,y0).ge.0.0) go to 500
               end if
            end if
         end if
      else
         nit = 1
 
c - divides the x-y plane into nine rectangular sections.
         xmn = xd(1)
         xmx = xmn
         ymn = yd(1)
         ymx = ymn
         do 50 idp = 2, ndp0
            xi = xd(idp)
            yi = yd(idp)
            xmn = amin1(xi, xmn)
            xmx = amax1(xi, xmx)
            ymn = amin1(yi, ymn)
            ymx = amax1(yi, ymx)
 50      continue
         xs1 = (xmn+xmn+xmx)/3.0
         xs2 = (xmn+xmx+xmx)/3.0
         ys1 = (ymn+ymn+ymx)/3.0
         ys2 = (ymn+ymx+ymx)/3.0
 
c - determines and stores in the iwk array triangle numbers of
c - the triangles associated with each of the nine sections.
         do 100 isc = 1, 9
            ntsc(isc) = 0
            idsc(isc) = 0
 100     continue
         it0t3 = 0
         jwk = 0
         do 150 it0 = 1, nt0
            it0t3 = it0t3 + 3
            i1 = ipt(it0t3-2)
            i2 = ipt(it0t3-1)
            i3 = ipt(it0t3)
            xmn = amin1(xd(i1), xd(i2), xd(i3))
            xmx = amax1(xd(i1), xd(i2), xd(i3))
            ymn = amin1(yd(i1), yd(i2), yd(i3))
            ymx = amax1(yd(i1), yd(i2), yd(i3))
            if ( ymn.le.ys1 ) then
               if ( xmn.le.xs1 ) idsc(1) = 1
               if ( xmx.ge.xs1 .and. xmn.le.xs2 ) idsc(2) = 1
               if ( xmx.ge.xs2 ) idsc(3) = 1
            end if
            if ( ymx.ge.ys1 .and. ymn.le.ys2 ) then
               if ( xmn.le.xs1 ) idsc(4) = 1
               if ( xmx.ge.xs1 .and. xmn.le.xs2 ) idsc(5) = 1
               if ( xmx.ge.xs2 ) idsc(6) = 1
            end if
            if ( ymx.ge.ys2 ) then
               if ( xmn.le.xs1 ) idsc(7) = 1
               if ( xmx.ge.xs1 .and. xmn.le.xs2 ) idsc(8) = 1
               if ( xmx.ge.xs2 ) idsc(9) = 1
            end if
            do 120 isc = 1, 9
               if ( idsc(isc).ne.0 ) then
                  jiwk = 9*ntsc(isc) + isc
                  iwk(jiwk) = it0
                  ntsc(isc) = ntsc(isc) + 1
                  idsc(isc) = 0
               end if
 120        continue
 
c - stores in the wk array the minimum and maximum of the x and
c - y coordinate values for each of the triangle.
            jwk = jwk + 4
            wk(jwk-3) = xmn
            wk(jwk-2) = xmx
            wk(jwk-1) = ymn
            wk(jwk) = ymx
 150     continue
      end if
 
c locates inside the data area.
c - determines the section in which the point in question lies.
      isc = 1
      if ( x0.ge.xs1 ) isc = isc + 1
      if ( x0.ge.xs2 ) isc = isc + 1
      if ( y0.ge.ys1 ) isc = isc + 3
      if ( y0.ge.ys2 ) isc = isc + 3
 
c - searches through the triangles associated with the section.
      ntsci = ntsc(isc)
      if ( ntsci.gt.0 ) then
         jiwk = -9 + isc
         do 200 itsc = 1, ntsci
            jiwk = jiwk + 9
            it0 = iwk(jiwk)
            jwk = it0*4
            if ( x0.ge.wk(jwk-3) ) then
               if ( x0.le.wk(jwk-2) ) then
                  if ( y0.ge.wk(jwk-1) ) then
                     if ( y0.le.wk(jwk) ) then
                        it0t3 = it0*3
                        ip1 = ipt(it0t3-2)
                        x1 = xd(ip1)
                        y1 = yd(ip1)
                        ip2 = ipt(it0t3-1)
                        x2 = xd(ip2)
                        y2 = yd(ip2)
                        if (GJP_SIDE(x1,y1,x2,y2,x0,y0).ge.0.0) then
                           ip3 = ipt(it0t3)
                           x3 = xd(ip3)
                           y3 = yd(ip3)
                           if (GJP_SIDE(x2,y2,x3,y3,x0,y0).ge.0.0) then
                              if (GJP_SIDE(x3,y3,x1,y1,x0,y0).ge.0.0)
     :                             go to 500
                           end if
                        end if
                     end if
                  end if
               end if
            end if
 200     continue
      end if
 
c locates outside the data area.
      do 300 il1 = 1, nl0
         il1t3 = il1*3
         ip1 = ipl(il1t3-2)
         x1 = xd(ip1)
         y1 = yd(ip1)
         ip2 = ipl(il1t3-1)
         x2 = xd(ip2)
         y2 = yd(ip2)
         if (GJP_SPDT(x2,y2,x1,y1,x0,y0).ge.0.0) then
            if (GJP_SPDT(x1,y1,x2,y2,x0,y0).lt.0.0) then
               il2 = mod(il1, nl0) + 1
               ip3 = ipl(3*il2-1)
               x3 = xd(ip3)
               y3 = yd(ip3)
               if (GJP_SPDT(x3,y3,x2,y2,x0,y0).le.0.0) go to 400
            else if (GJP_SIDE(x1,y1,x2,y2,x0,y0).le.0.0) then
               il2 = il1
               go to 400
            end if
         end if
 300  continue
      it0 = 1
      go to 500
 400  continue
      it0 = il1*ntl + il2
 
c normal exit
 500  continue
      iti = it0
      itipv = it0
      return
 
      end
 
 
      SUBROUTINE GJP_IDPDRV(ndp,xd,yd,zd,ncp,ipc,pd,istat)
 
c this subroutine estimates partial derivatives of the first and
c second order at the data points.
 
c the input parameters are
c     ndp = number of data points,
c     xd,yd,zd = arrays of dimension ndp containing the x,
c           y, and z coordinates of the data points,
c     ncp = number of additional data points used for esti-
c           mating partial derivatives at each data point,
c     ipc = integer array of dimension ncp*ndp containing
c           the point numbers of ncp data points closest to
c           each of the ndp data points.
 
c the output parameter is
c     pd  = array of dimension 5*ndp, where the estimated
c           zx, zy, zxx, zxy, and zyy values at the data
c           points are to be stored.
*     istat = starlink error message.
 
 
c declaration statements
      dimension xd(100), yd(100), zd(100), ipc(400), pd(500)
      real nmx, nmy, nmz, nmxx, nmxy, nmyx, nmyy
      integer istat
 
*   check the inherited error status.
      if ( istat.ne.0 ) return
 
c preliminary processing
      ndp0 = ndp
      ncp0 = ncp
      ncpm1 = ncp0 - 1
 
c estimation of zx and zy
      do 100 ip0 = 1, ndp0
         x0 = xd(ip0)
         y0 = yd(ip0)
         z0 = zd(ip0)
         nmx = 0.0
         nmy = 0.0
         nmz = 0.0
         jipc0 = ncp0*(ip0-1)
         do 50 ic1 = 1, ncpm1
            jipc = jipc0 + ic1
            ipi = ipc(jipc)
            dx1 = xd(ipi) - x0
            dy1 = yd(ipi) - y0
            dz1 = zd(ipi) - z0
            ic2mn = ic1 + 1
            do 20 ic2 = ic2mn, ncp0
               jipc = jipc0 + ic2
               ipi = ipc(jipc)
               dx2 = xd(ipi) - x0
               dy2 = yd(ipi) - y0
               dnmz = dx1*dy2 - dy1*dx2
               if ( dnmz.ne.0.0 ) then
                  dz2 = zd(ipi) - z0
                  dnmx = dy1*dz2 - dz1*dy2
                  dnmy = dz1*dx2 - dx1*dz2
                  if ( dnmz.lt.0.0 ) then
                     dnmx = -dnmx
                     dnmy = -dnmy
                     dnmz = -dnmz
                  end if
                  nmx = nmx + dnmx
                  nmy = nmy + dnmy
                  nmz = nmz + dnmz
               end if
 20         continue
 50      continue
         jpd0 = 5*ip0
         pd(jpd0-4) = -nmx/nmz
         pd(jpd0-3) = -nmy/nmz
 100  continue
 
c estimation of zxx, zxy, and zyy
      do 200 ip0 = 1, ndp0
         jpd0 = jpd0 + 5
         x0 = xd(ip0)
         jpd0 = 5*ip0
         y0 = yd(ip0)
         zx0 = pd(jpd0-4)
         zy0 = pd(jpd0-3)
         nmxx = 0.0
         nmxy = 0.0
         nmyx = 0.0
         nmyy = 0.0
         nmz = 0.0
         jipc0 = ncp0*(ip0-1)
         do 150 ic1 = 1, ncpm1
            jipc = jipc0 + ic1
            ipi = ipc(jipc)
            dx1 = xd(ipi) - x0
            dy1 = yd(ipi) - y0
            jpd = 5*ipi
            dzx1 = pd(jpd-4) - zx0
            dzy1 = pd(jpd-3) - zy0
            ic2mn = ic1 + 1
            do 120 ic2 = ic2mn, ncp0
               jipc = jipc0 + ic2
               ipi = ipc(jipc)
               dx2 = xd(ipi) - x0
               dy2 = yd(ipi) - y0
               dnmz = dx1*dy2 - dy1*dx2
               if ( dnmz.ne.0.0 ) then
                  jpd = 5*ipi
                  dzx2 = pd(jpd-4) - zx0
                  dzy2 = pd(jpd-3) - zy0
                  dnmxx = dy1*dzx2 - dzx1*dy2
                  dnmxy = dzx1*dx2 - dx1*dzx2
                  dnmyx = dy1*dzy2 - dzy1*dy2
                  dnmyy = dzy1*dx2 - dx1*dzy2
                  if ( dnmz.lt.0.0 ) then
                     dnmxx = -dnmxx
                     dnmxy = -dnmxy
                     dnmyx = -dnmyx
                     dnmyy = -dnmyy
                     dnmz = -dnmz
                  end if
                  nmxx = nmxx + dnmxx
                  nmxy = nmxy + dnmxy
                  nmyx = nmyx + dnmyx
                  nmyy = nmyy + dnmyy
                  nmz = nmz + dnmz
               end if
 120        continue
 150     continue
         pd(jpd0-2) = -nmxx/nmz
         pd(jpd0-1) = -(nmxy+nmyx)/(2.0*nmz)
         pd(jpd0) = -nmyy/nmz
 200  continue
      return
      end
 
 
      SUBROUTINE GJP_IDPTIP(xd,yd,zd,nt,ipt,nl,ipl,pdd,iti,xii, 
     :                      yii,zii,istat)
 
c this subroutine performs punctual interpolation or extrapola-
c tion, i.e., determines the z value at a point.
 
c the input parameters are
c     xd,yd,zd = arrays of dimension ndp containing the x,
c           y, and z coordinates of the data points, where
c           ndp is the number of the data points,
c     nt  = number of triangles,
c     ipt = integer array of dimension 3*nt containing the
c           point numbers of the vertices of the triangles,
c     nl  = number of border line segments,
c     ipl = integer array of dimension 3*nl containing the
c           point numbers of the end points of the border
c           line segments and their respective triangle
c           numbers,
c     pdd = array of dimension 5*ndp containing the partial
c           derivatives at the data points,
c     iti = triangle number of the triangle in which lies
c           the point for which interpolation is to be
c           performed,
c     xii,yii = x and y coordinates of the point for which
c           interpolation is to be performed.
 
c the output parameter is
c     zii = interpolated z value.
*     istat = starlink error message.
 
 
c declaration statements
      dimension xd(100), yd(100), zd(100), ipt(585), ipl(300), pdd(500)
      common /idpi  / itpv
      dimension x(3), y(3), z(3), pd(15), zu(3), zv(3), zuu(3), zuv(3), 
     :          zvv(3)
      real lu, lv
      equivalence (p5, p50)
      integer istat
 
*   check the inherited error status.
      if ( istat.ne.0 ) return
 
c preliminary processing
      it0 = iti
      ntl = nt + nl
      if ( it0.le.ntl ) then
 
c calculation of zii by interpolation.
c checks if the necessary coefficients have been calculated.
         if ( it0.ne.itpv ) then
 
c loads coordinate and partial derivative values at the
c vertices.
            jipt = 3*(it0-1)
            jpd = 0
            do 20 i = 1, 3
               jipt = jipt + 1
               idp = ipt(jipt)
               x(i) = xd(idp)
               y(i) = yd(idp)
               z(i) = zd(idp)
               jpdd = 5*(idp-1)
               do 10 kpd = 1, 5
                  jpd = jpd + 1
                  jpdd = jpdd + 1
                  pd(jpd) = pdd(jpdd)
 10            continue
 20         continue
 
c determines the coefficients for the coordinate system
c transformation from the x-y system to the u-v system
c and vice versa.
            x0 = x(1)
            y0 = y(1)
            a = x(2) - x0
            b = x(3) - x0
            c = y(2) - y0
            d = y(3) - y0
            ad = a*d
            bc = b*c
            dlt = ad - bc
            ap = d/dlt
            bp = -b/dlt
            cp = -c/dlt
            dp = a/dlt
 
c converts the partial derivatives at the vertices of the
c triangle for the u-v coordinate system.
            aa = a*a
            act2 = 2.0*a*c
            cc = c*c
            ab = a*b
            adbc = ad + bc
            cd = c*d
            bb = b*b
            bdt2 = 2.0*b*d
            dd = d*d
            do 40 i = 1, 3
               jpd = 5*i
               zu(i) = a*pd(jpd-4) + c*pd(jpd-3)
               zv(i) = b*pd(jpd-4) + d*pd(jpd-3)
               zuu(i) = aa*pd(jpd-2) + act2*pd(jpd-1) + cc*pd(jpd)
               zuv(i) = ab*pd(jpd-2) + adbc*pd(jpd-1) + cd*pd(jpd)
               zvv(i) = bb*pd(jpd-2) + bdt2*pd(jpd-1) + dd*pd(jpd)
 40         continue
 
c calculates the coefficients of the polynomial.
            p00 = z(1)
            p10 = zu(1)
            p01 = zv(1)
            p20 = 0.5*zuu(1)
            p11 = zuv(1)
            p02 = 0.5*zvv(1)
            h1 = z(2) - p00 - p10 - p20
            h2 = zu(2) - p10 - zuu(1)
            h3 = zuu(2) - zuu(1)
            p30 = 10.0*h1 - 4.0*h2 + 0.5*h3
            p40 = -15.0*h1 + 7.0*h2 - h3
            p50 = 6.0*h1 - 3.0*h2 + 0.5*h3
            h1 = z(3) - p00 - p01 - p02
            h2 = zv(3) - p01 - zvv(1)
            h3 = zvv(3) - zvv(1)
            p03 = 10.0*h1 - 4.0*h2 + 0.5*h3
            p04 = -15.0*h1 + 7.0*h2 - h3
            p05 = 6.0*h1 - 3.0*h2 + 0.5*h3
            lu = sqrt(aa+cc)
            lv = sqrt(bb+dd)
            thxu = atan2(c, a)
            thuv = atan2(d, b) - thxu
            csuv = cos(thuv)
            p41 = 5.0*lv*csuv/lu*p50
            p14 = 5.0*lu*csuv/lv*p05
            h1 = zv(2) - p01 - p11 - p41
            h2 = zuv(2) - p11 - 4.0*p41
            p21 = 3.0*h1 - h2
            p31 = -2.0*h1 + h2
            h1 = zu(3) - p10 - p11 - p14
            h2 = zuv(3) - p11 - 4.0*p14
            p12 = 3.0*h1 - h2
            p13 = -2.0*h1 + h2
            thus = atan2(d-c, b-a) - thxu
            thsv = thuv - thus
            aa = sin(thsv)/lu
            bb = -cos(thsv)/lu
            cc = sin(thus)/lv
            dd = cos(thus)/lv
            ac = aa*cc
            ad = aa*dd
            bc = bb*cc
            g1 = aa*ac*(3.0*bc+2.0*ad)
            g2 = cc*ac*(3.0*ad+2.0*bc)
            h1 = -aa*aa*aa*(5.0*aa*bb*p50+(4.0*bc+ad)*p41)
     :           - cc*cc*cc*(5.0*cc*dd*p05+(4.0*ad+bc)*p14)
            h2 = 0.5*zvv(2) - p02 - p12
            h3 = 0.5*zuu(3) - p20 - p21
            p22 = (g1*h2+g2*h3-h1)/(g1+g2)
            p32 = h2 - p22
            p23 = h3 - p22
            itpv = it0
         end if
 
c converts xii and yii to u-v system.
         dx = xii - x0
         dy = yii - y0
         u = ap*dx + bp*dy
         v = cp*dx + dp*dy
 
c evaluates the polynomial.
         p0 = p00 + v*(p01+v*(p02+v*(p03+v*(p04+v*p05))))
         p1 = p10 + v*(p11+v*(p12+v*(p13+v*p14)))
         p2 = p20 + v*(p21+v*(p22+v*p23))
         p3 = p30 + v*(p31+v*p32)
         p4 = p40 + v*p41
         zii = p0 + u*(p1+u*(p2+u*(p3+u*(p4+u*p5))))
         return
      else
         il1 = it0/ntl
         il2 = it0 - il1*ntl
         if ( il1.eq.il2 ) then
 
c calculation of zii by extrapolation in the rectangle.
c checks if the necessary coefficients have been calculated.
            if ( it0.ne.itpv ) then
 
c loads coordinate and partial derivative values at the end
c points of the border line segment.
               jipl = 3*(il1-1)
               jpd = 0
               do 50 i = 1, 2
                  jipl = jipl + 1
                  idp = ipl(jipl)
                  x(i) = xd(idp)
                  y(i) = yd(idp)
                  z(i) = zd(idp)
                  jpdd = 5*(idp-1)
                  do 45 kpd = 1, 5
                     jpd = jpd + 1
                     jpdd = jpdd + 1
                     pd(jpd) = pdd(jpdd)
 45               continue
 50            continue
 
c determines the coefficients for the coordinate system
c transformation from the x-y system to the u-v system
c and vice versa.
               x0 = x(1)
               y0 = y(1)
               a = y(2) - y(1)
               b = x(2) - x(1)
               c = -b
               d = a
               ad = a*d
               bc = b*c
               dlt = ad - bc
               ap = d/dlt
               bp = -b/dlt
               cp = -bp
               dp = ap
 
c converts the partial derivatives at the end points of the
c border line segment for the u-v coordinate system.
               aa = a*a
               act2 = 2.0*a*c
               cc = c*c
               ab = a*b
               adbc = ad + bc
               cd = c*d
               bb = b*b
               bdt2 = 2.0*b*d
               dd = d*d
               do 60 i = 1, 2
                  jpd = 5*i
                  zu(i) = a*pd(jpd-4) + c*pd(jpd-3)
                  zv(i) = b*pd(jpd-4) + d*pd(jpd-3)
                  zuu(i) = aa*pd(jpd-2) + act2*pd(jpd-1) + cc*pd(jpd)
                  zuv(i) = ab*pd(jpd-2) + adbc*pd(jpd-1) + cd*pd(jpd)
                  zvv(i) = bb*pd(jpd-2) + bdt2*pd(jpd-1) + dd*pd(jpd)
 60            continue
 
c calculates the coefficients of the polynomial.
               p00 = z(1)
               p10 = zu(1)
               p01 = zv(1)
               p20 = 0.5*zuu(1)
               p11 = zuv(1)
               p02 = 0.5*zvv(1)
               h1 = z(2) - p00 - p01 - p02
               h2 = zv(2) - p01 - zvv(1)
               h3 = zvv(2) - zvv(1)
               p03 = 10.0*h1 - 4.0*h2 + 0.5*h3
               p04 = -15.0*h1 + 7.0*h2 - h3
               p05 = 6.0*h1 - 3.0*h2 + 0.5*h3
               h1 = zu(2) - p10 - p11
               h2 = zuv(2) - p11
               p12 = 3.0*h1 - h2
               p13 = -2.0*h1 + h2
               p21 = 0.0
               p23 = -zuu(2) + zuu(1)
               p22 = -1.5*p23
               itpv = it0
            end if
 
c converts xii and yii to u-v system.
            dx = xii - x0
            dy = yii - y0
            u = ap*dx + bp*dy
            v = cp*dx + dp*dy
 
c evaluates the polynomial.
            p0 = p00 + v*(p01+v*(p02+v*(p03+v*(p04+v*p05))))
            p1 = p10 + v*(p11+v*(p12+v*p13))
            p2 = p20 + v*(p21+v*(p22+v*p23))
            zii = p0 + u*(p1+u*p2)
            return
 
c calculation of zii by extrapolation in the triangle.
c checks if the necessary coefficients have been calculated.
         else if ( it0.ne.itpv ) then
 
c loads coordinate and partial derivative values at the vertex
c of the triangle.
            jipl = 3*il2 - 2
            idp = ipl(jipl)
            x(1) = xd(idp)
            y(1) = yd(idp)
            z(1) = zd(idp)
            jpdd = 5*(idp-1)
            do 80 kpd = 1, 5
               jpdd = jpdd + 1
               pd(kpd) = pdd(jpdd)
 80         continue
 
c calculates the coefficients of the polynomial.
            p00 = z(1)
            p10 = pd(1)
            p01 = pd(2)
            p20 = 0.5*pd(3)
            p11 = pd(4)
            p02 = 0.5*pd(5)
            itpv = it0
         end if
      end if
 
c converts xii and yii to u-v system.
      u = xii - x(1)
      v = yii - y(1)
 
c evaluates the polynomial.
      p0 = p00 + v*(p01+v*p02)
      p1 = p10 + v*p11
      zii = p0 + u*(p1+u*p20)
      return
      end
 
 
      SUBROUTINE GJP_IDSFFT(md,ncp,ndp,xd,yd,zd,nxi,nyi,xi,yi,zi, 
     :                      iwk,wk,istat,status)
 
c this subroutine performs smooth surface fitting when the pro-
c jections of the data points in the x-y plane are irregularly
c distributed in the plane.
 
c the input parameters are
c     md  = mode of computation (must be 1, 2, or 3),
c         = 1 for new ncp and/or new xd-yd,
c         = 2 for old ncp, old xd-yd, new xi-yi,
c         = 3 for old ncp, old xd-yd, old xi-yi,
c     ncp = number of additional data points used for esti-
c           mating partial derivatives at each data point
c           (must be 2 or greater, but smaller than ndp),
c     ndp = number of data points (must be 4 or greater),
c     xd  = array of dimension ndp containing the x
c           coordinates of the data points,
c     yd  = array of dimension ndp containing the y
c           coordinates of the data points,
c     zd  = array of dimension ndp containing the z
c           coordinates of the data points,
c     nxi = number of output grid points in the x coordinate
c           (must be 1 or greater),
c     nyi = number of output grid points in the y coordinate
c           (must be 1 or greater),
c     xi  = array of dimension nxi containing the x
c           coordinates of the output grid points,
c     yi  = array of dimension nyi containing the y
c           coordinates of the output grid points.
 
c the output parameter is
c     zi  = doubly-dimensioned array of dimension (nxi,nyi),
c           where the interpolated z values at the output
c           grid points are to be stored.
c     istat = error message.
c     status= Starlink error status
 
c the other parameters are
c     iwk = integer array of dimension
c              max0(31,27+ncp)*ndp+nxi*nyi
c           used internally as a work area,
c     wk  = array of dimension 5*ndp used internally as a
c           work area.
 
c the very first call to this subroutine and the call with a new
c ncp value, a new ndp value, and/or new contents of the xd and
c yd arrays must be made with md=1.  the call with md=2 must be
c preceded by another call with the same ncp and ndp values and
c with the same contents of the xd and yd arrays.  the call with
c md=3 must be preceded by another call with the same ncp, ndp,
c nxi, and nyi values and with the same contents of the xd, yd,
c xi, and yi arrays.  between the call with md=2 or md=3 and its
c preceding call, the iwk and wk arrays must not be disturbed.
c use of a value between 3 and 5 (inclusive) for ncp is recom-
c mended unless there are evidences that dictate otherwise.

c this subroutine calls the idcldp, idgrid, idpdrv, idptip, and
c idtang subroutines.
 
c  Starlink Status.     
      INTEGER STATUS                  ! Global status
   
c declaration statements
      dimension xd(100), yd(100), zd(100), xi(101), yi(101), zi(10201), 
     :          iwk(13301), wk(500)
      common /idpi  / itpv
      integer istat
 
c   check the inherited error status.
      if (STATUS.NE.0) return
 
c setting of some input parameters to local variables.
c (for md=1,2,3)
      md0 = md
      ncp0 = ncp
      ndp0 = ndp
      nxi0 = nxi
      nyi0 = nyi
 
c error check.  (for md=1,2,3)
      if ( md0.ge.1 .and. md0.le.3 ) then
         if ( ncp0.ge.2 .and. ncp0.lt.ndp0 ) then
            if ( ndp0.ge.4 ) then
               if ( nxi0.ge.1 .and. nyi0.ge.1 ) then
                  if ( md0.ge.2 ) then
                     ncppv = iwk(1)
                     ndppv = iwk(2)
                     if ( ncp0.ne.ncppv ) go to 100
                     if ( ndp0.ne.ndppv ) go to 100
                  else
                     iwk(1) = ncp0
                     iwk(2) = ndp0
                  end if
                  if ( md0.ge.3 ) then
                     nxipv = iwk(3)
                     nyipv = iwk(4)
                     if ( nxi0.ne.nxipv ) go to 100
                     if ( nyi0.ne.nyipv ) go to 100
                  else
                     iwk(3) = nxi0
                     iwk(4) = nyi0
                  end if
 
c allocation of storage areas in the iwk array.  (for md=1,2,3)
                  jwipt = 16
                  jwiwl = 6*ndp0 + 1
                  jwngp0 = jwiwl - 1
                  jwipl = 24*ndp0 + 1
                  jwiwp = 30*ndp0 + 1
                  jwipc = 27*ndp0 + 1
                  jwigp0 = max0(31, 27+ncp0)*ndp0
 
c triangulates the x-y plane.  (for md=1)
                  if ( md0.le.1 ) then
                     call GJP_IDTANG(ndp0,xd,yd,nt,iwk(jwipt),nl, 
     :                               iwk(jwipl),iwk(jwiwl),
     :                               iwk(jwiwp),wk,istat)
                     iwk(5) = nt
                     iwk(6) = nl
                     if ( nt.eq.0 ) then
                        if(istat.ne.0) status=1
                        return
                     end if
                  end if
 
c determines ncp points closest to each data point.  (for md=1)
                  if ( md0.le.1 ) then
                     call GJP_IDCLDP(ndp0,xd,yd,ncp0,iwk(jwipc),istat)
                     if (iwk(jwipc).eq.0) then
                        if(istat.ne.0) status=1
                        return
                     end if
                  end if
 
c sorts output grid points in ascending order of the triangle
c number and the border line segment number.  (for md=1,2)
                  if ( md0.ne.3 ) then
                     call GJP_IDGRID(xd,yd,nt,iwk(jwipt), 
     :                               nl,iwk(jwipl),nxi0,nyi0,xi,yi, 
     :                               iwk(jwngp0+1),iwk(jwigp0+1),
     :                               istat)
                  end if

c estimates partial derivatives at all data points.
c (for md=1,2,3)
                  call GJP_IDPDRV(ndp0,xd,yd,zd,ncp0,iwk(jwipc),
     :                            wk,istat)
 
c interpolates the zi values.  (for md=1,2,3)
                  itpv = 0
                  jig0mx = 0
                  jig1mn = nxi0*nyi0 + 1
                  nngp = nt + 2*nl
                  do 5 jngp = 1, nngp
                     iti = jngp
                     if ( jngp.gt.nt ) then
                        il1 = (jngp-nt+1)/2
                        il2 = (jngp-nt+2)/2
                        if ( il2.gt.nl ) il2 = 1
                        iti = il1*(nt+nl) + il2
                     end if
                     jwngp = jwngp0 + jngp
                     ngp0 = iwk(jwngp)
                     if ( ngp0.ne.0 ) then
                        jig0mn = jig0mx + 1
                        jig0mx = jig0mx + ngp0
                        do 2 jigp = jig0mn, jig0mx
                           jwigp = jwigp0 + jigp
                           izi = iwk(jwigp)
                           iyi = (izi-1)/nxi0 + 1
                           ixi = izi - nxi0*(iyi-1)
                           call GJP_IDPTIP(xd,yd,zd,nt,iwk(jwipt),nl, 
     :                                     iwk(jwipl),wk,iti,xi(ixi), 
     :                                     yi(iyi),zi(izi),istat)
 2                      continue
                     end if
                     jwngp = jwngp0 + 2*nngp + 1 - jngp
                     ngp1 = iwk(jwngp)
                     if ( ngp1.ne.0 ) then
                        jig1mx = jig1mn - 1
                        jig1mn = jig1mn - ngp1
                        do 4 jigp = jig1mn, jig1mx
                           jwigp = jwigp0 + jigp
                           izi = iwk(jwigp)
                           iyi = (izi-1)/nxi0 + 1
                           ixi = izi - nxi0*(iyi-1)
                           call GJP_IDPTIP(xd,yd,zd,nt,iwk(jwipt),nl, 
     :                                     iwk(jwipl),wk,iti,xi(ixi), 
     :                                     yi(iyi),zi(izi),istat)
 4                      continue
                     end if
 5                continue
                  if(istat.ne.0) status=1
                  return
               end if
            end if
         end if
      end if
 
c error exit
 
 100  continue
      istat = 4
      status=1
 
      end
 
 
      SUBROUTINE GJP_IDTANG(ndp,xd,yd,nt,ipt,nl,ipl,iwl,iwp,wk, 
     :                      istat)
 
 
c this subroutine performs triangulation.  it divides the x-y
c plane into a number of triangles according to given data
c points in the plane, determines line segments that form the
c border of data area, and determines the triangle numbers
c corresponding to the border line segments.
c at completion, point numbers of the vertices of each triangle
c are listed counter-clockwise.  point numbers of the end points
c of each border line segment are listed counter-clockwise,
c listing order of the line segments being counter-clockwise.

c this subroutine calls the idxchg function.
 
c the input parameters are
c     ndp = number of data points,
c     xd  = array of dimension ndp containing the
c           x coordinates of the data points,
c     yd  = array of dimension ndp containing the
c           y coordinates of the data points.
 
c the output parameters are
c     nt  = number of triangles,
c     ipt = integer array of dimension 6*ndp-15, where the
c           point numbers of the vertices of the (it)th
c           triangle are to be stored as the (3*it-2)nd,
c           (3*it-1)st, and (3*it)th elements,
c           it=1,2,...,nt,
c     nl  = number of border line segments,
c     ipl = integer array of dimension 6*ndp, where the
c           point numbers of the end points of the (il)th
c           border line segment and its respective triangle
c           number are to be stored as the (3*il-2)nd,
c           (3*il-1)st, and (3*il)th elements,
c           il=1,2,..., nl.
*     istat = starlink error message.
 
c the other parameters are
c     iwl = integer array of dimension 18*ndp used
c           internally as a work area,
c     iwp = integer array of dimension ndp used
c           internally as a work area,
c     wk  = array of dimension ndp used internally as a
c           work area.
  
c declaration statements
      dimension xd(100), yd(100), ipt(585), ipl(600), iwl(1800), 
     :          iwp(100), wk(100)
      dimension itf(2)
      data ratio/1.0e-6/, nrep/100/
      integer istat
 
*   check the inherited error status.
      if ( istat.ne.0 ) return
 
c preliminary processing
      ndp0 = ndp
      ndpm1 = ndp0 - 1
      if ( ndp0.lt.4 ) then
 
c error exit
         istat = 5
         nt = 0
         return
      else
 
c determines the closest pair of data points and their midpoint.
         dsqmn = GJP_DSQF(xd(1),yd(1),xd(2),yd(2))
         ipmn1 = 1
         ipmn2 = 2
         do 50 ip1 = 1, ndpm1
            x1 = xd(ip1)
            y1 = yd(ip1)
            ip1p1 = ip1 + 1
            do 20 ip2 = ip1p1, ndp0
               dsqi = GJP_DSQF(x1,y1,xd(ip2),yd(ip2))
               if ( dsqi.eq.0.0 ) go to 800
               if ( dsqi.lt.dsqmn ) then
                  dsqmn = dsqi
                  ipmn1 = ip1
                  ipmn2 = ip2
               end if
 20         continue
 50      continue
         dsq12 = dsqmn
         xdmp = (xd(ipmn1)+xd(ipmn2))/2.0
         ydmp = (yd(ipmn1)+yd(ipmn2))/2.0
 
c sorts the other (ndp-2) data points in ascending order of
c distance from the midpoint and stores the sorted data point
c numbers in the iwp array.
         jp1 = 2
         do 100 ip1 = 1, ndp0
            if ( ip1.ne.ipmn1 .and. ip1.ne.ipmn2 ) then
               jp1 = jp1 + 1
               iwp(jp1) = ip1
               wk(jp1) = GJP_DSQF(xdmp,ydmp,xd(ip1),yd(ip1))
            end if
 100     continue
         do 150 jp1 = 3, ndpm1
            dsqmn = wk(jp1)
            jpmn = jp1
            do 120 jp2 = jp1, ndp0
               if ( wk(jp2).lt.dsqmn ) then
                  dsqmn = wk(jp2)
                  jpmn = jp2
               end if
 120        continue
            its = iwp(jp1)
            iwp(jp1) = iwp(jpmn)
            iwp(jpmn) = its
            wk(jpmn) = wk(jp1)
 150     continue
 
c if necessary, modifies the ordering in such a way that the
c first three data points are not collinear.
         ar = dsq12*ratio
         x1 = xd(ipmn1)
         y1 = yd(ipmn1)
         dx21 = xd(ipmn2) - x1
         dy21 = yd(ipmn2) - y1
         do 200 jp = 3, ndp0
            ip = iwp(jp)
            if ( abs((yd(ip)-y1)*dx21-(xd(ip)-x1)*dy21).gt.ar )
     :           go to 300
 200     continue
 
         istat = 6
         nt = 0
         go to 99999
      end if
 300  continue
      if ( jp.ne.3 ) then
         jpmx = jp
         jp = jpmx + 1
         do 350 jpc = 4, jpmx
            jp = jp - 1
            iwp(jp) = iwp(jp-1)
 350     continue
         iwp(3) = ip
      end if
 
c forms the first triangle.  stores point numbers of the ver-
c texes of the triangle in the ipt array, and stores point num-
c bers of the border line segments and the triangle number in
c the ipl array.
      ip1 = ipmn1
      ip2 = ipmn2
      ip3 = iwp(3)
      if (GJP_SIDE2(xd(ip1),yd(ip1),xd(ip2),yd(ip2),xd(ip3),yd(ip3))
     :     .lt.0.0 ) then
         ip1 = ipmn2
         ip2 = ipmn1
      end if
      nt0 = 1
      ntt3 = 3
      ipt(1) = ip1
      ipt(2) = ip2
      ipt(3) = ip3
      nl0 = 3
      nlt3 = 9
      ipl(1) = ip1
      ipl(2) = ip2
      ipl(3) = 1
      ipl(4) = ip2
      ipl(5) = ip3
      ipl(6) = 1
      ipl(7) = ip3
      ipl(8) = ip1
      ipl(9) = 1
 
c adds the remaining (ndp-3) data points, one by one.
      do 600 jp1 = 4, ndp0
         ip1 = iwp(jp1)
         x1 = xd(ip1)
         y1 = yd(ip1)
 
c - determines the visible border line segments.
         ip2 = ipl(1)
         jpmn = 1
         dxmn = xd(ip2) - x1
         dymn = yd(ip2) - y1
         dsqmn = dxmn**2 + dymn**2
         armn = dsqmn*ratio
         jpmx = 1
         dxmx = dxmn
         dymx = dymn
         dsqmx = dsqmn
         armx = armn
         do 400 jp2 = 2, nl0
            ip2 = ipl(3*jp2-2)
            dx = xd(ip2) - x1
            dy = yd(ip2) - y1
            ar = dy*dxmn - dx*dymn
            if ( ar.le.armn ) then
               dsqi = dx**2 + dy**2
               if ( ar.lt.(-armn) .or. dsqi.lt.dsqmn ) then
                  jpmn = jp2
                  dxmn = dx
                  dymn = dy
                  dsqmn = dsqi
                  armn = dsqmn*ratio
               end if
            end if
            ar = dy*dxmx - dx*dymx
            if ( ar.ge.(-armx) ) then
               dsqi = dx**2 + dy**2
               if ( ar.gt.armx .or. dsqi.lt.dsqmx ) then
                  jpmx = jp2
                  dxmx = dx
                  dymx = dy
                  dsqmx = dsqi
                  armx = dsqmx*ratio
               end if
            end if
 400     continue
         if ( jpmx.lt.jpmn ) jpmx = jpmx + nl0
         nsh = jpmn - 1
         if ( nsh.gt.0 ) then
 
c - shifts (rotates) the ipl array to have the invisible border
c - line segments contained in the first part of the ipl array.
            nsht3 = nsh*3
            do 420 jp2t3 = 3, nsht3, 3
               jp3t3 = jp2t3 + nlt3
               ipl(jp3t3-2) = ipl(jp2t3-2)
               ipl(jp3t3-1) = ipl(jp2t3-1)
               ipl(jp3t3) = ipl(jp2t3)
 420        continue
            do 440 jp2t3 = 3, nlt3, 3
               jp3t3 = jp2t3 + nsht3
               ipl(jp2t3-2) = ipl(jp3t3-2)
               ipl(jp2t3-1) = ipl(jp3t3-1)
               ipl(jp2t3) = ipl(jp3t3)
 440        continue
            jpmx = jpmx - nsh
         end if
 
c - adds triangles to the ipt array, updates border line
c - segments in the ipl array, and sets flags for the border
c - line segments to be reexamined in the iwl array.
         jwl = 0
         do 450 jp2 = jpmx, nl0
            jp2t3 = jp2*3
            ipl1 = ipl(jp2t3-2)
            ipl2 = ipl(jp2t3-1)
            it = ipl(jp2t3)
 
c - - adds a triangle to the ipt array.
            nt0 = nt0 + 1
            ntt3 = ntt3 + 3
            ipt(ntt3-2) = ipl2
            ipt(ntt3-1) = ipl1
            ipt(ntt3) = ip1
 
c - - updates border line segments in the ipl array.
            if ( jp2.eq.jpmx ) then
               ipl(jp2t3-1) = ip1
               ipl(jp2t3) = nt0
            end if
            if ( jp2.eq.nl0 ) then
               nln = jpmx + 1
               nlnt3 = nln*3
               ipl(nlnt3-2) = ip1
               ipl(nlnt3-1) = ipl(1)
               ipl(nlnt3) = nt0
            end if
 
c - - determines the vertex that does not lie on the border
c - - line segments.
            itt3 = it*3
            ipti = ipt(itt3-2)
            if ( ipti.eq.ipl1 .or. ipti.eq.ipl2 ) then
               ipti = ipt(itt3-1)
               if ( ipti.eq.ipl1 .or. ipti.eq.ipl2 ) ipti = ipt(itt3)
            end if
 
c - - checks if the exchange is necessary.
            if (GJP_IDXCHG(xd,yd,ip1,ipti,ipl1,ipl2,istat)
     :          .ne.0) then
 
c - - modifies the ipt array when necessary.
               ipt(itt3-2) = ipti
               ipt(itt3-1) = ipl1
               ipt(itt3) = ip1
               ipt(ntt3-1) = ipti
               if ( jp2.eq.jpmx ) ipl(jp2t3) = it
               if ( jp2.eq.nl0 .and. ipl(3).eq.it ) ipl(3) = nt0
 
c - - sets flags in the iwl array.
               jwl = jwl + 4
               iwl(jwl-3) = ipl1
               iwl(jwl-2) = ipti
               iwl(jwl-1) = ipti
               iwl(jwl) = ipl2
            end if
 450     continue
         nl0 = nln
         nlt3 = nlnt3
         nlf = jwl/2
         if ( nlf.ne.0 ) then
 
c - improves triangulation.
            ntt3p3 = ntt3 + 3
            do 500 irep = 1, nrep
               do 470 ilf = 1, nlf
                  ilft2 = ilf*2
                  ipl1 = iwl(ilft2-1)
                  ipl2 = iwl(ilft2)
 
c - - locates in the ipt array two triangles on both sides of
c - - the flagged line segment.
                  ntf = 0
                  do 455 itt3r = 3, ntt3, 3
                     itt3 = ntt3p3 - itt3r
                     ipt1 = ipt(itt3-2)
                     ipt2 = ipt(itt3-1)
                     ipt3 = ipt(itt3)
                     if ( ipl1.eq.ipt1 .or. ipl1.eq.ipt2 .or. 
     :                    ipl1.eq.ipt3 ) then
                        if ( ipl2.eq.ipt1 .or. ipl2.eq.ipt2 .or. 
     :                       ipl2.eq.ipt3 ) then
                           ntf = ntf + 1
                           itf(ntf) = itt3/3
                           if ( ntf.eq.2 ) go to 460
                        end if
                     end if
 455              continue
                  if ( ntf.lt.2 ) go to 470
 
c - - determines the vertices of the triangles that do not lie
c - - on the line segment.
 460              continue
                  it1t3 = itf(1)*3
                  ipti1 = ipt(it1t3-2)
                  if ( ipti1.eq.ipl1 .or. ipti1.eq.ipl2 ) then
                     ipti1 = ipt(it1t3-1)
                     if ( ipti1.eq.ipl1 .or. ipti1.eq.ipl2 )
     :                    ipti1 = ipt(it1t3)
                  end if
                  it2t3 = itf(2)*3
                  ipti2 = ipt(it2t3-2)
                  if ( ipti2.eq.ipl1 .or. ipti2.eq.ipl2 ) then
                     ipti2 = ipt(it2t3-1)
                     if ( ipti2.eq.ipl1 .or. ipti2.eq.ipl2 )
     :                    ipti2 = ipt(it2t3)
                  end if
 
c - - checks if the exchange is necessary.
                  if (GJP_IDXCHG(xd,yd,ipti1,ipti2,ipl1,ipl2,istat)
     :                .ne.0) then
 
c - - modifies the ipt array when necessary.
                     ipt(it1t3-2) = ipti1
                     ipt(it1t3-1) = ipti2
                     ipt(it1t3) = ipl1
                     ipt(it2t3-2) = ipti2
                     ipt(it2t3-1) = ipti1
                     ipt(it2t3) = ipl2
 
c - - sets new flags.
                     jwl = jwl + 8
                     iwl(jwl-7) = ipl1
                     iwl(jwl-6) = ipti1
                     iwl(jwl-5) = ipti1
                     iwl(jwl-4) = ipl2
                     iwl(jwl-3) = ipl2
                     iwl(jwl-2) = ipti2
                     iwl(jwl-1) = ipti2
                     iwl(jwl) = ipl1
                     do 462 jlt3 = 3, nlt3, 3
                        iplj1 = ipl(jlt3-2)
                        iplj2 = ipl(jlt3-1)
                        if ( (iplj1.eq.ipl1.and.iplj2.eq.ipti2) .or. 
     :                       (iplj2.eq.ipl1.and.iplj1.eq.ipti2) )
     :                       ipl(jlt3) = itf(1)
                        if ( (iplj1.eq.ipl2.and.iplj2.eq.ipti1) .or. 
     :                       (iplj2.eq.ipl2.and.iplj1.eq.ipti1) )
     :                       ipl(jlt3) = itf(2)
 462                 continue
                  end if
 470           continue
               nlfc = nlf
               nlf = jwl/2
               if ( nlf.eq.nlfc ) go to 600
 
c - - resets the iwl array for the next round.
               jwl = 0
               jwl1mn = (nlfc+1)*2
               nlft2 = nlf*2
               do 480 jwl1 = jwl1mn, nlft2, 2
                  jwl = jwl + 2
                  iwl(jwl-1) = iwl(jwl1-1)
                  iwl(jwl) = iwl(jwl1)
 480           continue
               nlf = jwl/2
 500        continue
         end if
 600  continue
 
c rearranges the ipt array so that the vertices of each triangle
c are listed counter-clockwise.
      do 700 itt3 = 3, ntt3, 3
         ip1 = ipt(itt3-2)
         ip2 = ipt(itt3-1)
         ip3 = ipt(itt3)
         if (GJP_SIDE2(xd(ip1),yd(ip1),xd(ip2),yd(ip2),xd(ip3),yd(ip3))
     :        .lt.0.0 ) then
            ipt(itt3-2) = ip2
            ipt(itt3-1) = ip1
         end if
 700  continue
      nt = nt0
      nl = nl0
      return
 
 800  continue
      istat = 7
      nt = 0
      return
 
 
99999 continue
      end
 
 
      FUNCTION GJP_IDXCHG(x,y,i1,i2,i3,i4,istat)
 
c this function determines whether or not the exchange of two
c triangles is necessary on the basis of max-min-angle criterion
c by c. l. lawson.
 
c the input parameters are
c     x,y = arrays containing the coordinates of the data
c           points,
c     i1,i2,i3,i4 = point numbers of four points p1, p2,
c           p3, and p4 that form a quadrilateral with p3
c           and p4 connected diagonally.
c this function returns an integer value 1 (one) when an ex-
c change is necessary, and 0 (zero) otherwise.
 
c declaration statements
      dimension x(100), y(100)
      equivalence (c2sq, c1sq), (a3sq, b2sq), (b3sq, a1sq), (a4sq, b1sq)
     :             , (b4sq, a2sq), (c4sq, c3sq)
 
      integer istat
 
c preliminary processing
      x1 = x(i1)
      y1 = y(i1)
      x2 = x(i2)
      y2 = y(i2)
      x3 = x(i3)
      y3 = y(i3)
      x4 = x(i4)
      y4 = y(i4)
 
c calculation
      idx = 0
      u3 = (y2-y3)*(x1-x3) - (x2-x3)*(y1-y3)
      u4 = (y1-y4)*(x2-x4) - (x1-x4)*(y2-y4)
      if ( u3*u4.gt.0.0 ) then
         u1 = (y3-y1)*(x4-x1) - (x3-x1)*(y4-y1)
         u2 = (y4-y2)*(x3-x2) - (x4-x2)*(y3-y2)
         a1sq = (x1-x3)**2 + (y1-y3)**2
         b1sq = (x4-x1)**2 + (y4-y1)**2
         c1sq = (x3-x4)**2 + (y3-y4)**2
         a2sq = (x2-x4)**2 + (y2-y4)**2
         b2sq = (x3-x2)**2 + (y3-y2)**2
         c3sq = (x2-x1)**2 + (y2-y1)**2
 
         s1sq = u1*u1/(c1sq*amax1(a1sq,b1sq))
         s2sq = u2*u2/(c2sq*amax1(a2sq,b2sq))
         s3sq = u3*u3/(c3sq*amax1(a3sq,b3sq))
         s4sq = u4*u4/(c4sq*amax1(a4sq,b4sq))
 
         if ( amin1(s1sq,s2sq).lt.amin1(s3sq,s4sq) ) idx = 1
      end if
 
      GJP_IDXCHG = idx
      return
      end
 
 
 
c functions
 
 
      real FUNCTION GJP_DSQF(u1,v1,u2,v2)
 
      real u1, v1, u2, v2
 
      GJP_DSQF = (u2-u1)**2 + (v2-v1)**2
 
      end
 
 
      real FUNCTION GJP_SPDT(u1, v1, u2, v2, u3, v3)
 
      real u1, v1, u2, v2, u3, v3
 
      GJP_SPDT = (u1-u2)*(u3-u2) + (v1-v2)*(v3-v2)
 
      end
 
 
      real FUNCTION GJP_SIDE(u1, v1, u2, v2, u3, v3)
 
      real u1, v1, u2, v2, u3, v3
 
      GJP_SIDE = (u1-u3)*(v2-v3) - (v1-v3)*(u2-u3)
 
      end
 
 
      real FUNCTION GJP_SIDE2(u1, v1, u2, v2, u3, v3)
 
      real u1, v1, u2, v2, u3, v3
 
      GJP_SIDE2 = (v3-v1)*(u2-u1) - (u3-u1)*(v2-v1)
 
      end
 


      SUBROUTINE ELP1_SOLVE(NP,XV,YV,S,C,STATUS)
*+
*  Name: 
*     ELP1_SOLVE
 
*  Purpose:
*     To look at the variation in brightness around the ellipse
*     chosen and see what SIN and COS factors are present.     
*
*     The method used is a crude matrix inversion.
*
*     This is a temporary routine used only until PDA is working properly.
*     The current (JAN 1997) version of PDA_DBOLS falls over in some
*     instances if no compiled with an FFLAG of -check nobounds
*
*     This method is slow but stable so it is necessary to cut down the 
*     number of points used when it exceeds 90.
 
*  Language:
*     Starlink Fortran 77
 
*  Invocation:
*     CALL ELP1_SOLVE(NP,XV,YV,S,C,STATUS)
 
*  Arguments:
*     NP = INTEGER (Given)
*        The number of pixels that have an associated brightness.
*     XV(500) = DOUBLE PRECISION (Given)
*        The array containing the angle values in radians.
*     YV(500) = DOUBLE PRECISION (Given)
*        The array containing the brightness values.
*     S = DOUBLE PRECISION (Returned)
*        The SINE function amplitude.
*     C = DOUBLE PRECISION (Returned)
*        The COSINE function amplitude.
*     STATUS = INTEGER (Given and Returned) 
*        The global status.     
 
*  Authors:
*     GJP: Grant Privett (STARLINK)
 
*  History:
*     2-May-1996
*     (Original version)
*     26-Jan-1997
*     Modified to improve speed and robustness. 

*  Notes:
*     This routine is not documented and is only to be used until
*     the PDA library has been modified or recompiled so that
*     the PDA_DBOLS routine does not fall over with an array out of
*     bounds error.
*
*     This routine was required quickly for an emergency bug fix.
 
*  Bugs:
*     None known.
 
*-
*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
                     
*  Arguments Given:
      INTEGER NP                      ! Number of data points
      DOUBLE PRECISION XV(500)        ! Angle values
      DOUBLE PRECISION YV(500)        ! Brightness values
 
*  Arguments Returned:
      DOUBLE PRECISION C              ! Cosine function amplitude
      DOUBLE PRECISION S              ! Sine function amplitude
 
*  Status:     
      INTEGER STATUS                  ! Global status
 
*  Local variables:                 
      DOUBLE PRECISION CO
      DOUBLE PRECISION D     
      DOUBLE PRECISION H(500)
      DOUBLE PRECISION K2
      DOUBLE PRECISION P(3)
      DOUBLE PRECISION TRACE
      DOUBLE PRECISION W(3,500)
      DOUBLE PRECISION X(500,3)
      DOUBLE PRECISION X1
      DOUBLE PRECISION X2
      DOUBLE PRECISION XV2(500)
      DOUBLE PRECISION Y(3,500)
      DOUBLE PRECISION YV2(500)
      DOUBLE PRECISION Z(500,500)
      DOUBLE PRECISION ZERO           ! Double zero
      DOUBLE PRECISION TEMP           ! A temporary value
      INTEGER I                       ! Loop variable
      INTEGER J                       ! Loop variable
      INTEGER K                       ! Loop variable
      INTEGER L                       ! Loop variable
      INTEGER M                       ! Number of variables
      INTEGER N                       ! Number of points used
*.
 
*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN
  
*   Number of variables (ie sine and cosine and a constant).
      M=2

      N=NP
      DO WHILE (N.GT.90) 

*      Average two points (done in sets of 4 since data is organised 
*      so that sets of 4 points are all from different quadrants).
         J=1
         DO 10 I=1,N-6,8
            DO 12 K=0,3
               XV2(J)=(XV(I+K)+XV(I+K+4))/2.
               YV2(J)=(YV(I+K)+YV(I+K+4))/2.
               J=J+1
 12         CONTINUE
 10      CONTINUE         

*      Modify the number of points available.
         N=J

*      Put results back into the source array.
         DO 11 I=1,N
            XV(I)=XV2(I)
            YV(I)=YV2(I)
 11      CONTINUE         
       
      END DO
     
*   Set double precision zero.
      ZERO=0.D0
 
*   Preparing the input arrays.,
      DO 200 I = 1,N
         H(I) =   YV(I)
         X(I,1) = SIN(XV(I))
         X(I,2) = COS(XV(I))
 200  CONTINUE
 
*   Starting to process.
      DO 300 J = 1,M
        DO 400 I = 1,N
          W(J, I) = X(I, J)
 400    CONTINUE
 300  CONTINUE
 
      K2 = ZERO
      DO 500 J = 1,N
        DO 600 I = 1,N
          Z(I, J) = ZERO
          DO 700 L = 1,M
            Z(I, J) = Z(I, J) + X(I, L) * W(L, J)
 700      CONTINUE
          K2 = K2 + ABS(Z(I, J))
 600    CONTINUE
 500  CONTINUE
      K2 = 1.0D0 / K2
 
*   Threshold value.
      D =1.D-3
     
      DO 800 J = 1,N
        DO 900 I = 1,M
          Y(I, J) = K2 * W(I, J)
 900    CONTINUE
 800  CONTINUE
 
*   Cycle around until we get the right threshold.      
      X1=D*2.
      DO WHILE (X1.GT.D)
         
         DO 1000 I = 1,N
           DO 1100 J = 1,N
             Z(I, J) = ZERO
             DO 1200 L = 1,M
               Z(I, J) = Z(I, J) + X(I, L) * Y(L, J)
 1200        CONTINUE
 1100      CONTINUE
 1000    CONTINUE
 
*      Reset the array trace.
         TRACE = ZERO
         CO = 2.0D0
         DO 1300 I = 1,N
           Z(I, I) = Z(I, I) - CO
           TRACE = TRACE + Z(I, I)
 1300    CONTINUE
     
         DO 1400 J = 1,N
           DO 1500 I = 1,M
             W(I, J) = ZERO
             DO 1600 L = 1,N
               W(I, J) = W(I, J) + Y(I, L) * Z(L, J)
 1600        CONTINUE
 1500      CONTINUE
 1400    CONTINUE
 
         DO 1700 J = 1,N
           DO 1800 I = 1,M
             Y(I, J) = -W(I, J)
 1800      CONTINUE
 1700    CONTINUE
 
*      Consider the residuals.
         X1 = ABS(TRACE - INT(TRACE) - 1)
         X2 = ABS(TRACE - INT(TRACE))
         IF (X2.LT.X1) THEN 
            TEMP=X1
            X1=X2
            X2=TEMP
         END IF
 
*      Increment threshold to avoid getting stuck.
         D=D+1.D-4
     
      END DO
 
*   Generate the output parameters.
      DO 1900 I = 1,M
        P(I) = ZERO
        DO 2000 J = 1,N
          P(I) = P(I) + Y(I, J) * H(J)
 2000   CONTINUE
 1900 CONTINUE
 
*   Assign the parameters.
      S=P(1)
      C=P(2)
 
 9999 CONTINUE
 
      END 
 

