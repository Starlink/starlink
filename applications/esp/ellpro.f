       SUBROUTINE ELLPRO(STATUS)
*+
*  Name:
*     ELLPRO

*  Purpose:
*     Performs an ellipse fitting galaxy profile using simple
*     intensity analysis.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELLPRO( STATUS )

*  Arguments:
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description:
*
*     Fits a galaxy profile using simple intensity analysis.  The
*     routine fits a series of ellipses to the galaxy, at varying
*     intensity values, and displays the position, size and angle of
*     these ellipses, as well as the azimuthally-averaged intensity
*     around them.  It plots these intensities as a function of radius.
*
*     The position of the centre of the galaxy
*     (and a number of other parameters) may be specified
*     interactively (using cursor or keyboard) or the location
*     within the image of several galaxies may be specified using
*     an ASCII text file.
*
*     A number of options allow the user to determine criteria for
*     when profiling should end, whether an ARD file is to be used
*     to mask out bad areas of the image, whether the initial galaxy
*     centre value is to be fixed throughout profiling, and whether
*     or not the initial galaxy centre co-ordinates provided
*     by the user may be refined by the application before the first
*     profile is generated.
*
*     The position of the centre of the galaxy in question may be
*     input interactively, MODE=TRUE), or (if there are many galaxies
*     to be considered) may be read in from a text file (MODE=FALSE).
*     In addition, when in MODE=TRUE the galaxy can be identified
*     using a cursor (CURSOR=TRUE) as opposed to a keyboard entry of
*     its co-ordinates.

*  Usage:
*     ELLPRO MODE BACK SIGMA PSIZE ZEROP ARDFIL DEVICE OUT (OUTCAT)
*            AUTOL AUTOLT FRZORI [CURSOR] [IN] [ORIGIN] (FAST)
*            (FINE) [RLIM] (LIM1) (LIM2) (LIM3) (FRACT) [SAME]
*            [AGAIN] [INFILE) [IMGDEV] (COLOUR) (ANGCON) (ANGOFF)

*  ADAM Parameters:
*     AGAIN=_LOGICAL (Read)
*        Allows the user to elect to repeat the profiling operation
*        on the current input image.
*     ANGCON=_LOGICAL (Read)
*        Angle rotation convention. Defines if clockwise or
*        anticlockwise is considered positive. TRUE=Clockwise.
*     ANGOFF=_REAL (Read)
*        Angular offset for position angles generated. Units degrees.
*     ARDFIL=_CHAR (Read)
*        The name of an ARD file to be used to mask out regions of the
*        image that are not to be used.
*     AUTOL=_LOGICAL (Read)
*        If true, then the application attempts to find a better initial
*        estimate of the galaxy centre.  See also the AUTOLT parameter
*        for further control of this, and contrast the FRZORI parameter.
*     AUTOLT=_LOGICAL (Read)
*        Controls the method used when improving the estimate of the
*        galaxy centre (see parameter AUTOL).  If autolt=true, the
*        application refines the initial galaxy centre by taking the
*        centroid of the points in a small region around the given
*        location.  If autolt=false, it uses an alternative
*        weighted-mean method.
*     BACK=_REAL (Read)
*        The background count value for the image. Units counts.
*     COLOUR = _INTEGER (Given)
*        Colour of the pen used to mark galaxy centres.
*     CURSOR=_LOGICAL (Read)
*        Whether the galaxy locations are to be identified using the
*        graphics cursor or the keyboard. True=cursor. False=keyboard.
*     DEVICE=_DEVICE (Read)
*        Name of the graphics device on which the results graph should
*        be displayed.
*     FAST=_LOGICAL (Read)
*        Is the faster method of profiling to be used? Default value is
*        true. The slower version should yield better values at low
*        radii values since surface interpolation (rather than
*        bi-linear) is used. The surface generated by the slow method to
*        model the galaxy near its centre is a 8x8 bi-cubic spline, so
*        considerable calculation is involved.
*     FINE=_REAL (Read)
*        A factor modifying the default separation of ellipses
*        profiled. The default value is 1. Decreasing this value
*        increases the number of profiles generated for a given object.
*        Increasing this value above 2.0 is not recommended.
*     FRACT=_REAL (Read)
*        The minimum fraction of the points round the ellipse for which
*        no value was available due to either image pixels set to the
*        bad value or parts of the ellipse being beyond the bounds of
*        the image. If the fraction of points available for a given
*        ellipse drops below this value the results for that radius
*        are not kept.
*     FRZORI=_LOGICAL (Read)
*        If FRZORI is true, then the initial galaxy position, after any
*        initial refinement if the AUTOL parameter is true, will be
*        frozen for the rest of the calculation.  If FRZORI is false,
*        then the initial estimate will be allowed to drift if that
*        improves an ellipse fit.
*     IMGDEV=_DEVICE (Read)
*        Name of the graphics device displaying an image.
*     INFILE=_CHAR (Read)
*        Name of a text file containing the co-ordinates of galaxies
*        to be profiled. (Only used in file mode i.e. MODE=FALSE)
*        Co-ordinates are in the Current coordinate system of the
*        WCS component of IN.
*     IN=_NDF (Read)
*        The name of the source NDF data structure/file.
*     LIM1=_REAL (Read)
*        The maximum ratio that is permitted between the average mean
*        count value of the two preceeding radii profiled and that of
*        the current radius. If this value is exceeded, the profiling
*        operation stops.
*     LIM2=_REAL (Read)
*        The lower limit for mean profile count value (above sky).
*        If the mean count value for the current profile drops below
*        this value the profiling operation stops. Units
*        are standard deviations.
*     LIM3=_REAL (Read)
*        The distance from the galaxy origin at which the profile is
*        assumed to maintain a constant position angle, origin and
*        ellipticity. At radii beyond these, parameters are no longer
*        modified. The position angle, origin and ellipticity are not
*        frozen if a value of zero or less than zero is suggested.
*        Units are pixels
*     MINMOD=_INTEGER (Read)
*        Which type of ellipse-residual minimisation is to be used.
*
*        The type of residual to be calculated is specified as 0, 1 or
*        2.  It's not
*        completely clear what is the best type of residual to use.  The
*        original one -- a weighted standard error, selected by giving
*        this parameter the option~0 -- is rational, but not obviously
*        ideal.  As alternatives, you can use the range and the
*        squared-differences, selectable by options~1 and~2 respectively.
*        This also controls which type of statistic is returned in
*        the final column of the ELLPRO output file: this statistic is
*        the mean, median and mean (including background) in the three
*        cases, but you should not regard this as useful information.
*        You are advised not to play with this unless you particularly wish to
*        experiment.  If this parameter makes much of a difference, the
*        ESP maintainer would be interested to hear about it.
*     MODE=_LOGICAL (Read)
*        Whether the application is to run in file input mode or
*        interactively. Interactive MODE=TRUE. File mode=FALSE.
*     ORIGIN=_REAL (Read)
*        Image co-ordinates for the origin point to be used.  Co-ordinates
*        are in the Current co-ordinate system of the WCS component
*        of IN.
*     OUT=_CHAR (Read)
*        File name for the output text file containing the profile
*        data.
*     OUTCAT=_CHAR (Read)
*        File name for an output file which is written using the CAT
*        library.  See SUN/181.  The type of catalogue which is written
*        depends on the file extension to the filename presented here.
*        A file ending .txt will be written as a STL (Small Text List)
*        file, and one ending .fits will be written as a FITS file.
*     PSIZE=_REAL (Read)
*        The size of each pixel in arc seconds.  If the image contains
*        a SKY co-ordinate frame this value will be determined
*        automatically.
*     RLIM=_REAL (Read)
*        Radius at which the profiling will be stopped. Units pixels.
*     SAME=_LOGICAL (Read)
*        Is the results graph to be displayed on the device currently
*        displaying the input image? Only valid if CURSOR is true.
*        If SAME is set to true then the user is prompted to identify
*        the quadrant of the input device in which graph will be
*        displayed.
*     SIGMA=_REAL (Read)
*        The standard deviation of the background value. Units counts.
*     ZEROP=_REAL (Read)
*        Zero point of the scale for surface brightness plots. Units
*        magnitudes per arc seconds.

*  Examples:
*     ellpro mode=true back=6200 sigma=390
*            zerop=27.5 ardfil=^ardfile.dat device=xwindows
*            out=elp1.dat autol=true frzori=false cursor=false
*            in=p2 rlim=10 origin="12:36:53.42 62:12:21.8"
*
*        Performs profiling on an object positioned at the co-ordinates
*        indicated on image P2; the Current co-ordinate system of P2 is
*        in the SKY domain.  Pixel size in arcseconds will be determined
*        automatically from the SKY co-ordinates.  The profile
*        determined will  be output to a graphical display on device
*        XWINDOWS and to text file ELP1.DAT. The galaxy centre
*        provided will be refined by the application and during
*        profiling the galaxy centre will be allowed to change. The
*        profiling will be stopped at a radius of 10 pixels.
*
*     ellpro mode=true back=6200 sigma=390 psize=1. zerop=27.5
*            ardfil=^ardfile.dat device=xwindows out=elp1.dat
*            autol=false frzori=true cursor=true
*
*       Performs profiling on a galaxy identified using a cursor/mouse
*       and the most recently displayed image. The ARD area definition
*       contained in the file ARDFILE.DAT is used to mask out bad
*       parts of the image. The galaxy centre identified by the user
*       is not refined by the software and is not allowed to change
*       during profiling. The galaxy location is defined using a
*       cursor/mouse on the most recently displayed image.
*
*     ellpro mode=false back=760 sigma=12 psize=0.44 zerop=27.5
*            ardfil=^arddef.dat in=p2 infile=p2log.dat
*            out=output.dat autol=true frzori=false
*
*       The appliication reads the object locations in file P2LOG.DAT
*       (in the Current co-ordinates of P2) and performs profiling on
*       those locations on image P2. The profiling output is displayed
*       on the text screen and is also placed in file OUTPUT.DAT.

*  Notes:
*     Parameters surrounded by curved brackets may only be
*     modified via the command line.

*  Authors:
*     GJP: Grant Privett (STARLINK)
*     MBT: Mark Taylor (STARLINK)
*     NG: Norman Gray (Starlink, Glasgow)

*  History:
*     19-JUL-1994 (GJP).
*       Original version
*     16-OCT-1996 (GJP).
*       NAG free version.
*     27-JAN-1997 (GJP).
*       Modified output formatting to make it work better with
*       very large images. Also tweaked ELP1_SOLVE routine
*       to enhance robustness/speed. Some pointer usage slightly modified.
*     8-NOV-1999 (MBT).
*       Modified to work with World Coordinate System components.
*     5-Feb-2000 (NG).
*       Added OUTCAT parameter, assorted fixes.

*-

*  Developer notes, not to appear in generated documentation:
*
*     [NG, 9-Dec-1999] Throughout this task, the ellipses are
*     parameterised by a `radius', RADIUS, and an `ellipticity', ELLIP.
*     Somewhat confusingly, these two parameters are not the radius and
*     ellipticity of the ellipse, but instead the semi-major axis and
*     1/ellipticity.  The ellipticity is semi-major/semi-minor, and not,
*     as Grant has it, semi-minor/semi-major.  The (real) ellipticity is
*     related to the eccentricity as
*     $\mbox{ellipticity}=1/\sqrt(1-e^2)$.  I haven't changed the
*     parameter names in this version, nor the output, but I have
*     changed the header on the appropriate output column.

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Status:
      INTEGER STATUS                  ! Global status

*  Local Variables:
      LOGICAL CURSOR                  ! Keyboard or cursor origin selction
      LOGICAL MODE                    ! Interactive or file mode
      REAL TEMP                       ! Temporary value

*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Initialise the random number generator.
      CALL ELP1_RAND(0,2001,TEMP,STATUS)

*   Show that the application is running.
      CALL MSG_BLANK(STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999
      CALL MSG_OUT(' ','ESP ELLPRO running.',STATUS)

*   Get the user selection of working interactively or by file?
      CALL PAR_GET0L('MODE',MODE,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999

*   Begin AST context.
      CALL AST_BEGIN(STATUS)

*   Transfer control to a fully interactive mode or to file input
*   handling routine.
      IF (.NOT.MODE) THEN

*      Pass control to a file input routine.
         CALL ELP1_FMODE(STATUS)

      ELSE

*      Get the user selection of using the cursor or a keyboard?
         CALL PAR_GET0L('CURSOR',CURSOR,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Pass control to an appropriate interactive routine.
         IF (.NOT.CURSOR) THEN
*         Keyboard user input.
            CALL ELP1_KMODE(STATUS)
         ELSE
*         Keyboard and mouse input.
            CALL ELP1_CMODE(STATUS)
         END IF

      END IF

*   Abort the program.
 9999 CONTINUE

*   End AST context.
      CALL AST_END(STATUS)

      END



      SUBROUTINE ELP1_INTER(ELEMS,ARRAY,NUMPOI,X,Y,PRANGE,USED,
     :                       VA,STATUS)
*+
*  Name:
*     ELP1_INTER1

*  Purpose:
*     Uses an 8x8 grid based set of image points to obtain the interpolated
*     value at a given image location using PDA spline routines.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_INTER(ELEMS,ARRAY,NUMPOI,X,Y,PRANGE,USED,
*                      VA,STATUS)

*  Description:
*     The values of image pixels forming a 8x8 grid surrounding a given
*     image location are passed to a PDA routine which uses it to
*     generate a 3-D surface via a bi-cubic spline method.
*
*     This surface is then used to determine the values of image pixel
*     count at the points around the 'fit' ellipse.
*
*     The first method fails if any of the 8x8 image pixels are not
*     available due to being BAD or off the edge of the image. This is
*     A call is then made to another (slower) routine that does not
*     require an entire grid to be available.

*  Arguments:
*     ELEMS = INTEGER (Given)
*        The number of pixels in the image.
*     ARRAY(ELEMS) = REAL (Given)
*        The image array.
*     NUMPOI = INTEGER (Given)
*        The number of ellipse points defined.
*     X(ELP__MXPOI) = REAL (Given)
*        X co-ordinates of the 'fit' ellipse points.
*     Y(ELP__MXPOI) = REAL (Given)
*        Y co-ordinates of the 'fit' ellipse points.
*     PRANGE(2) = INTEGER (Given)
*        Dimensions of the image. Units pixels.
*     USED(ELP__MXPOI) = INTEGER (Returned)
*        Was a value pixel count value found for a given ellipse
*        'fit' point.
*     VA(ELP__MXPOI) = REAL (Returned)
*        The value found at a given image location. The position
*        is defined in XR and YR arrays. Units counts.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     12-Feb-1996 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'PRM_PAR'               ! PRIMDAT primitive data constants
      INCLUDE 'ELP_PAR'               ! ELLPRO constants

*  Status:
      INTEGER STATUS                  ! Global status

*  Arguments Given:
      INTEGER ELEMS                   ! Number of pixels in the image
      INTEGER NUMPOI                  ! Number of ellipse points
      INTEGER PRANGE(2)               ! Dimensions of the image
      REAL ARRAY(ELEMS)               ! Image array
      REAL X(ELP__MXPOI)              ! X co-ord for the translated ellipse
      REAL Y(ELP__MXPOI)              ! Y co-ord for the translated ellipse

*  Arguments Given and Returned:
      INTEGER USED(ELP__MXPOI)        ! Was the interpolation for a given
                                      ! ellipse point successful
      REAL VA(ELP__MXPOI)             ! Value of the pixel count at each
                                      ! of the ellipse locations

*  Local variables:
      INTEGER FAIL                    ! Interpolation failed for method
      INTEGER HIGHX                   ! Grid limits
      INTEGER HIGHY                   ! Grid limits
      INTEGER I                       ! Loop variable
      INTEGER J                       ! Counter
      INTEGER K                       ! Loop variable
      INTEGER L                       ! Counter
      INTEGER LOWX                    ! Grid limits defining edge of grid/mesh
      INTEGER LOWY                    ! Grid limits defining edge of grid/mesh
      INTEGER ORD                     ! Order of polynomial
      REAL VALUE                      ! Pixel count value
      DOUBLE PRECISION FV1(8,8)       ! Grid Z values
      REAL             FV2(64)        ! Gird Z values
      DOUBLE PRECISION XD             ! X coord
      REAL             XR             ! X coord
      DOUBLE PRECISION X1(8)          ! X gird location
      DOUBLE PRECISION YD             ! Y coord
      REAL             YR             ! X coord
      DOUBLE PRECISION Y1(8)          ! Y grid location

      REAL             XV(64)         ! Pixel co-ordinates
      REAL             YV(64)         ! Pixel co-ordinates

      INTEGER ADDR                    ! Pixel address in array
      INTEGER IFAIL                   ! Was the 3-D surface successfully
                                      ! created?
      INTEGER MXY                     ! Size of the grid
      INTEGER ID                      ! Specifies use value not differential

      DOUBLE PRECISION BCOEF(8,8)     ! Array used by GJP_DB2INK
      DOUBLE PRECISION DVALUE         ! Interpolated value returned
      DOUBLE PRECISION TX(11),TY(11)  ! Array used by GJP_DB2INK
      DOUBLE PRECISION WORK(168)      ! Array used by GJP_DB2INK

      INTEGER  IWK(2500)              ! Work space
      INTEGER  NCP,NOP                ! Mode control/number of points
      INTEGER  NXI,NYI                ! Grid size
      INTEGER  MD                     ! Mode

      REAL     WK(640)                ! Workspace
      REAL     XI(1),YI(1)            ! Required coords
      REAL     ZI(1,1)                ! Interpolated value

*.
*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Order of the polynomial used.
      ORD=3

*   Use value rather than differential.
      ID=0

*   Setup parameters for a 8x8 grid of data points.
*   MX must be even numbers.
      MXY=8

*   Look at each of the ellipse 'fit' locations in turn.
      DO 5 K=1,NUMPOI

*      Assign the latest X and Y co-ordinates.
         XR=X(K)
         YR=Y(K)
         XD=DBLE(XR)
         YD=DBLE(YR)

*      Calculate the grid limits.
         LOWX=INT(XR) -MXY/2
         HIGHX=INT(XR)+MXY/2-1
         LOWY=INT(YR) -MXY/2
         HIGHY=INT(YR)+MXY/2-1

*      Ignore the current value if the x or y values required are off
*      the image. Also set the flag.
         IF ((LOWX.LT.1).OR.(HIGHX.GT.PRANGE(1)).OR.
     :       (LOWY.LT.1).OR.(HIGHY.GT.PRANGE(2))) THEN

            IFAIL=1

         ELSE

*         Set up the array containing the x co-ordinates of the pixel
*         grid to be used. Points surround the required location.
            J=0
            DO 10 I=LOWX,HIGHX
               J=J+1
               X1(J)=DBLE(I)
 10         CONTINUE

*         Set up the array containing the y co-ordinates of the pixel
*         grid to be used. Points surround the required location.
            J=0
            DO 20 I=LOWY,HIGHY
               J=J+1
               Y1(J)=DBLE(I)
 20         CONTINUE

*         Set up the array containing the observed pixel counts for the
*         grid points.
            L=0
            DO 30 I=1,MXY
               DO 40 J=1,MXY

*               Calculate the array element in which the image pixel is.
                  ADDR=INT(Y1(J)-1)*PRANGE(1)+INT(X1(I))
                  VALUE=ARRAY(ADDR)

*               Check to ensure that no bad points are present.
                  IF (VALUE.NE.VAL__BADR) THEN

*                  Increment the counter.
                     L=L+1

*                  Save the surface data.
                     XV(L)=REAL(X1(I))
                     YV(L)=REAL(Y1(J))
                     FV1(I,J)=DBLE(VALUE)
                     FV2(L)=VALUE

                  END IF

 40            CONTINUE

 30         CONTINUE

         END IF

*      Only interpolate if a grid can be constructed.
         IF (L.GT.31.) THEN

            FAIL=0
            IF (L.EQ.64) THEN

*            Build surface using complete grid.
               IFAIL=0
               CALL GJP_DB2INK(X1,MXY,Y1,MXY,FV1,MXY,
     :                         ORD,ORD,TX,TY,BCOEF,
     :                         WORK,IFAIL,STATUS)

*            See if the routine exited okay
               IF (IFAIL.EQ.1) THEN

*               Interpolate.
                  IFAIL=0
                  CALL GJP_DB2VAL(XD,YD,ID,ID,TX,TY,
     :                            MXY,MXY,ORD,ORD,BCOEF,WORK,
     :                            DVALUE,IFAIL,STATUS)

                  IF (IFAIL.NE.0) THEN

*                  Set the fail flag.
                     FAIL=1

                  ELSE

*                  Keep the result.
                     VA(K)=REAL(DVALUE)
                     USED(K)=1

                  END IF

               ELSE

*               Reset status.
                  STATUS=SAI__OK
                  FAIL=1

               END IF

            END IF

            IF ((FAIL.GT.0).OR.(L.NE.64)) THEN


*            Set the error flag default value.
               IFAIL=0

*            Set mode and the grid positions (for GJP_IDBVIP).
               MD= 1
               NCP=2
               NOP=1
               NXI=1
               NYI=1

*            Set up locations to interpolate.
               XI(1)=XR
               YI(1)=YR

*            Call interpolation subroutine.
               CALL GJP_IDBVIP(MD,NCP,L,XV,YV,FV2,NOP,XI,YI,
     :                         ZI,IWK,WK,IFAIL,STATUS)

*            Keep the result.
               IF (IFAIL.EQ.0) THEN

                  VA(K)=ZI(1,1)
                  USED(K)=1

               ELSE

*               Reset status.
                  STATUS=SAI__OK

               END IF

            END IF

         END IF

 5    CONTINUE

 9999 CONTINUE

      END


      SUBROUTINE ELP1_PRO(DMODE,MINMOD,ANGCON,ANGOFF,FRZORI,FINE,
     :     LIM1,LIM2,LIM3,FRACT,PSIZE,FAST,RLIM,BACK,SIGMA,
     :     ELEMS,ARRP,PRANGE,XCO,YCO,VALIDP,
     :     RESULT,STATUS)
*+
*  Name:
*     ELP1_PRO

*  Purpose:
*     Routine wherein the ellipse parameters and Fourier descriptors
*     are determined.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ELP1_PRO(DMODE,MINMOD,ANGCON,ANGOFF,FRZORI,FINE,LIM1,LIM2,LIM3,
*                   FRACT,PSIZE,FAST,RLIM,BACKS,DEV,ELEMS,ARRP,PRANGE,
*                   XCO,YCO,VALIDP,RESULT,STATUS)

*  Description:
*     The routine works by examining the intensity variation of pixels
*     around a theoretical ellipse. A minimisation method where
*     ellipse ellipticity, origin and position angle are varied is employed
*     to determine what values of these parameters lead to the
*     minimum variation in intensity around the ellipse. Care is taken
*     to ensure this isnt acheived by merely moving the ellipse away
*     from the galaxy centre and down into the noise. The ellipse
*     parameters are varied over a wide range to ensure that local minima
*     are avoided if possible.
*
*     Pixel brightness values are obtained by bi-linear interpolation or
*     (FAST=FALSE) bi-cubic spline.
*
*     Once the ellipse parameters have been determined these are used
*     to normalise the pixel positions to a unit circle. The brightness
*     variations around the circle are analysed to determine the
*     Fourier descriptors.

*  Arguments:
*     DMODE = INTEGER (Given)
*        Is a display to be generated? 0=No 1=Yes.
*     MINMOD = INTEGER (Given)
*        Which type of ellipse-residual minimisation is to be used (see
*        elp1_stats)
*     FRZORI = LOGICAL (Given)
*        Is the galaxy centre given to be used unchanged or is it
*        allowed to be modified?
*     FINE = REAL (Given)
*        Determines how closely spaced the radii are to be.
*     LIM1 = REAL (Given)
*        Defines how large an upward fluctuation in the ellipse mean count
*        value may be tolerated between adjacent radii.
*     LIM2 = REAL (Given)
*        Defines a lower limit of ellipse mean count value at which point the
*        ellipse fitting is terminated.
*     LIM3 = REAL (Given)
*        The ellipse radius value at which the position angle, ellipticity
*        and origin are frozen. If the value is less than or equal to zero
*        no such cutoff is applied. Units pixels.
*     FRACT = REAL (Given)
*        Proportion of points within an ellipse that must be valid for
*        the result for that radius to be retained.
*     PSIZE = REAL (Given)
*        The pixel size. Units arc secs.
*     FAST = LOGICAL (Given)
*        Use the faster method of interpolating data points at low radii?
*     RLIM = REAL (Given)
*        The maximum distance from the origin at which profiling
*        takes place.
*     BACK = REAL (Given)
*        The background count for the image. Units counts.
*     SIGMA = REAL (Given)
*        Standard deviation value of BACK. Units counts.
*     ELEMS = INTEGER (Given)
*        Number of elements/pixels in the image array. Units pixels.
*     ARRP(1) = INTEGER (Given)
*        Pointer to the image array.
*     PRANGE(2) = INTEGER (Given)
*        Length of the X and Y axes of the image. Units pixels.
*     XCO = REAL (Given)
*        X index of the galaxy centre/origin supplied by the user.
*        Units pixels.
*     YCO = REAL (Given)
*        Y index of the galaxy centre/origin supplied by the user.
*        Units pixels.
*     VALIDP = INTEGER (Returned)
*        Number of valid radius fits stored.
*     RESULT(ELP__NRES,ELP__RESUL) = REAL (Returned)
*        Fitted ellipse parameters.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)
*     NG: Norman Gray (Starlink, Glasgow)

*  History:
*     20-Mar-1993 (GJP)
*     (Original version)
*     20-FEB-1997 (GJP)
*     Removed improper use of INTEGER as LOGICAL.
*     18 Aug 1998 (NG)
*     Changed calls to elp1_stats to use newer version.

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'ELP_PAR'               ! ELLPRO constants
      INCLUDE 'CNF_PAR'

*  Status:
      INTEGER STATUS                  ! Global status

*  Arguments Given:
      INTEGER ARRP(1)                 ! The image array pointer
      INTEGER DMODE                   ! Is a display to be generated
      INTEGER MINMOD                  ! Which minimisation statistic to use
      LOGICAL ANGCON                  ! Angular rotation convention
      LOGICAL FAST                    ! Use fast method of profiling?
      LOGICAL FRZORI                  ! Frozen galaxy origin?
      LOGICAL STOP                    ! Should the profiling stop
      INTEGER ELEMS                   ! Number of pixels in the image
      INTEGER PRANGE(2)               ! Image size
      REAL ANGOFF                     ! Angular offset for output
                                      ! position angles
      REAL BACK                       ! Background count value
      REAL FINE                       ! Radii separation factor
      REAL FRACT                      ! Proportion of points in an
                                      ! ellipse that must be valid for the
                                      ! result to be retained
      REAL LIM1                       ! Count increase limit factor
      REAL LIM2                       ! Determines lower count limit
      REAL LIM3                       ! Radius at which the parameters
                                      ! are frozen
      REAL PSIZE                      ! Pixel size
      REAL RLIM                       ! Maximum ellipse radius used
      REAL SIGMA                      ! Std. dev. of BACK
      REAL XCO                        ! X co-ordinate of the object
      REAL YCO                        ! Y co-ordinate of the object

*  Arguments Returned:
      INTEGER VALIDP                  ! Number of valid radius fits
      REAL RESULT(ELP__NRES,ELP__RESUL)      ! Ellipse parameters

*  Arguments Given and Returned:

*  Local variables:
      LOGICAL FIRST                   ! Is this the first profile?
      LOGICAL ONCE                    ! Permit a reduction in radius only once
      CHARACTER *(80) TEXT            ! An output message token
      INTEGER CHANGE                  ! Was a parameter changed at all?
      INTEGER FLAG                    ! Was the interpolation successful?
      INTEGER FOUND                   ! Number of ellipse points for
                                      ! which a value was found
      INTEGER I                       ! Miscellaneous loop
      INTEGER J                       ! Miscellaneous counter
      INTEGER K                       ! Miscellaneous counter
      INTEGER LOOPMAX                 ! The maximum number of attempts
                                      ! to fit a given radius
      INTEGER NUMPOI                  ! Number of pixels in the current
                                      ! 'fit' ellipse
      INTEGER TRYS                    ! Number of times a fit parameter
                                      ! is changed before the next
                                      ! parameter is considered
      INTEGER STRYS                   ! Above but only counting those
                                      ! occasions on which a sensible fit
                                      ! was obtained
      INTEGER USED(ELP__MXPOI)        ! Was an ellipse point used
      REAL ANGL(ELP__MXPOI)           ! Position angle of each ellipse point
      REAL ANGLE                      ! Current position angle
      REAL CURX                       ! Current X co-ord
      REAL CURY                       ! Current Y co-ord
      REAL DIS(ELP__MXPOI)            ! Distance of each ellipse point from
                                      ! the ellipse origin
      REAL EGUESS                     ! Initial ellipticity value
      REAL ELL                        ! Temporary ellipticity value
      REAL ELLIP                      ! Current ellipticity value
      REAL FACT                       ! Multiplying factor
      REAL HIGH                       ! Highest residual value found for
                                      ! the 'fit' loop
      REAL LOOPS                      ! Loops counter for the number of
                                      ! iterations at a given radius
      REAL MEAN                       ! Mean pixel count for current ellipse
      REAL MINANG                     ! Lower limit of the position angle rang
      REAL MINELL                     ! Minimum ellipticity permitted
      REAL MAXELL                     ! Maximum ellipticty permitted
      REAL MAX                        ! A temporary value
      REAL MIN                        ! A temporary value
      REAL MAXANG                     ! Upper limit of the position angle rang
      REAL PAR(20)                    ! Latest values for a given parameter
      REAL PAR2(20)                   ! Latest values for a given parameter
      REAL PGUESS                     ! Initial position angle value
      REAL POSANG                     ! Position angle of the object
      REAL RADIUS                     ! Ellipse radius currently in use
      REAL RANGE                      ! Temporary value
      REAL RES(20)                    ! Residuals at parameter values given
                                      ! by PAR
      REAL RESID                      ! Ellipse 'fit' residuals
      REAL RND                        ! A random number
      REAL SDP                        ! Standard deviation of the points on
                                      ! the 'fit' ellipse
      REAL STAT                       ! Statistic returned from elp1_stats
      REAL TEMP                       ! Temporary value
      REAL VA(ELP__MXPOI)             ! Interpolated values of the pixels
                                      ! at the required points of the 'fit'
                                      ! ellipse
      REAL X                          ! Current X co-ordinate
      REAL XCH                        ! Amount by which X co-ord may
                                      ! be varied
      REAL XR(ELP__MXPOI)             ! X co-ord for the translated ellipse
      REAL XCHS                       ! Initial value of XCH
      REAL Y                          ! Current Y co-ordinate
      REAL YCH                        ! Amount by which Y co-ord may
                                      ! be varied
      REAL YCHS                       ! Initial value of YCH
      REAL YR(ELP__MXPOI)             ! X co-ord for the translated ellipse
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Initialize housekeeping variables.
      VALIDP=0
      LOOPMAX=75
      STOP=.FALSE.

*   Set the once only radius reduction flag.
      ONCE=.TRUE.

*   Set up the initial X and Y ellipse origin.
      X=XCO
      Y=YCO

*   Get an estimate for the first position angle, radius and
*   ellipticity values to try. retain the initial value of radius
*   for later use.
      CALL ELP1_GUESS(DMODE,ANGCON,SIGMA,BACK,X,Y,ELEMS,
     :                %VAL(CNF_PVAL(ARRP(1))),
     :                PRANGE,POSANG,RADIUS,ELLIP,STATUS)
      EGUESS=ELLIP
      PGUESS=POSANG

*   Loop round until the radius has become too large or the outer edge
*   of the galaxy has been detected.
      FIRST=.TRUE.
      DO WHILE (((RADIUS.LT.RLIM).OR.(FIRST)).AND.(.NOT.STOP))

*      Clear the first profile flag.
         FIRST=.FALSE.

*      Initialize loop counter.
         LOOPS=0

*      Set up the initial parameter values. Use previous values as a guide.
         IF (VALIDP.GT.1) THEN

            IF (RESULT(4,VALIDP-1).GT.RESULT(4,1)) THEN

*            For radii larger than the first.
               X=(RESULT(1,VALIDP)+RESULT(1,VALIDP-1))/2.
               Y=(RESULT(2,VALIDP)+RESULT(2,VALIDP-1))/2.

               IF(RESULT(4,VALIDP).LT.RESULT(4,1)) THEN
                  ELLIP=(EGUESS+RESULT(3,VALIDP-1)+ELLIP)/3.
                  POSANG=(PGUESS+RESULT(5,VALIDP-1)+POSANG)/3.
               ELSE
                  ELLIP=(RESULT(3,VALIDP-1)+ELLIP)/2.
                  POSANG=(RESULT(5,VALIDP-1)+POSANG)/2.
              END IF

            ELSE

*            For radii smaller than the first.
               X=RESULT(1,1)
               Y=RESULT(2,1)
               ELLIP=(RESULT(3,1)+EGUESS)/2.
               POSANG=(RESULT(5,1)+PGUESS)/2.

            END IF

         END IF

*      Set sensible ellipticity limits.
         IF (ELLIP.LT.0.1) ELLIP=0.1
         IF (ELLIP.GT.0.9) ELLIP=0.9

*      Assign the current values of the parameters and skip the iterative
*      search if the radius has exceeded the value at which position angle,
*      centre and ellipticity are no longer changed.
         IF ((RADIUS.GE.LIM3).AND.(LIM3.GT.ELP__VSMAL)) THEN

            CHANGE=1

         ELSE

*         Perform the iterative search for a minimum value for the scatter
*         of the pixel points found around the ellipse.

*         Initialise the number of angles etc that will be tried per loop,
*         the number of loops that will be allowed at a given radius, the
*         angular range over which position may vary and the permitted
*         initial spread of values permitted for the variation of ellipticity,
*         X and Y.
            IF (VALIDP.EQ.0) THEN

*            First profile generated at a given radius.
               TRYS=20
               LOOPMAX=60
               MINANG=POSANG-22.5
               MAXANG=POSANG+22.5
               MINELL=ELLIP-.25
               MAXELL=ELLIP+.25
               XCHS=.5
               YCHS=.5

            ELSE

*            Subsequent profiles at the current radius.
               TRYS=10
               LOOPMAX=10
               MINANG=POSANG-5.
               MAXANG=POSANG+5.
               MINELL=ELLIP-.1
               MAXELL=ELLIP+.1
               XCHS=.1
               YCHS=.1

            END IF

*         Generate the the points on an untransformed
*         un/rotated version of the current 'fit' ellipse.
            CALL ELP1_GENER(ELLIP,RADIUS,NUMPOI,ANGL,DIS,STATUS)

*         Set a flag to show that during the loops one of the
*         parameters did change.
            CHANGE=0

            DO WHILE (LOOPS.LT.LOOPMAX)

*            Set up the current amounts by which fit parameters
*            may be adjusted.
               FACT=(1.-.5*REAL(LOOPS)/REAL(LOOPMAX))
               XCH=XCHS*FACT
               YCH=YCHS*FACT

*            Ensure the ellipticity range is within .01 to .99
               IF (MINELL.LT.0.01) MINELL=.01
               IF (MINELL.GT.0.98) MINELL=.98
               IF (MAXELL.GT.0.99) MAXELL=.99
               IF (MAXELL.LT.0.02) MAXELL=.02

*            VARY THE POSITION ANGLE

*            Translate/rotate the raw 'fit' ellipse co-ordinates to generate
*            their positions on the image. Then examine the
*            pixel count value at each and determine some measure of their
*            variation. Repeat varying position angle.
               STRYS=0
               DO 40 I=1,TRYS

*               Generate an angle value within the allowed range.
                  ANGLE=MINANG+(I-1)*(MAXANG-MINANG)/(TRYS-1)
                  CALL ELP1_ROTAT(X,Y,DIS,ANGL,ANGLE,NUMPOI,
     :                            XR,YR,STATUS)
                  CALL ELP1_STATS(FAST,MINMOD,
     :                 RADIUS,ELEMS,ARRP,XR,YR,NUMPOI,
     :                 FRACT,PRANGE,USED,MEAN,SDP,RESID,FLAG,
     :                 VA,FOUND,STAT,STATUS)

*               Update the residuals record if required.
                  IF (FLAG.EQ.0) THEN
                     STRYS=STRYS+1
                     PAR(STRYS)=ANGLE
                     RES(STRYS)=RESID
                  END IF

 40            CONTINUE

*            Look at the residuals of the fit attempts made by varying
*            position angle and choose the best value to discard.
               IF (STRYS.GT.5) THEN

                  CHANGE=1
                  J=0
                  MAX=-ELP__VBIG
                  K=0
                  MIN=ELP__VBIG
                  DO 45 I=2,STRYS-1

*                  Find the largest and smallest residuals.
                     TEMP=RES(I-1)+RES(I)+RES(I+1)
                     IF (TEMP.GT.MAX) THEN
                        MAX=TEMP
                        J=I
                     END IF
                     IF (TEMP.LT.MIN) THEN
                        MIN=TEMP
                        K=I
                     END IF

 45               CONTINUE

*               Modify the bounds within which position angle will
*               be varied in future.
                  IF (J.NE.0) THEN
                     IF (PAR(J).GE.POSANG) THEN
                        MAXANG=(PAR(STRYS-1)+PAR(STRYS))/2.
                     ELSE
                        MINANG=(PAR(1)+PAR(2))/2.
                     END IF
                     RANGE=MAXANG-MINANG
                  END IF
                  IF (K.NE.0) POSANG=(PAR(K)+POSANG)/2.
                  MINANG=POSANG-RANGE/2.
                  MAXANG=POSANG+RANGE/2.

               END IF

*            VARY THE X AND Y CO_ORDINATES
*            Only performed if the galaxy origin has not been frozen
*            via input parameter FRZORI.

               IF (.NOT.FRZORI) THEN

*               Translate/rotate the raw 'fit' ellipse co-ordinates to
*               generate the actual positions of ellipse points on the image.
*               Then examine the pixel count value at each and determine
*               some measure of their variation. Repeat varying x and y.
                  STRYS=0
                  DO 20 I=1,TRYS

*                  Make sure the previous best guess is considered.
                     IF (I.EQ.1) THEN

*                     Previous X/Y values.
                        CURX=X
                        CURY=Y

                     ELSE

*                     Generate an X/Y value within the allowed range.
                        CALL ELP1_RAND(1,0,RND,STATUS)
                        CURX=X+(RND-.5)*XCH
                        CALL ELP1_RAND(1,0,RND,STATUS)
                        CURY=Y+(RND-.5)*YCHS

                     END IF

                     CALL ELP1_ROTAT(CURX,CURY,DIS,ANGL,ANGLE,NUMPOI,
     :                               XR,YR,STATUS)
                     CALL ELP1_STATS(FAST,MINMOD,
     :                    RADIUS,ELEMS,ARRP,XR,YR,
     :                    NUMPOI,FRACT,PRANGE,USED,MEAN,SDP,
     :                    RESID,FLAG,VA,FOUND,STAT,STATUS)

*                  Update the residuals record if required.
                     IF (FLAG.EQ.0) THEN
                        STRYS=STRYS+1
                        PAR(STRYS)=CURX
                        PAR2(STRYS)=CURY
                        RES(STRYS)=RESID
                     END IF

 20               CONTINUE

*               Look at the residuals of the fit attempts made by varying
*               x/y co-ordinate and choose the best value to retain.
                  IF (STRYS.GT.5) THEN

                     CHANGE=1
                     J=0
                     HIGH=ELP__VBIG
                     DO 25 I=1,STRYS

*                     Find the smallest residual.
                        IF (RES(I).LT.HIGH) THEN
                           J=I
                           HIGH=RES(I)
                        END IF

 25                  CONTINUE
                     IF (J.NE.0) THEN
                        X=PAR(J)
                        Y=PAR2(J)
                     END IF

                  END IF

               END IF

*            VARY THE ELLIPTICITY

*            Generate the co-ordinates of points of a 'raw' ellipse. Then
*            rotate/translate the co-ordinates to generate the position of
*            the points on the image. Examine the pixel count value at each
*            and determine their variation. Repeat varying ellipticity.
               STRYS=0
               DO 10 I=1,TRYS

*               Generate an angle value within the allowed range.
                  ELL=MINELL+(I-1)*(MAXELL-MINELL)/(TRYS-1)

                  CALL ELP1_GENER(ELL,RADIUS,NUMPOI,ANGL,
     :                            DIS,STATUS)
                  CALL ELP1_ROTAT(X,Y,DIS,ANGL,POSANG,NUMPOI,
     :                            XR,YR,STATUS)
                  CALL ELP1_STATS(FAST,MINMOD,
     :                 RADIUS,ELEMS,ARRP,XR,YR,NUMPOI,
     :                 FRACT,PRANGE,USED,MEAN,SDP,RESID,FLAG,
     :                 VA,FOUND,STAT,STATUS)

*               Update the residuals record if required.
                  IF (FLAG.EQ.0) THEN
                     STRYS=STRYS+1
                     PAR(STRYS)=ELL
                     RES(STRYS)=RESID
                  END IF

 10            CONTINUE

*            Look at the residuals of the fit attempts made by varying
*            ellipticity and choose the best value to discard.
               IF (STRYS.GT.5) THEN

                  J=0
                  MAX=-ELP__VBIG
                  K=0
                  MIN=ELP__VBIG
                  DO 55 I=2,STRYS-1

*                  Find the largest and smallest residuals.
                     TEMP=RES(I-1)+RES(I)+RES(I+1)
                     IF (TEMP.GT.MAX) THEN
                        MAX=TEMP
                        J=I
                     END IF
                     IF (TEMP.LT.MIN) THEN
                        MIN=TEMP
                        K=I
                     END IF

 55               CONTINUE

*               Modify the bounds within which ellipticity will
*               be varied in future.
                  IF (J.NE.0) THEN
                     CHANGE=1
                     IF (PAR(J).GE.ELLIP) THEN
                        MAXELL=(PAR(STRYS-1)+PAR(STRYS))/2.
                        IF (K.EQ.2) MINELL=MINELL-(PAR(2)-PAR(1))
                     ELSE
                        MINELL=(PAR(1)+PAR(2))/2.
                        IF (K.EQ.STRYS-1) MAXELL=MAXELL+(PAR(2)-PAR(1))
                     END IF
                     RANGE=MAXELL-MINELL
                  END IF
                  IF (K.NE.0) ELLIP=(PAR(K)+ELLIP)/2.
                  MINELL=ELLIP-RANGE/2.
                  MAXELL=ELLIP+RANGE/2.

               END IF

               LOOPS=LOOPS+1

            END DO

         END IF

*      Generate the positions of all the points on an untransformed
*      /unrotated version of the current 'fit' ellipse.
         CALL ELP1_GENER(ELLIP,RADIUS,NUMPOI,ANGL,DIS,STATUS)
         CALL ELP1_ROTAT(X,Y,DIS,ANGL,POSANG,NUMPOI,XR,YR,STATUS)
         CALL ELP1_STATS(FAST,MINMOD,RADIUS,ELEMS,ARRP,XR,YR,NUMPOI,
     :                   FRACT,PRANGE,USED,MEAN,SDP,RESID,FLAG,
     :                   VA,FOUND,STAT,STATUS)

*      Store the results for the current radius value. Should not be done if
*      nothing changed. Not likely in the real world except when LIM3 is being
*      used i.e. parameter modification being turned off at large radii.
         IF ((CHANGE.NE.0).AND.(MEAN-BACK.GT.0.0)
     :                    .AND.(FLAG.EQ.0)) THEN

*         Increment valid fit counter.
            VALIDP=VALIDP+1

*       Determine the Fourier descriptors.
            CALL ELP1_FOUR(NUMPOI,BACK,VALIDP,XR,YR,VA,X,Y,
     :                     POSANG,ELLIP,RESULT,STATUS)

*         Assign results values.
            RESULT(1,VALIDP)=X
            RESULT(2,VALIDP)=Y
            RESULT(3,VALIDP)=ELLIP
            RESULT(4,VALIDP)=RADIUS
            RESULT(5,VALIDP)=POSANG
            RESULT(6,VALIDP)=MEAN-BACK
            RESULT(7,VALIDP)=SDP
            RESULT(8,VALIDP)=REAL(NUMPOI)
            RESULT(9,VALIDP)=100.*REAL(FOUND)/REAL(NUMPOI)
            RESULT(ELP__STAT,VALIDP)=STAT

*         Display the results in suitably formatted form (if required).
*         Graphics screen display radii values are equivalent radii.
            IF (DMODE.GT.0) THEN
               CALL MSG_FMTR('X','F6.1',X)
               CALL MSG_FMTR('Y','F6.1',Y)
               CALL MSG_FMTI('N','I3',NUMPOI)
               TEMP=PSIZE*SQRT(RADIUS*RADIUS*ELLIP)
               CALL MSG_FMTR('RAD','F8.2',TEMP)
               CALL MSG_FMTR('VAL','F9.1',MEAN-BACK)
               IF (ANGCON) THEN
                  TEMP=POSANG+ANGOFF
               ELSE
                  TEMP=-POSANG+ANGOFF
               END IF
               CALL MSG_FMTR('POS','F6.1',TEMP)
               CALL MSG_FMTR('ELL','F5.3',ELLIP)
               CALL MSG_FMTR('DEV','F7.1',SDP)
               CALL MSG_FMTR('POI','F4.0',RESULT(9,VALIDP))
               CALL MSG_FMTR('STAT','E9.2',STAT)
               TEXT='^X  ^Y   ^N  ^RAD  ^VAL ^POS  ^ELL'//
     :              '^DEV  ^POI ^STAT'
               CALL MSG_OUT(' ',TEXT,STATUS)
            END IF

         END IF

*      After the first radius has been examined successfully, go to
*      smaller radii. Also, allow for second point to be duff.
         IF ((VALIDP.EQ.1).AND.(CHANGE.NE.0).AND.(RADIUS.GT.0.501)
     :        .AND.(ONCE)) THEN
            RADIUS=0.5
            ONCE=.FALSE.
         ELSE
*         Increase the ellipse radius.
            TEMP=0.25
            IF (RADIUS.GT.1.0) TEMP=0.5
            IF (RADIUS.GT.2.0) TEMP=1.0
            IF (RADIUS.GT.10.0) TEMP=1.5
            IF (RADIUS.GT.20.0) TEMP=2.0
            IF (RADIUS.GT.30.0) TEMP=2.5
            RADIUS=RADIUS+TEMP*FINE


*         Decrease the ellipse radius if it has not been previously tried.
*         Otherwise abort.
            IF(RADIUS.GE.RLIM) THEN
               IF(ONCE)THEN
                  RADIUS=0.5
                  ONCE=.FALSE.
               ELSE
                  STOP=.TRUE.
               END IF
            ENDIF
         END IF


*      Test to see if the profiling should stop.
         IF (VALIDP.GT.4) THEN

            IF ((MEAN.LE.BACK).AND.(FLAG.EQ.0)) THEN

*           Mean count for the ellipse is below sky.
               STOP=.TRUE.
               VALIDP=VALIDP-1
               IF (DMODE.GT.0) THEN
                  CALL MSG_BLANK(STATUS)
                  CALL MSG_OUT(' ',
     :                 'Mean count below background.',STATUS)
                  CALL MSG_BLANK(STATUS)
               END IF

            ELSE

              TEMP=(RESULT(6,VALIDP-1)+RESULT(6,VALIDP-2))/2.
              IF (((MEAN-BACK)/TEMP.GT.LIM1).AND.(FLAG.EQ.0)) THEN

*              Mean count has risen too quickly.
                 STOP=.TRUE.
                 IF (DMODE.GT.0) THEN
                    CALL MSG_BLANK(STATUS)
                    CALL MSG_OUT(' ',
     :                   'Mean count varying beyond LIM1.',STATUS)
                    CALL MSG_BLANK(STATUS)
                 END IF

              END IF

              IF ((MEAN-BACK.LT.SIGMA*LIM2).AND.(FLAG.EQ.0)) THEN

*              Mean count level below LIM2 threshold.
                  STOP=.TRUE.
                  IF (DMODE.GT.0) THEN
                     CALL MSG_BLANK(STATUS)
                     CALL MSG_OUT(' ',
     :                    'Mean count below threshold LIM2.',STATUS)
                     CALL MSG_BLANK(STATUS)
                  END IF
              END IF
            END IF

         END IF

      END DO

      IF (DMODE.GT.0) CALL MSG_BLANK(STATUS)

 9999 CONTINUE

      END



**************************************
* Modified version of CMLIB BD2INK   *
*                                    *
* All names modified so that they    *
* will not cause double declaration  *
* errors when the routines appear in *
* PDA library.                       *
*                                    *
**************************************


      SUBROUTINE GJP_DB2INK(X,NX,Y,NY,FCN,LDF,
     :                      KX,KY,TX,TY,BCOEF,
     :                      WORK,IFLAG,STATUS)

C***BEGIN PROLOGUE  DB2INK
C***DATE WRITTEN   25 MAY 1982
C***REVISION DATE  25 MAY 1982
C***CATEGORY NO.  E1A
C***KEYWORDS  INTERPOLATION, TWO-DIMENSIONS, GRIDDED DATA, SPLINES,
C             PIECEWISE POLYNOMIALS
C***AUTHOR  BOISVERT, RONALD, NBS
C             SCIENTIFIC COMPUTING DIVISION
C             NATIONAL BUREAU OF STANDARDS
C             WASHINGTON, DC 20234
C***PURPOSE  DOUBLE PRECISION VERSION OF B2INK.
C            DB2INK DETERMINES A PIECEWISE POLYNOMIAL FUNCTION THAT
C            INTERPOLATES TWO-DIMENSIONAL GRIDDED DATA. USERS SPECIFY
C            THE POLYNOMIAL ORDER (DEGREE+1) OF THE INTERPOLANT AND
C            (OPTIONALLY) THE KNOT SEQUENCE.
C***DESCRIPTION
C
C   DB2INK determines the parameters of a  function  that  interpolates
C   the two-dimensional gridded data (X(i),Y(j),FCN(i,j)) for i=1,..,NX
C   and j=1,..,NY. The interpolating function and its  derivatives  may
C   subsequently be evaluated by the function DB2VAL.
C
C   The interpolating  function  is  a  piecewise  polynomial  function
C   represented as a tensor product of one-dimensional  B-splines.  The
C   form of this function is
C
C                          NX   NY
C              S(x,y)  =  SUM  SUM  a   U (x) V (y)
C                         i=1  j=1   ij  i     j
C
C   where the functions U(i)  and  V(j)  are  one-dimensional  B-spline
C   basis functions. The coefficients a(i,j) are chosen so that
C
C         S(X(i),Y(j)) = FCN(i,j)   for i=1,..,NX and j=1,..,NY
C
C   Note that  for  each  fixed  value  of  y  S(x,y)  is  a  piecewise
C   polynomial function of x alone, and for each fixed value of x  S(x,
C   y) is a piecewise polynomial function of y alone. In one  dimension
C   a piecewise polynomial may  be  created  by  partitioning  a  given
C   interval into subintervals and defining a distinct polynomial piece
C   on each one. The points where adjacent subintervals meet are called
C   knots. Each of the functions U(i) and V(j)  above  is  a  piecewise
C   polynomial.
C
C   Users of DB2INK choose  the  order  (degree+1)  of  the  polynomial
C   pieces used to define the piecewise polynomial in each of the x and
C   y directions (KX and KY). Users also  may  define  their  own  knot
C   sequence in x and y separately (TX and TY).  If  IFLAG=0,  however,
C   DB2INK will choose sequences of knots that result  in  a  piecewise
C   polynomial interpolant with KX-2 continuous partial derivatives  in
C   x and KY-2 continuous partial derivatives in y. (KX knots are taken
C   near each endpoint in the x direction,  not-a-knot  end  conditions
C   are used, and the remaining knots are placed at data points  if  KX
C   is even or at midpoints between data points if KX  is  odd.  The  y
C   direction is treated similarly.)
C
C   After a call to DB2INK, all information  necessary  to  define  the
C   interpolating function are contained in the parameters NX, NY,  KX,
C   KY, TX, TY, and BCOEF. These quantities should not be altered until
C   after the last call of the evaluation routine DB2VAL.
C
C
C   I N P U T
C   ---------
C
C   X       Double precision 1D array (size NX)
C           Array of x abcissae. Must be strictly increasing.
C
C   NX      Integer scalar (.GE. 3)
C           Number of x abcissae.
C
C   Y       Double precision 1D array (size NY)
C           Array of y abcissae. Must be strictly increasing.
C
C   NY      Integer scalar (.GE. 3)
C           Number of y abcissae.
C
C   FCN     Double precision 2D array (size LDF by NY)
C           Array of function values to interpolate. FCN(I,J) should
C           contain the function value at the point (X(I),Y(J))
C
C   LDF     Integer scalar (.GE. NX)
C           The actual leading dimension of FCN used in the calling
C           calling program.
C
C   KX      Integer scalar (.GE. 2, .LT. NX)
C           The order of spline pieces in x.
C           (Order = polynomial degree + 1)
C
C   KY      Integer scalar (.GE. 2, .LT. NY)
C           The order of spline pieces in y.
C           (Order = polynomial degree + 1)
C
C
C   I N P U T   O R   O U T P U T
C   -----------------------------
C
C   TX      Double precision 1D array (size NX+KX)
C           The knots in the x direction for the spline interpolant.
C           If IFLAG=0 these are chosen by DB2INK.
C           If IFLAG=1 these are specified by the user.
C                      (Must be non-decreasing.)
C
C   TY      Double precision 1D array (size NY+KY)
C           The knots in the y direction for the spline interpolant.
C           If IFLAG=0 these are chosen by DB2INK.
C           If IFLAG=1 these are specified by the user.
C                      (Must be non-decreasing.)
C
C
C   O U T P U T
C   -----------
C
C   BCOEF   Double precision 2D array (size NX by NY)
C           Array of coefficients of the B-spline interpolant.
C           This may be the same array as FCN.
C
C
C   M I S C E L L A N E O U S
C   -------------------------
C
C   WORK    Double precision 1D array (size NX*NY + max( 2*KX*(NX+1),
C                                             2*KY*(NY+1) ))
C           Array of working storage.
C
C   IFLAG   Integer scalar.
C           On input:  0 == knot sequence chosen by DB2INK
C                      1 == knot sequence chosen by user.
C           On output: 1 == successful execution - Starlink modification
C                      2 == IFLAG out of range
C                      3 == NX out of range
C                      4 == KX out of range
C                      5 == X not strictly increasing
C                      6 == TX not non-decreasing
C                      7 == NY out of range
C                      8 == KY out of range
C                      9 == Y not strictly increasing
C                     10 == TY not non-decreasing
C
C   STATUS   Integer. Starlink error status.
C
C***REFERENCES  CARL DE BOOR, A PRACTICAL GUIDE TO SPLINES,
C                 SPRINGER-VERLAG, NEW YORK, 1978.
C               CARL DE BOOR, EFFICIENT COMPUTER MANIPULATION OF TENSOR
C                 PRODUCTS, ACM TRANSACTIONS ON MATHEMATICAL SOFTWARE,
C                 VOL. 5 (1979), PP. 173-182.
C***ROUTINES CALLED  DBTPCF,DBKNOT
C***END PROLOGUE  DB2INK
C
C  ------------
C  DECLARATIONS
C  ------------

C  Starlink error status.
      INTEGER STATUS

C
C  PARAMETERS
C

      INTEGER NX, NY, LDF, KX, KY, IFLAG
      DOUBLE PRECISION X(NX), Y(NY), FCN(LDF,NY), TX(1), TY(1)
      DOUBLE PRECISION BCOEF(NX,NY),WORK(1)
C
C  LOCAL VARIABLES
C
      INTEGER I, IW, NPK
C
C  -----------------------
C  CHECK VALIDITY OF INPUT
C  -----------------------
C
C***FIRST EXECUTABLE STATEMENT

*   Check the inherited global status.
      IF (STATUS.NE.0) RETURN

      IF ((IFLAG .LT. 0) .OR. (IFLAG .GT. 1))  GO TO 920
      IF (NX .LT. 3)  GO TO 930
      IF (NY .LT. 3)  GO TO 970
      IF ((KX .LT. 2) .OR. (KX .GE. NX))  GO TO 940
      IF ((KY .LT. 2) .OR. (KY .GE. NY))  GO TO 980
      DO 10 I=2,NX
         IF (X(I) .LE. X(I-1))  GO TO 950
   10 CONTINUE
      DO 20 I=2,NY
         IF (Y(I) .LE. Y(I-1))  GO TO 990
   20 CONTINUE
      IF (IFLAG .EQ. 0)  GO TO 50
         NPK = NX + KX
         DO 30 I=2,NPK
            IF (TX(I) .LT. TX(I-1))  GO TO 960
   30    CONTINUE
         NPK = NY + KY
         DO 40 I=2,NPK
            IF (TY(I) .LT. TY(I-1))  GO TO 1000
   40    CONTINUE
   50 CONTINUE
C
C  ------------
C  CHOOSE KNOTS
C  ------------
C
      IF (IFLAG .NE. 0)  GO TO 100
         CALL GJP_DBKNOT(X,NX,KX,TX,IFLAG)
         CALL GJP_DBKNOT(Y,NY,KY,TY,IFLAG)
  100 CONTINUE
C
C  -------------------------------
C  CONSTRUCT B-SPLINE COEFFICIENTS
C  -------------------------------
C
      IFLAG = 1
      IW = NX*NY + 1
      CALL GJP_DBTPCF(X,NX,FCN,LDF,NY,TX,KX,WORK,WORK(IW),IFLAG)
      CALL GJP_DBTPCF(Y,NY,WORK,NY,NX,TY,KY,BCOEF,WORK(IW),IFLAG)

*****************************
*   Starlink modification   *
*                           *
*   Ensures STATUS okay     *
*    when routine ends      *
*                           *
*****************************
      IF (IFLAG.NE.1) STATUS=1
      GO TO 9999

C
C  -----
C  EXITS
C  -----
C
  920 CONTINUE
      IFLAG = 2
      STATUS=1
      GO TO 9999
C
  930 CONTINUE
      IFLAG = 3
      STATUS=1
      GO TO 9999
C
  940 CONTINUE
      IFLAG = 4
      STATUS=1
      GO TO 9999
C
  950 CONTINUE
      IFLAG = 5
      STATUS=1
      GO TO 9999
C
  960 CONTINUE
      IFLAG = 6
      STATUS=1
      GO TO 9999
C
  970 CONTINUE
      IFLAG = 7
      STATUS=1
      GO TO 9999
C
  980 CONTINUE
      IFLAG = 8
      STATUS=1
      GO TO 9999
C
  990 CONTINUE
      IFLAG = 9
      STATUS=1
      GO TO 9999
C
 1000 CONTINUE
      IFLAG = 10
      STATUS=1
      GO TO 9999
C
 9999 CONTINUE

      END


      SUBROUTINE GJP_DBKNOT(X,N,K,T,IFLAG)

C***BEGIN PROLOGUE  DBKNOT
C***REFER TO  DB2INK,DB3INK
C***ROUTINES CALLED  (NONE)
C***END PROLOGUE  DBKNOT
C
C  --------------------------------------------------------------------
C  DBKNOT CHOOSES A KNOT SEQUENCE FOR INTERPOLATION OF ORDER K AT THE
C  DATA POINTS X(I), I=1,..,N.  THE N+K KNOTS ARE PLACED IN THE ARRAY
C  T.  K KNOTS ARE PLACED AT EACH ENDPOINT AND NOT-A-KNOT END
C  CONDITIONS ARE USED.  THE REMAINING KNOTS ARE PLACED AT DATA POINTS
C  IF N IS EVEN AND BETWEEN DATA POINTS IF N IS ODD.  THE RIGHTMOST
C  KNOT IS SHIFTED SLIGHTLY TO THE RIGHT TO INSURE PROPER INTERPOLATION
C  AT X(N) (SEE PAGE 350 OF THE REFERENCE).
C  DOUBLE PRECISION VERSION OF BKNOT.
C  --------------------------------------------------------------------
C
C  ------------
C  DECLARATIONS
C  ------------
C
C  PARAMETERS
C
      INTEGER
     *        N, K
      DOUBLE PRECISION
     *     X(N), T(1)
C
C  LOCAL VARIABLES
C
      INTEGER
     *        I, J, IPJ, NPJ, IP1, JSTRT
      INTEGER IFLAG
      DOUBLE PRECISION
     *     RNOT
C
C
C  ----------------------------
C  PUT K KNOTS AT EACH ENDPOINT
C  ----------------------------
C
C     (SHIFT RIGHT ENPOINTS SLIGHTLY -- SEE PG 350 OF REFERENCE)
      RNOT = X(N) + 0.10D0*( X(N)-X(N-1) )
      DO 110 J=1,K
         T(J) = X(1)
         NPJ = N + J
         T(NPJ) = RNOT
  110 CONTINUE
C
C  --------------------------
C  DISTRIBUTE REMAINING KNOTS
C  --------------------------
C
      IF (MOD(K,2) .EQ. 1)  GO TO 150
C
C     CASE OF EVEN K --  KNOTS AT DATA POINTS
C
      I = (K/2) - K
      JSTRT = K+1
      DO 120 J=JSTRT,N
         IPJ = I + J
         T(J) = X(IPJ)
  120 CONTINUE
      GO TO 200
C
C     CASE OF ODD K --  KNOTS BETWEEN DATA POINTS
C
  150 CONTINUE
      I = (K-1)/2 - K
      IP1 = I + 1
      JSTRT = K + 1
      DO 160 J=JSTRT,N
         IPJ = I + J
         T(J) = 0.50D0*( X(IPJ) + X(IPJ+1) )
  160 CONTINUE
  200 CONTINUE
C
      RETURN
      END


      SUBROUTINE GJP_DBTPCF(X,N,FCN,LDF,NF,T,K,BCOEF,WORK,IFLAG)

C***BEGIN PROLOGUE  DBTPCF
C***REFER TO  DB2INK,DB3INK
C***ROUTINES CALLED  DBINTK,DBNSLV
C***END PROLOGUE  DBTPCF
C
C  -----------------------------------------------------------------
C  DBTPCF COMPUTES B-SPLINE INTERPOLATION COEFFICIENTS FOR NF SETS
C  OF DATA STORED IN THE COLUMNS OF THE ARRAY FCN. THE B-SPLINE
C  COEFFICIENTS ARE STORED IN THE ROWS OF BCOEF HOWEVER.
C  EACH INTERPOLATION IS BASED ON THE N ABCISSA STORED IN THE
C  ARRAY X, AND THE N+K KNOTS STORED IN THE ARRAY T. THE ORDER
C  OF EACH INTERPOLATION IS K. THE WORK ARRAY MUST BE OF LENGTH
C  AT LEAST 2*K*(N+1).
C  DOUBLE PRECISION VERSION OF BTPCF.
C  -----------------------------------------------------------------
C
C  ------------
C  DECLARATIONS
C  ------------
C
C  PARAMETERS
C
      INTEGER
     *        N, LDF, K,NF
      INTEGER IFLAG
      DOUBLE PRECISION
     *     X(N), FCN(LDF,NF), T(1), BCOEF(NF,N), WORK(1)
C
C  LOCAL VARIABLES
C
      INTEGER
     *        I, J, K1, K2, IQ, IW
C
C  ---------------------------------------------
C  CHECK FOR NULL INPUT AND PARTITION WORK ARRAY
C  ---------------------------------------------
C
C***FIRST EXECUTABLE STATEMENT
      IF (NF .LE. 0)  GO TO 500
      K1 = K - 1
      K2 = K1 + K
      IQ = 1 + N
      IW = IQ + K2*N+1
C
C  -----------------------------
C  COMPUTE B-SPLINE COEFFICIENTS
C  -----------------------------
C
C
C   FIRST DATA SET
C
      CALL PDA_DBINTK(X,FCN,T,N,K,WORK,WORK(IQ),WORK(IW),IFLAG)
      DO 20 I=1,N
         BCOEF(1,I) = WORK(I)
   20 CONTINUE
C
C  ALL REMAINING DATA SETS BY BACK-SUBSTITUTION
C
      IF (NF .EQ. 1)  GO TO 500
      DO 100 J=2,NF
         DO 50 I=1,N
            WORK(I) = FCN(I,J)
   50    CONTINUE
         CALL PDA_DBNSLV(WORK(IQ),K2,N,K1,K1,WORK)
         DO 60 I=1,N
            BCOEF(J,I) = WORK(I)
   60    CONTINUE
  100 CONTINUE
C
C  ----
C  EXIT
C  ----
C
  500 CONTINUE
      RETURN

      END




      SUBROUTINE GJP_DB2VAL(XVAL,YVAL,IDX,IDY,TX,TY,
     :                      NX,NY,KX,KY,BCOEF,WORK,
     :                      RVALUE,IFAIL,STATUS)
C***BEGIN PROLOGUE  DB2VAL
C***DATE WRITTEN   25 MAY 1982
C***REVISION DATE  25 MAY 1982
C***CATEGORY NO.  E1A
C***KEYWORDS  INTERPOLATION, TWO-DIMENSIONS, GRIDDED DATA, SPLINES,
C             PIECEWISE POLYNOMIALS
C***AUTHOR  BOISVERT, RONALD, NBS
C             SCIENTIFIC COMPUTING DIVISION
C             NATIONAL BUREAU OF STANDARDS
C             WASHINGTON, DC 20234
C***PURPOSE  DB2VAL EVALUATES THE PIECEWISE POLYNOMIAL INTERPOLATING
C            FUNCTION CONSTRUCTED BY THE ROUTINE DB2INK OR ONE OF ITS
C            PARTIAL DERIVATIVES.
C            DOUBLE PRECISION VERSION OF B2VAL.
C***DESCRIPTION
C
C   DB2VAL  evaluates   the   tensor   product   piecewise   polynomial
C   interpolant constructed  by  the  routine  DB2INK  or  one  of  its
C   derivatives at the point (XVAL,YVAL). To evaluate  the  interpolant
C   itself, set IDX=IDY=0, to evaluate the first partial  with  respect
C   to x, set IDX=1,IDY=0, and so on.
C
C   DB2VAL returns 0.0E0 if (XVAL,YVAL) is out of range. That is, if
C            XVAL.LT.TX(1) .OR. XVAL.GT.TX(NX+KX) .OR.
C            YVAL.LT.TY(1) .OR. YVAL.GT.TY(NY+NY)
C   If the knots TX  and  TY  were  chosen  by  DB2INK,  then  this  is
C   equivalent to
C            XVAL.LT.X(1) .OR. XVAL.GT.X(NX)+EPSX .OR.
C            YVAL.LT.Y(1) .OR. YVAL.GT.Y(NY)+EPSY
C   where EPSX = 0.1*(X(NX)-X(NX-1)) and EPSY = 0.1*(Y(NY)-Y(NY-1)).
C
C   The input quantities TX, TY, NX, NY, KX, KY, and  BCOEF  should  be
C   unchanged since the last call of DB2INK.
C
C
C   I N P U T
C   ---------
C
C   XVAL    Double precision scalar
C           X coordinate of evaluation point.
C
C   YVAL    Double precision scalar
C           Y coordinate of evaluation point.
C
C   IDX     Integer scalar
C           X derivative of piecewise polynomial to evaluate.
C
C   IDY     Integer scalar
C           Y derivative of piecewise polynomial to evaluate.
C
C   TX      Double precision 1D array (size NX+KX)
C           Sequence of knots defining the piecewise polynomial in
C           the x direction.  (Same as in last call to DB2INK.)
C
C   TY      Double precision 1D array (size NY+KY)
C           Sequence of knots defining the piecewise polynomial in
C           the y direction.  (Same as in last call to DB2INK.)
C
C   NX      Integer scalar
C           The number of interpolation points in x.
C           (Same as in last call to DB2INK.)
C
C   NY      Integer scalar
C           The number of interpolation points in y.
C           (Same as in last call to DB2INK.)
C
C   KX      Integer scalar
C           Order of polynomial pieces in x.
C           (Same as in last call to DB2INK.)
C
C   KY      Integer scalar
C           Order of polynomial pieces in y.
C           (Same as in last call to DB2INK.)
C
C   BCOEF   Double precision 2D array (size NX by NY)
C           The B-spline coefficients computed by DB2INK.
C
C   WORK    Double precision 1D array (size 3*max(KX,KY) + KY)
C           A working storage array.
C
C   IFAIL   A returned error value.
C
C   RVALUE  The interpolated value.
C
C   STATUS  Integer. Starlink status report.
C
C***REFERENCES  CARL DE BOOR, A PRACTICAL GUIDE TO SPLINES,
C                 SPRINGER-VERLAG, NEW YORK, 1978.
C***ROUTINES CALLED  DINTRV,DBVAL2
C***END PROLOGUE  DB2VAL
C
C  ------------
C  DECLARATIONS
C  ------------

C  Starlink error status.
      INTEGER STATUS

C
C  PARAMETERS
C
      INTEGER          IFAIL
      DOUBLE PRECISION RVALUE,VALUE

      INTEGER          IDX,IDY,NX,NY,KX,KY
      DOUBLE PRECISION XVAL,YVAL,TX(1),TY(1),BCOEF(NX,NY),WORK(1)

C
C  LOCAL VARIABLES
C
      INTEGER         ILOY,INBVX,INBV,K,LEFTY,MFLAG,KCOL,IW
C
      DATA ILOY /1/,  INBVX /1/
C     SAVE ILOY    ,  INBVX
C
C
C***FIRST EXECUTABLE STATEMENT

*   Check the inherited global status.
      IF (STATUS.NE.0) RETURN

*   Clear interpolated value.
      RVALUE=0.0D0

      CALL PDA_DINTRV(TY,NY+KY,YVAL,ILOY,LEFTY,MFLAG)

      IF (MFLAG .NE. 0) GO TO 100
         IW = KY + 1
         KCOL = LEFTY - KY
         DO 50 K=1,KY
            KCOL = KCOL + 1
            CALL GJP_DBVAL2(TX,BCOEF(1,KCOL),NX,
     :                      KX,IDX,XVAL,INBVX,
     :                      WORK(IW),VALUE,IFAIL)
            WORK(K)=VALUE
  50     CONTINUE
         INBV = 1
         KCOL = LEFTY - KY + 1
         CALL GJP_DBVAL2(TY(KCOL),WORK,KY,KY,IDY,
     :                      YVAL,INBV,WORK(IW),VALUE,IFAIL)
         RVALUE=VALUE
  100 CONTINUE

*   Set up the status value.
      IF (IFAIL.NE.0) STATUS=1

      END


      SUBROUTINE GJP_DBVAL2(T,A,N,K,IDERIV,X,
     :                      INBV,WORK,VALUE,IFAIL)
C***BEGIN PROLOGUE  DBVAL2
C***DATE WRITTEN   800901   (YYMMDD)
C***REVISION DATE  820801   (YYMMDD)
C***CATEGORY NO.  E3,K6
C***KEYWORDS  B-SPLINE,DATA FITTING,DOUBLE PRECISION,INTERPOLATION,
C             SPLINE
C***AUTHOR  AMOS, D. E., (SNLA)
C***PURPOSE  Evaluates the B-representation of a B-spline at X for the
C            function value or any of its derivatives.
C***DESCRIPTION
C
C     Written by Carl de Boor and modified by D. E. Amos
C
C     Reference
C         SIAM J. Numerical Analysis, 14, No. 3, June, 1977, pp.441-472.
C
C     Abstract   **** a double precision subroutine ****
C         DBVAL2 is the BVALUE function of the reference.
C
C         DBVAL2 evaluates the B-representation (T,A,N,K) of a B-spline
C         at X for the function value on IDERIV=0 or any of its
C         derivatives on IDERIV=1,2,...,K-1.  Right limiting values
C         (right derivatives) are returned except at the right end
C         point X=T(N+1) where left limiting values are computed.  The
C         spline is defined on T(K) .LE. X .LE. T(N+1).  DBVAL2 returns
C         a fatal error message when X is outside of this interval.
C
C         To compute left derivatives or left limiting values at a
C         knot T(I), replace N by I-1 and set X=T(I), I=K+1,N+1.
C
C         DBVAL2 calls DINTRV
C
C     Description of Arguments
C
C         Input      T,A,X are double precision
C          T       - knot vector of length N+K
C          A       - B-spline coefficient vector of length N
C          N       - number of B-spline coefficients
C                    N = sum of knot multiplicities-K
C          K       - order of the B-spline, K .GE. 1
C          IDERIV  - order of the derivative, 0 .LE. IDERIV .LE. K-1
C                    IDERIV = 0 returns the B-spline value
C          X       - argument, T(K) .LE. X .LE. T(N+1)
C          INBV    - an initialization parameter which must be set
C                    to 1 the first time DBVAL2 is called.
C
C         Output     WORK,DBVAL2 are double precision
C          INBV    - INBV contains information for efficient process-
C                    ing after the initial call and INBV must not
C                    be changed by the user.  Distinct splines require
C                    distinct INBV parameters.
C          WORK    - work vector of length 3*K.
C          DBVAL2  - value of the IDERIV-th derivative at X
C
C     Error Conditions
C         An improper input is a fatal error
C***REFERENCES  C. DE BOOR, *PACKAGE FOR CALCULATING WITH B-SPLINES*,
C                 SIAM JOURNAL ON NUMERICAL ANALYSIS, VOLUME 14, NO. 3,
C                 JUNE 1977, PP. 441-472.
C***ROUTINES CALLED  DINTRV,XERROR
C***END PROLOGUE  DBVAL2
C
C
      INTEGER IFAIL
      DOUBLE PRECISION VALUE
      INTEGER I,IDERIV,IDERP1,IHI,IHMKMJ,ILO,IMK,IMKPJ, INBV, IPJ,
     1 IP1, IP1MJ, J, JJ, J1, J2, K, KMIDER, KMJ, KM1, KPK, MFLAG, N
      DOUBLE PRECISION A, FKMJ, T, WORK, X
      DIMENSION T(1), A(N), WORK(*)
C***FIRST EXECUTABLE STATEMENT  DBVAL2

      VALUE = 0.0D0
      IF(K.LT.1) GO TO 102
      IF(N.LT.K) GO TO 101
      IF(IDERIV.LT.0 .OR. IDERIV.GE.K) GO TO 110
      KMIDER = K - IDERIV
C
C *** FIND *I* IN (K,N) SUCH THAT T(I) .LE. X .LT. T(I+1)
C     (OR, .LE. T(I+1) IF T(I) .LT. T(I+1) = T(N+1)).
      KM1 = K - 1
      CALL PDA_DINTRV(T, N+1, X, INBV, I, MFLAG)
      IF (X.LT.T(K)) GO TO 120
      IF (MFLAG.EQ.0) GO TO 20
      IF (X.GT.T(I)) GO TO 130
   10 IF (I.EQ.K) GO TO 140
      I = I - 1
      IF (X.EQ.T(I)) GO TO 10
C
C *** DIFFERENCE THE COEFFICIENTS *IDERIV* TIMES
C     WORK(I) = AJ(I), WORK(K+I) = DP(I), WORK(K+K+I) = DM(I), I=1.K
C
   20 IMK = I - K
      DO 30 J=1,K
        IMKPJ = IMK + J
        WORK(J) = A(IMKPJ)
   30 CONTINUE
      IF (IDERIV.EQ.0) GO TO 60
      DO 50 J=1,IDERIV
        KMJ = K - J
        FKMJ = DBLE(REAL(KMJ))
        DO 40 JJ=1,KMJ
          IHI = I + JJ
          IHMKMJ = IHI - KMJ
          WORK(JJ) = (WORK(JJ+1)-WORK(JJ))/(T(IHI)-T(IHMKMJ))*FKMJ
   40   CONTINUE
   50 CONTINUE
C
C *** COMPUTE VALUE AT *X* IN (T(I),(T(I+1)) OF IDERIV-TH DERIVATIVE,
C     GIVEN ITS RELEVANT B-SPLINE COEFF. IN AJ(1),...,AJ(K-IDERIV).
   60 IF (IDERIV.EQ.KM1) GO TO 100
      IP1 = I + 1
      KPK = K + K
      J1 = K + 1
      J2 = KPK + 1
      DO 70 J=1,KMIDER
        IPJ = I + J
        WORK(J1) = T(IPJ) - X
        IP1MJ = IP1 - J
        WORK(J2) = X - T(IP1MJ)
        J1 = J1 + 1
        J2 = J2 + 1
   70 CONTINUE
      IDERP1 = IDERIV + 1
      DO 90 J=IDERP1,KM1
        KMJ = K - J
        ILO = KMJ
        DO 80 JJ=1,KMJ
          WORK(JJ) = (WORK(JJ+1)*WORK(KPK+ILO)+WORK(JJ)
     1              *WORK(K+JJ))/(WORK(KPK+ILO)+WORK(K+JJ))
          ILO = ILO - 1
   80   CONTINUE
   90 CONTINUE

  100 VALUE = WORK(1)

      RETURN
C
C
  101 CONTINUE
c      CALL XERROR( ' DBVAL2,  N DOES NOT SATISFY N.GE.K',35,2,1)
      IFAIL=13
      RETURN

  102 CONTINUE
c      CALL XERROR( ' DBVAL2,  K DOES NOT SATISFY K.GE.1',35,2,1)
      IFAIL=14
      RETURN

  110 CONTINUE
c      CALL XERROR( ' DBVAL2,  IDERIV DOES NOT SATISFY 0.LE.IDERIV.LT.K',1 50, 2, 1)
      IFAIL=15
      RETURN

  120 CONTINUE
c      CALL XERROR( ' DBVAL2,  X IS N0T GREATER THAN OR EQUAL TO T(K)',1 48, 2, 1)
      IFAIL=16
      RETURN

  130 CONTINUE
c      CALL XERROR( ' DBVAL2,  X IS NOT LESS THAN OR EQUAL TO T(N+1)',1 47, 2, 1)
      IFAIL=17
      RETURN

  140 CONTINUE
c      CALL XERROR( ' DBVAL2,  A LEFT LIMITING VALUE CANN0T BE OBTAINED A1T T(K)',    58, 2, 1)
      IFAIL=18
      RETURN

      END


      SUBROUTINE GJP_IDBVIP(md,ncp,ndp,xd,yd,zd,nip,xi,yi,zi,iwk,
     :                      wk,istat,status)

c this subroutine performs bivariate interpolation when the pro-
c jections of the data points in the x-y plane are irregularly
c distributed in the plane.

c the input parameters are
c     md  = mode of computation (must be 1, 2, or 3),
c         = 1 for new ncp and/or new xd-yd,
c         = 2 for old ncp, old xd-yd, new xi-yi,
c         = 3 for old ncp, old xd-yd, old xi-yi,
c     ncp = number of additional data points used for esti-
c           mating partial derivatives at each data point
c           (must be 2 or greater, but smaller than ndp),
c     ndp = number of data points (must be 4 or greater),
c     xd  = array of dimension ndp containing the x
c           coordinates of the data points,
c     yd  = array of dimension ndp containing the y
c           coordinates of the data points,
c     zd  = array of dimension ndp containing the z
c           coordinates of the data points,
c     nip = number of output points at which interpolation
c           is to be performed (must be 1 or greater),
c     xi  = array of dimension nip containing the x
c           coordinates of the output points,
c     yi  = array of dimension nip containing the y
c           coordinates of the output points.

c the output parameter is
c     zi  = array of dimension nip where interpolated z
c           values are to be stored.
c     istat = error message.
c     status= Starlink error status

c the other parameters are
c     iwk = integer array of dimension
c              max0(31,27+ncp)*ndp+nip
c           used internally as a work area,
c     wk  = array of dimension 8*ndp used internally as a
c           work area.

c the very first call to this subroutine and the call with a new
c ncp value, a new ndp value, and/or new contents of the xd and
c yd arrays must be made with md=1.  the call with md=2 must be
c preceded by another call with the same ncp and ndp values and
c with the same contents of the xd and yd arrays.  the call with
c md=3 must be preceded by another call with the same ncp, ndp,
c and nip values and with the same contents of the xd, yd, xi,
c and yi arrays.  between the call with md=2 or md=3 and its
c preceding call, the iwk and wk arrays must not be disturbed.
c use of a value between 3 and 5 (inclusive) for ncp is recom-
c mended unless there are evidences that dictate otherwise.

c this subroutine calls the idcldp, idlctn, idpdrv, idptip, and
c idtang subroutines.

C  Starlink Status.
      INTEGER STATUS                  ! Global status

c declaration statements
      dimension xd(*), yd(*), zd(*), xi(*), yi(*),
     :          zi(*), iwk(*), wk(*)
      common /idlc  / nit
      common /idpi  / itpv
      integer istat

c   Check the inherited global status.
      IF (STATUS.NE.0) RETURN

c setting of some input parameters to local variables.
c (for md=1,2,3)
      md0 = md
      ncp0 = ncp
      ndp0 = ndp
      nip0 = nip

c error check.  (for md=1,2,3)
      if ( md0.ge.1 .and. md0.le.3 ) then
         if ( ncp0.ge.2 .and. ncp0.lt.ndp0 ) then
            if ( ndp0.ge.4 ) then
               if ( nip0.ge.1 ) then
                  if ( md0.ge.2 ) then
                     ncppv = iwk(1)
                     ndppv = iwk(2)
                     if ( ncp0.ne.ncppv ) go to 100
                     if ( ndp0.ne.ndppv ) go to 100
                  else
                     iwk(1) = ncp0
                     iwk(2) = ndp0
                  end if
                  if ( md0.ge.3 ) then
                     nippv = iwk(3)
                     if ( nip0.ne.nippv ) go to 100
                  else
                     iwk(3) = nip
                  end if

c allocation of storage areas in the iwk array.  (for md=1,2,3)
                  jwipt = 16
                  jwiwl = 6*ndp0 + 1
                  jwiwk = jwiwl
                  jwipl = 24*ndp0 + 1
                  jwiwp = 30*ndp0 + 1
                  jwipc = 27*ndp0 + 1
                  jwit0 = max0(31, 27+ncp0)*ndp0

c triangulates the x-y plane.  (for md=1)
                  if ( md0.le.1 ) then
                     call GJP_IDTANG(ndp0,xd,yd,nt,iwk(jwipt),nl,
     :                               iwk(jwipl),iwk(jwiwl),
     :                               iwk(jwiwp),wk,istat)
                     iwk(5) = nt
                     iwk(6) = nl
                     if ( nt.eq.0 ) then
                        if(istat.ne.0) status=1
                        return
                     end if
                  end if

c determines ncp points closest to each data point.  (for md=1)
                  if ( md0.le.1 ) then
                     call GJP_IDCLDP(ndp0,xd,yd,ncp0,
     :                               iwk(jwipc),istat)
                     if ( iwk(jwipc).eq.0 ) then
                        if(istat.ne.0) status=1
                        return
                     end if
                  end if

c locates all points at which interpolation is to be performed.
c (for md=1,2)
                  if ( md0.ne.3 ) then
                     nit = 0
                     jwit = jwit0
                     do 2 iip = 1, nip0
                        jwit = jwit + 1
                        call GJP_IDLCTN(ndp0,xd,yd,nt,iwk(jwipt),nl,
     :                                  iwk(jwipl),xi(iip),yi(iip),
     :                                  iwk(jwit),iwk(jwiwk),wk,
     :                                  istat)
 2                   continue
                  end if

c estimates partial derivatives at all data points.
c (for md=1,2,3)
                  call GJP_IDPDRV(ndp0,xd,yd,zd,ncp0,iwk(jwipc),wk,
     :                            istat)

c interpolates the zi values.  (for md=1,2,3)
                  itpv = 0
                  jwit = jwit0
                  do 5 iip = 1, nip0
                     jwit = jwit + 1
                     call GJP_IDPTIP(xd,yd,zd,nt,iwk(jwipt),nl,
     :                               iwk(jwipl),wk,iwk(jwit),
     :                               xi(iip),yi(iip),zi(iip),
     :                               istat)
 5                continue
                  if(istat.ne.0) status=1
                  return

               end if
            end if
         end if
      end if

c error exit

 100  continue
      istat = 1

*   Setup Starlink status.
      STATUS=1

      end


      SUBROUTINE GJP_IDCLDP(ndp,xd,yd,ncp,ipc,istat)

c this subroutine selects several data points that are closest
c to each of the data point.

c the input parameters are
c     ndp = number of data points,
c     xd,yd = arrays of dimension ndp containing the x and y
c           coordinates of the data points,
c     ncp = number of data points closest to each data
c           points.

c the output parameter is
c     ipc = integer array of dimension ncp*ndp, where the
c           point numbers of ncp data points closest to
c           each of the ndp data points are to be stored.
*     istat = starlink error message.

c this subroutine arbitrarily sets a restriction that ncp must
c not exceed 25.

c declaration statements
      dimension xd(100), yd(100), ipc(400)
      dimension dsq0(25), ipc0(25)
      data ncpmx/25/
      integer istat

*   check the inherited error status.
      if ( istat.ne.0 ) return

c preliminary processing
      ndp0 = ndp
      ncp0 = ncp
      if ( ndp0.ge.2 ) then
         if ( ncp0.ge.1 .and. ncp0.le.ncpmx .and. ncp0.lt.ndp0 ) then

c calculation
            do 80 ip1 = 1, ndp0

c - selects ncp points.
               x1 = xd(ip1)
               y1 = yd(ip1)
               j1 = 0
               dsqmx = 0.0
               do 10 ip2 = 1, ndp0
                  if ( ip2.ne.ip1 ) then
                     dsqi = GJP_DSQF(x1,y1,xd(ip2),yd(ip2))
                     j1 = j1 + 1
                     dsq0(j1) = dsqi
                     ipc0(j1) = ip2
                     if ( dsqi.gt.dsqmx ) then
                        dsqmx = dsqi
                        jmx = j1
                     end if
                     if ( j1.ge.ncp0 ) go to 20
                  end if
 10            continue
 20            continue
               ip2mn = ip2 + 1
               if ( ip2mn.le.ndp0 ) then
                  do 25 ip2 = ip2mn, ndp0
                     if ( ip2.ne.ip1 ) then
                        dsqi = GJP_DSQF(x1,y1,xd(ip2),yd(ip2))
                        if ( dsqi.lt.dsqmx ) then
                           dsq0(jmx) = dsqi
                           ipc0(jmx) = ip2
                           dsqmx = 0.0
                           do 22 j1 = 1, ncp0
                              if ( dsq0(j1).gt.dsqmx ) then
                                 dsqmx = dsq0(j1)
                                 jmx = j1
                              end if
 22                        continue
                        end if
                     end if
 25               continue
               end if

c - checks if all the ncp+1 points are collinear.
               ip2 = ipc0(1)
               dx12 = xd(ip2) - x1
               dy12 = yd(ip2) - y1
               do 30 j3 = 2, ncp0
                  ip3 = ipc0(j3)
                  dx13 = xd(ip3) - x1
                  dy13 = yd(ip3) - y1
                  if ( (dy13*dx12-dx13*dy12).ne.0.0 ) go to 50
 30            continue

c - searches for the closest noncollinear point.
               nclpt = 0
               do 40 ip3 = 1, ndp0
                  if ( ip3.ne.ip1 ) then
                     do 32 j4 = 1, ncp0
                        if ( ip3.eq.ipc0(j4) ) go to 40
 32                  continue
                     dx13 = xd(ip3) - x1
                     dy13 = yd(ip3) - y1
                     if ( (dy13*dx12-dx13*dy12).ne.0.0 ) then
                        dsqi = GJP_DSQF(x1,y1,xd(ip3),yd(ip3))
                        if ( nclpt.ne.0 ) then
                           if ( dsqi.ge.dsqmn ) go to 40
                        end if
                        nclpt = 1
                        dsqmn = dsqi
                        ip3mn = ip3
                     end if
                  end if
 40            continue
               if ( nclpt.eq.0 ) go to 100
               dsqmx = dsqmn
               ipc0(jmx) = ip3mn

c - replaces the local array for the output array.
 50            continue
               j1 = (ip1-1)*ncp0
               do 60 j2 = 1, ncp0
                  j1 = j1 + 1
                  ipc(j1) = ipc0(j2)
 60            continue
 80         continue
            return
         end if
      end if

c error exit
      istat = 2
      ipc(1) = 0
      return

 100  continue
      istat = 3
      ipc(1) = 0


      end


      SUBROUTINE GJP_IDGRID(xd,yd,nt,ipt,nl,ipl,nxi,nyi,xi,yi,ngp,
     :                      igp,istat)

c this subroutine organizes grid points for surface fitting by
c sorting them in ascending order of triangle numbers and of the
c border line segment number.

c the input parameters are
c     xd,yd = arrays of dimension ndp containing the x and y
c           coordinates of the data points, where ndp is the
c           number of the data points,
c     nt  = number of triangles,
c     ipt = integer array of dimension 3*nt containing the
c           point numbers of the vertices of the triangles,
c     nl  = number of border line segments,
c     ipl = integer array of dimension 3*nl containing the
c           point numbers of the end points of the border
c           line segments and their respective triangle
c           numbers,
c     nxi = number of grid points in the x coordinate,
c     nyi = number of grid points in the y coordinate,
c     xi,yi = arrays of dimension nxi and nyi containing
c           the x and y coordinates of the grid points,
c           respectively.

c the output parameters are
c     ngp = integer array of dimension 2*(nt+2*nl) where the
c           number of grid points that belong to each of the
c           triangles or of the border line segments are to
c           be stored,
c     igp = integer array of dimension nxi*nyi where the
c           grid point numbers are to be stored in ascending
c           order of the triangle number and the border line
c           segment number.
*     istat = starlink error message.


c declaration statements
      dimension xd(100), yd(100), ipt(585), ipl(300), xi(101), yi(101),
     :          ngp(800), igp(10201)
      integer istat

*   check the inherited error status.
      if ( istat.ne.0 ) return

c preliminary processing
      nt0 = nt
      nl0 = nl
      nxi0 = nxi
      nyi0 = nyi
      nxinyi = nxi0*nyi0
      ximn = amin1(xi(1), xi(nxi0))
      ximx = amax1(xi(1), xi(nxi0))
      yimn = amin1(yi(1), yi(nyi0))
      yimx = amax1(yi(1), yi(nyi0))

c determines grid points inside the data area.
      jngp0 = 0
      jngp1 = 2*(nt0+2*nl0) + 1
      jigp0 = 0
      jigp1 = nxinyi + 1
      do 300 it0 = 1, nt0
         ngp0 = 0
         ngp1 = 0
         it0t3 = it0*3
         ip1 = ipt(it0t3-2)
         ip2 = ipt(it0t3-1)
         ip3 = ipt(it0t3)
         x1 = xd(ip1)
         y1 = yd(ip1)
         x2 = xd(ip2)
         y2 = yd(ip2)
         x3 = xd(ip3)
         y3 = yd(ip3)
         xmn = amin1(x1, x2, x3)
         xmx = amax1(x1, x2, x3)
         ymn = amin1(y1, y2, y3)
         ymx = amax1(y1, y2, y3)
         insd = 0
         do 50 ixi = 1, nxi0
            if ( xi(ixi).ge.xmn .and. xi(ixi).le.xmx ) then
               if ( insd.ne.1 ) then
                  insd = 1
                  iximn = ixi
               end if
            else if ( insd.ne.0 ) then
               iximx = ixi - 1
               go to 100
            end if
 50      continue
         if ( insd.eq.0 ) go to 200
         iximx = nxi0
 100     continue
         do 150 iyi = 1, nyi0
            yii = yi(iyi)
            if ( yii.ge.ymn .and. yii.le.ymx ) then
               do 110 ixi = iximn, iximx
                  xii = xi(ixi)
                  l = 0
                  if (GJP_SIDE(x1,y1,x2,y2,xii,yii).lt.0) go to 110
                  if (GJP_SIDE(x1,y1,x2,y2,xii,yii).eq.0) l = 1
                  if (GJP_SIDE(x2,y2,x3,y3,xii,yii).lt.0) go to 110
                  if (GJP_SIDE(x2,y2,x3,y3,xii,yii).eq.0) l = 1
                  if (GJP_SIDE(x3,y3,x1,y1,xii,yii).lt.0) go to 110
                  if (GJP_SIDE(x3,y3,x1,y1,xii,yii).eq.0) l = 1
                  izi = nxi0*(iyi-1) + ixi
                  if ( l.eq.1 ) then
                     if ( jigp1.le.nxinyi ) then
                        do 102 jigp1i = jigp1, nxinyi
                           if ( izi.eq.igp(jigp1i) ) go to 110
 102                    continue
                     end if
                     ngp1 = ngp1 + 1
                     jigp1 = jigp1 - 1
                     igp(jigp1) = izi
                  else
                     ngp0 = ngp0 + 1
                     jigp0 = jigp0 + 1
                     igp(jigp0) = izi
                  end if
 110           continue
            end if
 150     continue
 200     continue
         jngp0 = jngp0 + 1
         ngp(jngp0) = ngp0
         jngp1 = jngp1 - 1
         ngp(jngp1) = ngp1
 300  continue

c determines grid points outside the data area.
c - in semi-infinite rectangular area.
      do 800 il0 = 1, nl0
         ngp0 = 0
         ngp1 = 0
         il0t3 = il0*3
         ip1 = ipl(il0t3-2)
         ip2 = ipl(il0t3-1)
         x1 = xd(ip1)
         y1 = yd(ip1)
         x2 = xd(ip2)
         y2 = yd(ip2)
         xmn = ximn
         xmx = ximx
         ymn = yimn
         ymx = yimx
         if ( y2.ge.y1 ) xmn = amin1(x1, x2)
         if ( y2.le.y1 ) xmx = amax1(x1, x2)
         if ( x2.le.x1 ) ymn = amin1(y1, y2)
         if ( x2.ge.x1 ) ymx = amax1(y1, y2)
         insd = 0
         do 350 ixi = 1, nxi0
            if ( xi(ixi).ge.xmn .and. xi(ixi).le.xmx ) then
               if ( insd.ne.1 ) then
                  insd = 1
                  iximn = ixi
               end if
            else if ( insd.ne.0 ) then
               iximx = ixi - 1
               go to 400
            end if
 350     continue
         if ( insd.eq.0 ) go to 500
         iximx = nxi0
 400     continue
         do 450 iyi = 1, nyi0
            yii = yi(iyi)
            if ( yii.ge.ymn .and. yii.le.ymx ) then
               do 410 ixi = iximn, iximx
                  xii = xi(ixi)
                  l = 0
                  if (GJP_SIDE(x1,y1,x2,y2,xii,yii).lt.0) then
                  else if (GJP_SIDE(x1,y1,x2,y2,xii,yii).eq.0) then
                     l = 1
                  else
                     go to 410
                  end if
                  if (GJP_SPDT(x2,y2,x1,y1,xii,yii).lt.0) go to 410
                  if (GJP_SPDT(x2,y2,x1,y1,xii,yii).eq.0) l = 1
                  if (GJP_SPDT(x1,y1,x2,y2,xii,yii).lt.0) go to 410
                  if (GJP_SPDT(x1,y1,x2,y2,xii,yii).eq.0) l = 1
                  izi = nxi0*(iyi-1) + ixi
                  if ( l.eq.1 ) then
                     if ( jigp1.le.nxinyi ) then
                        do 402 jigp1i = jigp1, nxinyi
                           if ( izi.eq.igp(jigp1i) ) go to 410
 402                    continue
                     end if
                     ngp1 = ngp1 + 1
                     jigp1 = jigp1 - 1
                     igp(jigp1) = izi
                  else
                     ngp0 = ngp0 + 1
                     jigp0 = jigp0 + 1
                     igp(jigp0) = izi
                  end if
 410           continue
            end if
 450     continue
 500     continue
         jngp0 = jngp0 + 1
         ngp(jngp0) = ngp0
         jngp1 = jngp1 - 1
         ngp(jngp1) = ngp1

c - in semi-infinite triangular area.
         ngp0 = 0
         ngp1 = 0
         ilp1 = mod(il0, nl0) + 1
         ilp1t3 = ilp1*3
         ip3 = ipl(ilp1t3-1)
         x3 = xd(ip3)
         y3 = yd(ip3)
         xmn = ximn
         xmx = ximx
         ymn = yimn
         ymx = yimx
         if ( y3.ge.y2 .and. y2.ge.y1 ) xmn = x2
         if ( y3.le.y2 .and. y2.le.y1 ) xmx = x2
         if ( x3.le.x2 .and. x2.le.x1 ) ymn = y2
         if ( x3.ge.x2 .and. x2.ge.x1 ) ymx = y2
         insd = 0
         do 550 ixi = 1, nxi0
            if ( xi(ixi).ge.xmn .and. xi(ixi).le.xmx ) then
               if ( insd.ne.1 ) then
                  insd = 1
                  iximn = ixi
               end if
            else if ( insd.ne.0 ) then
               iximx = ixi - 1
               go to 600
            end if
 550     continue
         if ( insd.eq.0 ) go to 700
         iximx = nxi0
 600     continue
         do 650 iyi = 1, nyi0
            yii = yi(iyi)
            if ( yii.ge.ymn .and. yii.le.ymx ) then
               do 610 ixi = iximn, iximx
                  xii = xi(ixi)
                  l = 0
                  if (GJP_SPDT(x1,y1,x2,y2,xii,yii).lt.0) then
                  else if (GJP_SPDT(x1,y1,x2,y2,xii,yii).eq.0) then
                     l = 1
                  else
                     go to 610
                  end if
                  if (GJP_SPDT(x3,y3,x2,y2,xii,yii).lt.0) then
                  else if (GJP_SPDT(x3,y3,x2,y2,xii,yii).eq.0) then
                     l = 1
                  else
                     go to 610
                  end if
                  izi = nxi0*(iyi-1) + ixi
                  if ( l.eq.1 ) then
                     if ( jigp1.le.nxinyi ) then
                        do 602 jigp1i = jigp1, nxinyi
                           if ( izi.eq.igp(jigp1i) ) go to 610
 602                    continue
                     end if
                     ngp1 = ngp1 + 1
                     jigp1 = jigp1 - 1
                     igp(jigp1) = izi
                  else
                     ngp0 = ngp0 + 1
                     jigp0 = jigp0 + 1
                     igp(jigp0) = izi
                  end if
 610           continue
            end if
 650     continue
 700     continue
         jngp0 = jngp0 + 1
         ngp(jngp0) = ngp0
         jngp1 = jngp1 - 1
         ngp(jngp1) = ngp1
 800  continue
      return
      end


      SUBROUTINE GJP_IDLCTN(ndp,xd,yd,nt,ipt,nl,ipl,xii,yii,iti,
     :                      iwk,wk,istat)

c this subroutine locates a point, i.e., determines to what tri-
c angle a given point (xii,yii) belongs.  when the given point
c does not lie inside the data area, this subroutine determines
c the border line segment when the point lies in an outside
c rectangular area, and two border line segments when the point
c lies in an outside triangular area.

c the input parameters are
c     ndp = number of data points,
c     xd,yd = arrays of dimension ndp containing the x and y
c           coordinates of the data points,
c     nt  = number of triangles,
c     ipt = integer array of dimension 3*nt containing the
c           point numbers of the vertices of the triangles,
c     nl  = number of border line segments,
c     ipl = integer array of dimension 3*nl containing the
c           point numbers of the end points of the border
c           line segments and their respective triangle
c           numbers,
c     xii,yii = x and y coordinates of the point to be
c           located.

c the output parameter is
c     iti = triangle number, when the point is inside the
c           data area, or
c           two border line segment numbers, il1 and il2,
c           coded to il1*(nt+nl)+il2, when the point is
c           outside the data area.
*     istat = starlink error message.

c the other parameters are
c     iwk = integer array of dimension 18*ndp used inter-
c           nally as a work area,
c     wk  = array of dimension 8*ndp used internally as a
c           work area.

c declaration statements
      dimension xd(100), yd(100), ipt(585), ipl(300), iwk(1800), wk(800)
      dimension ntsc(9), idsc(9)
      common /idlc  / nit
      integer istat

*   check the inherited error status.
      if ( istat.ne.0 ) return

c preliminary processing
      ndp0 = ndp
      nt0 = nt
      nl0 = nl
      ntl = nt0 + nl0
      x0 = xii
      y0 = yii

c processing for a new set of data points
      if ( nit.ne.0 ) then

c checks if in the same triangle as previous.
         it0 = itipv
         if ( it0.gt.nt0 ) then

c checks if on the same border line segment.
            il1 = it0/ntl
            il2 = it0 - il1*ntl
            il1t3 = il1*3
            ip1 = ipl(il1t3-2)
            x1 = xd(ip1)
            y1 = yd(ip1)
            ip2 = ipl(il1t3-1)
            x2 = xd(ip2)
            y2 = yd(ip2)
            if ( il2.ne.il1 ) then

c checks if between the same two border line segments.
               if (GJP_SPDT(x1,y1,x2,y2,x0,y0).le.0.0) then
                  ip3 = ipl(3*il2-1)
                  x3 = xd(ip3)
                  y3 = yd(ip3)
                  if (GJP_SPDT(x3,y3,x2,y2,x0,y0).le.0.0) go to 500
               end if
            else if (GJP_SPDT(x1,y1,x2,y2,x0,y0).ge.0.0) then
               if (GJP_SPDT(x2,y2,x1,y1,x0,y0).ge.0.0) then
                  if (GJP_SIDE(x1,y1,x2,y2,x0,y0).le.0.0) go to 500
               end if
            end if
         else
            it0t3 = it0*3
            ip1 = ipt(it0t3-2)
            x1 = xd(ip1)
            y1 = yd(ip1)
            ip2 = ipt(it0t3-1)
            x2 = xd(ip2)
            y2 = yd(ip2)
            if (GJP_SIDE(x1,y1,x2,y2,x0,y0).ge.0.0) then
               ip3 = ipt(it0t3)
               x3 = xd(ip3)
               y3 = yd(ip3)
               if (GJP_SIDE(x2,y2,x3,y3,x0,y0).ge.0.0) then
                  if (GJP_SIDE(x3,y3,x1,y1,x0,y0).ge.0.0) go to 500
               end if
            end if
         end if
      else
         nit = 1

c - divides the x-y plane into nine rectangular sections.
         xmn = xd(1)
         xmx = xmn
         ymn = yd(1)
         ymx = ymn
         do 50 idp = 2, ndp0
            xi = xd(idp)
            yi = yd(idp)
            xmn = amin1(xi, xmn)
            xmx = amax1(xi, xmx)
            ymn = amin1(yi, ymn)
            ymx = amax1(yi, ymx)
 50      continue
         xs1 = (xmn+xmn+xmx)/3.0
         xs2 = (xmn+xmx+xmx)/3.0
         ys1 = (ymn+ymn+ymx)/3.0
         ys2 = (ymn+ymx+ymx)/3.0

c - determines and stores in the iwk array triangle numbers of
c - the triangles associated with each of the nine sections.
         do 100 isc = 1, 9
            ntsc(isc) = 0
            idsc(isc) = 0
 100     continue
         it0t3 = 0
         jwk = 0
         do 150 it0 = 1, nt0
            it0t3 = it0t3 + 3
            i1 = ipt(it0t3-2)
            i2 = ipt(it0t3-1)
            i3 = ipt(it0t3)
            xmn = amin1(xd(i1), xd(i2), xd(i3))
            xmx = amax1(xd(i1), xd(i2), xd(i3))
            ymn = amin1(yd(i1), yd(i2), yd(i3))
            ymx = amax1(yd(i1), yd(i2), yd(i3))
            if ( ymn.le.ys1 ) then
               if ( xmn.le.xs1 ) idsc(1) = 1
               if ( xmx.ge.xs1 .and. xmn.le.xs2 ) idsc(2) = 1
               if ( xmx.ge.xs2 ) idsc(3) = 1
            end if
            if ( ymx.ge.ys1 .and. ymn.le.ys2 ) then
               if ( xmn.le.xs1 ) idsc(4) = 1
               if ( xmx.ge.xs1 .and. xmn.le.xs2 ) idsc(5) = 1
               if ( xmx.ge.xs2 ) idsc(6) = 1
            end if
            if ( ymx.ge.ys2 ) then
               if ( xmn.le.xs1 ) idsc(7) = 1
               if ( xmx.ge.xs1 .and. xmn.le.xs2 ) idsc(8) = 1
               if ( xmx.ge.xs2 ) idsc(9) = 1
            end if
            do 120 isc = 1, 9
               if ( idsc(isc).ne.0 ) then
                  jiwk = 9*ntsc(isc) + isc
                  iwk(jiwk) = it0
                  ntsc(isc) = ntsc(isc) + 1
                  idsc(isc) = 0
               end if
 120        continue

c - stores in the wk array the minimum and maximum of the x and
c - y coordinate values for each of the triangle.
            jwk = jwk + 4
            wk(jwk-3) = xmn
            wk(jwk-2) = xmx
            wk(jwk-1) = ymn
            wk(jwk) = ymx
 150     continue
      end if

c locates inside the data area.
c - determines the section in which the point in question lies.
      isc = 1
      if ( x0.ge.xs1 ) isc = isc + 1
      if ( x0.ge.xs2 ) isc = isc + 1
      if ( y0.ge.ys1 ) isc = isc + 3
      if ( y0.ge.ys2 ) isc = isc + 3

c - searches through the triangles associated with the section.
      ntsci = ntsc(isc)
      if ( ntsci.gt.0 ) then
         jiwk = -9 + isc
         do 200 itsc = 1, ntsci
            jiwk = jiwk + 9
            it0 = iwk(jiwk)
            jwk = it0*4
            if ( x0.ge.wk(jwk-3) ) then
               if ( x0.le.wk(jwk-2) ) then
                  if ( y0.ge.wk(jwk-1) ) then
                     if ( y0.le.wk(jwk) ) then
                        it0t3 = it0*3
                        ip1 = ipt(it0t3-2)
                        x1 = xd(ip1)
                        y1 = yd(ip1)
                        ip2 = ipt(it0t3-1)
                        x2 = xd(ip2)
                        y2 = yd(ip2)
                        if (GJP_SIDE(x1,y1,x2,y2,x0,y0).ge.0.0) then
                           ip3 = ipt(it0t3)
                           x3 = xd(ip3)
                           y3 = yd(ip3)
                           if (GJP_SIDE(x2,y2,x3,y3,x0,y0).ge.0.0) then
                              if (GJP_SIDE(x3,y3,x1,y1,x0,y0).ge.0.0)
     :                             go to 500
                           end if
                        end if
                     end if
                  end if
               end if
            end if
 200     continue
      end if

c locates outside the data area.
      do 300 il1 = 1, nl0
         il1t3 = il1*3
         ip1 = ipl(il1t3-2)
         x1 = xd(ip1)
         y1 = yd(ip1)
         ip2 = ipl(il1t3-1)
         x2 = xd(ip2)
         y2 = yd(ip2)
         if (GJP_SPDT(x2,y2,x1,y1,x0,y0).ge.0.0) then
            if (GJP_SPDT(x1,y1,x2,y2,x0,y0).lt.0.0) then
               il2 = mod(il1, nl0) + 1
               ip3 = ipl(3*il2-1)
               x3 = xd(ip3)
               y3 = yd(ip3)
               if (GJP_SPDT(x3,y3,x2,y2,x0,y0).le.0.0) go to 400
            else if (GJP_SIDE(x1,y1,x2,y2,x0,y0).le.0.0) then
               il2 = il1
               go to 400
            end if
         end if
 300  continue
      it0 = 1
      go to 500
 400  continue
      it0 = il1*ntl + il2

c normal exit
 500  continue
      iti = it0
      itipv = it0
      return

      end


      SUBROUTINE GJP_IDPDRV(ndp,xd,yd,zd,ncp,ipc,pd,istat)

c this subroutine estimates partial derivatives of the first and
c second order at the data points.

c the input parameters are
c     ndp = number of data points,
c     xd,yd,zd = arrays of dimension ndp containing the x,
c           y, and z coordinates of the data points,
c     ncp = number of additional data points used for esti-
c           mating partial derivatives at each data point,
c     ipc = integer array of dimension ncp*ndp containing
c           the point numbers of ncp data points closest to
c           each of the ndp data points.

c the output parameter is
c     pd  = array of dimension 5*ndp, where the estimated
c           zx, zy, zxx, zxy, and zyy values at the data
c           points are to be stored.
*     istat = starlink error message.


c declaration statements
      dimension xd(100), yd(100), zd(100), ipc(400), pd(500)
      real nmx, nmy, nmz, nmxx, nmxy, nmyx, nmyy
      integer istat

*   check the inherited error status.
      if ( istat.ne.0 ) return

c preliminary processing
      ndp0 = ndp
      ncp0 = ncp
      ncpm1 = ncp0 - 1

c estimation of zx and zy
      do 100 ip0 = 1, ndp0
         x0 = xd(ip0)
         y0 = yd(ip0)
         z0 = zd(ip0)
         nmx = 0.0
         nmy = 0.0
         nmz = 0.0
         jipc0 = ncp0*(ip0-1)
         do 50 ic1 = 1, ncpm1
            jipc = jipc0 + ic1
            ipi = ipc(jipc)
            dx1 = xd(ipi) - x0
            dy1 = yd(ipi) - y0
            dz1 = zd(ipi) - z0
            ic2mn = ic1 + 1
            do 20 ic2 = ic2mn, ncp0
               jipc = jipc0 + ic2
               ipi = ipc(jipc)
               dx2 = xd(ipi) - x0
               dy2 = yd(ipi) - y0
               dnmz = dx1*dy2 - dy1*dx2
               if ( dnmz.ne.0.0 ) then
                  dz2 = zd(ipi) - z0
                  dnmx = dy1*dz2 - dz1*dy2
                  dnmy = dz1*dx2 - dx1*dz2
                  if ( dnmz.lt.0.0 ) then
                     dnmx = -dnmx
                     dnmy = -dnmy
                     dnmz = -dnmz
                  end if
                  nmx = nmx + dnmx
                  nmy = nmy + dnmy
                  nmz = nmz + dnmz
               end if
 20         continue
 50      continue
         jpd0 = 5*ip0
         pd(jpd0-4) = -nmx/nmz
         pd(jpd0-3) = -nmy/nmz
 100  continue

c estimation of zxx, zxy, and zyy
      do 200 ip0 = 1, ndp0
         jpd0 = jpd0 + 5
         x0 = xd(ip0)
         jpd0 = 5*ip0
         y0 = yd(ip0)
         zx0 = pd(jpd0-4)
         zy0 = pd(jpd0-3)
         nmxx = 0.0
         nmxy = 0.0
         nmyx = 0.0
         nmyy = 0.0
         nmz = 0.0
         jipc0 = ncp0*(ip0-1)
         do 150 ic1 = 1, ncpm1
            jipc = jipc0 + ic1
            ipi = ipc(jipc)
            dx1 = xd(ipi) - x0
            dy1 = yd(ipi) - y0
            jpd = 5*ipi
            dzx1 = pd(jpd-4) - zx0
            dzy1 = pd(jpd-3) - zy0
            ic2mn = ic1 + 1
            do 120 ic2 = ic2mn, ncp0
               jipc = jipc0 + ic2
               ipi = ipc(jipc)
               dx2 = xd(ipi) - x0
               dy2 = yd(ipi) - y0
               dnmz = dx1*dy2 - dy1*dx2
               if ( dnmz.ne.0.0 ) then
                  jpd = 5*ipi
                  dzx2 = pd(jpd-4) - zx0
                  dzy2 = pd(jpd-3) - zy0
                  dnmxx = dy1*dzx2 - dzx1*dy2
                  dnmxy = dzx1*dx2 - dx1*dzx2
                  dnmyx = dy1*dzy2 - dzy1*dy2
                  dnmyy = dzy1*dx2 - dx1*dzy2
                  if ( dnmz.lt.0.0 ) then
                     dnmxx = -dnmxx
                     dnmxy = -dnmxy
                     dnmyx = -dnmyx
                     dnmyy = -dnmyy
                     dnmz = -dnmz
                  end if
                  nmxx = nmxx + dnmxx
                  nmxy = nmxy + dnmxy
                  nmyx = nmyx + dnmyx
                  nmyy = nmyy + dnmyy
                  nmz = nmz + dnmz
               end if
 120        continue
 150     continue
         pd(jpd0-2) = -nmxx/nmz
         pd(jpd0-1) = -(nmxy+nmyx)/(2.0*nmz)
         pd(jpd0) = -nmyy/nmz
 200  continue
      return
      end


      SUBROUTINE GJP_IDPTIP(xd,yd,zd,nt,ipt,nl,ipl,pdd,iti,xii,
     :                      yii,zii,istat)

c this subroutine performs punctual interpolation or extrapola-
c tion, i.e., determines the z value at a point.

c the input parameters are
c     xd,yd,zd = arrays of dimension ndp containing the x,
c           y, and z coordinates of the data points, where
c           ndp is the number of the data points,
c     nt  = number of triangles,
c     ipt = integer array of dimension 3*nt containing the
c           point numbers of the vertices of the triangles,
c     nl  = number of border line segments,
c     ipl = integer array of dimension 3*nl containing the
c           point numbers of the end points of the border
c           line segments and their respective triangle
c           numbers,
c     pdd = array of dimension 5*ndp containing the partial
c           derivatives at the data points,
c     iti = triangle number of the triangle in which lies
c           the point for which interpolation is to be
c           performed,
c     xii,yii = x and y coordinates of the point for which
c           interpolation is to be performed.

c the output parameter is
c     zii = interpolated z value.
*     istat = starlink error message.


c declaration statements
      dimension xd(100), yd(100), zd(100), ipt(585), ipl(300), pdd(500)
      common /idpi  / itpv
      dimension x(3), y(3), z(3), pd(15), zu(3), zv(3), zuu(3), zuv(3),
     :          zvv(3)
      real lu, lv
      equivalence (p5, p50)
      integer istat

*   check the inherited error status.
      if ( istat.ne.0 ) return

c preliminary processing
      it0 = iti
      ntl = nt + nl
      if ( it0.le.ntl ) then

c calculation of zii by interpolation.
c checks if the necessary coefficients have been calculated.
         if ( it0.ne.itpv ) then

c loads coordinate and partial derivative values at the
c vertices.
            jipt = 3*(it0-1)
            jpd = 0
            do 20 i = 1, 3
               jipt = jipt + 1
               idp = ipt(jipt)
               x(i) = xd(idp)
               y(i) = yd(idp)
               z(i) = zd(idp)
               jpdd = 5*(idp-1)
               do 10 kpd = 1, 5
                  jpd = jpd + 1
                  jpdd = jpdd + 1
                  pd(jpd) = pdd(jpdd)
 10            continue
 20         continue

c determines the coefficients for the coordinate system
c transformation from the x-y system to the u-v system
c and vice versa.
            x0 = x(1)
            y0 = y(1)
            a = x(2) - x0
            b = x(3) - x0
            c = y(2) - y0
            d = y(3) - y0
            ad = a*d
            bc = b*c
            dlt = ad - bc
            ap = d/dlt
            bp = -b/dlt
            cp = -c/dlt
            dp = a/dlt

c converts the partial derivatives at the vertices of the
c triangle for the u-v coordinate system.
            aa = a*a
            act2 = 2.0*a*c
            cc = c*c
            ab = a*b
            adbc = ad + bc
            cd = c*d
            bb = b*b
            bdt2 = 2.0*b*d
            dd = d*d
            do 40 i = 1, 3
               jpd = 5*i
               zu(i) = a*pd(jpd-4) + c*pd(jpd-3)
               zv(i) = b*pd(jpd-4) + d*pd(jpd-3)
               zuu(i) = aa*pd(jpd-2) + act2*pd(jpd-1) + cc*pd(jpd)
               zuv(i) = ab*pd(jpd-2) + adbc*pd(jpd-1) + cd*pd(jpd)
               zvv(i) = bb*pd(jpd-2) + bdt2*pd(jpd-1) + dd*pd(jpd)
 40         continue

c calculates the coefficients of the polynomial.
            p00 = z(1)
            p10 = zu(1)
            p01 = zv(1)
            p20 = 0.5*zuu(1)
            p11 = zuv(1)
            p02 = 0.5*zvv(1)
            h1 = z(2) - p00 - p10 - p20
            h2 = zu(2) - p10 - zuu(1)
            h3 = zuu(2) - zuu(1)
            p30 = 10.0*h1 - 4.0*h2 + 0.5*h3
            p40 = -15.0*h1 + 7.0*h2 - h3
            p50 = 6.0*h1 - 3.0*h2 + 0.5*h3
            h1 = z(3) - p00 - p01 - p02
            h2 = zv(3) - p01 - zvv(1)
            h3 = zvv(3) - zvv(1)
            p03 = 10.0*h1 - 4.0*h2 + 0.5*h3
            p04 = -15.0*h1 + 7.0*h2 - h3
            p05 = 6.0*h1 - 3.0*h2 + 0.5*h3
            lu = sqrt(aa+cc)
            lv = sqrt(bb+dd)
            thxu = atan2(c, a)
            thuv = atan2(d, b) - thxu
            csuv = cos(thuv)
            p41 = 5.0*lv*csuv/lu*p50
            p14 = 5.0*lu*csuv/lv*p05
            h1 = zv(2) - p01 - p11 - p41
            h2 = zuv(2) - p11 - 4.0*p41
            p21 = 3.0*h1 - h2
            p31 = -2.0*h1 + h2
            h1 = zu(3) - p10 - p11 - p14
            h2 = zuv(3) - p11 - 4.0*p14
            p12 = 3.0*h1 - h2
            p13 = -2.0*h1 + h2
            thus = atan2(d-c, b-a) - thxu
            thsv = thuv - thus
            aa = sin(thsv)/lu
            bb = -cos(thsv)/lu
            cc = sin(thus)/lv
            dd = cos(thus)/lv
            ac = aa*cc
            ad = aa*dd
            bc = bb*cc
            g1 = aa*ac*(3.0*bc+2.0*ad)
            g2 = cc*ac*(3.0*ad+2.0*bc)
            h1 = -aa*aa*aa*(5.0*aa*bb*p50+(4.0*bc+ad)*p41)
     :           - cc*cc*cc*(5.0*cc*dd*p05+(4.0*ad+bc)*p14)
            h2 = 0.5*zvv(2) - p02 - p12
            h3 = 0.5*zuu(3) - p20 - p21
            p22 = (g1*h2+g2*h3-h1)/(g1+g2)
            p32 = h2 - p22
            p23 = h3 - p22
            itpv = it0
         end if

c converts xii and yii to u-v system.
         dx = xii - x0
         dy = yii - y0
         u = ap*dx + bp*dy
         v = cp*dx + dp*dy

c evaluates the polynomial.
         p0 = p00 + v*(p01+v*(p02+v*(p03+v*(p04+v*p05))))
         p1 = p10 + v*(p11+v*(p12+v*(p13+v*p14)))
         p2 = p20 + v*(p21+v*(p22+v*p23))
         p3 = p30 + v*(p31+v*p32)
         p4 = p40 + v*p41
         zii = p0 + u*(p1+u*(p2+u*(p3+u*(p4+u*p5))))
         return
      else
         il1 = it0/ntl
         il2 = it0 - il1*ntl
         if ( il1.eq.il2 ) then

c calculation of zii by extrapolation in the rectangle.
c checks if the necessary coefficients have been calculated.
            if ( it0.ne.itpv ) then

c loads coordinate and partial derivative values at the end
c points of the border line segment.
               jipl = 3*(il1-1)
               jpd = 0
               do 50 i = 1, 2
                  jipl = jipl + 1
                  idp = ipl(jipl)
                  x(i) = xd(idp)
                  y(i) = yd(idp)
                  z(i) = zd(idp)
                  jpdd = 5*(idp-1)
                  do 45 kpd = 1, 5
                     jpd = jpd + 1
                     jpdd = jpdd + 1
                     pd(jpd) = pdd(jpdd)
 45               continue
 50            continue

c determines the coefficients for the coordinate system
c transformation from the x-y system to the u-v system
c and vice versa.
               x0 = x(1)
               y0 = y(1)
               a = y(2) - y(1)
               b = x(2) - x(1)
               c = -b
               d = a
               ad = a*d
               bc = b*c
               dlt = ad - bc
               ap = d/dlt
               bp = -b/dlt
               cp = -bp
               dp = ap

c converts the partial derivatives at the end points of the
c border line segment for the u-v coordinate system.
               aa = a*a
               act2 = 2.0*a*c
               cc = c*c
               ab = a*b
               adbc = ad + bc
               cd = c*d
               bb = b*b
               bdt2 = 2.0*b*d
               dd = d*d
               do 60 i = 1, 2
                  jpd = 5*i
                  zu(i) = a*pd(jpd-4) + c*pd(jpd-3)
                  zv(i) = b*pd(jpd-4) + d*pd(jpd-3)
                  zuu(i) = aa*pd(jpd-2) + act2*pd(jpd-1) + cc*pd(jpd)
                  zuv(i) = ab*pd(jpd-2) + adbc*pd(jpd-1) + cd*pd(jpd)
                  zvv(i) = bb*pd(jpd-2) + bdt2*pd(jpd-1) + dd*pd(jpd)
 60            continue

c calculates the coefficients of the polynomial.
               p00 = z(1)
               p10 = zu(1)
               p01 = zv(1)
               p20 = 0.5*zuu(1)
               p11 = zuv(1)
               p02 = 0.5*zvv(1)
               h1 = z(2) - p00 - p01 - p02
               h2 = zv(2) - p01 - zvv(1)
               h3 = zvv(2) - zvv(1)
               p03 = 10.0*h1 - 4.0*h2 + 0.5*h3
               p04 = -15.0*h1 + 7.0*h2 - h3
               p05 = 6.0*h1 - 3.0*h2 + 0.5*h3
               h1 = zu(2) - p10 - p11
               h2 = zuv(2) - p11
               p12 = 3.0*h1 - h2
               p13 = -2.0*h1 + h2
               p21 = 0.0
               p23 = -zuu(2) + zuu(1)
               p22 = -1.5*p23
               itpv = it0
            end if

c converts xii and yii to u-v system.
            dx = xii - x0
            dy = yii - y0
            u = ap*dx + bp*dy
            v = cp*dx + dp*dy

c evaluates the polynomial.
            p0 = p00 + v*(p01+v*(p02+v*(p03+v*(p04+v*p05))))
            p1 = p10 + v*(p11+v*(p12+v*p13))
            p2 = p20 + v*(p21+v*(p22+v*p23))
            zii = p0 + u*(p1+u*p2)
            return

c calculation of zii by extrapolation in the triangle.
c checks if the necessary coefficients have been calculated.
         else if ( it0.ne.itpv ) then

c loads coordinate and partial derivative values at the vertex
c of the triangle.
            jipl = 3*il2 - 2
            idp = ipl(jipl)
            x(1) = xd(idp)
            y(1) = yd(idp)
            z(1) = zd(idp)
            jpdd = 5*(idp-1)
            do 80 kpd = 1, 5
               jpdd = jpdd + 1
               pd(kpd) = pdd(jpdd)
 80         continue

c calculates the coefficients of the polynomial.
            p00 = z(1)
            p10 = pd(1)
            p01 = pd(2)
            p20 = 0.5*pd(3)
            p11 = pd(4)
            p02 = 0.5*pd(5)
            itpv = it0
         end if
      end if

c converts xii and yii to u-v system.
      u = xii - x(1)
      v = yii - y(1)

c evaluates the polynomial.
      p0 = p00 + v*(p01+v*p02)
      p1 = p10 + v*p11
      zii = p0 + u*(p1+u*p20)
      return
      end


      SUBROUTINE GJP_IDSFFT(md,ncp,ndp,xd,yd,zd,nxi,nyi,xi,yi,zi,
     :                      iwk,wk,istat,status)

c this subroutine performs smooth surface fitting when the pro-
c jections of the data points in the x-y plane are irregularly
c distributed in the plane.

c the input parameters are
c     md  = mode of computation (must be 1, 2, or 3),
c         = 1 for new ncp and/or new xd-yd,
c         = 2 for old ncp, old xd-yd, new xi-yi,
c         = 3 for old ncp, old xd-yd, old xi-yi,
c     ncp = number of additional data points used for esti-
c           mating partial derivatives at each data point
c           (must be 2 or greater, but smaller than ndp),
c     ndp = number of data points (must be 4 or greater),
c     xd  = array of dimension ndp containing the x
c           coordinates of the data points,
c     yd  = array of dimension ndp containing the y
c           coordinates of the data points,
c     zd  = array of dimension ndp containing the z
c           coordinates of the data points,
c     nxi = number of output grid points in the x coordinate
c           (must be 1 or greater),
c     nyi = number of output grid points in the y coordinate
c           (must be 1 or greater),
c     xi  = array of dimension nxi containing the x
c           coordinates of the output grid points,
c     yi  = array of dimension nyi containing the y
c           coordinates of the output grid points.

c the output parameter is
c     zi  = doubly-dimensioned array of dimension (nxi,nyi),
c           where the interpolated z values at the output
c           grid points are to be stored.
c     istat = error message.
c     status= Starlink error status

c the other parameters are
c     iwk = integer array of dimension
c              max0(31,27+ncp)*ndp+nxi*nyi
c           used internally as a work area,
c     wk  = array of dimension 5*ndp used internally as a
c           work area.

c the very first call to this subroutine and the call with a new
c ncp value, a new ndp value, and/or new contents of the xd and
c yd arrays must be made with md=1.  the call with md=2 must be
c preceded by another call with the same ncp and ndp values and
c with the same contents of the xd and yd arrays.  the call with
c md=3 must be preceded by another call with the same ncp, ndp,
c nxi, and nyi values and with the same contents of the xd, yd,
c xi, and yi arrays.  between the call with md=2 or md=3 and its
c preceding call, the iwk and wk arrays must not be disturbed.
c use of a value between 3 and 5 (inclusive) for ncp is recom-
c mended unless there are evidences that dictate otherwise.

c this subroutine calls the idcldp, idgrid, idpdrv, idptip, and
c idtang subroutines.

c  Starlink Status.
      INTEGER STATUS                  ! Global status

c declaration statements
      dimension xd(100), yd(100), zd(100), xi(101), yi(101), zi(10201),
     :          iwk(13301), wk(500)
      common /idpi  / itpv
      integer istat

c   check the inherited error status.
      if (STATUS.NE.0) return

c setting of some input parameters to local variables.
c (for md=1,2,3)
      md0 = md
      ncp0 = ncp
      ndp0 = ndp
      nxi0 = nxi
      nyi0 = nyi

c error check.  (for md=1,2,3)
      if ( md0.ge.1 .and. md0.le.3 ) then
         if ( ncp0.ge.2 .and. ncp0.lt.ndp0 ) then
            if ( ndp0.ge.4 ) then
               if ( nxi0.ge.1 .and. nyi0.ge.1 ) then
                  if ( md0.ge.2 ) then
                     ncppv = iwk(1)
                     ndppv = iwk(2)
                     if ( ncp0.ne.ncppv ) go to 100
                     if ( ndp0.ne.ndppv ) go to 100
                  else
                     iwk(1) = ncp0
                     iwk(2) = ndp0
                  end if
                  if ( md0.ge.3 ) then
                     nxipv = iwk(3)
                     nyipv = iwk(4)
                     if ( nxi0.ne.nxipv ) go to 100
                     if ( nyi0.ne.nyipv ) go to 100
                  else
                     iwk(3) = nxi0
                     iwk(4) = nyi0
                  end if

c allocation of storage areas in the iwk array.  (for md=1,2,3)
                  jwipt = 16
                  jwiwl = 6*ndp0 + 1
                  jwngp0 = jwiwl - 1
                  jwipl = 24*ndp0 + 1
                  jwiwp = 30*ndp0 + 1
                  jwipc = 27*ndp0 + 1
                  jwigp0 = max0(31, 27+ncp0)*ndp0

c triangulates the x-y plane.  (for md=1)
                  if ( md0.le.1 ) then
                     call GJP_IDTANG(ndp0,xd,yd,nt,iwk(jwipt),nl,
     :                               iwk(jwipl),iwk(jwiwl),
     :                               iwk(jwiwp),wk,istat)
                     iwk(5) = nt
                     iwk(6) = nl
                     if ( nt.eq.0 ) then
                        if(istat.ne.0) status=1
                        return
                     end if
                  end if

c determines ncp points closest to each data point.  (for md=1)
                  if ( md0.le.1 ) then
                     call GJP_IDCLDP(ndp0,xd,yd,ncp0,iwk(jwipc),istat)
                     if (iwk(jwipc).eq.0) then
                        if(istat.ne.0) status=1
                        return
                     end if
                  end if

c sorts output grid points in ascending order of the triangle
c number and the border line segment number.  (for md=1,2)
                  if ( md0.ne.3 ) then
                     call GJP_IDGRID(xd,yd,nt,iwk(jwipt),
     :                               nl,iwk(jwipl),nxi0,nyi0,xi,yi,
     :                               iwk(jwngp0+1),iwk(jwigp0+1),
     :                               istat)
                  end if

c estimates partial derivatives at all data points.
c (for md=1,2,3)
                  call GJP_IDPDRV(ndp0,xd,yd,zd,ncp0,iwk(jwipc),
     :                            wk,istat)

c interpolates the zi values.  (for md=1,2,3)
                  itpv = 0
                  jig0mx = 0
                  jig1mn = nxi0*nyi0 + 1
                  nngp = nt + 2*nl
                  do 5 jngp = 1, nngp
                     iti = jngp
                     if ( jngp.gt.nt ) then
                        il1 = (jngp-nt+1)/2
                        il2 = (jngp-nt+2)/2
                        if ( il2.gt.nl ) il2 = 1
                        iti = il1*(nt+nl) + il2
                     end if
                     jwngp = jwngp0 + jngp
                     ngp0 = iwk(jwngp)
                     if ( ngp0.ne.0 ) then
                        jig0mn = jig0mx + 1
                        jig0mx = jig0mx + ngp0
                        do 2 jigp = jig0mn, jig0mx
                           jwigp = jwigp0 + jigp
                           izi = iwk(jwigp)
                           iyi = (izi-1)/nxi0 + 1
                           ixi = izi - nxi0*(iyi-1)
                           call GJP_IDPTIP(xd,yd,zd,nt,iwk(jwipt),nl,
     :                                     iwk(jwipl),wk,iti,xi(ixi),
     :                                     yi(iyi),zi(izi),istat)
 2                      continue
                     end if
                     jwngp = jwngp0 + 2*nngp + 1 - jngp
                     ngp1 = iwk(jwngp)
                     if ( ngp1.ne.0 ) then
                        jig1mx = jig1mn - 1
                        jig1mn = jig1mn - ngp1
                        do 4 jigp = jig1mn, jig1mx
                           jwigp = jwigp0 + jigp
                           izi = iwk(jwigp)
                           iyi = (izi-1)/nxi0 + 1
                           ixi = izi - nxi0*(iyi-1)
                           call GJP_IDPTIP(xd,yd,zd,nt,iwk(jwipt),nl,
     :                                     iwk(jwipl),wk,iti,xi(ixi),
     :                                     yi(iyi),zi(izi),istat)
 4                      continue
                     end if
 5                continue
                  if(istat.ne.0) status=1
                  return
               end if
            end if
         end if
      end if

c error exit

 100  continue
      istat = 4
      status=1

      end


      SUBROUTINE GJP_IDTANG(ndp,xd,yd,nt,ipt,nl,ipl,iwl,iwp,wk,
     :                      istat)


c this subroutine performs triangulation.  it divides the x-y
c plane into a number of triangles according to given data
c points in the plane, determines line segments that form the
c border of data area, and determines the triangle numbers
c corresponding to the border line segments.
c at completion, point numbers of the vertices of each triangle
c are listed counter-clockwise.  point numbers of the end points
c of each border line segment are listed counter-clockwise,
c listing order of the line segments being counter-clockwise.

c this subroutine calls the idxchg function.

c the input parameters are
c     ndp = number of data points,
c     xd  = array of dimension ndp containing the
c           x coordinates of the data points,
c     yd  = array of dimension ndp containing the
c           y coordinates of the data points.

c the output parameters are
c     nt  = number of triangles,
c     ipt = integer array of dimension 6*ndp-15, where the
c           point numbers of the vertices of the (it)th
c           triangle are to be stored as the (3*it-2)nd,
c           (3*it-1)st, and (3*it)th elements,
c           it=1,2,...,nt,
c     nl  = number of border line segments,
c     ipl = integer array of dimension 6*ndp, where the
c           point numbers of the end points of the (il)th
c           border line segment and its respective triangle
c           number are to be stored as the (3*il-2)nd,
c           (3*il-1)st, and (3*il)th elements,
c           il=1,2,..., nl.
*     istat = starlink error message.

c the other parameters are
c     iwl = integer array of dimension 18*ndp used
c           internally as a work area,
c     iwp = integer array of dimension ndp used
c           internally as a work area,
c     wk  = array of dimension ndp used internally as a
c           work area.

c declaration statements
      dimension xd(100), yd(100), ipt(585), ipl(600), iwl(1800),
     :          iwp(100), wk(100)
      dimension itf(2)
      data ratio/1.0e-6/, nrep/100/
      integer istat

*   check the inherited error status.
      if ( istat.ne.0 ) return

c preliminary processing
      ndp0 = ndp
      ndpm1 = ndp0 - 1
      if ( ndp0.lt.4 ) then

c error exit
         istat = 5
         nt = 0
         return
      else

c determines the closest pair of data points and their midpoint.
         dsqmn = GJP_DSQF(xd(1),yd(1),xd(2),yd(2))
         ipmn1 = 1
         ipmn2 = 2
         do 50 ip1 = 1, ndpm1
            x1 = xd(ip1)
            y1 = yd(ip1)
            ip1p1 = ip1 + 1
            do 20 ip2 = ip1p1, ndp0
               dsqi = GJP_DSQF(x1,y1,xd(ip2),yd(ip2))
               if ( dsqi.eq.0.0 ) go to 800
               if ( dsqi.lt.dsqmn ) then
                  dsqmn = dsqi
                  ipmn1 = ip1
                  ipmn2 = ip2
               end if
 20         continue
 50      continue
         dsq12 = dsqmn
         xdmp = (xd(ipmn1)+xd(ipmn2))/2.0
         ydmp = (yd(ipmn1)+yd(ipmn2))/2.0

c sorts the other (ndp-2) data points in ascending order of
c distance from the midpoint and stores the sorted data point
c numbers in the iwp array.
         jp1 = 2
         do 100 ip1 = 1, ndp0
            if ( ip1.ne.ipmn1 .and. ip1.ne.ipmn2 ) then
               jp1 = jp1 + 1
               iwp(jp1) = ip1
               wk(jp1) = GJP_DSQF(xdmp,ydmp,xd(ip1),yd(ip1))
            end if
 100     continue
         do 150 jp1 = 3, ndpm1
            dsqmn = wk(jp1)
            jpmn = jp1
            do 120 jp2 = jp1, ndp0
               if ( wk(jp2).lt.dsqmn ) then
                  dsqmn = wk(jp2)
                  jpmn = jp2
               end if
 120        continue
            its = iwp(jp1)
            iwp(jp1) = iwp(jpmn)
            iwp(jpmn) = its
            wk(jpmn) = wk(jp1)
 150     continue

c if necessary, modifies the ordering in such a way that the
c first three data points are not collinear.
         ar = dsq12*ratio
         x1 = xd(ipmn1)
         y1 = yd(ipmn1)
         dx21 = xd(ipmn2) - x1
         dy21 = yd(ipmn2) - y1
         do 200 jp = 3, ndp0
            ip = iwp(jp)
            if ( abs((yd(ip)-y1)*dx21-(xd(ip)-x1)*dy21).gt.ar )
     :           go to 300
 200     continue

         istat = 6
         nt = 0
         go to 99999
      end if
 300  continue
      if ( jp.ne.3 ) then
         jpmx = jp
         jp = jpmx + 1
         do 350 jpc = 4, jpmx
            jp = jp - 1
            iwp(jp) = iwp(jp-1)
 350     continue
         iwp(3) = ip
      end if

c forms the first triangle.  stores point numbers of the ver-
c texes of the triangle in the ipt array, and stores point num-
c bers of the border line segments and the triangle number in
c the ipl array.
      ip1 = ipmn1
      ip2 = ipmn2
      ip3 = iwp(3)
      if (GJP_SIDE2(xd(ip1),yd(ip1),xd(ip2),yd(ip2),xd(ip3),yd(ip3))
     :     .lt.0.0 ) then
         ip1 = ipmn2
         ip2 = ipmn1
      end if
      nt0 = 1
      ntt3 = 3
      ipt(1) = ip1
      ipt(2) = ip2
      ipt(3) = ip3
      nl0 = 3
      nlt3 = 9
      ipl(1) = ip1
      ipl(2) = ip2
      ipl(3) = 1
      ipl(4) = ip2
      ipl(5) = ip3
      ipl(6) = 1
      ipl(7) = ip3
      ipl(8) = ip1
      ipl(9) = 1

c adds the remaining (ndp-3) data points, one by one.
      do 600 jp1 = 4, ndp0
         ip1 = iwp(jp1)
         x1 = xd(ip1)
         y1 = yd(ip1)

c - determines the visible border line segments.
         ip2 = ipl(1)
         jpmn = 1
         dxmn = xd(ip2) - x1
         dymn = yd(ip2) - y1
         dsqmn = dxmn**2 + dymn**2
         armn = dsqmn*ratio
         jpmx = 1
         dxmx = dxmn
         dymx = dymn
         dsqmx = dsqmn
         armx = armn
         do 400 jp2 = 2, nl0
            ip2 = ipl(3*jp2-2)
            dx = xd(ip2) - x1
            dy = yd(ip2) - y1
            ar = dy*dxmn - dx*dymn
            if ( ar.le.armn ) then
               dsqi = dx**2 + dy**2
               if ( ar.lt.(-armn) .or. dsqi.lt.dsqmn ) then
                  jpmn = jp2
                  dxmn = dx
                  dymn = dy
                  dsqmn = dsqi
                  armn = dsqmn*ratio
               end if
            end if
            ar = dy*dxmx - dx*dymx
            if ( ar.ge.(-armx) ) then
               dsqi = dx**2 + dy**2
               if ( ar.gt.armx .or. dsqi.lt.dsqmx ) then
                  jpmx = jp2
                  dxmx = dx
                  dymx = dy
                  dsqmx = dsqi
                  armx = dsqmx*ratio
               end if
            end if
 400     continue
         if ( jpmx.lt.jpmn ) jpmx = jpmx + nl0
         nsh = jpmn - 1
         if ( nsh.gt.0 ) then

c - shifts (rotates) the ipl array to have the invisible border
c - line segments contained in the first part of the ipl array.
            nsht3 = nsh*3
            do 420 jp2t3 = 3, nsht3, 3
               jp3t3 = jp2t3 + nlt3
               ipl(jp3t3-2) = ipl(jp2t3-2)
               ipl(jp3t3-1) = ipl(jp2t3-1)
               ipl(jp3t3) = ipl(jp2t3)
 420        continue
            do 440 jp2t3 = 3, nlt3, 3
               jp3t3 = jp2t3 + nsht3
               ipl(jp2t3-2) = ipl(jp3t3-2)
               ipl(jp2t3-1) = ipl(jp3t3-1)
               ipl(jp2t3) = ipl(jp3t3)
 440        continue
            jpmx = jpmx - nsh
         end if

c - adds triangles to the ipt array, updates border line
c - segments in the ipl array, and sets flags for the border
c - line segments to be reexamined in the iwl array.
         jwl = 0
         do 450 jp2 = jpmx, nl0
            jp2t3 = jp2*3
            ipl1 = ipl(jp2t3-2)
            ipl2 = ipl(jp2t3-1)
            it = ipl(jp2t3)

c - - adds a triangle to the ipt array.
            nt0 = nt0 + 1
            ntt3 = ntt3 + 3
            ipt(ntt3-2) = ipl2
            ipt(ntt3-1) = ipl1
            ipt(ntt3) = ip1

c - - updates border line segments in the ipl array.
            if ( jp2.eq.jpmx ) then
               ipl(jp2t3-1) = ip1
               ipl(jp2t3) = nt0
            end if
            if ( jp2.eq.nl0 ) then
               nln = jpmx + 1
               nlnt3 = nln*3
               ipl(nlnt3-2) = ip1
               ipl(nlnt3-1) = ipl(1)
               ipl(nlnt3) = nt0
            end if

c - - determines the vertex that does not lie on the border
c - - line segments.
            itt3 = it*3
            ipti = ipt(itt3-2)
            if ( ipti.eq.ipl1 .or. ipti.eq.ipl2 ) then
               ipti = ipt(itt3-1)
               if ( ipti.eq.ipl1 .or. ipti.eq.ipl2 ) ipti = ipt(itt3)
            end if

c - - checks if the exchange is necessary.
            if (GJP_IDXCHG(xd,yd,ip1,ipti,ipl1,ipl2,istat)
     :          .ne.0) then

c - - modifies the ipt array when necessary.
               ipt(itt3-2) = ipti
               ipt(itt3-1) = ipl1
               ipt(itt3) = ip1
               ipt(ntt3-1) = ipti
               if ( jp2.eq.jpmx ) ipl(jp2t3) = it
               if ( jp2.eq.nl0 .and. ipl(3).eq.it ) ipl(3) = nt0

c - - sets flags in the iwl array.
               jwl = jwl + 4
               iwl(jwl-3) = ipl1
               iwl(jwl-2) = ipti
               iwl(jwl-1) = ipti
               iwl(jwl) = ipl2
            end if
 450     continue
         nl0 = nln
         nlt3 = nlnt3
         nlf = jwl/2
         if ( nlf.ne.0 ) then

c - improves triangulation.
            ntt3p3 = ntt3 + 3
            do 500 irep = 1, nrep
               do 470 ilf = 1, nlf
                  ilft2 = ilf*2
                  ipl1 = iwl(ilft2-1)
                  ipl2 = iwl(ilft2)

c - - locates in the ipt array two triangles on both sides of
c - - the flagged line segment.
                  ntf = 0
                  do 455 itt3r = 3, ntt3, 3
                     itt3 = ntt3p3 - itt3r
                     ipt1 = ipt(itt3-2)
                     ipt2 = ipt(itt3-1)
                     ipt3 = ipt(itt3)
                     if ( ipl1.eq.ipt1 .or. ipl1.eq.ipt2 .or.
     :                    ipl1.eq.ipt3 ) then
                        if ( ipl2.eq.ipt1 .or. ipl2.eq.ipt2 .or.
     :                       ipl2.eq.ipt3 ) then
                           ntf = ntf + 1
                           itf(ntf) = itt3/3
                           if ( ntf.eq.2 ) go to 460
                        end if
                     end if
 455              continue
                  if ( ntf.lt.2 ) go to 470

c - - determines the vertices of the triangles that do not lie
c - - on the line segment.
 460              continue
                  it1t3 = itf(1)*3
                  ipti1 = ipt(it1t3-2)
                  if ( ipti1.eq.ipl1 .or. ipti1.eq.ipl2 ) then
                     ipti1 = ipt(it1t3-1)
                     if ( ipti1.eq.ipl1 .or. ipti1.eq.ipl2 )
     :                    ipti1 = ipt(it1t3)
                  end if
                  it2t3 = itf(2)*3
                  ipti2 = ipt(it2t3-2)
                  if ( ipti2.eq.ipl1 .or. ipti2.eq.ipl2 ) then
                     ipti2 = ipt(it2t3-1)
                     if ( ipti2.eq.ipl1 .or. ipti2.eq.ipl2 )
     :                    ipti2 = ipt(it2t3)
                  end if

c - - checks if the exchange is necessary.
                  if (GJP_IDXCHG(xd,yd,ipti1,ipti2,ipl1,ipl2,istat)
     :                .ne.0) then

c - - modifies the ipt array when necessary.
                     ipt(it1t3-2) = ipti1
                     ipt(it1t3-1) = ipti2
                     ipt(it1t3) = ipl1
                     ipt(it2t3-2) = ipti2
                     ipt(it2t3-1) = ipti1
                     ipt(it2t3) = ipl2

c - - sets new flags.
                     jwl = jwl + 8
                     iwl(jwl-7) = ipl1
                     iwl(jwl-6) = ipti1
                     iwl(jwl-5) = ipti1
                     iwl(jwl-4) = ipl2
                     iwl(jwl-3) = ipl2
                     iwl(jwl-2) = ipti2
                     iwl(jwl-1) = ipti2
                     iwl(jwl) = ipl1
                     do 462 jlt3 = 3, nlt3, 3
                        iplj1 = ipl(jlt3-2)
                        iplj2 = ipl(jlt3-1)
                        if ( (iplj1.eq.ipl1.and.iplj2.eq.ipti2) .or.
     :                       (iplj2.eq.ipl1.and.iplj1.eq.ipti2) )
     :                       ipl(jlt3) = itf(1)
                        if ( (iplj1.eq.ipl2.and.iplj2.eq.ipti1) .or.
     :                       (iplj2.eq.ipl2.and.iplj1.eq.ipti1) )
     :                       ipl(jlt3) = itf(2)
 462                 continue
                  end if
 470           continue
               nlfc = nlf
               nlf = jwl/2
               if ( nlf.eq.nlfc ) go to 600

c - - resets the iwl array for the next round.
               jwl = 0
               jwl1mn = (nlfc+1)*2
               nlft2 = nlf*2
               do 480 jwl1 = jwl1mn, nlft2, 2
                  jwl = jwl + 2
                  iwl(jwl-1) = iwl(jwl1-1)
                  iwl(jwl) = iwl(jwl1)
 480           continue
               nlf = jwl/2
 500        continue
         end if
 600  continue

c rearranges the ipt array so that the vertices of each triangle
c are listed counter-clockwise.
      do 700 itt3 = 3, ntt3, 3
         ip1 = ipt(itt3-2)
         ip2 = ipt(itt3-1)
         ip3 = ipt(itt3)
         if (GJP_SIDE2(xd(ip1),yd(ip1),xd(ip2),yd(ip2),xd(ip3),yd(ip3))
     :        .lt.0.0 ) then
            ipt(itt3-2) = ip2
            ipt(itt3-1) = ip1
         end if
 700  continue
      nt = nt0
      nl = nl0
      return

 800  continue
      istat = 7
      nt = 0
      return


99999 continue
      end


      FUNCTION GJP_IDXCHG(x,y,i1,i2,i3,i4,istat)

c this function determines whether or not the exchange of two
c triangles is necessary on the basis of max-min-angle criterion
c by c. l. lawson.

c the input parameters are
c     x,y = arrays containing the coordinates of the data
c           points,
c     i1,i2,i3,i4 = point numbers of four points p1, p2,
c           p3, and p4 that form a quadrilateral with p3
c           and p4 connected diagonally.
c this function returns an integer value 1 (one) when an ex-
c change is necessary, and 0 (zero) otherwise.

c declaration statements
      dimension x(100), y(100)
      equivalence (c2sq, c1sq), (a3sq, b2sq), (b3sq, a1sq), (a4sq, b1sq)
     :             , (b4sq, a2sq), (c4sq, c3sq)

      integer istat

c preliminary processing
      x1 = x(i1)
      y1 = y(i1)
      x2 = x(i2)
      y2 = y(i2)
      x3 = x(i3)
      y3 = y(i3)
      x4 = x(i4)
      y4 = y(i4)

c calculation
      idx = 0
      u3 = (y2-y3)*(x1-x3) - (x2-x3)*(y1-y3)
      u4 = (y1-y4)*(x2-x4) - (x1-x4)*(y2-y4)
      if ( u3*u4.gt.0.0 ) then
         u1 = (y3-y1)*(x4-x1) - (x3-x1)*(y4-y1)
         u2 = (y4-y2)*(x3-x2) - (x4-x2)*(y3-y2)
         a1sq = (x1-x3)**2 + (y1-y3)**2
         b1sq = (x4-x1)**2 + (y4-y1)**2
         c1sq = (x3-x4)**2 + (y3-y4)**2
         a2sq = (x2-x4)**2 + (y2-y4)**2
         b2sq = (x3-x2)**2 + (y3-y2)**2
         c3sq = (x2-x1)**2 + (y2-y1)**2

         s1sq = u1*u1/(c1sq*amax1(a1sq,b1sq))
         s2sq = u2*u2/(c2sq*amax1(a2sq,b2sq))
         s3sq = u3*u3/(c3sq*amax1(a3sq,b3sq))
         s4sq = u4*u4/(c4sq*amax1(a4sq,b4sq))

         if ( amin1(s1sq,s2sq).lt.amin1(s3sq,s4sq) ) idx = 1
      end if

      GJP_IDXCHG = idx
      return
      end



c functions


      real FUNCTION GJP_DSQF(u1,v1,u2,v2)

      real u1, v1, u2, v2

      GJP_DSQF = (u2-u1)**2 + (v2-v1)**2

      end


      real FUNCTION GJP_SPDT(u1, v1, u2, v2, u3, v3)

      real u1, v1, u2, v2, u3, v3

      GJP_SPDT = (u1-u2)*(u3-u2) + (v1-v2)*(v3-v2)

      end


      real FUNCTION GJP_SIDE(u1, v1, u2, v2, u3, v3)

      real u1, v1, u2, v2, u3, v3

      GJP_SIDE = (u1-u3)*(v2-v3) - (v1-v3)*(u2-u3)

      end


      real FUNCTION GJP_SIDE2(u1, v1, u2, v2, u3, v3)

      real u1, v1, u2, v2, u3, v3

      GJP_SIDE2 = (v3-v1)*(u2-u1) - (u3-u1)*(v2-v1)

      end
