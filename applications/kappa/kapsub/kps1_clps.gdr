      SUBROUTINE KPS1_CLPS<T>( AXIS, LO, HI, VAR, METH, WLIM, NEL2, 
     :                       NDIM1, LBND1, UBND1, DIN, VIN, CIN, NDIM2,
     :                       LBND2, UBND2, USEWRK, NFLAG, DOUT, VOUT, 
     :                       WOUT, WORK1, WORK2, WORK3, STATUS )
*+
*  Name:
*     KPS1_CLPS<T>

*  Purpose:
*     Collapse one axis of an N-dimensional array using one of a
*     selection of statistics.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL KPS1_CLPS<T>( AXIS, LO, HI, VAR, METH, WLIM, NEL2, NDIM1, 
*                      LBND1, UBND1, DIN, VIN, CIN, NDIM2, LBND2,
*                      UBND2, USEWRK, NFLAG, DOUT, VOUT, WOUT, WORK1, 
*                      WORK2, WORK3, STATUS )

*  Description:
*     This routine collapses the supplied data and variance arrays
*     along the specified axis.  See the COLLAPSE documentation.

*  Arguments:
*     AXIS = INTEGER (Given)
*        The index of the axis to be collapsed.
*     LO = INTEGER (Given)
*        The low pixel index bound of the range of axis AXIS to be
*        collapsed.
*     HI = INTEGER (Given)
*        The high pixel index bound of the range of axis AXIS to be
*        collapsed.
*     VAR = LOGICAL (Given)
*        Process variances?
*     METH = CHARACTER * ( * ) (Given)
*        Estimator: 'MEAN', 'WMEAN', 'MODE', 'MEDIAN', 'SUM', 'SIGMA', 
*        'INTEG', 'IWC', 'IWD', 'RMS', 'ABSDEV', 'MAX', 'MIN', 'COMAX',
*        or 'COMIN'.  See the COLLAPSE documentation for details.
*     WLIM = REAL (Given)
*        Fraction of pixels which must be good to create a good output
*        pixel.
*     NEL2 = INTEGER (Given)
*        Total number of elements in the output array (i.e. the product
*        of the output dimension sizes).
*     NDIM1 = INTEGER (Given)
*        The number of axes in the input array.
*     LBND1( NDIM1 ) = INTEGER (Given)
*        The lower pixel index bounds of the input array.
*     UBND1( NDIM1 ) = INTEGER (Given)
*        The upper pixel index bounds of the input array.
*     DIN( * ) = <TYPE> (Given)
*        The input data values.
*     VIN( * ) = <TYPE> (Given)
*        The input variance values.  It is only accessed if VAR is
*        .TRUE.
*     CIN( * ) = <TYPE> (Given)
*        The co-ordinates along the collapse axis, starting at index LO,
*        for each pixel.  It is only accessed if METH is one of 'INTEG',
*        'IWC', 'IWD', 'COMAX', or 'COMIN'.
*     NDIM2 = INTEGER (Given)
*        The number of axes in the output array.
*     LBND2( NDIM2 ) = INTEGER (Given)
*        The lower pixel index bounds of the output array.
*     UBND2( NDIM2 ) = INTEGER (Given)
*        The upper pixel index bounds of the output array.
*     USEWRK = LOGICAL (Given)
*        Whether or not to use the work arrays.  This should be set
*        .TRUE. if there are significant (i.e. >1) higher dimensions
*        than the collapse axis.
*     NFLAG = INTEGER (Given & Returned)
*        Number of output pixels set to bad because insufficient pixels
*        were present to form the statistic for the collapsed axis.
*        The count excludes those lines where there are no good values.
*        NFLAG  should be initialised to zero before any subdivision of
*        the collapse by chunking.
*     DOUT( * ) = <TYPE> (Returned)
*        The output data values.
*     VOUT( * ) = <TYPE> (Returned)
*        The output variance values.  It is only accessed if VAR is
*        .TRUE.
*     WOUT( * ) = <TYPE> (Returned)
*        The pixel widths along the collapse axis, starting at index LO.
*        It is only accessed if METH is 'INTEG'
*     WORK1( NEL2, * ) = <TYPE> (Returned)
*        Work array.  The second axis should have at least (HI-LO+1) 
*        elements. It is nly accessed if AXIS is not equal to NDIM1.
*     WORK2( NEL2, * ) = <TYPE> (Returned)
*        Work array.  The second axis should have at least (HI-LO+1)
*        elements.  It is only accessed if VAR is .TRUE., and AXIS is
*        not equal to NDIM1.
*     WORK3( NEL2, * ) = <TYPE> (Returned)
*        Work array.  The second axis should have at least (HI-LO+1)
*        elements.  It is only accessed if METH is one of 'INTEG',
*        'IWC', 'IWD', 'COMAX', 'COMIN'; and AXIS is not equal to NDIM1.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Copyright:
*     Copyright (C) 2000-2001, 2003-2004 Central Laboratory of the
*     Research Councils. Copyright (C) 2005-2006 Particle Physics &
*     Astronomy Research Council. All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 2 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful, but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
*     02111-1307, USA.

*  Authors:
*     DSB: David Berry (STARLINK)
*     TIMJ: Tim Jenness (JAC, Hawaii)
*     MJC: Malcolm J. Currie (STARLINK)
*     {enter_new_authors_here}

*  History:
*     31-AUG-2000 (DSB):
*        Original version.
*     27-OCT-2000 (DSB):
*        Modified to avoid re-ordering the data if it is already in the
*        correct order (i.e. if the collapse axis is the last pixel
*        axis).
*     26-SEP-2001 (DSB):
*        Do not allocate memory for a covariance array (IPCOV) if
*        method=mean.
*     14-DEC-2001 (DSB):
*        Renamed weighted mean method as WMEAN, and add unweighted 
*        method MEAN.
*     27-AUG-2003 (DSB):
*        To avoid impractical memory requirements, estimate the output
*        median variances rather than calculating them properly for
*        sample sizes larger than 300.
*     2004 September 3 (TIMJ):
*        Use CNF_PVAL.
*     2005 December 22 (MJC):
*        Add MAX and MIN methods.
*     2005 December 24 (MJC):
*        Add ABSDEV method.
*     2005 December 27 (MJC):
*        Add SIGMA method.
*     2005 December 28 (MJC):
*        Add RMS method.
*     2005 December 29 (MJC):
*        Add SUM method.  Corrected prologue.
*     2005 December 30 (MJC):
*        Add INTEG, COMAX, COMIN, IWC, IWD methods.  Obtain workspace
*        for COMAX and COMIN.
*     2005 January 2 (MJC):
*        Added CIN argument, passed through to main subroutines.
*     2005 January 6 (MJC):
*        Added WIN argument, passed through to main subroutines.
*     2005 January 27 (MJC):
*        Added WORK3 argument, and use to permute width or co-ordinate
*        array.
*     2006 February 10 (MJC):
*        Obtain the pixel-index workspace for methods 31 and 32.
*     2006 February 13 (MJC):
*        Better initialisation of START to avoid valgrind warning.
*     2006 April 11 (MJC):
*        Make USEWRK an argument for efficiency when higher dimensions
*        are degenerate.
*     22-DEC-2006 (DSB):
*        Avoid allocating a covariance array if it is not needed.
*     2006 December 22 (MJC):
*        Revise the test for the methods that use covariance, following
*        the addition of the many new methods.
*     2007 September 26 (MJC):
*        Do not create covariance workspace for the median in large
*        arrays.
*     2007 November 17 (MJC):
*        Recognise that the width array is calculated within, not 
*        supplied, hence rename WIN to WOUT and relocate in the API.
*        Bug fix: reorder the co-ordinate array for INTEG.
*     2007 December 10 (MJC);
*        Add NFLAG argument.
*     2008 October 5 (MJC);
*        Allowed for non-trimmed data.
*     {enter_further_changes_here}

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'NDF_PAR'          ! NDF constants
      INCLUDE 'PRM_PAR'          ! VAL constants
      INCLUDE 'CNF_PAR'          ! For CNF_PVAL function

*  Arguments Given:
      INTEGER AXIS
      INTEGER LO
      INTEGER HI
      LOGICAL VAR
      CHARACTER METH*(*)
      REAL WLIM
      INTEGER NEL2
      INTEGER NDIM1
      INTEGER LBND1( NDIM1 )
      INTEGER UBND1( NDIM1 )
      <TYPE> DIN( * )
      <TYPE> VIN( * )
      <TYPE> CIN( * )
      INTEGER NDIM2
      INTEGER LBND2( NDIM2 )
      INTEGER UBND2( NDIM2 )
      LOGICAL USEWRK

*  Arguments Given and Returned:
      INTEGER NFLAG

*  Arguments Returned:
      <TYPE> DOUT( * )
      <TYPE> VOUT( * )
      <TYPE> WOUT( * )
      <TYPE> WORK1( NEL2, * )
      <TYPE> WORK2( NEL2, * )
      <TYPE> WORK3( NEL2, * )

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      LOGICAL CARRY              ! Increment next axis?
      INTEGER DIM1( NDF__MXDIM ) ! Input dimension sizes
      INTEGER DIM2( NDF__MXDIM ) ! Output dimension sizes
      LOGICAL HASCNT             ! Method counts contribting pixels
      INTEGER IAX1               ! Input axis index
      INTEGER IAX2               ! Output axis index
      INTEGER IEL1               ! Index into input data vectors
      INTEGER IEL2               ! Index into output data vectors
      INTEGER IMETH              ! Combination method
      INTEGER IPCOIN             ! Pointer to workspace, co-ord indices
      INTEGER IPCOV              ! Pointer to workspace
      INTEGER IPNCON             ! Pointer to workspace
      INTEGER IPPNT              ! Pointer to workspace
      INTEGER IPPP               ! Pointer to workspace
      INTEGER IPUSED             ! Pointer to workspace
      INTEGER IPVAR              ! Pointer to dummy line variances
      INTEGER IPWRK1             ! Pointer to workspace
      INTEGER IPWRK2             ! Pointer to workspace
      INTEGER J                  ! Pixel index on collapsed axis
      INTEGER K                  ! Work array index
      INTEGER NLIN               ! No. of i/p pixels in each o/p pixel
      INTEGER NMAT               ! Size of workspace 
      INTEGER POS1( NDF__MXDIM ) ! Input pixel indices 
      INTEGER POS2( NDF__MXDIM ) ! Output pixel indices 
      INTEGER START              ! The first input element to use
      INTEGER STEP1              ! Vector step between collapsed pixels
      LOGICAL TRIM               ! Number of axes is trimmed?
      LOGICAL USECO              ! Method uses the co-ordinate array?
      LOGICAL USECV              ! Method uses a covariance array?
      LOGICAL USEIND             ! Method uses the pixel-index array?
      LOGICAL USEWID             ! Method uses the width array?

*.

*  Check the inherited global status.
      IF( STATUS .NE. SAI__OK ) RETURN

*  Check the supplied METH value.
      IF( METH .EQ. 'MEAN' ) THEN
         IMETH = 1

      ELSE IF( METH .EQ. 'WMEAN' ) THEN
         IMETH = 2

      ELSE IF( METH .EQ. 'MEDIAN' ) THEN
         IMETH = 3

      ELSE IF( METH .EQ. 'MODE' ) THEN
         IMETH = 5

      ELSE IF( METH .EQ. 'SUM' ) THEN
         IMETH = 12

      ELSE IF( METH .EQ. 'SIGMA' ) THEN
         IMETH = 13

      ELSE IF( METH .EQ. 'INTEG' ) THEN
         IMETH = 21

      ELSE IF( METH .EQ. 'IWC' ) THEN
         IMETH = 22

      ELSE IF( METH .EQ. 'IWD' ) THEN
         IMETH = 23

      ELSE IF( METH .EQ. 'RMS' ) THEN
         IMETH = 24

      ELSE IF( METH .EQ. 'ABSDEV' ) THEN
         IMETH = 25

      ELSE IF( METH .EQ. 'MAX' ) THEN
         IMETH = 31

      ELSE IF( METH .EQ. 'MIN' ) THEN
         IMETH = 32

      ELSE IF( METH .EQ. 'COMAX' ) THEN
         IMETH = 33

      ELSE IF( METH .EQ. 'COMIN' ) THEN
         IMETH = 34

      ELSE IF( STATUS .EQ. SAI__OK ) THEN
         STATUS = SAI__ERROR
         CALL MSG_SETC( 'M', METH )
         CALL ERR_REP( 'KPS1_CLPS<T>_ERR1', 'KPS1_CLPS<T>: '//
     :                 'Unsupported combination method ''^M'' '//
     :                 'requested (programming error).', STATUS )    
         GO TO 999
      END IF

*  Decide whether indices, co-ordinates, covariances, and widths array 
*  is used.
      USEIND = IMETH .GE. 31 .AND. IMETH .LE. 34
      USECO = IMETH .EQ. 22 .OR. IMETH .EQ. 23 .OR. IMETH .EQ. 33 .OR.
     :        IMETH .EQ. 34
      USECV = IMETH .GE. 3 .AND. IMETH .LE. 11
      USEWID = IMETH .EQ. 21

*  Decide whether the WLIM pertains to the method.
      HASCNT = IMETH .LT. 30

*  Find the size of each dimension in the output array. Also initialize 
*  the pixel indices of the current output pixel to be the first pixel.
      DO IAX2 = 1, NDIM2
         DIM2( IAX2 ) = UBND2( IAX2 ) - LBND2( IAX2 ) + 1
         POS2( IAX2 ) = LBND2( IAX2 )
      END DO

*  Find the dimensions of the input array.
      DO IAX1 = 1, NDIM1
         DIM1( IAX1 ) = UBND1( IAX1 ) - LBND1( IAX1 ) + 1
      END DO

*  Note the step between adjacent pixels along the collapse axis.
      STEP1 = 1
      DO IAX1 = 1, AXIS - 1
         STEP1 = STEP1 * DIM1( IAX1 )
      END DO

*  If we are collapsing along the last axis, we do not need to
*  re-arrange the input data and variance values since the CCDPACK
*  combination routines used at the end of this routine can access them
*  in "natural" order.
      START = 1
      IF( .NOT. USEWRK ) THEN

*  Note the index of the first element of the first plane to be included
*  in the output array.
         START = ( LO - LBND1( AXIS ) ) * STEP1 + 1

*  If we are not collapsing along the last axis, we need to re-arrange
*  the input data and variance values. 
      ELSE 

*  Has there been a reduction in the number of axes.
         TRIM = NDIM1 .GT. NDIM2

*  Step through every pixel in the output arrays.
         DO IEL2 = 1, NEL2      

*  Find the pixel indices of the first input pixel to contribute to
*  the current output pixel.
            DO IAX1 = 1, NDIM1
               IF( IAX1 .LT. AXIS ) THEN 
                  POS1( IAX1 ) = POS2( IAX1 )
               ELSE IF( IAX1 .EQ. AXIS ) THEN
                  POS1( IAX1 ) = LO
               ELSE IF ( TRIM ) THEN
                  POS1( IAX1 ) = POS2( IAX1 - 1 )
               ELSE
                  POS1( IAX1 ) = POS2( IAX1 )
               END IF
            END DO

*  Find the corresponding vector index into the input arrays at this
*  position.
            IEL1 = 0
            DO IAX1 = NDIM1 - 1, 1, -1
               IEL1 = ( POS1( IAX1 + 1 ) - LBND1( IAX1 + 1 ) + IEL1 ) *
     :                DIM1( IAX1 )
            END DO
            IEL1 = IEL1 + POS1( 1 ) - LBND1( 1 ) + 1

*  Loop through the pixels to be collapsed in this "column".
            K = 0
            DO J = LO, HI
               K = K + 1

*  Store this pixel value in a work array.  Likewise for variance and
*  co-ordinates or widths.
               WORK1( IEL2, K ) = DIN( IEL1 )
               IF ( VAR ) WORK2( IEL2, K ) = VIN( IEL1 )
               IF ( USECO .OR. USEWID ) WORK3( IEL2, K ) = CIN( IEL1 )

*  Move on to the next input pixel.
               IEL1 = IEL1 + STEP1

            END DO

*  Update the pixel indices of the current output pixel.
            CARRY = .TRUE.
            IAX2 = 1
            DO WHILE( CARRY )
               POS2( IAX2 ) = POS2( IAX2 ) + 1
               IF( POS2( IAX2 ) .LE. UBND2( IAX2 ) ) THEN
                  CARRY = .FALSE.
               ELSE
                  POS2( IAX2 ) = LBND2( IAX2 )
                  IAX2 = IAX2 + 1
                  IF( IAX2 .GT. NDIM2 ) CARRY = .FALSE.
               END IF
            END DO            

         END DO

      END IF

*  Now we have the input data in the order needed by the CCDPACK
*  combination routines. Combine the values together into the output 
*  data and variances. The CCDPACK combination routines used below 
*  expect the data to be supplied as a series of lines in a 2D array. 
*  Each line comprises one "image" and each column gives the pixels to 
*  be combined. The result is a single line of data. Allocate the
*  required work arrays...
      NLIN = HI - LO + 1
      NMAT = NLIN * ( NLIN + 1 ) / 2

      CALL PSX_CALLOC( NLIN, '<HTYPE>', IPWRK1, STATUS )
      CALL PSX_CALLOC( NLIN, '<HTYPE>', IPWRK2, STATUS )
      CALL PSX_CALLOC( NLIN, '_DOUBLE', IPNCON, STATUS )
      CALL PSX_CALLOC( NLIN, '_INTEGER', IPPNT, STATUS )
      CALL PSX_CALLOC( NLIN, '_LOGICAL', IPUSED, STATUS )

*  Get workspace if co-ordinates are to be derived, otherwise
*  use a valid pointer.
      IF ( USEIND ) THEN
         CALL PSX_CALLOC( NEL2, '_INTEGER', IPCOIN, STATUS )
      ELSE
         IPCOIN = IPPNT
      END IF

*  There's no need to allocate allocate memory for the pixel indices
*  of the maximum or minimum values, or the intensity-weight 
*  co-ordinate or dispersion, as we can use the IPPNT array.

*  First deal with cases where input variances are available.
*  Output variances are generated based on these input variances.
      IF ( VAR ) THEN

*  If we are using a median estimator, and we are producing output
*  variances, and the input image is big, we will estimate the variance
*  on the median rather than calculating it properly. This is because
*  the memory requirements for the covariance array becomes huge for 
*  large images.  "Median with estimated variances" is treated as a new
*  IMETH value, 300.
         IF ( IMETH .EQ. 3 .AND. NLIN .GT. 300 ) THEN
            IMETH = 300
            USECV = .FALSE.
         END IF

*  Allocate memory.
         CALL PSX_CALLOC( NLIN, '_DOUBLE', IPPP, STATUS )
         NMAT = NLIN * ( NLIN + 1 ) / 2 
         IF ( USECV ) THEN
            CALL PSX_CALLOC( NLIN * NMAT, '_DOUBLE', IPCOV, STATUS )
         ELSE
            IPCOV = IPPP
         END IF

*  If the axis along which the input array was collapsed was not the
*  last axis, we need to use the re-ordered data in the work arrays.
         IF ( USEWRK ) THEN
            CALL CCG1_CM1<T><T>( WORK1, NEL2, NLIN, WORK2, WORK3, IMETH,
     :                           MAX( 1, NINT( WLIM * REAL( NLIN ) ) ),
     :                           7, 4.0, 0.0, 0.0, 0.0, DOUT, VOUT, 
     :                           WOUT, %VAL( CNF_PVAL( IPCOIN ) ), 
     :                           %VAL( CNF_PVAL( IPWRK1 ) ), 
     :                           %VAL( CNF_PVAL( IPWRK2 ) ),
     :                           %VAL( CNF_PVAL( IPPP ) ), 
     :                           %VAL( CNF_PVAL( IPCOV ) ), NMAT,
     :                           %VAL( CNF_PVAL( IPNCON ) ), 
     :                           %VAL( CNF_PVAL( IPPNT ) ),
     :                           %VAL( CNF_PVAL( IPUSED ) ), 
     :                           NFLAG, STATUS )

*  If the collapse axis is the last axis, we can use the original input
         ELSE 
            CALL CCG1_CM1<T><T>( DIN( START ), NEL2, NLIN, VIN( START ),
     :                           CIN, IMETH, 
     :                           MAX( 1, NINT( WLIM * REAL( NLIN ) ) ),
     :                           7, 4.0, 0.0, 0.0, 0.0, DOUT, VOUT,
     :                           WOUT, %VAL( CNF_PVAL( IPCOIN ) ), 
     :                           %VAL( CNF_PVAL( IPWRK1 ) ), 
     :                           %VAL( CNF_PVAL( IPWRK2 ) ),
     :                           %VAL( CNF_PVAL( IPPP ) ), 
     :                           %VAL( CNF_PVAL( IPCOV ) ), NMAT,
     :                           %VAL( CNF_PVAL( IPNCON ) ), 
     :                           %VAL( CNF_PVAL( IPPNT ) ),
     :                           %VAL( CNF_PVAL( IPUSED ) ),
     :                           NFLAG, STATUS )
         END IF

         CALL PSX_FREE( IPPP, STATUS )
         IF ( USECV ) CALL PSX_FREE( IPCOV, STATUS )

*  Now deal with cases where input variances are not available.  No
*  output variances will be created.
      ELSE
         CALL PSX_CALLOC( NLIN, '_DOUBLE', IPVAR, STATUS )
         CALL KPG1_FILLD( 1.0D0, NLIN, %VAL( CNF_PVAL( IPVAR ) ), 
     :                    STATUS )

*  If the axis along which the input array was collapsed was not the
*  last axis, we need to use the re-ordered data in the work arrays.
         IF ( USEWRK ) THEN   
            CALL CCG1_CM3<T><T>( WORK1, NEL2, NLIN, 
     :                           %VAL( CNF_PVAL( IPVAR ) ), WORK3,
     :                           IMETH,
     :                           MAX( 1, NINT( WLIM * REAL( NLIN ) ) ),
     :                           7, 4.0, 0.0, 0.0, 0.0,
     :                           DOUT, WOUT, %VAL( CNF_PVAL( IPCOIN ) ), 
     :                           %VAL( CNF_PVAL( IPWRK1 ) ),
     :                           %VAL( CNF_PVAL( IPWRK2 ) ),
     :                           %VAL( CNF_PVAL( IPNCON ) ), 
     :                           %VAL( CNF_PVAL( IPPNT ) ),
     :                           %VAL( CNF_PVAL( IPUSED ) ),
     :                           NFLAG, STATUS )

*  If the collapse axis is the last axis, we can use the original input
*  data.
         ELSE 
            CALL CCG1_CM3<T><T>( DIN( START ), NEL2, NLIN, 
     :                           %VAL( CNF_PVAL( IPVAR ) ), CIN, IMETH, 
     :                           MAX( 1, NINT( WLIM * REAL( NLIN ) ) ),
     :                           7, 4.0, 0.0, 0.0, 0.0,
     :                           DOUT, WOUT, %VAL( CNF_PVAL( IPCOIN ) ),
     :                           %VAL( CNF_PVAL( IPWRK1 ) ),
     :                           %VAL( CNF_PVAL( IPWRK2 ) ),
     :                           %VAL( CNF_PVAL( IPNCON ) ), 
     :                           %VAL( CNF_PVAL( IPPNT ) ),
     :                           %VAL( CNF_PVAL( IPUSED ) ),
     :                           NFLAG, STATUS )
         END IF

         CALL PSX_FREE( IPVAR, STATUS )

      END IF

*  Free the remaining work space.
      CALL PSX_FREE( IPWRK1, STATUS )
      CALL PSX_FREE( IPWRK2, STATUS )
      CALL PSX_FREE( IPNCON, STATUS )
      CALL PSX_FREE( IPPNT, STATUS )
      CALL PSX_FREE( IPUSED, STATUS )

      IF ( USEIND ) THEN
         CALL PSX_FREE( IPCOIN, STATUS )
      END IF

 999  CONTINUE

      END
