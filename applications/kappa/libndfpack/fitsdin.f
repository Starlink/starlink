      SUBROUTINE FITSDIN( STATUS )
*+
*  Name:
*     FITSDIN

*  Purpose:
*     Reads a FITS disc file composed of simple, group or table objects.

*  Language:
*     Starlink Fortran 77

*  Type of Module:
*     ADAM A-task

*  Invocation:
*     CALL FITSDIN( STATUS )

*  Arguments:
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description:
*     This application reads selected disc-FITS files.  The files may
*     be Basic (simple) FITS, and/or have TABLE extensions (Harten et
*     al. 1988).
*
*     The programme reads a simple or a random-groups-format FITS file
*     (Wells et al. 1981; Greisen & Harten 1981), and writes the data
*     into an NDF, and the headers into the NDF's FITS extension.
*     Table-format files (Grosbol et al. 1988) are read, and the
*     application creates two files: a text formatted table/catalogue
*     and a FACTS description file (as used by SCAR) based upon the FITS
*     header cards.  Composite FITS files can be processed.  You may
*     specify a list of files, including wildcards.  A record of the
*     FITS headers, and group parameters (for a group-format file) can
*     be stored in a text file.
*
*     There is an option to run in automatic mode, where the names of
*     output NDF data structures are generated automatically, and you
*     can decide whether or not format conversion is to be applied to
*     all files (rather than being prompted for each).  This is very
*     useful if there is a large number of files to be processed.  Even
*     if you want unique file names, format-conversion prompting may be
*     switched off globally.

*  Usage:
*     fitsdin files out [auto] fmtcnv [logfile] dscftable=? table=?

*  ADAM Parameters:
*     AUTO = _LOGICAL (Read)
*        It is TRUE if automatic mode is required, where the name of
*        each output NDF structure or table file is to be generated by
*        the application, and therefore not prompted; and a global
*        format-conversion switch may be set.  In manual mode the FITS
*        header is reported, but not in automatic.
*
*        In automatic mode the application generates a filename
*        beginning with the input filename, less any extension.  For
*        example, if the input file was SATURN.FITS the filename of the
*        output NDF would be SATURN.SDF, and an output table would be
*        SATURN.DAT with a description file dscfSATURN.DAT.  If there
*        are sub-files (more than one FITS object in the file) a suffix
*        _<subfile> is appended.  So if SATURN.FITS comprised a simple
*        file followed by a table, the table would be called
*        SATURN_2.DAT and the description file DSCFSATURN_2.DAT.  For
*        group format a suffix G<groupnumber> is appended.  Thus if
*        SATURN.FITS is a group format file, the first NDF created
*        would be called SATURN.SDF, the second would be SATURNG2.SDF.
*        [FALSE]
*     DSCFTABLE = FILENAME (Read)
*        Name of the text file to contain the FACTS descriptors, which
*        defines the table's format for SCAR.  Since SCAR is now
*        deprecated, this parameter has little use, except perhaps to
*        give a summary of the format of the file specified by parameter
*        TABLE.  A null value (!) means that no description file will
*        be created, so this is now the recommended usage.  If your
*        FITS file comprises just tables, you should consider other
*        tools such as the CURSA package, which has facilities for
*        examining and processing ASCII and binary tables in FITS files.
*
*        A suggested filename for the description file is reported
*        immediately prior to prompting in manual mode.  It is the name
*        of the catalogue, as written in the FITS header, with a "dscf"
*        prefix.
*     ENCODINGS = LITERAL (Read)
*        Determines which FITS keywords should be used to define the
*        world co-ordinate systems to be stored in the NDF's WCS
*        component.  The allowed values (case-insensitive) are:
*
*        "FITS-IRAF" --- This uses keywords CRVALi CRPIXi, CDi_j, and is the
*           system commonly used by IRAF. It is described in the document
*           "World Coordinate Systems Representations Within the FITS Format"
*           by R.J. Hanisch and D.G. Wells, 1988, available by ftp from
*           fits.cv.nrao.edu /fits/documents/wcs/wcs88.ps.Z.
*
*        "FITS-WCS" --- This is the proposed FITS standard WCS encoding scheme
*           described in the paper "Representation of celestial coordinates
*           in FITS" (http://www.cv.nrao.edu/fits/documents/wcs/wcs.html).
*           It is very similar to FITS-IRAF but supports a wider range of
*           projections and co-ordinate systems. Once the standard has been
*           agreed, this encoding should be understood by any FITS-WCS
*           compliant software and it is likely to be adopted widely for FITS
*           data in future.
*
*        "FITS-PC" --- This uses keywords CRVALi, CDELTi, CRPIXi, PCiiijjj,
*           etc, as described in a previous (now superceded) draft of the
*           above FITS world co-ordinate system paper by E.W.Greisen and
*           M.Calabretta.
*
*        "FITS-AIPS" --- This uses conventions described in the document
*           "Non-linear Coordinate Systems in AIPS" by Eric W. Greisen
*           (revised 9th September, 1994), available by ftp from
*           fits.cv.nrao.edu /fits/documents/wcs/aips27.ps.Z. It is currently
*           employed by the AIPS data analysis facility, so its use will
*           facilitate data exchange with AIPS. This encoding uses CROTAi
*           and CDELTi keywords to describe axis rotation and scaling.
*
*        "DSS" --- This is the system used by the Digital Sky Survey, and
*           uses keywords AMDXn, AMDYn, PLTRAH, etc.
*
*        "NATIVE" --- This is the native system used by the AST library (see
*           SUN/210) and provides a loss-free method for transferring WCS
*           information between AST-based application. It allows more
*           complicated WCS information to be stored and retrieved than any of
*           the other encodings.
*
*        A comma-separated list of up to six values may be supplied,
*        in which case the value actually used is in the first in the
*        list for which corresponding keywords can be found in the FITS
*        header.
*
*        A FITS header may contain keywords from more than one of these
*        encodings, in which case it is possible for the encodings to
*        be inconsistent with each other.  This may happen for instance
*        if an application modifies the keyword associated with one
*        encoding but fails to make equivalent modifications to the
*        others.  If a null parameter value (!) is supplied for
*        ENCODINGS, then an attempt is made to determine the most
*        reliable encoding to use as follows.  If both native and
*        non-native encodings are available, then the first non-native
*        encoding to be found which is inconsistent with the native
*        encoding is used.  If all encodings are consistent, then the
*        native encoding is used (if present). [!]
*     FILES() = LITERAL (Read)
*        A list of (optionally wild-carded) file specifications which
*        identify the disc-FITS files to be processed.  Up to 10 values
*        may be given, but only a single specification such as "*.FITS"
*        is normally required.  Be careful not to include non-FITS files
*        in this list.
*     FMTCNV = _LOGICAL (Read)
*        This specifies whether or not format conversion will occur.
*        If FALSE, the HDS type of the data array in the NDF will be
*        the equivalent of the FITS data format in the file (e.g.
*        BITPIX = 16 creates a _WORD array).  If TRUE, the data array
*        in the current file, or all files in automatic mode, will be
*        converted from the FITS data type in the FITS file to _REAL in
*        the NDF.  The conversion applies the values of the FITS
*        keywords BSCALE and BZERO to the FITS data to generate the
*        "true" data values.  If BSCALE and BZERO are not given in the
*        FITS header, they are taken to be 1.0 and 0.0 respectively.
*        The suggested default is TRUE.
*     GLOCON  = _LOGICAL (Read)
*        If FALSE, a format-conversion query occurs for each FITS file.
*        If TRUE, the value of parameter FMTCNV is obtained before any
*        file numbers and will apply to all data arrays.  It is ignored
*        in automatic mode---in effect it becomes true. [FALSE]
*     LOGFILE = FILENAME (Read)
*        The file name of the text log of the FITS header cards.
*        For group-format data the group parameters are evaluated
*        and appended to the full header.  The log includes the names of
*        the output files used to store the data array or table. A null
*        value (!) means that no log file is produced. [!]
*     OUT = NDF (Write)
*        Output NDF structure holding the full contents of the FITS
*        file.  If the null value (!) is given no NDF will be created.
*        This offers an opportunity to review the descriptors before
*        deciding whether or not the data are to be extracted.
*     TABLE = FILENAME (Read)
*        Name of the text file to contain the table itself, read from
*        the file.  In manual mode, the suggested default filename is
*        the name of description file less the "DSCF" prefix, or if
*        there is no description file or if the description file does
*        not have the DSCF prefix, the suggested name reverts to the
*        catalogue name in the FITS header.

*  Examples:
*     fitsdin files=*.fit auto nofmtcnv
*        This reads all the files with extension "fit" in the default
*        directory.  If the files were sao.fit and moimp.fit and each
*        contained just an image array, the output NDFs will be sao and
*        moimp respectively.  The data will not have format conversion.
*     fitsdin files=ccd.ifits fmtcnv logfile=jkt.log
*        This reads the file ccd.ifits and processes all the FITS
*        objects within it.  Integer data arrays are converted to real
*        using the scale and zero found in the FITS header.  A record
*        of the headers and the names of the output files are written
*        to the text file jkt.log.
*     fitsdin files="*.*fits,*.mt" glocon fmtcnv
*        This reads the files *.*fits and *.mt and processes all the
*        FITS objects within them.  Integer data arrays are converted
*        to real using the scale and zero found in the FITS header.
*        Any IEEE-format data will not be converted although the global
*        conversion switch is on.

*  Algorithm:
*     -  Open a logfile if required.
*     -  Determine whether or not automatic operation is wanted. If it
*     is obtain the global format conversion, otherwise see whether or
*     not a global format-conversion is required, and obtain its
*     polarity if it required.
*     -  Get byte workspace to store the character buffers.
*     -  Get the list of files and check the number of valid
*     specifications is not zero.  Store the file names in a GRP group.
*     -  There is a loop which applies to rest of the algorithm which
*     continues if there are more files to process.  Read the list of
*     files to be processed.
*     -  Loop for each file name in the list read from the temporary
*     file.  Inquire whether the name has been truncated.  Inquire the
*     characteristics of the required FITS file.  Check its blocksize.
*     Report if it is illegal, but continue.  Open the FITS file.
*     -  Create workspace to store the FITS headers.  Process the header
*     sections storing them in the workspace.  Find the number of
*     headers, the length and start cards of each header section.  The
*     application will not work if there is more than one dummy header
*     in each sub-file.  Obtain the mandatory headers.  See if the
*     sub-file is an extension.  Report the headers to the log file and
*     to the user in manual mode.
*     -  If the sub-file is an extension check that it is supported
*     currently TABLE alone.  If it is table, call a routine to create
*     a SCAR description file from the headers and a text table from
*     the FITS data.
*     -  If it is not an extension obtain the data type, format, scale,
*     zero and data blank.  If it is group-format find the number of
*     groups and parameters per group.  If group format extend the
*     workspace to accommodate the group parameters for each array.
*     -  For integer data decide whether or not format conversion is
*     required if not decided globally. Get the input and output
*     formats.  In automatic mode generate a file root name from the
*     name of the FITS file and file number.
*     -  Call a routine to create the output NDF, with a generated
*     name in automatic mode.  Read the file, filling the data array.
*     Apply a format conversion if needed and substitute blank values
*     with bad-pixel values.  Make a dummy NDF data array if there is
*     no FITS array.  Convert IEEE data to their Vax representations.
*     Create axis structures and WCS component if there is suitable data
*     in the FITS header.  Create the TITLE and UNITS components.
*     -  If there is an extension immediately following set the flag
*     to indicate that the record has been read and loop back to
*     process the sub-file, otherwise loop to the next file number.
*     When the file list has been exhausted, tidy up.

*  References:
*     Wells, D.C., Greisen, E.W. & Harten, R.H. 1981,
*        Astron. Astrophys. Suppl. Ser. 44, 363.
*     Greisen, E.W. & Harten, R.H. 1981,
*        Astron. Astrophys. Suppl. Ser. 44, 371.
*     Grosbol, P., Harten, R.H., Greisen, E.W & Wells, D.C.
*        1988 Astron. Astrophys. Suppl. Ser. 73, 359.
*     Harten, R.H., Grosbol, P., Greisen, E.W & Wells, D.C.
*        1988 Astron. Astrophys. Suppl. Ser. 73, 365.

*  Related Applications:
*     KAPPA: FITSHEAD, FITSIMP, FITSIMP, FITSLIST; CONVERT: FITS2NDF;
*     CURSA; Figaro: RDFITS.

*  Implementation Status:
*     -  The application processes files blocked at other than an
*     integer multiple of 2880 bytes up to a maximum of 28800, provided
*     it is a multiple of the number of bytes per data value.
*     -  For simple or group format FITS:
*        -  IEEE floating point is supported.
*        -  If BUNIT is present its value will appear as the NDF's
*        UNITS component.
*        -  If OBJECT is present its value will appear as the NDF's
*        TITLE component.
*        -  If the BLANK item is present in the header, undefined pixels
*        are converted from the BLANK value to Starlink-standard bad
*        value during data conversion.
*        -  An AXIS component will be stored in the NDF if the CRVALn
*        keyword is present.  (n is the number of the dimension.)  If
*        the CRPIXn keyword is absent it defaults to 1, and likewise
*        for the CDELTn keyword.  The value of CRTYPEn is made the label
*        of the axis structure.
*     -  For groups format, a new NDF is created for each data array.
*     The name of the NDF of the second and subsequent data arrays is
*     generated by the application as the <filename>G<number>, where
*     <filename> is the name of the first NDF, you supply or generated
*     automatically, and <number> is the number of the group.
*
*     Each group NDF contains the full header in the FITS extension,
*     appended by the set of group parameters.  The group parameters
*     are evaluated using their scales and offsets, and made to look
*     like FITS cards, whose keywords are derived from the values of
*     PTYPEm in the main header.  (m is the number of the group
*     parameter.) The same format is used in the log file.
*     -  If there is no data array in the FITS file, i.e. the FITS file
*     comprises header cards only, then a dummy vector data array of
*     dimension two is created to make the output a valid NDF.  This
*     data array is undefined.

*  Copyright:
*     Copyright (C) 1990-1993 Science & Engineering Research Council.
*     Copyright (C) 1995-1996, 1998-2000, 2004 Central Laboratory of
*     the Research Councils. All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 2 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful, but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 51 Franklin Street,Fifth Floor, Boston, MA
*     02110-1301, USA

*  Authors:
*     MJC: Malcolm J. Currie (STARLINK)
*     RDS: Richard D. Saxton (STARLINK, Leicester)
*     DSB: David S. Berry (STARLINK)
*     TIMJ: Tim Jenness (JAC, Hawaii)
*     {enter_new_authors_here}

*  History:
*     1990 December 4 (MJC):
*        Original version.
*     1991 February 28 (MJC):
*        Added the NCARD argument for various revised FTS1_x calls.
*     1991 October 10 (MJC):
*        Fixed bug when GLOCON and FMTCNV set to true and dealing with
*        IEEE-format data.
*     1992 February 24 (MJC):
*        Ensured that HDS file mapping will occur after tuning option
*        is added.
*     1992 March 3 (MJC):
*        Replaced AIF parameter-system calls by the extended PAR
*        library.
*     1992 December (RDS):
*        Modifications to improve the portability, including: BUFFER
*        and RECORD now mapped as BYTE arrays and passed into the
*        various subroutines as character arrays using descriptors
*        created by GRP1_CDESC.  File names are obtained using GRP,
*        wildcarding is done with a portable subroutine.  The FITS
*        files are opened for sequential access on the VAX but for
*        direct access on other platforms.  Calls to subroutines using
*        the BUFFER and RECORD mapped arrays, have generally had their
*        arguments reordered.
*     1993 January 5 (MJC):
*        Fixed bugs: tidied workspace, processing of integer data, and
*        multiple FITS objects.
*     1993 January 20 (MJC):
*        Made to work for DECstations.
*     1993 December 3 (MJC):
*        Made to work for Alphas.
*     1995 October 5 (MJC):
*        Documentation overhaul.  Changed dynamic default of FMTCNV.
*     1996 June 6 (MJC):
*        Linux usage enabled.
*     9-JUN-1998 (DSB):
*        Added support for WCS component.
*     9-DEC-1998 (DSB):
*        Added FITS-IRAF encoding.
*     9-JUN-1999 (DSB):
*        Remove use of non-standard RECORDTYPE option in INQUIRE
*        statements, and READONLY in OPEN statements.
*     11-APR-2000 (DSB):
*        Added FITS-PC and FITS-AIPS WCS encodings.
*     2-SEP-2004 (TIMJ):
*        Use ONE_FIND_FILE rather than FTS internal routine.
*     2004 September 3 (TIMJ):
*        Use CNF_PVAL
*     {enter_further_changes_here}

*-

*  Type Definitions:
      IMPLICIT  NONE           ! no default typing allowed

*  Global Constants:
      INCLUDE 'SAE_PAR'        ! SSE standard constants
      INCLUDE 'DAT_PAR'        ! Data-system constants
      INCLUDE 'FIO_PAR'        ! FIO public constants
      INCLUDE 'FIO_ERR'        ! FIO error constants
      INCLUDE 'PAR_ERR'        ! Parameter-system error constants
      INCLUDE 'GRP_PAR'        ! GRP constants
      INCLUDE 'ONE_ERR'        ! ONE errors
      INCLUDE 'CNF_PAR'        ! For CNF_PVAL function

*  Status:
      INTEGER  STATUS

*  External References:
      INTEGER
     :  CHR_LEN                ! String length less trailing blanks

      LOGICAL
     :  FTS1_BLCAR,            ! Tests whether the first card image of a
                               ! FITS record has a blank keyword
     :  ONE_FIND_FILE          ! Routine for file finding

      EXTERNAL ONE_FIND_FILE

*  Local Constants:
      INTEGER
     :  BLKSIZ,                ! Maximum blocksize, which is the FITS
                               ! record length, times the maximum
                               ! blocking factor of ten
     :  MAXCOD,                ! No. of known AST encodings.
     :  MAXHDR,                ! Maximum number of header sections in a
                               ! sub-file, including dummy header
                               ! sections before the extension *with*
                               ! data
     :  MXFILE,                ! Maximum size of input file list
     :  MXPARM,                ! Maximum number of parameters that can
                               ! be associated with a group-format array
     :  MXAXIS,                ! Maximum number of axes
     :  RECSIZ                 ! FITS record size
      PARAMETER(
     :  RECSIZ = 2880,
     :  BLKSIZ = RECSIZ * 10,
     :  MAXCOD = 3,
     :  MAXHDR = 2,
     :  MXFILE = 10,
     :  MXPARM = 999,
     :  MXAXIS = DAT__MXDIM )

*  Local Variables:
      INTEGER
     :  ACTSIZ,                ! Size of FITS block (=file recordsize)
     :  BITPIX,                ! Number of bits per pixel
     :  BLANK,                 ! FITS data value assigned to undefined-
                               ! value pixels
     :  BPV,                   ! Number of bytes per pixel
     :  BF,                    ! number of complete FITS records per
                               ! block
     :  BFPNTR,                ! Pointer to FITS block buffer
     :  BFPNTD,                ! Descriptor for FITS block buffer
     :  CONTEXT,               ! Used in expanding wildcard entries
     :  DIMS( MXAXIS ),        ! The size of each axis
     :  FD,                    ! File description of logfile
     :  FS,                    ! File sequence
     :  GCOUNT                 ! Number of groups contained in the file

      INTEGER
     :  HDNUM( MAXHDR ),       ! Number of headers cards in each header
                               ! section in the sub-file
     :  HPNTR( 1 ),            ! Pointer to array to store the header
                               ! cards for the sub-file
     :  HSTART( MAXHDR ),      ! Start card number of each header
                               ! section of the sub-file in the full
                               ! header
     :  IDUMMY,                ! Dummy variable
     :  IGRP1,                 ! Pointer to GRP file name group
     :  IGRP2,                 ! Pointer to expanded wcard GRP file name group
     :  IOERR,                 ! I/O error status
     :  NC,                    ! Number of characters in NDF character
                               ! component
     :  NCH,                   ! Number of characters returned by
                               ! CHR_ITOC
     :  NCROOT,                ! Number of characters in file root name
     :  NDIM                   ! Number of dimensions in the FITS image

      INTEGER
     :  NENCOD,                ! No. of of WCS encodings supplied
     :  NFILE,                 ! Number of input files
     :  NGLIST,                ! Number of entries in first group
     :  NHEADS,                ! Number of header sections in the FITS
                               ! sub-file and including the
                               ! dummy header section
     :  NKC,                   ! Number of a header card image that
                               ! contains a specified keyword
     :  OFFSET,                ! The number of bytes of the current FITS
                               ! block that contains processed
                               ! information (equal to ACTSIZ zero means
                               ! the block has been fully processed)
     :  OLDMAP,                ! The value of the HDS MAP tuning
                               ! parameter on entry to this routine
     :  PARAMS( MXPARM ),      ! Numerical values of parameters
                               ! associated with a group-format array,
                               ! note this assumes a BITPIX of no more
                               ! 32 (4 bytes per value)
     :  PCOUNT,                ! The number of parameter values
                               ! preceeding each data array
     :  RCPNTR,                ! Pointer to FITS record
     :  RCPNTD,              ! Descriptor for FITS record
     :  SIZE,                  ! Total size of the data array
     :  SUBFIL,                ! Number of the FITS sub file
     :  UDFITS,                ! I/O unit for input disc-FITS files
     :  WHDIM( 1 )             ! Size of the structure to store the
                               ! header cards
      INTEGER
     :  LP,                    ! Loop variable
     :  ADDED,                 ! Number of items added to a group
     :  ENCGRP                 ! Group identifier of ENCODINGS

      CHARACTER*(GRP__SZNAM)   !
     :  ENCODS( MAXCOD ),      ! AST encodings for WCS component
     :  FSPEC                  ! Entry in the initial filenames group

      LOGICAL                  ! True if:
     :  AUTO,                  ! Automatic mode is operative
     :  BADPIX,                ! Data array has undefined pixels
     :  CURREC,                ! The current FITS record is to be used
                               ! immediately
     :  DARRAY,                ! There is a data array in the FITS file
     :  EFMTCV,                ! The type of the data in FITS file will
                               ! be converted to real in the output
                               ! data structure
     :  EXTEND,                ! There is a FITS extension (XTENSION=T)
     :  FILEXS,                ! Input file exists (i.e. name not
                               ! truncated)
     :  FMTCNV,                ! The type of the FITS data will be
                               ! converted to real in the output data
                               ! structure
     :  FOUND,                 ! Found a file
     :  GEXTND,                ! The FITS file may contain an extension
     :  IEEE,                  ! FITS data are in IEEE floating-point
                               ! format
     :  INVEXT,                ! Extension is invalid
     :  LENDIA,                ! Machine uses little-endian order of
                               ! bytes (e.g. Digital OSF, Linux), and is
                               ! not VMS
     :  LOGHDR                 ! A log of the header is written to an
                               ! text file

      LOGICAL                  ! True if:
     :  LEAVE,                 ! Jump out of loop searching for input
                               ! files
     :  LFLAG,                 ! The last character in the group of
                               ! files is equal to the flag character
                               ! for the sifted and expanded group of
                               ! input files
     :  LOPEN,                 ! There a file open on this logical unit
     :  NEXT,                  ! Go on to the next FITS sub-file even
                               ! if status is bad when creating the NDF,
                               ! otherwise abort the application
     :  NOCON,                 ! No prompting for the format conversion
                               ! of each file
     :  NONSDA,                ! There is a non-standard data array in
                               ! the FITS file
     :  THERE,                 ! A specified descriptor is present in
                               ! the FITS header
     :  VALID,                 ! A locator/GRP identifier is valid
     :  VMS                    ! Operating system is VMS

      LOGICAL
     :  CFLAG                  ! Group requires further input ?

      REAL
     :  BSCALE,                ! Scale factor used to convert FITS
                               ! values to true values
     :  BZERO                  ! Offset applied to true pixel values

      DOUBLE PRECISION
     :  PSCALE( MXPARM ),      ! Scale factor used to convert FITS
                               ! parameter values to true values
     :  PZERO( MXPARM )        ! Offset applied to true parameter values

      CHARACTER
     :  COMENT * ( 48 ),       ! Comment from card (not used)
     :  CS * ( 12 ),           ! Sub file number
     :  EXTNAM * ( 8 ),        ! Extension name
     :  FILES( MXFILE ) * ( FIO__SZFNM ), ! File names
     :  FILROO * ( 80 ),       ! Root name of HDS container file for
                               ! groups format and automatic mode
     :  FORMTI*(DAT__SZTYP),   ! Format of input data array
     :  FORMAT*(DAT__SZTYP),   ! Format of output data array
     :  INFILE * ( FIO__SZFNM ), ! Current filename
     :  MACHIN * ( 24 ),       ! Machine name
     :  NODE * ( 20 ),         ! Node name
     :  PTYPE( MXPARM ) * ( 8 ), ! Parameter names for groups format
     :  PREFIX * ( 80 ),       ! Prefix for automatic generation of NDF
                               ! file names
     :  RELEAS * ( 10 ),       ! Release of operating system
     :  SYSNAM * ( 10 ),       ! Operating system
     :  VERSIO * ( 10 )        ! Sub-version of operating system

      CHARACTER*(DAT__SZLOC)   ! Locators for:
     :  BFLOC,                 !   FITS header block
     :  RCLOC,                 !   FITS record
     :  TLOC                   !   temporary header

*.
*    Check status on entry - return if not o.k.

      IF ( STATUS .NE. SAI__OK ) RETURN

*    Inquire the current HDS MAP flag, since workspace requires that
*    the data are written by file mapping.

      CALL HDS_GTUNE( 'MAP', OLDMAP, STATUS )
      IF ( STATUS .NE. SAI__OK ) GOTO 999

*    Set the tuning parameter to the file-mapping setting.

      CALL HDS_TUNE( 'MAP', 1, STATUS )

*    Enquire which operating system is being used.

      CALL PSX_UNAME( SYSNAM, NODE, RELEAS, VERSIO, MACHIN, STATUS )
      CALL CHR_UCASE( SYSNAM )
      CALL CHR_UCASE( MACHIN )

*    Is it VAX/VMS?
      VMS = INDEX( SYSNAM, 'VMS' ) .NE. 0 .OR.
     :      INDEX( SYSNAM, 'RSX' ) .NE. 0

*    Find if the machine is not VMS and uses little-endian order of the
*    bytes.
      IF ( VMS ) THEN
         LENDIA = .FALSE.
      ELSE
         LENDIA = SYSNAM( 1:6 ) .EQ. 'ULTRIX' .OR.
     :            SYSNAM( 1:4 ) .EQ. 'OSF1' .OR.
     :            SYSNAM( 1:7 ) .EQ. 'DIGITAL' .OR.
     :            SYSNAM( 1:5 ) .EQ. 'LINUX'
      END IF

*    Attempt to obtain and open a log file to output the headers and
*    destination files.  A null value, meaning no logfile is required,
*    is handled invisibly.

      LOGHDR = .FALSE.
      CALL ERR_MARK
      CALL FIO_ASSOC( 'LOGFILE', 'WRITE', 'LIST', 132, FD, STATUS )

      IF ( STATUS .EQ. PAR__NULL ) THEN
         CALL ERR_ANNUL( STATUS )
      ELSE IF ( STATUS .EQ. SAI__OK ) THEN
         LOGHDR = .TRUE.
      END IF
      CALL ERR_RLSE
      IF ( STATUS .NE. SAI__OK ) GOTO 990

      IF ( LOGHDR ) CALL MSG_OUT( 'LOG', 'Logging to $LOGFILE', STATUS )

*    Get some BYTE workspace to store character buffers.  This is to
*    avoid the use of %REF.  First is the buffer for a FITS header
*    block, and second is a buffer to hold the current FITS record of
*    2880 bytes.
      CALL AIF_GETVM( '_BYTE', 1, BLKSIZ, BFPNTR, BFLOC, STATUS )
      CALL AIF_GETVM( '_BYTE', 1, RECSIZ, RCPNTR, RCLOC, STATUS )

      IF ( STATUS .NE. SAI__OK ) THEN
         CALL ERR_REP( 'FITSIN_WSP',
     :     'FITSDIN: Unable to get workspace for character buffers '/
     :     /'table.', STATUS )
         GOTO 990
      END IF

*    Get a descriptor for these character arrays using the GRP routines
*    These convert the mapped array pointer into a character array
*    descriptor. NB. this only happens on the VAX; on UNIX, the same
*    pointer is used.

      BFPNTD = BFPNTR
      RCPNTD = RCPNTR

*    Is automatic mode required?

      AUTO = .FALSE.
      CALL PAR_GTD0L( 'AUTO', .FALSE., .TRUE., AUTO, STATUS )

      IF ( AUTO ) THEN

*       Set no prompting for the format conversion of each file.

         NOCON = .TRUE.

*       Determine whether or not format conversion is to be applied to
*       all the files to be read.  The suggested default is .TRUE..

         CALL PAR_GTD0L( 'FMTCNV', .TRUE., .TRUE., FMTCNV, STATUS )

         PREFIX = ' '
      ELSE

*       No format conversion?

         NOCON = .FALSE.
         CALL PAR_GTD0L( 'GLOCON', .FALSE., .TRUE., NOCON, STATUS )

*       Determine whether or not format conversion is to be applied to
*       all the files to be read.  The suggested default is .TRUE..

         IF ( NOCON ) CALL PAR_GTD0L( 'FMTCNV', .TRUE., .TRUE., FMTCNV,
     :                                STATUS )

      END IF

*  Get a list of the AST Encodings to be used when creating NDF WCS
*  components.
*  ================================================================

*  Abort if there has been an error.
      IF( STATUS .NE. SAI__OK ) GO TO 999

*  Get a group from parameter ENCODINGS holding the AST encodings to use
*  when creating the WCS component from the FITS header.
      CALL GRP_NEW( 'AST Encodings', ENCGRP, STATUS )
      CALL GRP_SETCS( ENCGRP, .FALSE., STATUS )

      CFLAG = .TRUE.
      DO WHILE ( CFLAG .AND. STATUS .EQ. SAI__OK )
         CALL GRP_GROUP( 'ENCODINGS', GRP__NOID, ENCGRP, NENCOD, ADDED,
     :                   CFLAG, STATUS )
         IF ( CFLAG ) CALL PAR_CANCL( 'ENCODINGS', STATUS )
      END DO

*  If a NULL parameter value was given for ENCODINGS annul the error,
*  and find the real number of values in the group.
      IF( STATUS .EQ. PAR__NULL ) THEN
         CALL ERR_ANNUL( STATUS )
         CALL GRP_GRPSZ( ENCGRP, NENCOD, STATUS )
      END IF

*  Limit the number of encodings used to MAXCOD.
      IF( NENCOD .GT. MAXCOD ) THEN
         CALL MSG_SETI( 'MX', MAXCOD )
         CALL MSG_OUT( 'ENCODINGS', 'Only the first ^MX '//
     :                 'values for parameter %ENCODINGS will be '//
     :                 'used.', STATUS )
         NENCOD = MAXCOD
      END IF

*  Extract the encodings from the group into an array.
      CALL GRP_GET( ENCGRP, 1, NENCOD, ENCODS, STATUS )

*    Get file list and check the number of specifications.
*    =====================================================
*
*    Use GRP to get a list of wildcarded filenames.

*    Obtain the I/O unit for the input files.

      CALL FIO_GUNIT( UDFITS, STATUS )

*    Create a new group to contain the input file names.

      CALL GRP_NEW( 'Input files', IGRP1, STATUS )

*    Get the list of file names from the environment.

      CALL GRP_GROUP( 'FILES', GRP__NOID, IGRP1, NGLIST, IDUMMY,
     :                LFLAG, STATUS )
      IF ( STATUS .NE. SAI__OK ) GOTO 980

*    Create a second group to hold the filenames including expanded
*    wildcards.

      CALL GRP_NEW( 'Expanded wild card files', IGRP2, STATUS )

*    Expand the wildcards.   We are using a UNIX-specific routine for
*    now, and therefore we must dummy up for VMS:

      NFILE = 0
      DO LP = 1, NGLIST

*       Get a file spec from the input group.

         CALL GRP_GET( IGRP1, LP, 1, FSPEC, STATUS )

*       Find the files which match this specification.

         CONTEXT=0
         LEAVE = .FALSE.

         DO WHILE ( .NOT. LEAVE )

*          Get a single file that matches this specification.

            FOUND = ONE_FIND_FILE( FSPEC, .TRUE., INFILE, CONTEXT,
     :           STATUS)

*          Check if a file has been found.

            IF ( FOUND .AND. STATUS .EQ. SAI__OK) THEN

*          Add this file into the output group.  NFILE keeps a count of
*          the number of files in the output group.

               CALL GRP_GRPEX( INFILE, GRP__NOID, IGRP2, NFILE,
     :                         IDUMMY, LFLAG, STATUS )
            ELSE

*             Clear status if no more files
               IF (STATUS .EQ. ONE__NOFILES) CALL ERR_ANNUL( STATUS )

*             Tidy up the file system.

               CALL ONE_FIND_FILE_END( CONTEXT, STATUS )

*             Go to the next GRP expression.

               LEAVE = .TRUE.

            END IF
         END DO
      END DO

      IF ( STATUS .NE. SAI__OK ) GO TO 980

*    If no files were found, then report an error.

      IF ( NFILE .LE. 0 ) THEN
         CALL GRP_GET( IGRP1, 1, 1, FILES( 1 ), STATUS )
         STATUS = SAI__ERROR
         CALL MSG_SETC( 'SPEC', FILES( 1 ) )
         CALL ERR_REP( 'FITSDIN_NOFILES',
     :     'FITSDIN: No input files found matching the specification '/
     :     /'"^SPEC".', STATUS )
         GOTO 980
      END IF

*    Report how many files are to be processed.

      CALL MSG_OUT( 'BLANK', ' ', STATUS )
      IF ( NFILE .EQ. 1 ) THEN
         CALL MSG_OUT( 'NFILE1', '   1 file to be processed...',
     :                 STATUS )
      ELSE
         CALL MSG_SETI( 'NFILE', NFILE )
         CALL MSG_OUT( 'NFILE', '   ^NFILE files to be processed...',
     :                 STATUS )
      END IF
      CALL MSG_OUT( 'BLANK', ' ', STATUS )

*    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*    Start the NDF context, even though it may just be FITS tables.
*    It's easier to follow the code this way.

      CALL NDF_BEGIN

*    Scan through the file of disc FITS file names, processing each
*    file in turn.

      DO FS = 1, NFILE

         CALL GRP_GET( IGRP2, FS, 1, INFILE, STATUS )

         IF ( STATUS .NE. SAI__OK ) GO TO 980

*       Start a new error context.

         CALL ERR_MARK

*       Inquire whether the file exists or not.  Since the wild carding
*       has obtained the files, a non-existent file indicates that the
*       file name has been truncated to FIO__SZFNM characters.  This is
*       not foolproof as some other file may be obtained.

         INQUIRE ( FILE = INFILE, EXIST=FILEXS )
         IF ( .NOT. FILEXS ) THEN
            STATUS = SAI__ERROR
            CALL MSG_SETI( 'MXFNC', FIO__SZFNM )
            CALL MSG_SETC( 'FNAME', INFILE )
            CALL ERR_REP( 'FITSDIN_TRUNC',
     :        'FITSDIN: File name is too long.  Maximum is ^MXFNC '/
     :        /'characters. Truncated to ^FNAME.', STATUS )
            IF ( FS .NE. NFILE ) CALL ERR_FLUSH( STATUS )
            CALL ERR_RLSE
            GOTO 960
         END IF

*       For non-VMS, i.e. UNIX, we must have 2880-byte FITS records.
         IF ( .NOT. VMS ) THEN
            ACTSIZ = 2880

*       On a VAX, inquire the record length (Only fixed-length records are
*       supported on a VAX - we do not check for this since it involves
*       using the non-standard RECORDTYPE option).
         ELSE
            INQUIRE ( FILE = INFILE, RECL = ACTSIZ )
         END IF

*       Blocking factor should be an integer factor from one to ten
*       of the standard FITS record. Note this application can cope
*       provided the actual blocksize is no large than BLKSIZ. Cater
*       for the special case of 512-byte blocking due to FTP.

         BF = ACTSIZ / 2880
         IF ( ( ( MOD( ACTSIZ, 2880 ) .NE. 0 .OR. BF .LT. 1 ) .AND.
     :          ACTSIZ .NE. 512 ) .OR. BF .GT. 10 ) THEN
            CALL MSG_SETI( 'ACTSIZ', ACTSIZ )
            CALL MSG_OUT( 'FITSDIN_IBLOCK',
     :        'File has illegal-length blocks (^ACTSIZ). '/
     :        /'Blocks should be a multiple (1--10) of '/
     :        /'the FITS record length of 2880 bytes.', STATUS )
         END IF

*       Close a file already open on this unit, if neccessary.
*       Open the input file and obtain a descriptor to it.

         INQUIRE( UNIT = UDFITS, OPENED = LOPEN )
         IF ( LOPEN ) CLOSE( UDFITS )

*       If the operating system is VMS/RSX open the file sequentially.

         IF ( VMS ) THEN
            OPEN( UNIT = UDFITS, FILE = INFILE, STATUS = 'OLD',
     :            FORM = 'UNFORMATTED', IOSTAT = IOERR )

*       Otherwise open it as a random-access file.  DEC Fortran uses
*       longwords (4 bytes).

         ELSE IF ( SYSNAM( 1:6 ) .EQ. 'ULTRIX' .OR.
     :             SYSNAM( 1:4 ) .EQ. 'OSF1' .OR.
     :             SYSNAM( 1:7 ) .EQ. 'DIGITAL' ) THEN
            OPEN( UNIT = UDFITS, FILE = INFILE, STATUS = 'OLD',
     :            FORM = 'UNFORMATTED', ACCESS = 'DIRECT', RECL = 720,
     :            IOSTAT = IOERR )

         ELSE
            OPEN( UNIT = UDFITS, FILE = INFILE, STATUS = 'OLD',
     :            FORM = 'UNFORMATTED', ACCESS = 'DIRECT', RECL = 2880,
     :            IOSTAT = IOERR )
         END IF

*       Check for errors, setting a suitable STATUS value and reporting
*       the error.  Note if there are further files to process, flush
*       the error so that subsequent files may be processed.

         IF ( IOERR .NE. 0 ) THEN
            CALL FIO_SERR( IOERR, STATUS )
            CALL MSG_SETC( 'FN', INFILE )
            CALL MSG_SETI( 'UNIT', UDFITS )
            CALL ERR_FIOER( 'MESSAGE', IOERR )
            CALL ERR_REP( 'FITSDIN_OPENIN',
     :        'FITSDIN: Error opening input file ^FN on Fortran '/
     :        /'unit ^UNIT - ^MESSAGE.', STATUS )
            IF ( FS .NE. NFILE ) CALL ERR_FLUSH( STATUS )
            CALL ERR_RLSE
            GOTO 960

*       Report the current file to keep the user posted of progress.

         ELSE
            CALL MSG_OUT( 'BLANK', ' ', STATUS )
            CALL MSG_SETC( 'FN', INFILE )
            CALL MSG_SETI( 'FS', FS )
            CALL MSG_OUT( 'CURRENT_INFILE',
     :        'Processing file number ^FS: ^FN.', STATUS )
         END IF

*       Release the new error context.

         CALL ERR_RLSE

*       Initialise the count of the number of FITS files or extensions
*       in the current FITS file.

         SUBFIL = 0

*       The offset in bytes within the block buffer is the record
*       length for a new file that has yet to be read.  For tape
*       FITS the offset is zero, because the first block is read in
*       first to obtain the blocksize.

         OFFSET = ACTSIZ

*       There is no current FITS record.

         CURREC = .FALSE.

*       This is the start of the loop for multiple FITS files.

  100    CONTINUE
         SUBFIL = SUBFIL + 1

*       Assume for the moment that there will be a data array
*       in the FITS header, and it is in a standard format.

         DARRAY = .TRUE.
         NONSDA = .FALSE.

*       Create a dummy header structure.

         WHDIM( 1 ) = 100
         CALL AIF_TEMP( '_CHAR*80', 1, WHDIM, TLOC, STATUS )
         IF ( STATUS .NE. SAI__OK ) THEN
            CALL ERR_REP( 'FITSDIN_HDS',
     :        'FITSDIN: Error creating a dummy header structure.',
     :        STATUS )
            GOTO 970
         END IF

         IF ( .NOT. AUTO ) THEN

*          Display file and sub-file number.

            CALL MSG_SETC( 'FN', INFILE )
            CALL MSG_SETI( 'SUBFIL', SUBFIL )
            CALL MSG_OUT( 'FILEHEAD',
     :        'File ^FN(^SUBFIL)  Descriptors follow:', STATUS )
         END IF

*       Process the header blocks.  OFFSET is updated.
         CALL FTS1_PHEAD( BFPNTR, RCPNTR, %VAL( CNF_PVAL( RCPNTD ) ),
     :                    'DISK',
     :                    UDFITS, TLOC, BLKSIZ, MAXHDR, .NOT. AUTO,
     :                    ACTSIZ, OFFSET, CURREC, HSTART, HDNUM, EXTEND,
     :                    NHEADS, STATUS, %VAL( CNF_CVAL( 80 ) ) )

         IF ( STATUS .NE. SAI__OK ) GOTO 970

*       Find the current size of the header structure.

         CALL DAT_SIZE( TLOC, WHDIM( 1 ), STATUS )

*       Now map the headers for later access.  This call is situated
*       after reading in all the headers because the size of the work
*       space may have been changed, and we don't want to mix mapping
*       with direct access to the work structure.

         CALL DAT_MAPC( TLOC, 'UPDATE', 1, WHDIM, HPNTR, STATUS )

*       Check we have a valid pointer before accessing it.

         IF ( STATUS .NE. SAI__OK ) THEN
            CALL ERR_REP( 'FITSDIN_WKMAP',
     :        'FITSDIN: Error mapping the dummy header structure.',
     :        STATUS )
            GOTO 970
         END IF

*       Could there be sub-files?  Store the global EXTEND value.

         IF ( SUBFIL .EQ. 1 ) THEN
            CALL FTS1_GKEYL( WHDIM( 1 ), %VAL( CNF_PVAL( HPNTR( 1 ) ) ),
     :                       HSTART( 1 ), 'EXTEND', 1, THERE, GEXTND,
     :                       COMENT, NKC, STATUS,
     :                       %VAL( CNF_CVAL( 1 ) ) )
            GEXTND = GEXTND .AND. THERE
         END IF

*       Now the complete header is stored in the buffer.  The values
*       of certain items stored in the buffer are required to generate
*       the data array.  This is not the most efficient method to
*       obtain selected descriptor values, but, in the main, the
*       important descriptors will be in the early cards.  Efficiency
*       has been sacrificed for more-structured and flexible code.

*       Check that the mandatory descriptors are present.

         CALL FTS1_MANDH( SUBFIL .EQ. 1, WHDIM( 1 ),
     :                    %VAL( CNF_PVAL( HPNTR( 1 ) ) ),
     :                    HSTART( NHEADS ), BITPIX,
     :                    NDIM, DIMS, DARRAY, NONSDA, SIZE, STATUS,
     :                    %VAL( CNF_CVAL( 1 ) ) )

*       Check for an error, because file is not in FITS
*       format, or has an unsupported FITS extension.

*       Start a new error context.

         CALL ERR_MARK

         IF ( STATUS .NE. SAI__OK ) THEN

*          Now report error context and future action.
*          First set up sub-file part of the message.

            IF ( SUBFIL .EQ. 1 ) THEN
               CALL MSG_SETC( 'SUBFIL', ' ' )
            ELSE
               CALL CHR_ITOC( SUBFIL, CS, NCH )
               CALL MSG_SETC( 'SUBFIL', 'Sub file is '//CS(:NCH)//'.' )
            END IF

*          Error occurred on the last file.

            IF ( FS .EQ. NFILE ) THEN
               CALL ERR_REP( 'FITSDIN_IVHEADL',
     :           'FITSDIN: Unable to read the last file ^SUBFIL',
     :           STATUS )
            ELSE
               CALL ERR_REP( 'FITSDIN_IVHEAD',
     :           'FITSDIN: Unable to read the current '/
     :           /'file. ^SUBFIL Going to next file.', STATUS )
               CALL ERR_FLUSH( STATUS )
            END IF

            CALL ERR_RLSE
            GOTO 960
         END IF

*       Release the new error context.

         CALL ERR_RLSE
         IF ( STATUS .NE. SAI__OK ) GOTO 960

*       Write header to log if required.

         IF ( LOGHDR ) THEN

            CALL FTS1_HDLOG( %VAL( CNF_PVAL( HPNTR( 1 ) ) ),
     :                       FD, INFILE, SUBFIL,
     :                       NHEADS, HDNUM, STATUS,
     :                       %VAL( CNF_CVAL( 1 ) ) )

            IF ( STATUS .NE. SAI__OK ) GOTO 970
         END IF

*-----------------------------------------------------------------------
*
*       Deal with Tables extension.
*       ===========================

         INVEXT = .FALSE.

         IF ( EXTEND ) THEN

*          Start a new error context.

            CALL ERR_MARK

*          Obtain the extension's name.

            CALL FTS1_GKEYC( WHDIM( 1 ), %VAL( CNF_PVAL( HPNTR( 1 ) ) ),
     :                       HSTART( NHEADS ), 'XTENSION', 1, THERE,
     :                       EXTNAM, COMENT, NKC, STATUS,
     :                       %VAL( CNF_CVAL( 1 ) ) )

*          Report any errors.

            IF ( NHEADS .GT. 2 ) THEN
               STATUS = SAI__ERROR
               CALL ERR_REP( 'FITSDIN_TMEXT',
     :           'FITSDIN: Only one extension recognised.', STATUS )
               CALL ERR_FLUSH( STATUS )
               INVEXT = .TRUE.
            ELSE IF ( EXTNAM( 1:8 ) .NE. 'TABLE   ' ) THEN
               NC = CHR_LEN( EXTNAM )
               CALL MSG_SETC( 'EXTNAM', EXTNAM( :NC ) )
               STATUS = SAI__ERROR
               CALL ERR_REP( 'FITSDIN_TMEXT',
     :           'FITSDIN: The extension ^EXTNAM cannot be processed.',
     :           STATUS )
               CALL ERR_FLUSH( STATUS )
               INVEXT = .TRUE.
            ELSE

*             Create the SCAR description file and text table.

               CALL FTS1_SCTAB( %VAL( CNF_PVAL( HPNTR( 1 ) ) ),
     :                          'DSCFTABLE',
     :                         'TABLE', 'DISK', UDFITS, WHDIM( 1 ),
     :                         HSTART( NHEADS ), NDIM, DIMS, LOGHDR,
     :                         FD, INFILE, SUBFIL, PREFIX, AUTO,
     :                         BLKSIZ, ACTSIZ, BFPNTR, OFFSET, CURREC,
     :                         RCPNTR, STATUS, %VAL( CNF_CVAL( 1 ) ) )

            END IF

            IF ( STATUS .EQ. PAR__ABORT ) THEN

*             Release the new error context.

               CALL ERR_RLSE
               GOTO 970

            ELSE IF ( INVEXT .OR. STATUS .NE. SAI__OK ) THEN

*             Now report error context and future action

*             First set up sub-file part of the message.

               IF ( SUBFIL .EQ. 1 ) THEN
                  CALL MSG_SETC( 'SUBFIL', ' ' )
               ELSE
                  CALL CHR_ITOC( SUBFIL, CS, NCH )
                  CALL MSG_SETC( 'SUBFIL', 'Sub file is '//CS(:NCH)/
     :                           /'.' )
               END IF

*             Error occurred on the last file.

               IF ( STATUS .EQ. SAI__OK ) STATUS = SAI__ERROR
               IF ( FS .EQ. NFILE ) THEN
                  CALL ERR_REP( 'FITSIN_IVHEADL',
     :              'FITSDIN: Unable to read the last file. ^SUBFIL.',
     :              STATUS )

*             Error occurred at arbitrary file.

               ELSE
                  CALL ERR_REP( 'FITSDIN_IVHEAD',
     :              'FITSDIN: Unable to read the current '/
     :              /'file. ^SUBFIL Going to next file.', STATUS )
                  CALL ERR_FLUSH( STATUS )
               END IF

*             Release the new error context.

               CALL ERR_RLSE
               GOTO 960

*          End of valid-extension-present check

            END IF

*          Release the new error context.

            CALL ERR_RLSE

*          Finished with the work array for the headers.

            CALL AIF_ANTMP( TLOC, STATUS )

*          See whether or not there is an extension
*          following the current sub file.

            GOTO 940

*       End of extension-present check

         END IF

*       ^^^^^^^^^^^^^^^^^^^^^^^^^^^

*-----------------------------------------------------------------------
*
*       Now the rest up to 960 loop deals with n-dimensional
*       data arrays and group format.

*       Obtain the scale and zero, the blank value.  If the FITS
*       object is in group format, obtain the number and values of
*       the group parameters.  Reset the dimensionality when there is
*       a dummy dimension.

         CALL FTS1_DTYPE( DARRAY, NONSDA, BITPIX, HSTART( NHEADS ),
     :                    WHDIM( 1 ), %VAL( CNF_PVAL( HPNTR( 1 ) ) ),
     :                    MXPARM,
     :                    NDIM, DIMS, BSCALE, BZERO, BLANK, BADPIX,
     :                    IEEE, GCOUNT, PCOUNT, PTYPE, PSCALE, PZERO,
     :                    STATUS, %VAL( CNF_CVAL( 1 ) ) )

         IF ( STATUS .NE. SAI__OK ) THEN

*          Report the problem now as the application is not exiting.

            CALL ERR_FLUSH( STATUS )
            GOTO 960
         END IF

*       Extend the header workspace.
*       ============================
*
*       From this point a non-standard array means group format.  If
*       there are any group parameters the work space for the headers
*       needs to be extended to include them.

         IF ( NONSDA .AND. PCOUNT .GT. 0 ) THEN

*          Unmap the structure containing the FITS header cards.

            CALL DAT_UNMAP( TLOC, STATUS )

*          Adjust its size to hold just the standard headers and the
*          group parameters.

            WHDIM( 1 ) = WHDIM( 1 ) + PCOUNT
            CALL DAT_ALTER( TLOC, 1, WHDIM( 1 ), STATUS )

            IF ( STATUS .NE. SAI__OK ) THEN
               CALL ERR_REP( 'FITSDIN_ENHEAD',
     :           'FITSDIN: Unable to enlarge the header '/
     :           /'workspace for the group parameters.', STATUS )
               GOTO 970
            END IF

*          Remap the header structure with update mode to
*          retain the existing header information.

            CALL DAT_MAPC( TLOC, 'UPDATE', 1, WHDIM, HPNTR, STATUS )

            IF ( STATUS .NE. SAI__OK ) THEN
               CALL ERR_REP( 'FITSDIN_REMAP',
     :           'FITSDIN: Error mapping the enlarged workspace for '/
     :           /'the header and group parameters.', STATUS )
            END IF
         END IF

*       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*       Is data conversion a possible requirement?

         IF ( ( .NOT. NOCON .AND. DARRAY ) .AND. .NOT. IEEE ) THEN

*          See if we wish to override the standard data TYPE.  The
*          suggested default is .TRUE..

            CALL PAR_GTD0L( 'FMTCNV', .TRUE., .TRUE., FMTCNV, STATUS )
            CALL PAR_CANCL( 'FMTCNV', STATUS )

            IF ( STATUS .EQ. PAR__ABORT ) GOTO 970
         END IF

*       Get the effective flag for format conversion for the current
*       FITS file.  The format conversion flag may have been set
*       globally, but we don't want to have a format conversion when
*       dealing with IEEE data.

         EFMTCV = FMTCNV .AND. .NOT. IEEE

*       Get the input and output formats.

         CALL FTS1_FRMT( BITPIX, IEEE, FMTCNV, BPV, FORMTI,
     :                   FORMAT, STATUS )

         IF ( STATUS .NE. SAI__OK ) THEN

*          Report the problem now as the application is not exiting.

            CALL ERR_FLUSH( STATUS )
            GOTO 960
         END IF

         IF ( AUTO ) THEN
            CALL FTS1_ROOTN( 'DISK', INFILE, SUBFIL, PREFIX,
     :                       FILROO, NCROOT, STATUS )
         END IF

*       Create and fill GCOUNT NDFs, performing the necessary
*       data conversions and blank-pixel removal.
*       =====================================================

         CALL FTS1_NDF( %VAL( CNF_PVAL( HPNTR( 1 ) ) ),
     :                  BFPNTR, RCPNTR, AUTO, 'OUT',
     :                  'DISK', UDFITS, VMS, LENDIA, SIZE, NDIM, DIMS,
     :                  BPV, EFMTCV, FORMTI, FORMAT, IEEE, BADPIX,
     :                  BLANK, BSCALE, BZERO, DARRAY, NONSDA, GCOUNT,
     :                  PCOUNT, MXPARM, PTYPE, PSCALE, PZERO, FILROO,
     :                  LOGHDR, FD, INFILE, SUBFIL, GEXTND, WHDIM( 1 ),
     :                  HSTART( NHEADS ), NENCOD, ENCODS, BLKSIZ,
     :                  ACTSIZ, OFFSET, CURREC, NEXT, PARAMS, STATUS,
     :                  %VAL( CNF_CVAL( 80 ) ) )

*       Test for exit.

         IF ( .NOT. NEXT ) GOTO 970

*       Flush any errors before continuing.

         IF ( STATUS .NE. SAI__OK ) CALL ERR_FLUSH( STATUS )

  940    CONTINUE

*       If there may be an extension following, it has to
*       be determined whether or not it actually exists.

         IF ( GEXTND ) THEN

*          Start a new error context.

            CALL ERR_MARK

*          Attempt to read the next record as if it were the first
*          header whenever the next card (first in the next record)
*          is the start of a sub-file header.  There is no sub file
*          when either the first record is blank, or when the end of
*          file is encountered.  On some platforms this may return
*          an IOSTAT that's not the EOF, so check for a read error too.

            CALL FTS1_DREAD( UDFITS, BLKSIZ, ACTSIZ, .FALSE.,
     :                       %VAL( CNF_PVAL( BFPNTR ) ), OFFSET,
     :                       %VAL( CNF_PVAL( RCPNTR ) ),
     :                       STATUS )

            IF ( .NOT. FTS1_BLCAR( %VAL( CNF_PVAL( RCPNTD ) ) ) .AND.
     :           STATUS .EQ. SAI__OK ) THEN

*             There is a sub file, so process its header like for
*             any other.  Note the fact that the first record of
*             a sub-file has been read.

               CURREC = .TRUE.

*             Tidy the workspace used to store the headers
*             if it exists, before going on to the next extension.

               CALL DAT_VALID( TLOC, VALID, STATUS )
               IF ( VALID ) CALL AIF_ANTMP( TLOC, STATUS )
               CALL ERR_RLSE
               GOTO 100

*          Ignore the error.

            ELSE IF ( STATUS .NE. SAI__OK ) THEN
               CALL ERR_ANNUL( STATUS )
            END IF

*          End the new error context.

            CALL ERR_RLSE

*       End of check for possible sub files/extensions.

         END IF


*       Go onto next file even if there has been a FITS
*       problem reading the current file.

  960    CONTINUE

*       Tidy the workspace used to store the headers if it exists.

         CALL DAT_VALID( TLOC, VALID, STATUS )
         IF ( VALID ) CALL AIF_ANTMP( TLOC, STATUS )

*       Close the input disc-FITS file.  The final file will be
*       closed during the tidying up operations.

         IF ( FS .NE. NFILE ) CLOSE( UDFITS )

*    End of process-each-file loop.

      END DO


*    Clear up locators and NDF after an abort.
*    =========================================

 970  CONTINUE

*    Tidy the workspace used to store the headers if it exists.

      CALL DAT_VALID( TLOC, VALID, STATUS )
      IF ( VALID ) CALL AIF_ANTMP( TLOC, STATUS )

*    Close down the NDF system.

      CALL NDF_END( STATUS )

*    Close the files and groups.
*    ===========================

 980  CONTINUE

*    Tidy the group resources.
      CALL GRP_VALID( IGRP2, VALID, STATUS )
      IF ( VALID ) CALL GRP_DELET( IGRP2, STATUS )
      CALL GRP_VALID( IGRP1, VALID, STATUS )
      IF ( VALID ) CALL GRP_DELET( IGRP1, STATUS )

*    Close the last input file.

      CLOSE( UDFITS )

*    Release the I/O channel.

      CALL FIO_PUNIT( UDFITS, STATUS )

*    Close the log file.

 990  CONTINUE

*    Tidy the byte work space.

      CALL AIF_ANTMP( RCLOC, STATUS )
      CALL AIF_ANTMP( BFLOC, STATUS )

*    Close an open log file.

      IF ( LOGHDR ) CALL FIO_ANNUL( FD, STATUS )

*    Return to the old tuning setting being careful to ensure that this
*    is successful, even if there has been an error.

      CALL ERR_BEGIN( STATUS )
      CALL HDS_TUNE( 'MAP', OLDMAP, STATUS )
      CALL ERR_END( STATUS )

*    Exit.

 999  CONTINUE

      END
