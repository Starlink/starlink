\documentclass[twoside,11pt,nolof]{starlink}

%------------------------------------------------------------------------------
\stardoccategory    {Starlink User Note}
\stardocinitials    {SUN}
\stardocsource      {sun7.6}
\stardocnumber      {7.6}
\stardocauthors     {S M Beard \\ P M Allan\\ Malcolm J. Currie\\ Peter W. Draper \\ David Berry}
\stardocdate        {2020 Feb 12}
\stardoctitle     {GENERIC --- A Utility for Preprocessing Generic
				\\ Fortran and C Subroutines}
\stardocversion     {1.4}
\stardocmanual      {User's Guide}
\stardocabstract   {%
\GENERIC\ is tool for Fortran 77 and C developers to create type-specific
code from a generic source that includes tokens for type-dependent
elements.  This saves effort supporting multiple versions of the
source code.
}
%------------------------------------------------------------------------------
% ? Document-specific \providecommand or \newenvironment commands.

% Shorthands for hypertext links.
% -------------------------------
\providecommand{\ASTERIX}{{\footnotesize ASTERIX}\normalsize}
\providecommand{\ASTERIXref}{\xref{\ASTERIX}{sun98}{}}
\providecommand{\GENERIC}{{\footnotesize GENERIC}\normalsize}
\providecommand{\HDS}{{\footnotesize HDS}\normalsize}
\providecommand{\HDSref}{\xref{\HDS}{sun92}{}~}
\providecommand{\PRIMDAT}{{\footnotesize PRIMDAT}\normalsize}
\providecommand{\PRIMDATref}{\xref{\PRIMDAT}{sun39}{}~}
\providecommand{\CNF}{{\footnotesize CNF}\normalsize}
\providecommand{\KAPLIBS}{{\footnotesize KAPLIBS}\normalsize}
\providecommand{\CNFref}{\xref{\CNF}{sun209}{}}

%------------------------------------------------------------------------------
% Add any \providecommand or \newenvironment commands here

% conditional text
\providecommand{\latexelsehtml}[2]{#1}

%------------------------------------------------------------------------------

% ? End of document specific commands
%------------------------------------------------------------------------------

%  Title Page.
%  ===========
\begin{document}
\scfrontmatter

% The main text begins here.
% -----------------------------------------------------------------------------

\section{Introduction}

\GENERIC\ is a utility which preprocesses a generic Fortran or C subroutine
into its different types and concatenates these routines into a file.
The file can then be compiled with the appropriate compiler to produce an
object module.

It also supports standardized C generic programming by providing a suitable
set of include files and rules for using them

\section{GENERIC Fortran Subroutines---an Example}

A generic subroutine is one which has an argument (or arguments)
which may be one of a number of different Fortran data types.

As an example, consider a subroutine which initialises every
element in an array to zero.
One might want a different version of the routine for initializing
a double precision array, an integer array and a real array.
The following subroutines would need to be written:

\begin{terminalv}
      ZEROD( N, DARR )   Zero every element in a DOUBLE PRECISION array
      ZEROI( N, IARR )   Zero every element in an INTEGER array
      ZEROR( N, RARR )   Zero every element in a REAL array
\end{terminalv}

The integer routine might contain the following code (in a file
called \texttt{zeroi.f}):

\begin{terminalv}
          SUBROUTINE ZEROI( N, ARRAY )
    *+
    *  Name:
    *     ZEROI
    *  Purpose:
    *     Zero all the elements of an4 INTEGER array
    *  Invocation :
    *     CALL ZEROI( N, ARRAY )
    *  Description :
    *     This sets all the elements of an INTEGER array to zero
    *  Arguments:
    *     N = INTEGER( Given )
    *        Dimension of array
    *     ARRAY( N ) = INTEGER( Given and Returned )
    *        The array to be zeroed
    *                   "
    *     (the rest of the standard prologue)
    *                   "
    *  Type Definitions:
          IMPLICIT NONE
    *  Arguments Given:
          INTEGER N
    *  Arguments Given and Returned:
          INTEGER ARRAY( N )
    *  Local Variables:
          INTEGER I                   ! Array index
    *-

          DO I = 1, N
             ARRAY( I ) = 0
          END DO
          END
\end{terminalv}

The REAL and DOUBLE PRECISION versions of the routine would have to be
written in a similar way, and this obviously involves a lot of
duplication of effort.
The situation gets even worse if other versions of the routine
(such as BYTE, INTEGER*2) are needed.
Also, it is very difficult and tedious to keep all the versions
in step if they have to be edited individually when the routines
are changed.

The \GENERIC\ utility is a labour-saving device which enables all the
various types of routines to be constructed automatically from
one master routine.
If any changes become necessary, only this one master routine needs
to be edited.

To use the \GENERIC\ utility, the routine listed above is replaced by
the following (in a file called \texttt{zero.gen}):

\begin{terminalv}
          SUBROUTINE ZERO<T>( N, ARRAY )
    *+
    *  Name:
    *     ZERO<T>
    *  Purpose:
    *     Zero all the elements of a <COMM> array
    *  Invocation :
    *     CALL ZERO<T>( N, ARRAY )
    *  Description :
    *     This sets all the elements of a <COMM> array to zero
    *  Argument:
    *     N = INTEGER( Given )
    *        Dimension of array
    *     ARRAY( N ) = <TYPE>( Given and Returned )
    *        The array to be zeroed
    *                   "
    *     (the rest of the standard prologue)
    *                   "
    *  Type Definitions:
          IMPLICIT NONE
    *  Arguments Given:
          INTEGER N
    *  Arguments Given and Returned:
          <TYPE> ARRAY( N )
    *  Local Variables:
          INTEGER I                  ! Array index
    *-

          DO I = 1, N
             ARRAY( I ) = 0<CONST>
          END DO
          END
\end{terminalv}

This is a ``generic routine.''
Other examples of generic routines include the DAT\_ routines in
the \xref{Hierarchical Data System}{sun92}{} (SUN/92) and the
\xref{PAR\_ routines}{sun114}{} of the \xref{ADAM parameter
system}{ssn29}{} (SSN/29).

The items in angle brackets, $<>$ , are ``tokens'' which the
\GENERIC\ utility replaces when it converts the routine into one
of a given type.
In the above example, the tokens would be replaced
as follows.

\begin{terminalv}
       Token       Double precision    Integer       Real
                   replacement         replacement   replacement

       <T>         D                   I             R
       <TYPE>      DOUBLE PRECISION    INTEGER       REAL
       <COMM>      DOUBLE PRECISION    INTEGER       REAL
       <CONST>     .0D0                (blank)       .0E0
\end{terminalv}

The types are generated by issuing the following command.

\begin{terminalv}
% generic -t dir zero.gen
\end{terminalv}

More details on the use of the \GENERIC\ utility, and a full list of
tokens and types, are given in the rest of this document.

\subsection{Using the GENERIC utilty to process generic C files}
If the source files supplied to the \GENERIC\ utility have a file type
that starts with ``\verb+.c+'', then they are assumed to contain C source
code for functions that are designed to be called from Fortran using the
macros in the \verb+f77.h+ header file provided by the \CNFref\ package.
The same rules apply regarding the interpretation of the file types as
for Fortran source code, except that ``\verb+.cgen+'' is used in place of
``\verb+.gen+'' and the initial ``\verb+.g+'' used in other Fortran files
type (for instance ``\verb+.gdr+'') becomes ``\verb+.c+'' (for instance
``\verb+.cdr+''). The output text is written to a file with type
``\verb+.c+'' rather than ``\verb+.f+'', and no text wrapping is performed
in the output files.

An example generic C source file is shown below (\verb+ccg8_um3.cdr+ from
 \KAPLIBS\ ):
\begin{terminalv}

#include <stdint.h>
#include "sae_par.h"
#include "prm_par.h"
#include "f77.h"

F77_SUBROUTINE(ccg8_um3<TLC>)( INTEGER8(NPIX), INTEGER8(NLINES),
                               <CNFTYPE>_ARRAY(STACK), INTEGER8(MINPIX),
                               <CNFTYPE>_ARRAY(RESULT), DOUBLE_ARRAY(NCON),
                               INTEGER8(NBAD), INTEGER(STATUS) ){
/*
*+
*  Name:
*     CCG8_UM3<T>

*  Purpose:
*     Combines data lines using an unweighted mean.

*  Language:
*     C (designed to be called from Fortran 77)

*  Invocation:
*     CALL CCG8_UM3<T>( NPIX, NLINES, STACK, MINPIX, RESULT, NCON,
*                       NBAD, STATUS )

*  Description:
*     This routine accepts an array consisting a series of (vectorised)
*     lines of data.  The data values in the lines are then combined to
*     form an unweighted mean.  The output means are returned in the
*     array RESULT.

*  Arguments:
*     NPIX = INTEGER*8 (Given)
*        The number of pixels in a line of data.
*     NLINES = INTEGER*8 (Given)
*        The number of lines of data in the stack.
*     STACK( NPIX, NLINES ) = <TYPE> (Given)
*        The array of lines which are to be combined into a single line.
*     MINPIX = INTEGER*8 (Given)
*        The minimum number of pixels required to contribute to an
*        output pixel.
*     RESULT( NPIX ) = <TYPE> (Returned)
*        The output line of data.
*        to the output line.
*     NCON( NLINES ) = DOUBLE PRECISION (Returned)
*        The actual number of contributing pixels from each input line
*        to the output line.
*     NBAD = INTEGER*8 (Returned)
*        The number of bad values in the output array created while
*        forming the statistics.  It excludes those bad values whose
*        corresponding values along the collapse axis are all bad.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*-
*/

/* Local Variables: */
   double sumd;          /* Sum of values */
   double sumw;          /* Sum of weights */
   double value;         /* Output value */
   int64_t i;            /* Loop variable */
   int64_t j;            /* Loop variable */
   int64_t ngood;        /* Number of good pixels */
   const <CTYPE> *pstack; /* Pointer to next input value */

/* Initialise returned values. */
   *NBAD = 0;
   for( i = 0; i < *NLINES; i++ ){
      NCON[ i ] = 0.0;
   }

/* Check inherited global status. */
   if( *STATUS != SAI__OK ) return;

/* Loop over for all possible output pixels.  */
   for( i = 0; i < *NPIX; i++ ){

/* Initialise sums. */
      sumw = 0.0;
      sumd = 0.0;

/* Set good pixel count. */
      ngood = 0;

/* Loop over all possible contributing pixels forming weighted mean
   sums. */
      pstack = STACK + i;
      for( j = 0; j < *NLINES; j++ ){
         if( *pstack != VAL__BAD<T> ) {

/* Conversion increment good value counter. */
            ngood++;

/* Sum weights. */
            sumw += 1.0;

/* Form weighted mean sum. */
            sumd += (double)( *pstack );

/* Update the contribution buffer---all values contribute when forming
   mean. */
            NCON[ j ] += 1.0;

/* Move the input pointer on to the value in the next input line. */
         pstack += *NPIX;
      }

/* If there are sufficient good pixels output the result. */
      if( ngood >= *MINPIX ) {
         value = sumd/sumw;
         RESULT[ i ] = (<CTYPE>) value;

/* Trap numeric errors. */
         if( RESULT[ i ] != (<CTYPE>) value ) {
            RESULT[ i ] = VAL__BAD<T>;
            (*NBAD)++;
         }

/* Not enough contributing pixels, set output invalid unless all of them
   are bad. */
      } else {
         RESULT[ i ] = VAL__BAD<T>;
         if( ngood > 0 ) (*NBAD)++;
      }
   }
}

\end{terminalv}

The above file could be processed using tyhe command:

\begin{terminalv}
% generic ccg8_um3.cdr
\end{terminalv}

to create output file \verb+ccg8_um3.c+ containing expanded versions of
the above code for HDS data types \_DOUBLE and \_REAL.


\section{Generic C programming}

Two tools are provided for generic C programming. Which one to use
depends on the nature of the C source code:

\begin{itemize}
\item If the C source code contains functions that are designed to be
called from Fortran using the macros in the \verb+f77.h+  header file provided
by the \CNFref\ package, then the same \GENERIC\ utility should be
used that is used to process Fortran source file (described in the
previous section).
\item Otherwise the recipe described in the rest of this section should
be used. Note that in this case we use the C preprocessor to create the
necessary code, not the \GENERIC\ utility. Clearly there are many ways to
do this task, what is presented here is just a standardized method tuned
for working with Starlink libraries.
\end{itemize}

First create your generic code routines. These actually go into an include
file that is conventionally named with extension \texttt{.cgen}. There are several
macros defined for use when defining generic functions.

\begin{itemize}
\item \texttt{CGEN\_BAD}
\item \texttt{CGEN\_FUNCTION}
\item \texttt{CGEN\_HDS\_TYPE}
\item \texttt{CGEN\_MAX}
\item \texttt{CGEN\_MIN}
\item \texttt{CGEN\_PRM\_TYPE}
\item \texttt{CGEN\_TYPE}
\end{itemize}

You need to use \texttt{CGEN\_FUNCTION} as part of the normal function
declaration so that generic forms of the function name can be generated on
inclusion. Each routine in a generic include file should start:

\begin{terminalv}
return_type CGEN_FUNCTION(function_name) ( arg decs )
\end{terminalv}

So a routine called \texttt{kpg1\_bad} that returned an int and accepted a
\texttt{CGEN\_CTYPE} pointer, called \texttt{value}, would be defined as:

\begin{terminalv}
    int CGEN_FUNCTION(kpg1_bad) (CGEN_CTYPE *value) {
        if ( value[0] == CGEN_BAD ) {
           return 1;
        }
        return 0;
    }
\end{terminalv}

with the trivial job of testing the first element of an array against the BAD
value constant.

The value of \texttt{CGEN\_TYPE} will be set to the C type, that is
\texttt{double}, \texttt{float}, \texttt{int}, \texttt{short int},
\texttt{unsigned short int}, \texttt{char} and \texttt{unsigned char}, as
appropriate.

The value of \texttt{CGEN\_BAD} will be set to one of the \PRIMDAT\ constants
\texttt{VAL\_\_BADD},
\texttt{VAL\_\_BADR},
\texttt{VAL\_\_BADI},
\texttt{VAL\_\_BADW},
\texttt{VAL\_\_BADUW},
\texttt{VAL\_\_BADB} or
\texttt{VAL\_\_BADUB}
as appropriate, and the value of \texttt{CGEN\_HDS\_TYPE} will be set to the HDS
type, one of
\texttt{\_DOUBLE},
\texttt{\_REAL},
\texttt{\_INTEGER},
\texttt{\_WORD},
\texttt{\_UWORD},
\texttt{\_BYTE} or
\texttt{\_UBYTE}.

Now create a C file to includes the generic code. The include file is included
once for each of the data types you want to support (this file can also
contain related non-generic code).  To do this define the macro
\texttt{CGEN\_CODE\_TYPE} to be one of the values:

\begin{terminalv}
    CGEN_DOUBLE_TYPE, CGEN_FLOAT_TYPE, CGEN_INT_TYPE, CGEN_WORD_TYPE,
    CGEN_UWORD_TYPE, CGEN_BYTE_TYPE, CGEN_UBYTE_TYPE
\end{terminalv}

which selects the data type. Then include the file \texttt{cgeneric\_defs.h}
followed by your generic include file, (called \texttt{mygenerics.cgen} in the
following example):

\begin{terminalv}
#include <prm_par.h>
#include <cgeneric.h>

#define CGEN_CODE_TYPE CGEN_DOUBLE_TYPE
#include "cgeneric_defs.h"
#include "mygenerics.cgen"
#undef CGEN_CODE_TYPE

#define CGEN_CODE_TYPE CGEN_INT_TYPE
#include "cgeneric_defs.h"
#include "mygenerics.cgen"
#undef CGEN_CODE_TYPE
\end{terminalv}

when compiled this will generate code for \texttt{double precision}
and \texttt{integer} versions of the generic functions defined in
\texttt{mygeneric.cgen}.

When you want to call the generic forms of a function, the name you supply to
the \texttt{CGEN\_FUNCTION} macro has one of character codes \texttt{D}, \texttt{F},
\texttt{I}, \texttt{W}, \texttt{UW},  \texttt{B}, and \texttt{UB} appended.  So for our
example \texttt{kpg1\_bad}, we have the two functions \texttt{kpg1\_badD} and
\texttt{kpg1\_badI}.

See the comments in the include files for descriptions of the other macros.

\section{Features of the GENERIC Utility}

\subsection{The KERNEL Tokens}

The following tokens are recognised by the \GENERIC\ utility:

\newlength{\numlen}
\settowidth{\numlen}{000000000000}
\settowidth{\labelsep}{000}

\begin{list}{}{%\setlength{\labelwidth}{\numlen}%\setlength{\leftmargin}{\numlen}
\addtolength{\leftmargin}{\labelsep}}

\item[\texttt{$<$T$>$}] To be replaced by a single character representation
of the specified type.

\item[\texttt{$<$TYPE$>$}] To be replaced by the string used to declare variables
of the specified type when they are passed as arguments to
the subroutine.

\item[\texttt{$<$LTYPE$>$}] To be replaced by the string used to declare variables
of the specified type when they are defined as local variables
in the subroutine.

\item[\texttt{$<$CONST$>$}] To be replaced by the string appended to numeric
constants of the specified type.

\item[\texttt{$<$HTYPE$>$}] To be replaced by the \HDSref\ name for the specified
type.

\item[\texttt{$<$COMM$>$}] To be replaced by a comment describing the specified type
in plain English.

\end{list}

A full table of the translation of these tokens for each variable type
is given in
\latexelsehtml{Appendix~\ref{ap_a}}{the
\htmlref{token translations}{ap_a}}
at the end of this document.

\subsection{The ASTERIX Tokens}

As well as the kernel tokens, there are an additional set of
tokens which will be translated if the \texttt{-a} option is specified
with the \GENERIC\ command (see below).

These tokens are available to allow \GENERIC\ to process existing
\ASTERIXref\ software (SUN/98) which uses them.
They are \emph{not}\ recommended for use by new software.
A list of the \ASTERIX\ tokens is given in
\latexelsehtml{Appendix~\ref{ap_a}}{the
\htmlref{token translations}{ap_a}}.

\subsection{The Local CHARACTER Size}

The \verb+<LTYPE>+ token is used for declaring a variable which is local
to the subroutine in which it is used, whereas \verb+<TYPE>+ is used
to declare a variable which is passed to the routine as an argument.
In practice, the translation for both of these tokens is identical
for all types except CHARACTER.

In the CHARACTER type, a variable passed as an argument is declared
CHARACTER*(*), but a local variable is declared CHARACTER*\verb+<CHASIZ>+.
\verb+<CHASIZ>+ is replaced by the ``local character size.''
If not told otherwise, \GENERIC\ will replace \verb+<CHASIZ>+ by 200,
making local character variables CHARACTER*200.

It is possible to override this default character size
if it is unsuitable.  You can define the environment4 variable
GENERIC\_CHASIZ or you can use the \texttt{-c} flag on the
\textbf{generic} command.

\subsection{The Fortran Maximum Record Length}

The \GENERIC\ utility assumes it is dealing with Fortran 77
source code which cannot go beyond column 72.
If the substitution of a token results in a line becoming longer
than 72 characters, it will be broken automatically at column 72
and continued on the next line, using a ``:'' continuation character
in column 6 of the next line.

It is recommended that source lines in generic routines be kept
well below 72 characters in length to prevent this from happening.

\textbf{NOTE:}~\textit{Comment lines (~{\rm i.e.} those beginning `C', `c', `D', `d'
or `*') which are longer than 72 characters are unaltered by \GENERIC.
So are lines of code with an in-line comment (~\emph{i.e.} those containing
a ``!'' character).}

This algorithm is not perfect and it is possible to fool it with end
of line comments on long lines or exclamation marks in character
strings.  However, this seems not to have proven a problem in practice.

\section{Using the GENERIC Utility}

The \GENERIC\ utility is executed by typing the following command:

\begin{terminalv}
% generic [-t <types>] [-a] [-c <chasiz>] [-s] [-sc <char>] [-u] [-x]
           file1 [file2...]}
\end{terminalv}

Arguments in square brackets are optional and items in angle brackets are
descriptive terms for the actual string that would be given.  The simplest form
of the \textbf{generic} command is:

\begin{terminalv}
% generic prog.gen
\end{terminalv}

which will produce a file called \texttt{prog.f} containing routines for
all of the supported data types.  Likewise for C

\begin{terminalv}
% generic prog.cgen
\end{terminalv}
will create a file \texttt{prog.c}.

A softlink called \textbf{fgeneric} is also provided to avoid a clash
with the IRAF generic preprocessor.

All generic input Fortran files must have a suffix of \texttt{.gen}, or
\texttt{.g}\verb+<types>+ where \verb+<types>+ is a list of data types
(see option \texttt{-t} below for a list).  The latter was introduced to
simplify building using GNU tools, and is the recommended naming
convention.  For C files the file extension should be \texttt{.cgen}.

You can specify multiple input files explicitly or with wild cards.
All output Fortran files have a suffix of \texttt{.f}, and output C files
have suffix \texttt{.c}.

The \textbf{generic} command accepts the following command-line options.

\begin{description}

\item[-t] This must be followed by a list of the data types to be
processed. The list should be separated from the \texttt{-t} by a space,
and should consist of one or more of the letters \texttt{a, b, B, c, d, i, l,
n, r, w or W}.  The letters have the following meanings:
\begin{center}
\begin{tabular}{ll}
\texttt{a} & all data types \\
\texttt{b} & BYTE \\
\texttt{B} & unsigned BYTE \\
\texttt{c} & CHARACTER \\
\texttt{d} & DOUBLE PRECISION \\
\texttt{i} & INTEGER \\
\texttt{l} & LOGICAL \\
\texttt{n} & all numeric types (\emph{i.e.} everything except CHARACTER and LOGICAL)\\
\texttt{r} & REAL \\
\texttt{w} & WORD (\emph{i.e.} INTEGER*2) \\
\texttt{W} & unsigned WORD \\
\end{tabular}
\end{center}

For example, to generate routines for all of the standard Fortran numeric data
types, type the command:

\begin{terminalv}
% generic -t dir prog.gen
\end{terminalv}

(Using \texttt{n} instead of \texttt{dir} would generate byte and word versions as
well.)

\item[-c] This should be followed by a space and then an integer
giving the value of the local character size required.  The default
value is 200. This value can be specified by the environment variable
\texttt{GENERIC\_CHASIZ}.  If \texttt{GENERIC\_CHASIZ} is defined and the
\texttt{-c} argument is present, the \texttt{-c} argument takes precedence.

\item[-s] Generate the output in separate files for each data type
with the single character type specifier appended to the base name of
the file.  The default is to generate one output file for each input
file.  For example, if the input file is \texttt{sub1.gen} and the \texttt{-t} flag is set to \texttt{dir}, then specifying the \texttt{-s} flag will
cause output files called \texttt{sub1d.f}, \texttt{sub1i.f} and \texttt{sub1r.f} to be generated.  This option is provided as it is usual on
Unix systems to have all Fortran routines in separate source files.

\item[-sc] This flag allows the user to specify one or more characters
that will be used to separate the base file name from the appended
character when generating separate output files for each data type.
The \texttt{-sc} should be followed by a space and then the character(s)
to be used as the separator.  For example, the command:

\begin{terminalv}
% generic -t dir -sc _ func2.gen
\end{terminalv}

will generate files called \texttt{func2\_d.f}, \texttt{func2\_i.f} and \texttt{func2\_r.f}.  If the \texttt{-sc} flag is given, then the \texttt{-s} flag can be
omitted.

\item[-a] This will cause the \ASTERIX\ tokens to be interpreted as well as the
standard ones.  Its use is deprecated.

\item[-u]  The B and W types substitute \texttt{ub} and \texttt{uw} tokens
respectively in the code and in generated filenames.  This is for
compability with the original VMS version when most generic routines were
developed.  However, note that the \texttt{-t} values of BW should still be
used to obtain unsigned byte and unsigned-word instantiations.

\item[-x]  Removes the last \texttt{x} from the file name before generating the
names of the output files.  This is provided for compatability
with early generic files in the VMS era files that had a final \texttt{x} in the
name to indicate where the token would be replaced in the
instantiated files.  In modern usage the trailing \texttt{x} is absent, and
this option is not required.

\end{description}

It is possible to specify the list of data types to be processed and the local
character size by setting environment variables \texttt{GENERIC\_TYPES} and \texttt{GENERIC\_CHASIZ}, \emph{e.g.}

\begin{terminalv}
% setenv GENERIC_TYPES cdilr
% setenv GENERIC_CHASIZ 300
\end{terminalv}

\section{Data Type Conversions---the DCV Routines}

\subsection{Introduction}

Occasionally, it may be necessary to convert data passed into a
generic routine in a generic variable into another data type. A
general set of conversion functions was originally provided within
\GENERIC\ to make this possible.  However, \emph{new code requiring such
conversions should invoke the \PRIMDATref\ library of functions}.
\PRIMDAT\ also provides many other instrinsic functions that are
amenable to inclusion in generic code.  This section remains
only to interpret legacy code that still calls DCV routines.

A naming convention is used so that the function
DCV\_\verb+<T1>TO<T2>+ converts data type \verb+<T1>+ into \verb+<T2>+.

The functions which can be are defined using Fortran statement
functions in a file which may be included in a program by

\begin{terminalv}
INCLUDE 'DCV_FUN'
\end{terminalv}

which should come after any data type definitions, but before
any DATA initialisation or executable code.
In the standard prologue of SGP/16, it should go in the
``Internal References'' section.

Conversions which cannot be defined as statement functions are
provided as external functions in an object library (\texttt{/star/lib/dcv.a} on a Starlink system).  Programs requiring these
functions should be compiled

\begin{terminalv}
% f77 prog.f -L/star/lib `dcv_link`
\end{terminalv}

on Unix.

The types of these functions can be declared in a program by including

\begin{terminalv}
INCLUDE 'DCV_EXT'
\end{terminalv}

(in the ``External References'' section of the standard prologue).

\textbf{NOTE:}~\emph{Statement functions are considerably faster than external
functions, so programs which use the common conversions defined in `DCV\_FUN'
will execute a lot faster.}

Only numeric conversions are supported at present, and
there are no DCV\_ functions for conversions involving CHARACTER and
LOGICAL data types.
A full list of the functions, the conversion performed, and their
location and restrictions, is given in
\latexelsehtml{Appendix~\ref{ap_b}}{the
\htmlref{conversion functions}{ap_b}}.

\subsection{An Example of Data Type Conversion}

As an example, a generic subroutine for finding the mean of the data
contained in an array, where the array is of varying type but the mean is
always REAL, might look like the following routine.

\begin{terminalv}
          SUBROUTINE MEAN<T>( N, ARRAY, MEAN )
    *+
    *  Name:
    *     MEAN<T>
    *  Purpose:
    *     Calculate the mean value contained in a <COMM> array.
    *  Invocation :
    *     CALL MEAN<T>( N, ARRAY, MEAN )
    *  Description :
    *     This calculates the mean value of then data contained in the given
    *     <COMM> array, and returns the value in the REAL variable MEAN.
    *  Arguments:
    *     N = INTEGER( Given )
    *        The dimension of the array.
    *     ARRAY( N ) = <TYPE>( Given )
    *        The array containing the data to be averaged.
    *     MEAN = REAL( Returned )
    *        The mean of the values contained in the array.
    *                   "
    *     (the rest of the standard prologue)
    *                   "
    *  Type Definitions:
          IMPLICIT NONE
    *  Arguments Given:
          INTEGER N
          <TYPE> ARRAY( N )
    *  Arguments Returned:
          REAL MEAN
    *  External References:
          INCLUDE 'DCV_EXT'          ! Data conversion external functions
    *  Local Variables:
          INTEGER I                  ! Array index
          <LTYPE> SUM                ! Sum of the data in the array
    *  Internal References:
          INCLUDE 'DCV_FUN'          ! Data conversion statement functions
    *-

    *  Initialise the sum to zero.
          SUM = 0<CONST>

    *  Accumulate the sum of the contents of the array.
          DO I = 1, N
            SUM = SUM + ARRAY( N )
          END DO

    *  Divide by the dimension of the array to obtain the mean, using
    *  DCV_<T>TOR to convert from <COMM> into REAL.
          MEAN = DCV_<T>TOR( SUM ) / REAL( N )

          END
\end{terminalv}

In the above example, for the INTEGER version of the routine for
instance, the \texttt{DCV\_ITOR(~SUM~)} statement will be converted to
\texttt{REAL(~SUM~)} by the statement function in \texttt{DCV\_FUN}.

\subsection{Range Checking}

The DCV\_\verb+<T1>+TO\verb+<T2>+ functions will not check the range of the
values given to them, and overflow errors are possible from some conversions
(\emph{e.g.} INTEGER to BYTE).
It is recommended that an application check the range of any value
given to a DCV function, to ensure it is within the allowed range.
Global parameters of the form DCV\_\_\verb+<T>+MIN and DCV\_\_\verb+<T>+MAX
are available for this purpose, which give the allowed range for type
\verb+<T>+ (\emph{e.g.} $-128$ to $+127$ for a BYTE).
These by may included in a program using the following line.

\begin{terminalv}
INCLUDE 'DCV_PAR'
\end{terminalv}

(in the ``Global Parameters'' section of the standard prologue).

Here is an example of the use of these parameters (for instance
converting an INTEGER to another type).

\begin{terminalv}
    *             "
    *     (standard prologue)
    *             "
    *  Global Parameters:
          INCLUDE 'DCV_PAR'          ! DCV global parameters giving allowed
                                     ! ranges
    *             "
    *  External References:
          INCLUDE 'DCV_EXT'          ! DCV external function definitions
    *             "
    *  Local Variables:
          INTEGER IVAL               ! Integer value to be converted
          <TYPE> VAL                 ! Destination variable of type <COMM>
                    "
    *  Internal References:
          INCLUDE 'DCV_FUN'          ! DCV in-line statement functions
    *-
                  "
                  "
          IF ( ( IVAL .GE. DCV__<T>MIN ) .AND.
         :     ( IVAL .LE. DCV__<T>MAX ) ) THEN

    *  Value within range. The conversion is allowed.
             VAL = DCV_ITO<T>( IVAL )

          ELSE

    *  Error. Value out of range ...
             <take appropriate action>
          END IF
                  "
                  "
\end{terminalv}

Note that ranges are only provided for numeric data types.

An alternative (and easier) way of preventing numerical overflow from
causing problems is to use the \PRIMDAT\ routines instead of the
DCV ones.  The \PRIMDAT\ routines will not crash your program if an
overflow occurs.  See \xref{SUN/39}{sun39}{} for details.

\appendix
\newpage
\section{\xlabel{ap_a}A Full Table of F77 Token Translations\label{ap_a}}

This appendix gives the translations of all the tokens
made by \GENERIC\ for each of the data types.
If a translation is illegal, the result will be ``?''
(and \GENERIC\ will give a warning message).

Additional substitutions are made if the input file is a C source file,
described in \latexelsehtml{Appendix~\ref{ap_c}}
{the \htmlref{C token translations}{ap_c}}.


To produce the BYTE version of a program, the following substitutions
are made.
\begin{quote}
%bytekernal
\begin{tabular}{lll}
\multicolumn{3}{l}{\bf{Kernel} tokens (translated by default):} \\
\hline
TOKEN  & SUBSTITUTE  & COMMENT \\
\\
$<$T$>$       & \texttt{"B"}       &\emph{Subroutine name extension} \\
$<$TYPE$>$    & \texttt{"BYTE"}    &\emph{Argument type definition} \\
$<$LTYPE$>$   & \texttt{"BYTE"}    &\emph{Local type definition} \\
$<$CONST$>$   & \texttt{" "}       &\emph{String to be appended to constant} \\
$<$HTYPE$>$   & \texttt{"\_BYTE"}  &\emph{\HDSref\ type} \\
$<$COMM$>$    & \texttt{"BYTE"}    &\emph{Comment describing type} \\
\end{tabular}

\begin{tabular}{lll}
\multicolumn{3}{l}{\bf{ASTERIX} tokens (translated when \texttt{-a} is specified):} \\
%byteasterix
\hline
TOKEN  &SUBSTITUTE  & COMMENT \\
\\
$<$CONV$>$    & \texttt{" "} &\emph{BYTE to REAL conversion} \\
$<$EXT$>$     & \texttt{" "} &\emph{BYTE to REAL conversion extension} \\
$<$BRAK$>$    & \texttt{" "} &\emph{Brackets for BYTE to REAL conversion} \\
$<$ICONV$>$   & \texttt{" "} &\emph{BYTE to INTEGER conversion} \\
$<$IEXT$>$    & \texttt{" "} &\emph{BYTE to INTEGER conversion extension} \\
$<$IBRAK$>$   & \texttt{" "} &\emph{Brackets for BYTE to INTEGER conversion} \\
$<$REV$>$     & \texttt{" "} &\emph{REAL to BYTE conversion} \\
$<$RVBRAK$>$  & \texttt{" "} &\emph{Brackets for REAL to BYTE conversion} \\
$<$IREV$>$    & \texttt{" "} &\emph{INTEGER to BYTE conversion} \\
$<$IRVBRAK$>$ & \texttt{" "} &\emph{Brackets for INTEGER to BYTE conversion} \\
\end{tabular}
\end{quote}

To produce the UNSIGNED BYTE version of a program, the following
substitutions are made.
\begin{quote}
%usbytekernal
\begin{tabular}{lll}
\multicolumn{3}{l}{\bf{Kernel} tokens (translated by default):} \\
\hline
TOKEN     &SUBSTITUTE     &COMMENT \\
\\
$<$T$>$       &\texttt{"UB"}     &\emph{Subroutine name extension} \\
$<$TYPE$>$    &\texttt{"BYTE"}   &\emph{Argument type definition} \\
$<$LTYPE$>$   &\texttt{"BYTE"}   &\emph{Local type definition} \\
$<$CONST$>$   &\texttt{" "}      &\emph{String to be appended to constant}\\
$<$HTYPE$>$   &\texttt{"\_UBYTE"}  &\emph{\HDS\ type} \\
$<$COMM$>$    &\texttt{"UNSIGNED BYTE"} &\emph{Comment describing type} \\
\end{tabular}

%usbyteasterix
\begin{tabular}{lll}
\multicolumn{3}{l}{\bf{ASTERIX} tokens (translated when \texttt{-a} is specified):} \\
\hline
TOKEN     &SUBSTITUTE     &COMMENT \\
\\
$<$CONV$>$  &\texttt{"REAL("} &\emph{UNSIGNED BYTE to REAL conversion} \\
$<$EXT$>$   &\texttt{"ZEXT("} &\emph{UNSIGNED BYTE to REAL conversion extension}\\
$<$BRAK$>$  &\texttt{"))"} &\emph{Brackets for UNSIGNED BYTE to REAL conversion}\\
$<$ICONV$>$ &\texttt{"INT("}  &\emph{UNSIGNED BYTE to INTEGER conversion} \\
$<$IEXT$>$  &\texttt{"ZEXT("} &\emph{UNSIGNED BYTE to INTEGER conversion extension}\\
$<$IBRAK$>$   &\texttt{"))"}    &\emph{Brackets for UNSIGNED BYTE to INTEGER conversion}\\
$<$REV$>$     &\texttt{"NINT("} &\emph{REAL to UNSIGNED BYTE conversion} \\
$<$RVBRAK$>$  &\texttt{")"}     &\emph{Brackets for REAL to UNSIGNED BYTE conversion} \\
$<$IREV$>$    &\texttt{" "} &\emph{INTEGER to UNSIGNED BYTE conversion} \\
$<$IRVBRAK$>$ &\texttt{" "} &\emph{Brackets for INTEGER to UNSIGNED BYTE conversion}\\
\end{tabular}
\end{quote}

To produce the CHARACTER version of a program, the following
substitutions are made.
\begin{quote}
%cHarkernal
\begin{tabular}{lll}
\multicolumn{3}{l}{\bf{Kernel} tokens (translated by default):} \\
\hline
TOKEN      &SUBSTITUTE     & COMMENT \\
\\
$<$T$>$     &\texttt{"C"}             &\emph{Subroutine name extension} \\
$<$TYPE$>$  &\texttt{"CHARACTER*(*)"} &\emph{Argument type definition} \\
$<$LTYPE$>$ &\texttt{"CHARACTER*$<$CHASIZ$>$"} &\emph{Local type definition (CHASIZ = 200 by default)} \\
$<$CONST$>$ &\texttt{"?"}            &\emph{String to be appended to constant} \\
$<$HTYPE$>$ &\texttt{"\_CHAR"}       &\emph{\HDS\ type} \\
$<$COMM$>$  &\texttt{"CHARACTER"}    &\emph{Comment describing type} \\
\end{tabular}

%charasterix
\begin{tabular}{lll}
\multicolumn{3}{l}{\bf{ASTERIX} tokens (translated when \texttt{-a} is specified):} \\
\hline
TOKEN      &SUBSTITUTE     & COMMENT \\
\\
$<$CONV$>$  &\texttt{"?"} &\emph{CHARACTER to REAL conversion}\\
$<$EXT$>$   &\texttt{"?"} &\emph{CHARACTER to REAL conversion extension}\\
$<$BRAK$>$  &\texttt{"?"} &\emph{Brackets for CHARACTER to REAL conversion}\\
$<$ICONV$>$ &\texttt{"?"} &\emph{CHARACTER to INTEGER conversion}\\
$<$IEXT$>$  &\texttt{"?"} &\emph{CHARACTER to INTEGER conversion extension}\\
$<$IBRAK$>$ &\texttt{"?"} &\emph{Brackets for CHARACTER to INTEGER conversion} \\
$<$REV$>$   &\texttt{"?"} &\emph{REAL to CHARACTER conversion} \\
$<$RVBRAK$>$ &\texttt{"?"} &\emph{Brackets for REAL to CHARACTER conversion}\\
$<$IREV$>$  &\texttt{"?"} &\emph{INTEGER to CHARACTER conversion}\\
$<$IRVBRAK$>$ &\texttt{"?"} &\emph{Brackets for INTEGER to CHARACTER conversion} \\
\end{tabular}
\end{quote}

To produce the DOUBLE PRECISION version of a program, the following
substitutions are made.
\begin{quote}
%dpkernal
\begin{tabular}{lll}
\multicolumn{3}{l}{\bf{Kernel} tokens (translated by default):} \\
\hline
TOKEN     &SUBSTITUTE  &COMMENT \\
\\
$<$T$>$     &\texttt{"D"}               &\emph{Subroutine name extension}\\
$<$TYPE$>$  &\texttt{"DOUBLE PRECISION"}&\emph{Argument type definition}\\
$<$LTYPE$>$ &\texttt{"DOUBLE PRECISION"}&\emph{Local type definition}\\
$<$CONST$>$ &\texttt{".0D0"}            &\emph{String to be appended to constant} \\
$<$HTYPE$>$ &\texttt{"\_DOUBLE"}        &\emph{\HDS\ type}\\
$<$COMM$>$  &\texttt{"DOUBLE PRECISION"}&\emph{Comment describing type}\\
\end{tabular}

%dpasterix
\begin{tabular}{lll}
\multicolumn{3}{l}{\bf{ASTERIX} tokens (translated when \texttt{-a} is specified):}\\
\hline
TOKEN  &SUBSTITUTE  &COMMENT \\
\\
$<$CONV$>$ &\texttt{"SNGL("} &\emph{DOUBLE PRECISION to REAL conversion}\\
$<$EXT$>$  &\texttt{" "}     &\emph{DOUBLE PRECISION to REAL conversion extension}\\
$<$BRAK$>$ &\texttt{")"}     &\emph{Brackets for DOUBLE PRECISION to REAL conversion}\\
$<$ICONV$>$ &\texttt{"NINT("} &\emph{DOUBLE PRECISION to INTEGER conversion}\\
$<$IEXT$>$  &\texttt{" "}   &\emph{DOUBLE PRECISION to INTEGER conversion extension}\\
$<$IBRAK$>$ &\texttt{")"} &\emph{Brackets for DOUBLE PRECISION to INTEGER conversion}\\
$<$REV$>$   &\texttt{"DBLE("} &\emph{REAL to DOUBLE PRECISION conversion}\\
$<$RVBRAK$>$ &\texttt{")"}    &\emph{Brackets for REAL to DOUBLE PRECISION conversion}\\
$<$IREV$>$  &\texttt{"DBLE("} &\emph{INTEGER to DOUBLE PRECISION conversion}\\
$<$IRVBRAK$>$ &\texttt{")"} &\emph{Brackets for INTEGER to DOUBLE PRECISION conversion}\\
\end{tabular}
\end{quote}

To produce the INTEGER version of a program, the following substitutions
are made.
\begin{quote}
%intkernal
\begin{tabular}{lll}
\multicolumn{3}{l}{\bf{Kernel} tokens (translated by default):}\\
\hline
TOKEN  &SUBSTITUTE   &COMMENT\\
\\
$<$T$>$     &\texttt{"I"}         &\emph{Subroutine name extension}\\
$<$TYPE$>$  &\texttt{"INTEGER"}   &\emph{Argument type definition}\\
$<$LTYPE$>$ &\texttt{"INTEGER"}   &\emph{Local type definition}\\
$<$CONST$>$ &\texttt{" "}         &\emph{String to be appended to constant}\\
$<$HTYPE$>$ &\texttt{"\_INTEGER"} &\emph{\HDS\ type}\\
$<$COMM$>$  &\texttt{"INTEGER"}   &\emph{Comment describing type}\\
\end{tabular}

%intasterix
\begin{tabular}{lll}
\multicolumn{3}{l}{\bf{ASTERIX} tokens (translated when \texttt{-a} is specified).}\\
\hline
TOKEN  &SUBSTITUTE   &COMMENT\\
\\
$<$CONV$>$     &\texttt{"REAL("} &\emph{INTEGER to REAL conversion}\\
$<$EXT$>$      &\texttt{" "}   &\emph{INTEGER to REAL conversion extension}\\
$<$BRAK$>$     &\texttt{")"}     &\emph{Brackets for INTEGER to REAL conversion}\\
$<$ICONV$>$    &\texttt{" "}     &\emph{INTEGER to INTEGER conversion}\\
$<$IEXT$>$     &\texttt{" "}     &\emph{INTEGER to INTEGER conversion extension}\\
$<$IBRAK$>$    &\texttt{" "}     &\emph{Brackets for INTEGER to INTEGER conversion}\\
$<$REV$>$      &\texttt{"NINT("} &\emph{REAL to INTEGER conversion}\\
$<$RVBRAK$>$   &\texttt{")"}     &\emph{Brackets for REAL to INTEGER conversion}\\
$<$IREV$>$     &\texttt{" "}     &\emph{INTEGER to INTEGER conversion}\\
$<$IRVBRAK$>$  &\texttt{" "}     &\emph{Brackets for INTEGER to INTEGER
conversion}\\
\end{tabular}
\end{quote}

To produce the LOGICAL version of a program, the following substitutions
are made.
\begin{quote}
%logkernal
\begin{tabular}{lll}
\multicolumn{3}{l}{\bf{Kernel} tokens (translated by default):}\\
\hline
TOKEN      &SUBSTITUTE      &COMMENT \\
\\
$<$T$>$        &\texttt{"L"}         &\emph{Subroutine name extension}\\
$<$TYPE$>$     &\texttt{"LOGICAL"}   &\emph{Argument type definition}\\
$<$LTYPE$>$    &\texttt{"LOGICAL"}   &\emph{Local type definition}\\
$<$CONST$>$    &\texttt{" "}         &\emph{String to be appended to constant}\\
$<$HTYPE$>$    &\texttt{"\_LOGICAL"} &\emph{\HDS\ type}\\
$<$COMM$>$     &\texttt{"LOGICAL"}   &\emph{Comment describing type}\\
\end{tabular}

%logasterix
\begin{tabular}{lll}
\multicolumn{3}{l}{\bf{ASTERIX} tokens (translated when \texttt{-a} is specified).}\\
\hline
TOKEN      &SUBSTITUTE      &COMMENT\\
\\
$<$CONV$>$     &\texttt{"?"} &\emph{LOGICAL to REAL conversion}\\
$<$EXT$>$      &\texttt{"?"} &\emph{LOGICAL to REAL conversion extension}\\
$<$BRAK$>$     &\texttt{"?"} &\emph{Brackets for LOGICAL to REAL conversion}\\
$<$ICONV$>$    &\texttt{"?"} &\emph{LOGICAL to INTEGER conversion}\\
$<$IEXT$>$     &\texttt{"?"} &\emph{LOGICAL to INTEGER conversion extension}\\
$<$IBRAK$>$    &\texttt{"?"} &\emph{Brackets for LOGICAL to INTEGER conversion}\\
$<$REV$>$      &\texttt{"?"} &\emph{REAL to LOGICAL conversion}\\
$<$RVBRAK$>$   &\texttt{"?"} &\emph{Brackets for REAL to LOGICAL conversion}\\
$<$IREV$>$     &\texttt{"?"} &\emph{INTEGER to LOGICAL conversion}\\
$<$IRVBRAK$>$  &\texttt{"?"} &\emph{Brackets for INTEGER to LOGICAL conversion}\\
\end{tabular}
\end{quote}

To produce the REAL version of a program, the following substitutions
are made.
\begin{quote}
%realkernal
\begin{tabular}{lll}
\multicolumn{3}{l}{\bf{Kernel} tokens (translated by default):}\\
\hline
TOKEN      &SUBSTITUTE      &COMMENT\\
\\
$<$T$>$     &\texttt{"R"}     &\emph{Subroutine name extension}\\
$<$TYPE$>$  &\texttt{"REAL"}  &\emph{Argument type definition}\\
$<$LTYPE$>$ &\texttt{"REAL"}  &\emph{Local type definition}\\
$<$CONST$>$ &\texttt{".0E0"}  &\emph{String to be appended to constant}\\
$<$HTYPE$>$ &\texttt{"\_REAL"} &\emph{\HDS\ type}\\
$<$COMM$>$  &\texttt{"REAL"}  &\emph{Comment describing type}\\
\end{tabular}

\begin{tabular}{lll}
%realasterix
\multicolumn{3}{l}{\bf{ASTERIX} tokens (translated when \texttt{-a} is specified).}\\
\hline
TOKEN      &SUBSTITUTE      &COMMENT\\
\\
$<$CONV$>$     &\texttt{" "}     &\emph{REAL to REAL conversion}\\
$<$EXT$>$      &\texttt{" "}     &\emph{REAL to REAL conversion extension}\\
$<$BRAK$>$     &\texttt{" "}  &\emph{Brackets for REAL to REAL conversion}\\
$<$ICONV$>$    &\texttt{"NINT("} &\emph{REAL to INTEGER conversion}\\
$<$IEXT$>$     &\texttt{" "}  &\emph{REAL to INTEGER conversion extension}\\
$<$IBRAK$>$    &\texttt{")"} &\emph{Brackets for REAL to INTEGER conversion}\\
$<$REV$>$      &\texttt{" "}     &\emph{REAL to REAL conversion}\\
$<$RVBRAK$>$   &\texttt{" "}   &\emph{Brackets for REAL to REAL conversion}\\
$<$IREV$>$     &\texttt{"REAL("} &\emph{INTEGER to REAL conversion}\\
$<$IRVBRAK$>$  &\texttt{")"} &\emph{Brackets for INTEGER to REAL conversion}\\
\end{tabular}
\end{quote}

To produce the WORD version of a program, the following substitutions
are made.
\begin{quote}
%wordkernal
\begin{tabular}{lll}
\multicolumn{3}{l}{\bf{Kernel} tokens (translated by default):}\\
\hline
TOKEN      &SUBSTITUTE     &COMMENT\\
\\
$<$T$>$     &\texttt{"W"}         &\emph{Subroutine name extension}\\
$<$TYPE$>$  &\texttt{"INTEGER*2"} &\emph{Argument type definition}\\
$<$LTYPE$>$ &\texttt{"INTEGER*2"} &\emph{Local type definition}\\
$<$CONST$>$ &\texttt{" "}         &\emph{String to be appended to constant}\\
$<$HTYPE$>$ &\texttt{"\_WORD"}    &\emph{\HDS\ type}\\
$<$COMM$>$  &\texttt{"WORD"}      &\emph{Comment describing type}\\
\end{tabular}

%wordasterix
\begin{tabular}{lll}
\multicolumn{3}{l}{\bf{ASTERIX} tokens (translated when \texttt{-a} is specified).}\\
\hline
TOKEN      &SUBSTITUTE      &COMMENT\\
\\
$<$CONV$>$     &\texttt{"REAL("} &\emph{WORD to REAL conversion}\\
$<$EXT$>$      &\texttt{" "}     &\emph{WORD to REAL conversion extension}\\
$<$BRAK$>$     &\texttt{")"}   &\emph{Brackets for WORD to REAL conversion}\\
$<$ICONV$>$    &\texttt{" "}     &\emph{WORD to INTEGER conversion}\\
$<$IEXT$>$     &\texttt{" "}   &\emph{WORD to INTEGER conversion extension}\\
$<$IBRAK$>$    &\texttt{" "} &\emph{Brackets for WORD to INTEGER conversion}\\
$<$REV$>$      &\texttt{"NINT("} &\emph{REAL to WORD conversion}\\
$<$RVBRAK$>$   &\texttt{")"}  &\emph{Brackets for REAL to WORD conversion}\\
$<$IREV$>$     &\texttt{" "}     &\emph{INTEGER to WORD conversion}\\
$<$IRVBRAK$>$  &\texttt{" "} &\emph{Brackets for INTEGER to WORD conversion}\\
\end{tabular}
\end{quote}

To produce the UNSIGNED WORD version of a program, the following
substitutions are made.
\begin{quote}
%uswordkernal
\begin{tabular}{lll}
\multicolumn{3}{l}{\bf{Kernel} tokens (translated by default):}\\
\hline
TOKEN      &SUBSTITUTE     &COMMENT\\
\\
$<$T$>$     &\texttt{"UW"}            &\emph{Subroutine name extension}\\
$<$TYPE$>$  &\texttt{"INTEGER*2"}     &\emph{Argument type definition}\\
$<$LTYPE$>$ &\texttt{"INTEGER*2"}     &\emph{Local type definition}\\
$<$CONST$>$ &\texttt{" "}         &\emph{String to be appended to constant}\\
$<$HTYPE$>$ &\texttt{"\_UWORD"}       &\emph{\HDS\ type}\\
$<$COMM$>$  &\texttt{"UNSIGNED WORD"} &\emph{Comment describing type}\\
\end{tabular}

\begin{tabular}{lll}
%uswordasterix
\multicolumn{3}{l}{\bf{ASTERIX} tokens (translated when \texttt{-a} is specified).}\\
\hline
TOKEN      &SUBSTITUTE      &COMMENT\\
\\
$<$CONV$>$     &\texttt{"REAL("} &\emph{UNSIGNED WORD to REAL conversion}\\
$<$EXT$>$      &\texttt{"ZEXT("} &\emph{UNSIGNED WORD to REAL conversion extension}\\
$<$BRAK$>$     &\texttt{"))"}    &\emph{Brackets for UNSIGNED WORD to REAL conversion}\\
$<$ICONV$>$    &\texttt{" "}     &\emph{UNSIGNED WORD to INTEGER conversion}\\
$<$IEXT$>$     &\texttt{"ZEXT("} &\emph{UNSIGNED WORD to INTEGER conversion extension}\\
$<$IBRAK$>$    &\texttt{")"}     &\emph{Brackets for UNSIGNED WORD to INTEGER conversion}\\
$<$REV$>$      &\texttt{"NINT("} &\emph{REAL to UNSIGNED WORD conversion}\\
$<$RVBRAK$>$   &\texttt{")"}     &\emph{Brackets for REAL to UNSIGNED WORD conversion}\\
$<$IREV$>$     &\texttt{" "}     &\emph{INTEGER to UNSIGNED WORD conversion}\\
$<$IRVBRAK$>$  &\texttt{" "}     &\emph{Brackets for INTEGER to UNSIGNED WORD conversion}\\
\end{tabular}
\end{quote}

\newpage

\section{\xlabel{ap_b}A Full List of Conversion Functions\label{ap_b}}

This appendix gives the conversion functions which are available using
the DCV utility, and describes which ones are statement functions and
which ones are external.

The following conversions are defined as in-line statement functions in
`DCV\_FUN'. (They are either trivial, or are mentioned in the Fortran
manual as legal conversions).
\begin{quote}
\begin{tabular}{lll}
\textbf{Function name} & \bf {Conversion} \\
\hline
DCV\_BTOB   &BYTE to BYTE \\
DCV\_UBTOUB &UNSIGNED BYTE to UNSIGNED BYTE \\
DCV\_UBTOD  &UNSIGNED BYTE to DOUBLE PRECISION \\
DCV\_DTOD   &DOUBLE PRECISION to DOUBLE PRECISION \\
DCV\_ITOD   &INTEGER to DOUBLE PRECISION \\
DCV\_RTOD   &REAL to DOUBLE PRECISION \\
DCV\_WTOD   &WORD to DOUBLE PRECISION \\
DCV\_UWTOD  &UNSIGNED WORD to DOUBLE PRECISION \\
DCV\_UBTOI  &UNSIGNED BYTE to INTEGER \\
DCV\_DTOI   &DOUBLE PRECISION to INTEGER \\
DCV\_ITOI   &INTEGER to INTEGER \\
DCV\_RTOI   &REAL to INTEGER \\
DCV\_UWTOI  &UNSIGNED WORD to INTEGER \\
DCV\_UBTOR  &UNSIGNED BYTE to REAL \\
DCV\_DTOR   &DOUBLE PRECISION to REAL \\
DCV\_ITOR   &INTEGER to REAL \\
DCV\_RTOR   &REAL to REAL \\
DCV\_WTOR   &WORD to REAL \\
DCV\_UWTOR  &UNSIGNED WORD to REAL \\
DCV\_UBTOW  &UNSIGNED BYTE to WORD \\
DCV\_DTOW   &DOUBLE PRECISION to WORD       &*** \\
DCV\_RTOW   &REAL to WORD                   &*** \\
DCV\_WTOW   &WORD to WORD \\
DCV\_UBTOUW &UNSIGNED BYTE to UNSIGNED WORD \\
DCV\_UWTOUW &UNSIGNED WORD to UNSIGNED WORD \\
\end{tabular}
\end{quote}

Overflow errors are possible from the conversions marked ``***''

\newpage

The following conversions are also defined as in-line statement functions in
`DCV\_FUN'. However, they are not mentioned in the Fortran manual and should be
used with caution. Trial and error has shown that the Fortran compliers on all
Starlink supported systems will make the conversions successfully :-

\begin{quote}
\begin{tabular}{lll}
\textbf{Function name}      &\textbf{Conversion} \\
\hline
DCV\_UBTOB &UNSIGNED BYTE to BYTE          &*** \\
DCV\_DTOB  &DOUBLE PRECISION to BYTE       &*** \\
DCV\_ITOB  &INTEGER to BYTE                &*** \\
DCV\_RTOB  &REAL to BYTE                   &*** \\
DCV\_WTOB  &WORD to BYTE                   &*** \\
DCV\_UWTOB &UNSIGNED WORD to BYTE          &*** \\
DCV\_BTOD  &BYTE to DOUBLE PRECISION \\
DCV\_BTOI  &BYTE to INTEGER \\
DCV\_WTOI  &WORD to INTEGER \\
DCV\_BTOR  &BYTE to REAL \\
DCV\_BTOW  &BYTE to WORD \\
DCV\_ITOW  &INTEGER to WORD                &*** \\
\end{tabular}
\end{quote}

Overflow errors are possible from the conversions marked ``***''

The following conversions are defined as external
functions in the DCV object library :-

\begin{quote}
\begin{tabular}{ll}
\textbf{Function name}     &\textbf{Conversion}\\
\hline
DCV\_BTOUB  &BYTE to UNSIGNED BYTE \\
DCV\_DTOUB  &DOUBLE PRECISION to UNSIGNED BYTE \\
DCV\_ITOUB  &INTEGER to UNSIGNED BYTE \\
DCV\_RTOUB  &REAL to UNSIGNED BYTE \\
DCV\_WTOUB  &WORD to UNSIGNED BYTE \\
DCV\_UWTOUB &UNSIGNED WORD to UNSIGNED BYTE \\
DCV\_BTOUW  &BYTE to UNSIGNED WORD \\
DCV\_UBTOUW &UNSIGNED BYTE to UNSIGNED WORD \\
DCV\_DTOUW  &DOUBLE PRECISION to UNSIGNED WORD \\
DCV\_ITOUW  &INTEGER to UNSIGNED WORD \\
DCV\_RTOUW  &REAL to UNSIGNED WORD \\
DCV\_WTOUW  &WORD to UNSIGNED WORD \\
\end{tabular}
\end{quote}

Overflow errors are possible in ALL these conversions, so range checking is
essential.

\appendix
\newpage
\section{\xlabel{ap_C}C Token Translations\label{ap_c}}

This appendix gives the extra translations for use within C sources files
that define functions intended to be called from Fortran:

\begin{quote}
\begin{tabular}{lll}
\multicolumn{3}{l}{\bf{Kernel} tokens (translated by default):}\\
\hline
TOKEN          &COMMENT\\
\\
$<$TC$>$       &\emph{Upper case C function name extension - D, I, F etc}\\
$<$TLC$>$      &\emph{Lower case subroutine name extension - d, i, c etc}\\
$<$CNFTYPE$>$  &\emph{CNF data type - DOUBLE, INTEGER, CHARACTER etc}\\
$<$CTYPE$>$    &\emph{C data type - double, int, char $*$ etc}\\
\end{tabular}

\end{quote}



\end{document}
