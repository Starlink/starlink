#+
#  Name:
#     smurf_makemap.def

#  Purpose:
#     Default parameters for SMURF application MAKEMAP.

#  Description:
#     This file specifies default values for all parameters for the
#     MAKEMAP iterative map-maker. The main purpose of this file is
#     to define the complete list of all legal parameters, with initial
#     values. Users will be notified if they specify parameter names that
#     are not included in this file. This helps to guard against spelling
#     mistakes, etc, on the part of the user.

#  Notes:
#     - The parameters are listed in alphabetical order in this file.
#     - Different defaults can be specified for 450 and 850 um by
#     including the parameter name twice, prefixed with "450." and "850."

#  Authors:
#     TIMJ: Tim Jenness (JAC, Hawaii)
#     DSB: David Berry (JAC, Hawaii)

#  History:
#     2010-05-05 (TIMJ):
#        Original version.
#     2010-05-12 (DSB):
#        Added com.gain_is_one
#     2010-06-08 (EC):
#        Added two.amap, two.bmap
#     2010-06-13 (DSB):
#        Added com.offset_is_zero
#     2010-12-13 (DSB):
#        Added dump_lonlat
#     2012-02-24 (DSB):
#        Added COM zero masking options.
#     2013-02-07 (DSB):
#        This file is now the primary source of documentation for these
#        parameters. It has been reformatted to enable automatic documentation.
#     2014-07-17 (DSB):
#        Added memcheck.
#     2015-03-09 (DSB):
#        Modified to ensure that the defaults in this file match those
#        provided by dimmconfig.lis.
#     2015-11-19 (GSB):
#        Update description to ext.tausrc to metion "csofit" and "wvmfit".
#-

#  Include parameters defined in other files...
^$SMURF_DIR/smurf_sc2clean.def
^$SMURF_DIR/smurf_extinction.def


#-----------------------------------------------------------------
#  Name: 	ast.filt_diff
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Reduces spurious large scale structure in the final map - an
#               experimental alternative or addition to AST masking
#  Description: If ast.filt_diff is non-zero, the map created at the end
#               of each iteration is modified by removing any large scale
#               structures that have been introduced by the iteration.
#               Such structures are a natural outcome of the iterative
#               process and often take the form of ripples on the scale
#               of the FLT filter size that get stronger with each
#               iteration.
#
#               If "ast.filt_diff" is non-zero it gives the size of the
#               largest features to be retained, in arc-sconds. At the
#               end of each iteration the difference is taken between the
#               new map and the previous map. This difference is filtered
#               using a sharp-edged high-pass filter, of size specified
#               by "ast.filt_diff". The remaining high frequencies (i.e.
#               small structures that have been introduced by the new
#               iteration) are added back onto the map created by the
#               previous iteration. This modified map is then used, instead
#               of the original map, to define the AST model.
ast.filt_diff = 0

#-----------------------------------------------------------------
#  Name: 	ast.mapspike
#  Type: 	real
#  Default: 	10.0
#  Purpose: 	Removes spikes from the map.
#  Description: If ast.mapspike is non-zero, spikes in the time-series
#		residuals will be identified by looking at the spread of
#		residual values that contribute to each map pixel. Any
#		residuals that are above ast.mapspike standard deviations
#		from the mean value in the pixel are flagged as spikes.
#               Parameter "ast.mapspike_freeze" can be used to control
#               the number of iterations for which this de-spiking is
#               applied.
ast.mapspike = 10

#-----------------------------------------------------------------
#  Name: 	ast.mapspike_freeze
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Indicates when to stop flagging extra spikes in the map.
#  Description: If ast.mapspike_freeze is non-zero, then the map-based
#               de-spiking process (see parameter "ast.mapspike") is only
#               applied for a limited number of iterations. No further
#               spikes are then flagged, but spikes flagged on previous
#               iterations remain flagged. The limit may be specified
#               either as an integer number of iterations (in which case
#               the supplied value is incremented by the value of
#               parameter "ast.skip"), or as a normalised map-change
#               value in the range 0.0 to 1.0 (not including the limits).
#               In this case, the check on the normalised map-change will
#               not be performed until the iterations specified by
#               parameter "ast.skip" have been performed. If zero is
#               supplied, spikes are flagged on all iterations.
ast.mapspike_freeze = 0.0

#-----------------------------------------------------------------
#  Name: 	ast.skip
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Skip subtraction of astronomical signal.
#  Description: If ast.skip is non-zero, it gives the number of initial
#               iterations for which no AST model (astronomical signal)
#               should be subtracted. A map is still formed at the end of
#               these iterations but the astronomical signal implied by this
#               map is not removed from the residuals (neither is it added
#               back prior to forming the next map). This means that the
#               residuals at the start of each of these iterations are
#               unchanging and essentially equal to the cleaned raw data.
#               The value supplied for parameter "numiter" should therefore
#               be greater than the value of "ast.skip".
#
#               This option is useful, for instance, when using SNR-based
#               masking for the FLT and/or COM models, since it allows a
#               reasonable mask to be formed before subtracting off the
#               first estimate of the astronommical signal.
#
#               If ast.skip is set to a negative value, it gives the
#               largest number of iterations to perform and indicates
#               that the AST model should be skipped on all of them. In
#               this case the value supplied for parameter "numiter" is
#               ignored.
ast.skip = 0

#-----------------------------------------------------------------
#  Name: 	ast.zero_accum
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Prevents unstable SNR masks halting convergence.
#  Description: Masks defined by SNR limits can show instabilities in which
#               pixels can repeatedly enter the mask on one iteration and
#               leave it on the next. Such oscillating pixels tend to
#               occur around the edges of source areas in the mask, and
#               can prevent convergence of the iterative map-making process.
#               Setting AST.ZERO_ACCUM to a non-zero value can prevent
#               this by forcing source pixels to be accumulated rather
#               than replaced on successive iterations. Thus, if
#               AST.ZERO_ACCUM is non-zero, any map pixel which is flagged
#               as a source pixel on some iteration will never be
#               unflagged - once a source pixel, always a souce pixel.
ast.zero_accum = 0

#-----------------------------------------------------------------
#  Name: 	ast.zero_circle
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Reduces spurious large scale structure in the final map
#		outside a circle of given radius.
#  Description: Using ast.zero_circle defines a circle on the map outside
#		of which the map will be constrained to zero on each
#               iteration (but see parameter "ast.zero_notlast"). If a value
#		is supplied for this parameter, it can be a single real value,
#		or a comma-separated list of three real values in parentheses.
#		If one value is supplied, it should be the radius of the
#		circle in decimal degrees (the centre of the circle defaults
#		to the coordinates at the tangent point of the map). If three
#		values are supplied they should be the central longitude,
#		latitude and radius of the circle, in decimal degrees, in the
#		coordinate system of the map (e.g., RA and Dec.).
ast.zero_circle = <undef>

#-----------------------------------------------------------------
#  Name: 	ast.zero_freeze
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Prevent the AST mask from changing after a given number
#		of iterations. This can help convergence.
#  Description: If ast.zero_freeze is 1.0 or more, the AST mask will be
#               frozen after the specified number of iterations (the
#               nearest integer value is used). Note, any initial iterations
#               specified by parameter "ast.skip" are not included in the
#               count of iterations. If ast.zero_freeze is greater than
#               zero but less than 1.0, the AST mask will be frozen when
#               the normalized change in the map between iterations drops
#               below the ast.zero_freeze value. A value less than zero
#               means that the mask is frozen as soon as the initial
#               iterations specified by parameter "ast.skip" have been
#               done. A value equal to zero means that the mask is never
#               frozen.
ast.zero_freeze = 0.0

#-----------------------------------------------------------------
#  Name: 	ast.zero_lowhits
#  Type: 	real
#  Default: 	0
#  Purpose: 	Reduces spurious large scale structure in the final map
#		in regions containing few data samples.
#  Description: Using ast.zero_lowhits causes the map to be forced to
#		zero in regions where the number of samples falling in
#		each pixel is less than ast.zero_lowhits times the mean
#               number of samples per pixel, averaged over the map. A
#               value of zero means that no masking of low hits regions
#		is performed. The mask is updated on each iteration.
ast.zero_lowhits = 0

#-----------------------------------------------------------------
#  Name: 	ast.zero_mask
#  Type: 	integer or string
#  Default: 	0
#  Purpose: 	Reduces spurious large scale structure in the final map
#		within fixed regions specified by an external mask.
#  Description: If ast.zero_mask is set to one of "REF", "MASK2" or
#		"MASK3" then an NDF will be obtained using the specified
#		ADAM parameter (REF, MASK2 or MASK3) and used as a
#		user-defined mask. Setting ast.zero_mask to an integer value
#		larger than zero has the same effect as setting it to "REF".
#		Setting it to an integer less than or equal to zero results
#		in no external mask being used with the AST model. Note,
#		using "REF" ensures that the mask and the output image of
#		MAKEMAP are on the same pixel grid - using "MASK2" or "MASK3"
#		does not provide this guarantee (it is then the users
#		responsibility to ensure that the supplied masks are aligned
# 		with the output image in pixel coordinates). The pixels in
#		the map that are to be constrained to 0 should be set to the
#		bad value in the mask. All other pixels will be allowed to
#		vary during map-making.
ast.zero_mask = 0

#-----------------------------------------------------------------
#  Name: 	ast.zero_niter
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Allows AST masking to be switched off after a given
#		number of iterations.
#  Description: If ast.zero_niter is non-zero, it determines the number
#		of iterations for which the AST model should be masked.
#		Subsequent iterations are not masked. A value of zero
#		means "mask on all iterations". However, if parameter
#		"ast.zero_notlast" is set, the mask will will not be
#		applied on the last iteration, even if ast.zero_niter
#		is zero. This feature will probably be useful for deep
#		point-source observations for which the large-scale noise
#		is not as important, but keeping as much data around the
#		edges of the map is. Note, any initial iterations
#               specified by parameter "ast.skip" are not included in
#               the count of iterations. If ast.zero_niter is greater than
#               zero but less than 1.0, the AST mask will be used until
#               the normalized change in the map between iterations drops
#               below the ast.zero_freeze value.
ast.zero_niter = 0

#-----------------------------------------------------------------
#  Name: 	ast.zero_notlast
#  Type: 	int
#  Default: 	1
#  Purpose: 	Allows flux to be present in masked areas in the final map.
#  Description: If ast.zero_notlast is 1, then the map is not masked on
# 		the final iteration. This means that data samples that fall
#            	outside the masked areas are allowed to remain in the final
#               map. If ast.zero_notlast is 0, then the map is masked even on
#               the final iteration, meaning that the masked areas will
#		be zero in the final map.
ast.zero_notlast = 1

#-----------------------------------------------------------------
#  Name: 	ast.zero_snr
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Reduces spurious large scale structure in the final map
#		within regions of low signal-to-noise.
#  Description: The ast.zero_snr parameter will mask the map after each
#		iteration based on the the signal to noise ratio within
#		each map pixel. For example, if it is set to 5, after each
#		iteration all map pixels with an SNR below this threshold
#		will be forced to zero. the mask is re-evaluated on each
#		iteration. An ast.zero_snr value of zero means no SNR mask
#		is used. See also parameter "ast.zero_snr_ffclean".
ast.zero_snr = 0.0

#-----------------------------------------------------------------
#  Name: 	ast.zero_snr_ffclean
#  Type: 	int
#  Default: 	0
#  Purpose: 	Provides alternative method for SNR masking.
#  Description: Setting this parameter to a non-zero value causes the
#               SNR mask requested by parameter "ast.zero_snr" to be
#               created using an algorithm like that used by the KAPPA
#               command "FFCLEAN" (see SUN/95), instead of using a simple
#               thresholding of the SNR map. The parameter "ast.zero_snr"
#               gives the clipping level of the ffclean algorithm, and the
#               parameter "ast.zero_snr_hipass" gives the box size. Using
#               an ffclean algorithm prevents the source regions within
#               the mask being larger than the box size, and may thus
#               produce faster convergence and avoid blobs developing.
ast.zero_snr_ffclean = 0

#-----------------------------------------------------------------
#  Name: 	ast.zero_snr_hipass
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Flatten map before making SNR mask
#  Description: Setting this parameter to a positive value causes the
#               SNR mask requested by parameter "ast.zero_snr" to be
#               based on a copy of the SNR map that has been high-pass
#               filtering to remove structures larger than the number of
#               arc-seconds given by ast.zero_snr_hipass. This will in
#               general reduce the number of source pixels in the mask.
#               See also parameter "ast.zero_snr_ffclean".
ast.zero_snr_hipass = 0.0

#-----------------------------------------------------------------
#  Name: 	ast.zero_snr_lopass
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Smooths map before making SNR mask
#  Description: Setting this parameter to a positive value causes the
#               SNR mask requested by parameter "ast.zero_snr" to be
#               based on a copy of the SNR map that has been low-pass
#               filtering (i.e smoothed) to remove noise and other
#               features smaller than the number of map pixels given
#               by ast.zero_snr_lopass. This may help to prevent pixels
#               oscillating in and out of the mask on successive
#               iterations, and thus aid smoother convergence.
ast.zero_snr_lopass = 0.0

#-----------------------------------------------------------------
#  Name: 	ast.zero_snr_fwhm
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Can help to remove bowls around sources.
#  Description: If ast.zero_snr_fwhm is non-zero, the map-maker produces
#           	two maps: the first is created normally using the mask
#		specified by parameter "ast.zero_snr". The final SNR-based
#		mask associated with this map is then smoothed using a
#		Gaussian with FWHM equal to the ast.zero_snr_fwhm value (in
#		arcsec). The whole iterative map-making process is then
#		run again from the start, using this smoothed mask on every
#		iteration, to create the final map. Consequently, setting
#		ast.zero_snr_fwhm causes the time taken to create the final
#		map to nearly double.
ast.zero_snr_fwhm = 0

#-----------------------------------------------------------------
#  Name: 	ast.zero_snr_low
#  Type: 	real
#  Default: 	-1.1
#  Purpose: 	Can help to remove bowls around sources.
#  Description: The ast.zero_snr_low parameter gives the value (in the range
#		0.0 to 1.0) at which to threshold the smoothed mask specified
#		by parameter "ast.zero_snr_fwhm". If it is negative, the value
#		is taken as the max smoothed value of a blob containing
#		"ast.zero_snr_low" pixels. Thus a value of "-1.1" will cut at
#		a height just sufficient to remove blobs of a single pixel
#		form the mask. A value of "-2.1" would remove blobs of two
#		pixels form the mask, etc.
ast.zero_snr_low = -1.1

#-----------------------------------------------------------------
#  Name: 	ast.zero_snrlo
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Can help to remove bowls around sources by increasing the
#		size of the SNR mask without introducing noise.
#  Description: If values are supplied for ast.zero_snrlo and
#		parameter "ast.zero_snr", then the basic mask created by
#		thresholding at the SNR value specified by ast.zero_snr is
#		modified by expanding each un-masked "source" area down to
#		an SNR equal to ast.zero_snrlo, without introducing any new
#		isolated source areas. The ast.zero_snrlo should be lower
#		than the ast.zero_snr value.
ast.zero_snrlo = <undef>

#-----------------------------------------------------------------
#  Name: 	ast.zero_union
#  Type: 	integer
#  Default: 	1
#  Purpose: 	Controls how multiple AST masks are combined.
#  Description: If more than one AST mask is specified (for instance, if
#		values are supplied for both parameter "ast.zero_lowhits"
#		and parameter "ast.zero_snr"), then they are combined
#		into a single mask. If ast.zero_union is true (i.e.
#		non-zero), then the source region in the combined mask is
#		the union of the source regions in the individual masks.
#		If ast.zero_union is false (i.e. zero), then the source
#		region in the combined mask is the intersection of the
#		source regions in the individual masks.
ast.zero_union = 1

#-----------------------------------------------------------------
#  Name: 	bolomap
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Create NDFs holding the map made form each bolometer.
#  Description: If non-zero, a separate map will be created from each
#		individual bolometer. These maps are placed in the BOLOMAPS
#		component of the SMURF extension in the main output map.
bolomap = 0

#-----------------------------------------------------------------
#  Name: 	chitol
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Specifies when to stop iterating.
#  Description: If the difference in reduced chi^2 between subsequent
#		iterations falls below the value of chitol, then the map-maker
#		performs one more iteration and then terminates. Only used if
#		parameter "numiter" is negative. Parameter "maptol" provides
#		an alternative (and usually better) termination criterion.
chitol = <undef>

#-----------------------------------------------------------------
#  Name: 	chunkweight
#  Type: 	real or string
#  Default: 	1.0
#  Purpose: 	Specifies a relative weight for each continuous chunk
#  Description: This parameter specifies the weight to use for each
#               chunk of continuous time series data that goes into the
#               final map. These weights are used when the maps made
#               from the individual chunks are combined together to form
#               the total map. They can be specified in two ways: 1) The
#               "chunkweight" parameter can be set to an arbitrary
#               algebraic expression in which the variable names are the
#               names of FITS keyword. The keyword must be present in the
#               FITS extension of the input data and must have numerical
#               values. The expression should be enclosed in double quotes.
#               The value of the expression using the FITS keywords values
#               for a chunk will then be used as the weight for that
#               chunk. 2) A comma-separated list of explicit numerical values
#               can be supplied. The list must be enclosed in parentheses.
#               The last value in the list will be replicated if the number
#               of values in the list is smaller than the number of chunks.
#               Thus, the default value of 1.0 will cause a weight of 1.0 to
#               be used for every chunk.
chunkweight = 1.0

#-----------------------------------------------------------------
#  Name: 	com.zero_accum
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Prevents unstable SNR masks halting convergence.
#  Description: Masks defined by SNR limits can show instabilities in which
#               pixels can repeatedly enter the mask on one iteration and
#               leave it on the next. Such oscillating pixels tend to
#               occur around the edges of source areas in the mask, and
#               can prevent convergence of the iterative map-making process.
#               Setting COM.ZERO_ACCUM to a non-zero value can prevent
#               this by forcing source pixels to be accumulated rather
#               than replaced on successive iterations. Thus, if
#               COM.ZERO_ACCUM is non-zero, any map pixel which is flagged
#               as a source pixel on some iteration will never be
#               unflagged - once a source pixel, always a souce pixel.
com.zero_accum = 0

#-----------------------------------------------------------------
#  Name: 	com.zero_circle
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Improves common-mode estimation by excluding sources
#               within a circle of given radius from the COM estimate.
#  Description: Using com.zero_circle causes any samples falling within a
#		specified circle on the map to be excluded from the
#		estimate of the mean signal at each time slice (the
#               common mode, or "COM", signal).
com.zero_circle = <undef>

#-----------------------------------------------------------------
#  Name: 	com.zero_freeze
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Prevent the COM mask from changing after a given number
#		of iterations. This can help convergence.
#  Description: If com.zero_freeze is 1.0 or more, the COM mask will be
#               frozen after the specified number of iterations (the
#               nearest integer value is used). Note, any initial iterations
#               specified by parameter "ast.skip" are not included in the
#               count of iterations. If com.zero_freeze is greater than
#               zero but less than 1.0, the COM mask will be frozen when
#               the normalized change in the map between iterations drops
#               below the com.zero_freeze value. A value less than or
#               equal to zero means that the mask is never frozen.
com.zero_freeze = 0.0

#-----------------------------------------------------------------
#  Name: 	com.zero_lowhits
#  Type: 	real
#  Default: 	0
#  Purpose: 	Improves common-mode estimation by excluding sources
#		in regions containing many data samples.
#  Description: Using com.zero_lowhits causes samples to be excluded from
#               the estimation of the common mode if they fall in regions
#               of the map where the number of samples falling in each
#               pixel is higher than com.zero_lowhits times the mean number
#               of samples per pixel, averaged over the map. A value of
#               zero means that no masking of low hits regions is
#               performed. The mask is updated on each iteration.
com.zero_lowhits = 0

#-----------------------------------------------------------------
#  Name: 	com.zero_mask
#  Type: 	integer or string
#  Default: 	0
#  Purpose: 	Provides a  better estimate of the common-mode ("COM")
#               signal, by excluding samples that fall within fixed
#               regions on the sky specified by an external mask.
#  Description: If com.zero_mask is set to one of "REF", "MASK2" or
#		"MASK3" then an NDF will be obtained using the specified
#		ADAM parameter (REF, MASK2 or MASK3) and used as a
#		user-defined mask. Setting com.zero_mask to an integer value
#		larger than zero has the same effect as setting it to "REF".
#		Setting it to an integer less than or equal to zero results
#		in no external mask being used with the COM model. Note,
#		using "REF" ensures that the mask and the output image of
#		MAKEMAP are on the same pixel grid - using "MASK2" or "MASK3"
#		does not provide this guarantee (it is then the users
#		responsibility to ensure that the supplied masks are aligned
# 		with the output image in pixel coordinates). The pixels in
#		the map that are to be included in the common-mode
#               estimation should be set to the bad value in the mask. All
#               other pixels will be excluded from the COM estimation.
com.zero_mask = 0

#-----------------------------------------------------------------
#  Name: 	com.zero_niter
#  Type: 	int
#  Default: 	0
#  Purpose: 	Allows COM masking to be switched off after a given
#		number of iterations.
#  Description: If com.zero_niter is non-zero, it gives the number of
#		iterations for which the COM model should be masked.
#		Subsequent iterations are not masked. A value of zero
#		means "mask on all iterations". However, if parameter
#		"com.zero_notlast" is set, the mask will will not be applied
#		on the last iteration, even if com.zero_niter is zero.
#               Note, any initial iterations specified by parameter
#               "ast.skip" are not included in the count of iterations.
com.zero_niter = 0

#-----------------------------------------------------------------
#  Name: 	com.zero_notlast
#  Type: 	int
#  Default: 	1
#  Purpose: 	Prevent COM masking being performed on the last iteration.
#  Description: If com.zero_notlast is 1, then the COM model is not masked on
# 		the final iteration. This means that data samples that fall
#            	inside the masked areas are include in the estimate of
#               the common-mode signal. This should make little difference
#               since the astronomical signal should have been removed by
#               then.
com.zero_notlast = 1

#-----------------------------------------------------------------
#  Name: 	com.zero_snr
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Improve the estimate of the common-mode by excluding samples
#               that correspond to high SNR pixels in the map.
#  Description: Setting the com.zero_snr parameter will exclude samples from
#               the COM estimate that fall within map pixels with SNR values
#               greater than com.zero_snr. A com.zero_snr value of zero means
#               no SNR mask is used. See also parameter "com.zero_snr_ffclean".
#
#               Note, the SNR values are only available once a map has been
#               created, and so using this parameter results in no COM masking
#               on the first iteration. Consequently the map at the end of the
#               first iteration will have a bowl around any bright sources,
#               since no COM masking was done. Normally, these rings
#               would polute the AST model derived from the map, and thus
#               polute the residuals on the next iteration, resulting in
#               the bowls remaining in later maps. To avoid this, parameter
#               "ast.skip" can be set to a positive value. This causes the
#               AST model to be skipped (i.e. no AST signal is subtracted from
#               the residuals) for the first "ast.skip" iterations. This means
#               that a good COM mask can be formed from these initial iterations
#               before any AST model is calculated and used.
com.zero_snr = 0

#-----------------------------------------------------------------
#  Name: 	com.zero_snr_ffclean
#  Type: 	int
#  Default: 	0
#  Purpose: 	Provides alternative method for SNR masking.
#  Description: Setting this parameter to a non-zero value causes the
#               SNR mask requested by parameter "com.zero_snr" to be
#               created using an algorithm like that used by the KAPPA
#               command "FFCLEAN" (see SUN/95), instead of using a simple
#               thresholding of the SNR map. The parameter "com.zero_snr"
#               gives the clipping level of the ffclean algorithm, and the
#               parameter "com.zero_snr_hipass" gives the box size. Using
#               an ffclean algorithm prevents the source regions within
#               the mask being larger than the box size.
com.zero_snr_ffclean = 0

#-----------------------------------------------------------------
#  Name: 	com.zero_snr_hipass
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	FLatten map before making SNR mask
#  Description: Setting this parameter to a positive value causes the
#               SNR mask requested by parameter "com.zero_snr" to be
#               based on a copy of the SNR map that has been high-pass
#               filtering to remove structures larger than the number of
#               arc-seconds given by com.zero_snr_hipass. This will in
#               general reduce the number of source pixels in the mask.
#               See also parameter "com.zero_snr_ffclean".
com.zero_snr_hipass = 0.0

#-----------------------------------------------------------------
#  Name: 	com.zero_snr_lopass
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Smooths map before making SNR mask
#  Description: Setting this parameter to a positive value causes the
#               SNR mask requested by parameter "com.zero_snr" to be
#               based on a copy of the SNR map that has been low-pass
#               filtering (i.e smoothed) to remove noise and other
#               features smaller than the number of map pixels given
#               by com.zero_snr_lopass. This may help to prevent pixels
#               oscillating in and out of the mask on successive
#               iterations, and thus aid smoother convergence.
com.zero_snr_lopass = 0.0

#-----------------------------------------------------------------
#  Name: 	com.zero_snrlo
#  Type: 	real
#  Default: 	0
#  Purpose: 	Improve estimate of the common-mode by increasing the size
#               of the SNR mask without introducing noise.
#  Description: If values are supplied for com.zero_snrlo and
#		parameter "com.zero_snr", then the basic mask created by
#		thresholding at the SNR value specified by com.zero_snr is
#		modified by expanding each un-masked "source" area down to
#		an SNR equal to com.zero_snrlo, without introducing any new
#		isolated source areas. The com.zero_snrlo should be lower than
#		the com.zero_snr value.
com.zero_snrlo = <undef>

#-----------------------------------------------------------------
#  Name: 	com.zero_union
#  Type: 	integer
#  Default: 	1
#  Purpose: 	Controls how multiple COM masks are combined.
#  Description: If more than one COM mask is specified (for instance, if
#		values are supplied for both parameter "com.zero_lowhits"
#		and parameter "com.zero_snr"), then they are combined
#		into a single mask. If com.zero_union is true (i.e.
#		non-zero), then the source region in the combined mask is
#		the union of the source regions in the individual masks.
#		If com.zero_union is false (i.e. zero), then the source
#		region in the combined mask is the intersection of the
#		source regions in the individual masks.
com.zero_union = 1

#-----------------------------------------------------------------
#  Name: 	diag.append
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Qualifies the required dignostic information.
#  Description: If non-zero, it indicates that diagnostic info should be
# 		appended to the container file specified by parameter
#		"diag.out", which should already exist. If zero, then any
#		existing container file is first deleted before storing new
#		diagnostics information in it. Only used if a value is
#		supplied for diag.out.
diag.append = 0

#-----------------------------------------------------------------
#  Name: 	diag.array
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Qualifies the required dignostic information.
#  Description: The name of the array (S8A, S8B, etc) containing the data to
#		be written out. If <undef>, the first available array is
#		used. Only used if a value is supplied for parameter "diag.out".
diag.array = <undef>

#-----------------------------------------------------------------
#  Name: 	diag.bolo
#  Type: 	integer or string
#  Default: 	WMEAN
#  Purpose: 	Qualifies the required dignostic information.
#  Description: Indicates the bolometer for which diagnostic information
# 		is required (the sub-array is indicated by diag.array).
#		Only used if a value is supplied for parameter "diag.out".
#		It can be:
#
#    		- A pair of integers, separated by a comma, contained in
#    		parentheses, giving the column and row of the bolometer. The
#    		first integer should be in the range 0 to 31, and the second
#    		should be in the range 0 to 39.
#
#    		- A single integer in the range 0 to 1279.
#
#    		- The string "MEAN" (case insensitive), in which case all
#    		unflagged data from all good bolometers is averaged to form
#    		the time-stream to dump.
#
#    		- The string "WMEAN" (case insensitive), in which case all
#    		unflagged data from all good bolometers is averaged using
#    		weights derived from the bolometer noise estimates to form
#    		the time-stream to dump.
#
#    		- The string "TYPICAL" (case insensitive), in which case a
#    		bolometer with typical noise charactersitics is chosen and
#    		used. The index of the chosen bolometer is reported, and
#    		stored in the dumped NDFs.
#
#               - The string "NONE", in which case the output NDFs
#               describing a single bolometer are not produced (maps and
#               cubes may still be produced though - see parameter
#               "diag.map" and parameter "diag.cube").
diag.bolo = WMEAN

#-----------------------------------------------------------------
#  Name: 	diag.cube
#  Type: 	int
#  Default: 	0
#  Purpose: 	Qualifies the required dignostic information.
#  Description: If non-zero, create 3D cubes containing the required
#               residuals or models for all bolometers at each iteration.
#               Warning - this can be a huge amount of data so only use
#               on very short time series (e.g. a single subscan) and for
#		very few iterations. The cubes have names of the form
#		"<where>_<chunk>_cube_<iter>", (see parameter "diag.out").
#		Only used if a value is supplied for diag.out.
diag.cube = 0

#-----------------------------------------------------------------
#  Name: 	diag.lastonly
#  Type: 	int
#  Default: 	0
#  Purpose: 	Qualifies the required dignostic information.
#  Description: If non-zero, diagnotics information is dumped only for
#               the last iteration. Otherwise, information is dumped on
#               all iterations.
diag.lastonly = 0

#-----------------------------------------------------------------
#  Name: 	diag.map
#  Type: 	int
#  Default: 	0
#  Purpose: 	Qualifies the required dignostic information.
#  Description: If non-zero, a 2D map containing the binned time-stream
#               data for all bolometers is created at each iteration, for
#               each required model and set of residuals. These are placed
#               in 2D NDFs with names in the following format:
#               "<where>_<chunk>_map_<it>", where <chunk> and <where> are
#               described above (under "OUT") and <it> is the iteration
#               number. If the "diag.map" value is positive, the map will
#               contain data for just the subarray specified by "diag.array".
#               If "diag.map" is negative, the map will contain data for all
#               available subarrays. Only used if a value is supplied for
#               "diag.out".
diag.map = 0

#-----------------------------------------------------------------
#  Name: 	diag.mask
#  Type: 	int
#  Default: 	0
#  Purpose: 	Qualifies the required dignostic information.
#  Description: If non-zero, then the AST model will be masked using the
# 		current AST mask before being dumped. Otherwise, the AST
# 		model will not be masked before being dumped. Only used if
#		a value is supplied for parameter "diag.out".
diag.mask = 0

#-----------------------------------------------------------------
#  Name: 	diag.mingood
#  Type: 	real
#  Default: 	0.2
#  Purpose: 	Qualifies the required dignostic information.
#  Description: The minimum fraction of good values in a time stream
# 		for which data should be dumped. An error is reported if
# 		the required minimum value is not met. Only used if a
#               value is supplied for parameter "diag.out".
diag.mingood = 0.2

#-----------------------------------------------------------------
#  Name: 	diag.models
#  Type: 	list of strings
#  Default: 	(com,ext,flt,ast,res)
#  Purpose: 	Qualifies the required dignostic information.
#  Description: Indicates the models that are to be written out. It
# 		should be a comma separated list of model names (e.g.
#		COM, FLT, AST, RES, etc) contained within parentheses,
#		or a single model name. A model name of RES here refers
#		to the residuals after subtraction of all models in use
#		(typically COM, FLT and AST). The residuals can also be
#		written out at other times - see diag.res_before and
#		diag.res_after. Only used if a value is supplied for
#		parameter "diag.out".
diag.models = (com,ext,flt,ast,res)

#-----------------------------------------------------------------
#  Name: 	diag.out
#  Type: 	string
#  Default: 	<undef>
#  Purpose: 	Switches on the dumping of various diagnostic information.
#  Description: The full path/name for the HDS container file in which to
# 		store the diagnostic info. This will contain components for
#		each requested model (see parameter "diag.models"), with
#		names like "COM", "FLT", etc. Each of these components will
#		contain multiple NDFs with names in the following format:
#		"<where>_<chunk>_<what>", where <what> is "power" or "time",
# 		<chunk> is the integer chunk index, and <where> is one of:
#
# 		- "bef": the NDF contains the residuals as they were
#		before the model was subtracted.
#
# 		- "mod": the NDF contains the model values themselves.
#
# 		- "aft": the NDF contains the residuals as they were after
#   		the model was subtracted.
#
# 		Each NDF will be 2-dimensional, with the first pixel axis
# 		representing time or frequency, and the second pixel axis
# 		representing iteration number.
diag.out = <undef>

#-----------------------------------------------------------------
#  Name: 	diag.power
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Qualifies the required dignostic information.
#  Description: If non-zero, write out the power spectrum for each
# 		selected model. Only used if a value is supplied for
#		parameter "diag.out".
diag.power = 0

#-----------------------------------------------------------------
#  Name: 	diag.qual
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Qualifies the required dignostic information.
#  Description: If zero, no Quality arrays will be stored in the diagnostic
#               NDFs. Instead, flagged Data values will be set to the
#               starlink bad value. If non-zero, each NDF holding diagnostic
#               information will include a Quality array, and flagged Data
#               values will retain their internal values (i.e. they will
#               not be set to the starlink bad value). This makes the NDF
#               seriously bigger.
diag.qual = 0

#-----------------------------------------------------------------
#  Name: 	diag.res_after
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Qualifies the required dignostic information.
#  Description: If non-zero, then in addition to writing out the
# 		requested models, the residuals are also written out
#		immediately after each requested model is subtracted.
#		Only used if a value is supplied for parameter "diag.out".
diag.res_after = 0

#-----------------------------------------------------------------
#  Name: 	diag.res_before
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Qualifies the required dignostic information.
#  Description: If non-zero, then in addition to writing out the
# 		requested models, the residuals are also written out
#		immediately before each requested model is subtracted.
#		Only used if a value is supplied for parameter "diag.out".
diag.res_before = 0

#-----------------------------------------------------------------
#  Name: 	diag.table
#  Type: 	string
#  Default: 	<undef>
#  Purpose: 	Qualifies the required dignostic information.
#  Description: If supplied, a text file is created with the given name
#               containing a table with columns that hold the
#               bolometer and time slice index (zero-based) of each sample
#               that falls within the map pixel given by parameter
#               "diag.xpix" and parameter "diag.ypix". The table also
#               holds columns for the other quantities requested by the
#               other "diag..." parameters.
diag.table = <undef>

#-----------------------------------------------------------------
#  Name: 	diag.time
#  Type: 	real
#  Default: 	1
#  Purpose: 	Qualifies the required dignostic information.
#  Description: If non-zero, write out the time-series for each
# 		selected model. Only used if a value is supplied for
#		parameter "diag.out".
diag.time = 1

#-----------------------------------------------------------------
#  Name: 	diag.xpix
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Qualifies the required dignostic information.
#  Description: The X pixel index of the map pixel that is to be recorded
#               in the table specified by parameter "diag.table".
diag.xpix = 0

#-----------------------------------------------------------------
#  Name: 	diag.ypix
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Qualifies the required dignostic information.
#  Description: The Y pixel index of the map pixel that is to be recorded
#               in the table specified by parameter "diag.table".
diag.ypix = 0

#-----------------------------------------------------------------
#  Name: 	dks.boxcar
#  Type: 	real
#  Default: 	100
#  Purpose:
#  Description: If set, then low-pass filter dark squid signals using a
#		boxcar filter of this width (but only if the dks model is
#		specified in parameter "modelorder"). The value is in
#		samples (after any downsampling) if it is positive, and in
#		seconds if negative.
dks.boxcar = 100

#-----------------------------------------------------------------
#  Name: 	dks.replacebad
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Controls the DKS model.
#  Description: If non-zero, replace dead dark squids with average of
#		working dark squids.
dks.replacebad = 0

#-----------------------------------------------------------------
#  Name: 	doclean
#  Type: 	integer
#  Default: 	1
#  Purpose: 	Allows pre-cleaned data to be used.
#  Description: Set this to 0 to turn off all data cleaning operations
#		prior to the start of iterative map-making.
doclean = 1

#-----------------------------------------------------------------
#  Name: 	downsampfreq
#  Type: 	real
#  Default: 	0
#  Purpose: 	Controls data down-sampling.
#  Description: Allows the down-sampled frequency to be specified
#		directly in Hz. See parameter "downsampscale".
downsampfreq = 0

#-----------------------------------------------------------------
#  Name: 	downsampscale
#  Type: 	real
#  Default: 	-1
#  Purpose: 	Speeds up map-making, and reduces memory requirements.
#  Description: If the telescope is scanning slowly the data may be
#		safely down-sampled to save memory and time. This parameter
#		controls the minimum angular scale on the sky. The new
#		sample frequency is chosen such that this scale will be
#		preserved taking into account the average slew speed and
# 		the sample rate of the input files. If a positive value is
#		selected, this gives the angular scale (in arcsec) to which
#		the new sample rate will be matched. Alternatively, if a
#		negative value is supplied, its magnitude will be multiplied
#		by the PIXSIZE for the requested map. For example, the default
#		here is to set it to -1 such that the time-series sample rate
#		matches the pixel grid (in practice, a factor of 2 might make
#		more sense as this would correspond to the Nyquist frequency
#		of the map pixel grid).
downsampscale = -1

#-----------------------------------------------------------------
#  Name: 	ensureflat
#  Type: 	integer
#  Default: 	1
#  Purpose: 	Controls flat-fielding of supplied time-series data.
#  Description: Apply the flatfield if loading raw data? Setting this to
#		zero will produce a map in raw DAC units (and you must
# 		also supply raw - i.e. unflat-fielded -  data).
ensureflat = 1

#-----------------------------------------------------------------
#  Name: 	epsin
#  Type: 	string
#  Default: 	<undef>
#  Purpose: 	Aid convergence and image flatness
#  Description: In some cases, each iteration can add a fixed constant
#               "error map" into the astronomical map, which accumulates
#               with each subsequent iteration, preventing convergence
#               and causing strong large-scale structures to appear in
#               the final map (typically ripples on the scale of the FLT
#               filter). This parameter attempts to counteract this by
#               allowing a map to be specified which will be subtracted
#               from the astronomical map at the end of each iteration.
# 		        At present, the dimensions of this map must be identical to
#               those of the real map. See also parameter "epsout".
epsin = <undef>

#-----------------------------------------------------------------
#  Name: 	epsout
#  Type: 	string
#  Default: 	<undef>
#  Purpose: 	Aid convergence and image flatness
#  Description: If a value is supplied for this parameter, an output NDF
#               will be created holding the median of the difference maps
#               created on the three final iterations (a difference map
#               is the difference between the astronoimical maps created
#               on two succesive iterations). This may be suitable for
#               feeding back in using parameter "epsin" on a subsequent
#               run of makemap. Note, currently this parameter may only
#               be used if the data is processed in a single continuous
#               chunk (an error is reported if this is not the case).
epsout = <undef>

#-----------------------------------------------------------------
#  Name: 	exportclean
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Allows the initial cleaned data to examined or saved for
#		later use.
#  Description: If non-zero, the data will be saved to an NDF immediately
#		after data cleaning and before map-making. The NDF name will
#		be the same as model components, except with the suffix
#		"_cln". Even if parameter "doclean" is set to zero, the
#		data will be exported immediately before map-making.
exportclean = 0

#-----------------------------------------------------------------
#  Name: 	exportlonlat
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Export sample sky positions for use with other software.
#  Description: If non-zero, the logitude/latitude of every sample will
#		be exported into a pair of NDFs. The file names will be the
#		same as model components, except with sufficies of "lon"
#       and "lat".
exportlonlat = 0

#-----------------------------------------------------------------
#  Name: 	exportndf
#  Type: 	integer or list of strings
#  Default: 	0
#  Purpose: 	Create NDFs holding final model values.
#  Description: Specify a value of 1 or 0 to export all or none of the
#		model components after the final iteration. You can also
#		specify a comma-separated list of component names, enclosed
#		in parentheses, to be exported. Note that you can specify
#		additional components RES and QUA to what may be provided to
#		parameter "modelorder" if you wish to export the residual
#		model or quality arrays respectively. Exportation of RES is
#		implied if NOI is specified as it becomes the variance
#		component of the resulting NDF for RES. QUA will become the
#		quality component of any full 3-dimensional model (e.g.
#		RES, AST, FLT, EXT), but no quality will be written to model
#		components with different dimensions. Note, since an NDF
#               can only contain 8 quality flags, it may be necessary to
#               compress quality information by combining flags with
#               similar purposes together. To avoid this, it is possible
#               to use parameter "exportqbits" to specify that only a
#               subset of the quality flags be written out t the NDF.
exportndf = 0

#-----------------------------------------------------------------
#  Name: 	exportqbits
#  Type: 	list of strings
#  Default: 	<undef>
#  Purpose: 	Specifies the quality bits to be written out.
#  Description: If the value of parameter "exportndf" includes" RES" or
#               "QUA", then the final quality array is exported to an NDF.
#		An NDF can only contain 8 quality flags, but makemap can
#               sometimes use more than 8 flags internally. The default
#               action in such cases is to combine flags with similar
#               purposes into more general flags in order to reduce the
#               number of used flags to 8 or fewer. This is a lossy
#               process - it is impossible to undo the combination to
#               recover the original flags. However, this can be avoided
#               by using this parameter to specify a list of explicit
#               quality flags to be exported, ensuring that the list
#               contains no more than 8 entries. Any information for
#               flags not in the list will simply be discarded, so choose
#               the flags that you are pf particularly interest to you.
#               If the parameter is left at "<undef>", all quality flags
#               will be exported, with consequent possible lossy compression.
#               Otherwise the parameter should be a comma-separated list
#               of quality names, enclosed in parentheses. Valid quality
#               names are: BADDA, BADB, SPIKE, JUMP, PAD, APOD, STAT, COM,
#               FILT, NOISE, EXT, LOWAP, BADEF, RING, SSN, PCA, IP.
exportqbits = <undef>

#-----------------------------------------------------------------
#  Name: 	ext.csotau
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Controls the extinction values used in the EXT model.
#  Description: Specifies the CSO tau value to be used by the EXT model.
#		If <undef>, the default value to use is derived from the
#		FITS headers. See parameter "ext.tausrc".
ext.csotau = <undef>

#-----------------------------------------------------------------
#  Name: 	ext.filtertau
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Controls the extinction values used in the EXT model.
#  Description: Used if parameter "ext.tausrc" is set to "filtertau". If
#		<undef>, the default value to use is derived from the
#               FITS headers.
ext.filtertau = <undef>

#-----------------------------------------------------------------
#  Name: 	ext.import
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Controls the extinction values used in the EXT model.
#  Description: If non-zero, import the the extinction values to use in
#		the EXT model from an NDF created by a previous run of
#		makemap. The NDF is expected to have the same name as would
#		be created by setting parameter "exportNDF" to "(ext)" in
#		the makemap configuration.
ext.import = 0

#-----------------------------------------------------------------
#  Name: 	ext.taumethod
#  Type: 	string
#  Default: 	adaptive
#  Purpose: 	Controls the extinction values used in the EXT model.
#  Description: The method to use for determing tau. Can be "adaptive",
#		"full" or "quick". See parameter "ext.tausrc".
ext.taumethod = adaptive

#-----------------------------------------------------------------
#  Name: 	ext.tausrc
#  Type: 	string
#  Default: 	auto
#  Purpose: 	Controls the extinction values used in the EXT model.
#  Description: Best is to use WVM, uses continuously varying measurements
#		as a function of time stored with each observation. Allowed
#		values are  "auto", "wvmraw", "wvmfit", "csofit", "csotau"
#		and "filtertau". See EXTINCTION task for further information.
ext.tausrc = auto

#-----------------------------------------------------------------
#  Name: 	fakedelay
#  Type: 	real
#  Default: 	0
#  Purpose: 	Diagnostic tool for checking delays in bolometer time
#		streams.
#  Description: A delay, in seconds, to apply to each fake time stream
#		sampled from the supplied fake map, prior to adding it to
#		the real data. See parameter "delay". The fakedelay value
#		should usually be equal and opposite to the delay value, so
#		that they cancel out, leaving the fake signal unaffected.
#		See parameter "fakemap".
fakedelay = 0.0

#-----------------------------------------------------------------
#  Name: 	fakemap
#  Type: 	string
#  Default: 	<undef>
#  Purpose: 	Diagnostic tool to explore the effects of the map-making
#		process on known sources.
#  Description: To test the response of the map-maker to different known
# 		astronomical sources, an external "fakemap" can be specified
#		to provide an image of the sky that will produce additional
# 		astronomical signal to the time series. At present, the
#		dimensions of this map must be identical to that of the real
#		map. A typical procedure may involve: (i) produce a map with
#		makemap; (ii) produce an image with simulated data with the
#		same pixel dimensions; (iii) specify this new map for the
#		"fakemap" parameter below. Note that this is a fully-parsed
#		ndf identifier, so you can do things like:
#
# 		- fakemap = fakesky.sdf
#
# 		- fakemap = fakesky[1:300,100:450]
fakemap = <undef>

#-----------------------------------------------------------------
#  Name: 	fakemce
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Diagnostic tool for checking effects of MCE filter.
#  Description: If non-zero, the time-series data generated from the fakemap
#		is smoothed using the MCE response. See parameter "fakemap".
#		This should normally be set non-zero if parameter "deconvmce"
#		is set non-zero, so that the fakemap signal is left
#		unaffected by the MCE filter.
fakemce = 0

#-----------------------------------------------------------------
#  Name: 	fakescale
#  Type: 	real
#  Default: 	1
#  Purpose: 	Control the use of the supplied fake map.
#  Description: Each pixel in the supplied fake map (see paramater "fakemap")
#		will be multiplied by this scaling factor before being added
#		to the time stream data.
fakescale = 1

#-----------------------------------------------------------------
#  Name: 	flagmap
#  Type: 	list of strings
#  Default: 	<undef>
#  Purpose: 	Dump diagnostic info about the time series qualities
#  Description: If set to a comma-separated list of quality names, enclosed
#		in parentheses, then an extension called .MORE.SMURF.FLAGMAPS
#		will be created in the output map NDF. This will contain
#		a set of "flagmaps", one for each continuous chunk of
#		time-series data, each containing a count of the number
#		of samples with a quality bit matching at least one of the
#		specified flags. Any of the standard quality names can be
#               specified. These are: BADDA, BADB, SPIKE, JUMP, PAD, APOD,
#               STAT, COM, FILT, NOISE, EXT, LOWAP, BADEF, RING, SSN, PCA,
#               IP.
#
#		Note: If BADBOL is set the behaviour is slightly different than
#		expected; the bolometer will be completely ignored when
#		creating the flag map.
#
#               Alternatively, if the single value "CUBE" is supplied for
#               flagmap, then each created NDF will be 3-dimensional,
#               containing a plane for each individual quality flag. Each
#               pixel in the lowest plane (pixel index -1) will count the
#               number of samples that had no flags set. Each of the
#               remaining planes will count the number of samples that had
#               a specific quality flag set. The planes are stored in the
#               same order in which the quality flags are listed above.
#               Thus, the plane with pixel index 0 will count the number
#               of samples that have the BADDA flag set, and the plane
#               with pixel index 16 will count the number of samples that
#               have the IP flag set
#
# 		The flagmap is mostly useful to verify whether the spike,
#		jump, and common-mode rejection is correlated with features
#		in the map (e.g. bright sources), for all of the detectors
#		that were used to produce the map,
#		e.g. flagmap = (BADBOL,SPIKE,DCJUMP,COM).
flagmap = <undef>

#-----------------------------------------------------------------
#  Name: 	flt.apod
#  Type: 	integer
#  Default: 	<undef>
#  Purpose: 	Control the removal of low frequencies from the time-stream data.
#  Description: The number of samples to apodise at each end of the data
#		stream prior to taking the FFT. If <undef>, a default
#		value is used equal to 1/(steptime*freq) where freq is
#		the lowest edge or notch frequency. Note, apodisation is
#		only performed if parameter "flt.zeropad" is set non-zero.
flt.apod = <undef>

#-----------------------------------------------------------------
#  Name: 	flt.filt_edge_largescale
#  Type: 	real
#  Default: 	600 (for 450 um), 300 (for 850 um)
#  Purpose: 	Specifies the largest scale size to be retained by the
#		FLT model.
#  Description: Together with parameter "flt.filt_edge_smallscale", this
#		specifies the frequencies which the FLT model is to remove
#		from the data streams, based on a range of requested spatial
#		scales (in arcsec), and using internal measurements of
# 		the average slew speed. These will override parameter
#		"flt.filt_edgehigh" and parameter "flt.filt_edgelow". For
#		example, suppose the slew speed is 100 arcsec/sec. We want to
#		ensure that the beam is fully sampled, say 2 arcsec at 450um.
#		That scale is crossed in 2/100 = 0.02 s, so we don't need
#		frequencies in the data above 1/0.02 = 50 Hz in this case
#		(i.e. internally it will set flt.filt_edgelow to 50Hz if
#		flt.filt_edge_smallscale is set to 2 arcsec). Similarly, if
#		we would like to attempt to preserve scales of 10 arcmin =
#		600 arcsec, we would want to keep frequencies that are
#		greater than 1/(600/100.) = 0.17 Hz (i.e. setting
# 		flt.filt_edge_largescale=600 would translate into
#		flt.filt_edgehigh = 0.17 Hz).
450.flt.filt_edge_largescale=600
850.flt.filt_edge_largescale=300

#-----------------------------------------------------------------
#  Name: 	flt.filt_edge_largescale_last
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Specifies the largest scale size to be retained by the
#		FLT model on the last iteration.
#  Description: This is the value to be used for parameter "flt.filt_edge_largescale"
#               on the last iteration. If it is "<undef>", then the same value
#               will be used as for earlier iterations.
flt.filt_edge_largescale_last=<undef>

#-----------------------------------------------------------------
#  Name: 	flt.filt_edge_smallscale
#  Type: 	real
#  Default: 	0
#  Purpose: 	Specifies the smallest scale size to be retained by the
#		FLT model.
#  Description: If non-zero, features with spatial sizes less than this
#		value (in arcsec) will be removed by the FLT model. See
#		parameter "flt.filt_edge_largescale".
flt.filt_edge_smallscale = 0

#-----------------------------------------------------------------
#  Name: 	flt.filt_edge_smallscale_last
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Specifies the smallest scale size to be retained by the
#		FLT model on the last iteration.
#  Description: This is the value to be used for parameter "flt.filt_edge_smallscale"
#               on the last iteration. If it is "<undef>", then the same value
#               will be used as for earlier iterations.
flt.filt_edge_smallscale_last=<undef>

#-----------------------------------------------------------------
#  Name: 	flt.filt_edgehigh
#  Type: 	real
#  Default: 	0
#  Purpose: 	Specifies the lowest frequency to be retained by the FLT model.
#  Description: If non-zero, this is the cut-off frequency of a hard-edged
#		high pass filter that is applied to the data stream as
#		part of the FLT model. See also parameter
#		"flt.filt_edge_largescale".
flt.filt_edgehigh = 0

#-----------------------------------------------------------------
#  Name: 	flt.filt_edgehigh_last
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Specifies the lowest frequency to be retained by the FLT model
#               on the last iteration.
#  Description: This is the value to be used for parameter "flt.filt_edgehigh"
#               on the last iteration. If it is "<undef>", then the same value
#               will be used as for earlier iterations.
flt.filt_edgehigh_last = <undef>

#-----------------------------------------------------------------
#  Name: 	flt.filt_edgelow
#  Type: 	real
#  Default: 	0
#  Purpose: 	Specifies the highest frequency to be retained by the FLT model.
#  Description: If non-zero, this is the cut-off frequency of a hard-edged
#		low pass filter that is applied to the data stream as
#		part of the FLT model. See also parameter
#		"flt.filt_edge_largescale".
flt.filt_edgelow = 0

#-----------------------------------------------------------------
#  Name: 	flt.filt_edgelow_last
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Specifies the highest frequency to be retained by the FLT model
#               on the last iteration.
#  Description: This is the value to be used for parameter "flt.filt_edgelow"
#               on the last iteration. If it is "<undef>", then the same value
#               will be used as for earlier iterations.
flt.filt_edgelow_last = <undef>

#-----------------------------------------------------------------
#  Name: 	flt.filt_order
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Indicates the shape of the filter.
#  Description: If flt.filt_order is zero or negative, a the edge filters
#               defined by the other "flt.filt_..." parameters are hard-edged.
#		That is, they change from zero to one without any intermediate
#		values. If flt.filt_order is larger than zero, the edge
#		filters are soft-edged Butterworth filters with order
#               given by the value of this parameter. An order of 1 is
#               the softest, and will thus produce least ringing, at the
#               expense of poorer frequency response. Higher orders
#               produce sharper filters that have better frequency response
#               but at the expense of greater ringing.
flt.filt_order = 0

#-----------------------------------------------------------------
#  Name: 	flt.filt_order_last
#  Type: 	integer
#  Default: 	<undef>
#  Purpose: 	Indicates the shape of the filter on the last iteration.
#  Description: This is the value to be used for parameter "flt.filt_order"
#               on the last iteration. If it is "<undef>", then the same value
#               will be used as for earlier iterations.
flt.filt_order_last = <undef>

#-----------------------------------------------------------------
#  Name: 	flt.filt_notchhigh
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Specifies additional frequencies to be removed by the FLT model.
#  Description: Together with parameter "flt.filt_notchlow", this parameter
#		specifies a set of 1 or more hard-edge band-cut frequency-domain
#		notch filters, specifying additional frequencies to be removed
#		by the FLT model. The flt.filt_notchhigh value should be a
#		comma-separated list of frequencies in Hz, enclosed in
#		parentheses. These are the frequencies of the upper edges
#		of the notch filters. The flt.filt_notchlow and
#		flt.filt_notchhigh parameters should contain the same
#		number of frequencies.
flt.filt_notchhigh = <undef>

#-----------------------------------------------------------------
#  Name: 	flt.filt_notchhigh_last
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Specifies additional frequencies to be removed by the FLT model
#               on the last iteration.
#  Description: This is the value to be used for parameter "flt.filt_notchhigh"
#               on the last iteration. If it is "<undef>", then the same value
#               will be used as for earlier iterations.
flt.filt_notchhigh_last = <undef>

#-----------------------------------------------------------------
#  Name: 	flt.filt_notchlow
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Specifies additional frequencies to be removed by the FLT model.
#  Description: Together with parameter "flt.filt_notchhigh", this parameter
#		specifies a set of 1 or more hard-edge band-cut frequency-domain
#		notch filters, specifying additional frequencies to be removed
#		by the FLT model. The flt.filt_notchlow value should be a
#		comma-separated list of frequencies in Hz, enclosed in
#		parentheses. These are the frequencies of the lower edges
#		of the notch filters. The flt.filt_notchlow and
#		flt.filt_notchhigh parameters should contain the same
#		number of frequencies.
flt.filt_notchlow = <undef>

#-----------------------------------------------------------------
#  Name: 	flt.filt_notchlow_last
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Specifies additional frequencies to be removed by the FLT model
#               on the last iteration.
#  Description: This is the value to be used for parameter "flt.filt_notchlow"
#               on the last iteration. If it is "<undef>", then the same value
#               will be used as for earlier iterations.
flt.filt_notchlow_last = <undef>

#-----------------------------------------------------------------
#  Name: 	flt.filt_wlim
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Enables an experimental filtering method.
#  Description: If supplied, this will switch on an experimental method for
#		handling missing or flagged data when filtering the time
#		streams, based on replacing missing data with zero, and
#		then normalising the smoothed data using a mask of good
#		samples smoothed in the same way. The flt.filt_wlim value
#		specifies the minimum fraction of good values that must
#		contribute to a filtered value. For instance, if wlim is
#		0.9 then a filtered data value is flagged as bad unless at
#	   	least 0.9 of the input values that contribute to it are good
#		(i.e. have not been flagged as unusable for any reason). Thus
#		a high filt_wlim value (i.e. close to 1.0) will cause more
#	  	data to be rejected, and a low value (i.e. close to 0.0) will
#	 	cause less data to be rejected. A value of <undef> causes the
#		old filtering algorithm to be used that is based on filling
#		gaps with artificial data. If the experimental algorithm is
#		used the following additional settings can be made: "apod=0,
#		fillgaps=0, noi.fillgaps=0".
flt.filt_wlim = <undef>

#-----------------------------------------------------------------
#  Name: 	flt.filt_wlim_last
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Enables an experimental filtering method on the last iteration.
#  Description: This is the value to be used for parameter "flt.filt_wlim"
#               on the last iteration. If it is "<undef>", then the same value
#               will be used as for earlier iterations.
flt.filt_wlim_last = <undef>

#-----------------------------------------------------------------
#  Name: 	flt.notfirst
#  Type: 	integer
#  Default: 	0
#  Purpose: 	May improve convergence by avoiding the filtering of
#		strong sources on the first iteration.
#  Description: If this is non-zero, then low frequencies will not be
#		removed from the time streams on the first iteration.
flt.notfirst = 0

#-----------------------------------------------------------------
#  Name: 	flt.ring_box1
#  Type: 	float
#  Default: 	0
#  Purpose: 	Controls the flagging of samples that suffer from ringing.
#  Description: If this is non-zero, then a ringing filter is applied to
#               the residuals once the FLT model has been removed. This
#               filter attempts to locate and flag residuals that suffer
#               from ringing. It gives the size of the box used to smooth
#               the residuals in order to determine the background. It
#               is specified as a multiple of the filter size. A value of
#               0.5 could be a good starting point. Note, the ringing
#               filter is not applied on any initial iterations specified
#               by parameter "ast.skip".
flt.ring_box1 = 0

#-----------------------------------------------------------------
#  Name: 	flt.ring_box2
#  Type: 	float
#  Default: 	1.5
#  Purpose: 	Controls the flagging of samples that suffer from ringing.
#  Description: Specifies the size of the box used to determine the
#               mean squared residual after FLT removal. It is specified
#               as a multiple of the filter size, and should be greater
#               than parameter "flt.ring_box1".
flt.ring_box2 = 1.5

#-----------------------------------------------------------------
#  Name: 	flt.ring_freeze
#  Type: 	integer
#  Default: 	10
#  Purpose: 	Controls the flagging of samples that suffer from ringing.
#  Description: The flags will be frozen after the number of iterations
#               specified by this parameter. This helps convergence. Set
#               it to zero to allow the flags to change on every iteration.
#               Note, any initial iterations specified by parameter
#               "ast.skip" are not included in the count of iterations.
flt.ring_freeze = 10

#-----------------------------------------------------------------
#  Name: 	flt.ring_mask
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Controls the flagging of samples that suffer from ringing.
#  Description: If this parameter is set to a non-zero value, then
#               samples that fall within a source region (as defined
#               by the AST and/or FLT mask) are never flagged by the
#               ringing filter. If this parameter is set to zero (the
#               default) then no distinction is made between background
#               and source samples within the ringing filter.
#
#               If an FLT mask is available, it is used to define source
#               regions. Otherwise, the AST mask is used. If no mask is
#               available, then behaviour is as if zero was supplied for
#               this parameter.
#
#               Bright compact sources can cause ringing, which the ringing
#               filter would normally identify, resulting in the source
#               samples being flagged and excluded from the map. This
#               results in fewer samples in the source pixels and so higher
#               noise. In bad cases, it can result in all source samples
#               being rejected, thus causing a hole of bad pixels in the map
#               at the position of the source. Setting this parameter to a
#               non-zero value can help in such cases.
flt.ring_mask = 0

#-----------------------------------------------------------------
#  Name: 	flt.ring_minsize
#  Type: 	float
#  Default: 	0.0
#  Purpose: 	Controls the flagging of samples that suffer from ringing.
#  Description: A contiguous section of residuals that are considered
#               to suffer from ringing will only be flagged if it is
#               longer than the size specified by this parameter. It is
#               given as a multiple of the filter size. See parameter
#               "flt.ring_box1".
flt.ring_minsize = 0.0

#-----------------------------------------------------------------
#  Name: 	flt.ring_nsigma
#  Type: 	float
#  Default: 	2.0
#  Purpose: 	Controls the flagging of samples that suffer from ringing.
#  Description: Specifies the number of standard deviations at which to
#               flag samples that suffer from ringing. See parameter
#               "flt.ring_box1".
flt.ring_nsigma = 2.0

#-----------------------------------------------------------------
#  Name: 	flt.ring_wing
#  Type: 	float
#  Default: 	0.3
#  Purpose: 	Controls the flagging of samples that suffer from ringing.
#  Description: For each contiguous section of residuals that are considered
#               to suffer from ringing, this parameter gives the number
#               of extra samples to flag at the beginning and end of the
#               section. It is given as a multiple of the filter size.
#               See parameter "flt.ring_box1".
flt.ring_wing = 0.3

#-----------------------------------------------------------------
#  Name: 	flt.undofirst
#  Type: 	integer
#  Default: 	1
#  Purpose: 	Improves convergence.
#  Description: If non-zero, add the old FLT model back into the
#		residuals at the start of the iteration (and so before COM)
#		rather than just before estimating a new FLT Model.
flt.undofirst = 1

#-----------------------------------------------------------------
#  Name: 	flt.whiten
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Experimental.
#  Description: If non-zero, then a whitening filter will be applied to
#		each time stream prior to apply the other FLT filters.
flt.whiten = 0

#-----------------------------------------------------------------
#  Name: 	flt.whiten_last
#  Type: 	integer
#  Default: 	<undef>
#  Purpose: 	Experimental.
#  Description: This is the value to be used for parameter "flt.whiten"
#               on the last iteration. If it is "<undef>", then the same value
#               will be used as for earlier iterations.
flt.whiten_last = <undef>

#-----------------------------------------------------------------
#  Name: 	flt.zero_accum
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Prevents unstable SNR masks halting convergence.
#  Description: Masks defined by SNR limits can show instabilities in which
#               pixels can repeatedly enter the mask on one iteration and
#               leave it on the next. Such oscillating pixels tend to
#               occur around the edges of source areas in the mask, and
#               can prevent convergence of the iterative map-making process.
#               Setting FLT.ZERO_ACCUM to a non-zero value can prevent
#               this by forcing source pixels to be accumulated rather
#               than replaced on successive iterations. Thus, if
#               FLT.ZERO_ACCUM is non-zero, any map pixel which is flagged
#               as a source pixel on some iteration will never be
#               unflagged - once a source pixel, always a souce pixel.
flt.zero_accum = 0

#-----------------------------------------------------------------
#  Name: 	flt.zero_circle
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Speeds up convergences and reduces ringing by excluding
#		sources within a circle of given radius from the FLT estimate.
#  Description: Using flt.zero_circle causes any samples falling within a
#		specified circle on the map to be excluded from the
#		filtering performed by the FLT model.
flt.zero_circle = <undef>

#-----------------------------------------------------------------
#  Name: 	flt.zero_freeze
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Prevent the FLT mask from changing after a given number
#		of iterations. This can help convergence.
#  Description: If flt.zero_freeze is 1.0 or more, the FLT mask will be
#               frozen after the specified number of iterations (the
#               nearest integer value is used). Note, any initial iterations
#               specified by parameter "ast.skip" are not included in the
#               count of iterations. If flt.zero_freeze is greater than
#               zero but less than 1.0, the FLT mask will be frozen when
#               the normalized change in the map between iterations drops
#               below the flt.zero_freeze value. A value less than or
#               equal to zero means that the mask is never frozen.
flt.zero_freeze = 0.0

#-----------------------------------------------------------------
#  Name: 	flt.zero_lowhits
#  Type: 	real
#  Default: 	0
#  Purpose: 	Experimental.
#  Description: Using flt.zero_lowhits causes samples to be excluded from
#               the filtering performed by the FLT model if they fall in
#               regions of the map where the number of samples falling in each
#               pixel is higher than flt.zero_lowhits times the mean number
#               of samples per pixel, averaged over the map. A value of
#               zero means that no masking of low hits regions is
#               performed. The mask is updated on each iteration.
flt.zero_lowhits = 0

#-----------------------------------------------------------------
#  Name: 	flt.zero_mask
#  Type: 	integer or string
#  Default: 	0
#  Purpose: 	Speeds up convergences and reduces ringing by excluding
#		sources within a region specified by an external mask file
#		from the filtering performed by the FLT model.
#  Description: If flt.zero_mask is set to one of "REF", "MASK2" or
#		"MASK3" then an NDF will be obtained using the specified
#		ADAM parameter (REF, MASK2 or MASK3) and used as a
#		user-defined mask. Setting flt.zero_mask to an integer value
#		larger than zero has the same effect as setting it to "REF".
#		Setting it to an integer less than or equal to zero results
#		in no external mask being used with the COM model. Note,
#		using "REF" ensures that the mask and the output image of
#		MAKEMAP are on the same pixel grid - using "MASK2" or "MASK3"
#		does not provide this guarantee (it is then the users
#		responsibility to ensure that the supplied masks are aligned
# 		with the output image in pixel coordinates). The pixels in
#		the map that are to be included in filtering performed by
#               the FLT model should be set to the bad value in the mask. All
#               other pixels will be excluded from the filtering (i.e.
#		they will be replaced by artifical data interpolated from the
#		adjacent data).
flt.zero_mask = 0

#-----------------------------------------------------------------
#  Name: 	flt.zero_niter
#  Type: 	int
#  Default: 	2
#  Purpose: 	Allows FLT masking to be switched off after a given
#		number of iterations.
#  Description: If flt.zero_niter is non-zero, it gives the number of
#		iterations for which the FLT model should be masked.
#		Subsequent iterations are not masked. A value of zero
#		means "mask on all iterations". However, if parameter
#		"flt.zero_notlast" is set, the mask will will not be applied
#		on the last iteration, even if flt.zero_niter is zero.
#		Note, using FLT masking on many iterations can inhibit
#		convergence. Also, any initial iterations specified by
#               parameter "ast.skip" are not included in the count of
#               iterations.
flt.zero_niter = 2

#-----------------------------------------------------------------
#  Name: 	flt.zero_notlast
#  Type: 	int
#  Default: 	1
#  Purpose: 	Prevent FLT masking being performed on the last iteration.
#  Description: If flt.zero_notlast is 1, then the FLT model is not masked on
# 		the final iteration.
flt.zero_notlast = 1

#-----------------------------------------------------------------
#  Name: 	flt.zero_snr
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Speeds up convergences and reduces ringing by excluding samples
#               that correspond to high SNR pixels in the map.
#  Description: Setting the flt.zero_snr parameter will prevent samples
#		contributing to the FLT model if they fall within map pixels
#		that have SNR values greater than flt.zero_snr. A flt.zero_snr
#		value of zero means no SNR mask is used. See also parameter
#               "flt.zero_snr_ffclean".
#
#               Note, the SNR values are only available once a map has been
#               created, and so using this parameter results in no FLT masking
#               on the first iteration. Consequently the map at the end of the
#               first iteration will have deep rings around bright sources,
#               since no FLT masking was done. Normally, these rings
#               would polute the AST model derived from the map, and thus
#               polute the residuals on the next iteration, resulting in
#               the rings remaining in later maps. To avoid this, parameter
#               "ast.skip" can be set to a positive value. This causes the
#               AST model to be skipped (i.e. no AST signal is subtracted from
#               the residuals) for the first "ast.skip" iterations. This means
#               that a good FLT mask can be formed from these initial iterations
#               before any AST model is calculated and used.
flt.zero_snr = 0

#-----------------------------------------------------------------
#  Name: 	flt.zero_snr_ffclean
#  Type: 	int
#  Default: 	0
#  Purpose: 	Provides alternative method for SNR masking.
#  Description: Setting this parameter to a non-zero value causes the
#               SNR mask requested by parameter "flt.zero_snr" to be
#               created using an algorithm like that used by the KAPPA
#               command "FFCLEAN" (see SUN/95), instead of using a simple
#               thresholding of the SNR map. The parameter "flt.zero_snr"
#               gives the clipping level of the ffclean algorithm, and the
#               parameter "flt.zero_snr_hipass" gives the box size. Using
#               an ffclean algorithm prevents the source regions within
#               the mask being larger than the box size, and may thus
#               produce faster convergence and avoid blobs developing.
flt.zero_snr_ffclean = 0

#-----------------------------------------------------------------
#  Name: 	flt.zero_snr_hipass
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Flatten map before making SNR mask
#  Description: Setting this parameter to a positive value causes the
#               SNR mask requested by parameter "flt.zero_snr" to be
#               based on a copy of the SNR map that has been high-pass
#               filtering to remove structures larger than the number of
#               arc-seconds given by flt.zero_snr_hipass. This will in
#               general reduce the number of source pixels in the mask.
#               See also parameter "flt.zero_snr_ffclean".
flt.zero_snr_hipass = 0.0

#-----------------------------------------------------------------
#  Name: 	flt.zero_snr_lopass
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Smooths map before making SNR mask
#  Description: Setting this parameter to a positive value causes the
#               SNR mask requested by parameter "flt.zero_snr" to be
#               based on a copy of the SNR map that has been low-pass
#               filtering (i.e smoothed) to remove noise and other
#               features smaller than the number of map pixels given
#               by flt.zero_snr_lopass. This may help to prevent pixels
#               oscillating in and out of the mask on successive
#               iterations, and thus aid smoother convergence.
flt.zero_snr_lopass = 0.0

#-----------------------------------------------------------------
#  Name: 	flt.zero_snrlo
#  Type: 	real
#  Default: 	0
#  Purpose: 	Speeds up convergences and reduces ringing by increasing the
#               size of the SNR mask without introducing noise.
#  Description: If values are supplied for flt.zero_snrlo and
#		parameter "flt.zero_snr", then the basic mask created by
#		thresholding at the SNR value specified by flt.zero_snr is
#		modified by expanding each un-masked "source" area down to
#		an SNR equal to flt.zero_snrlo, without introducing any new
#		isolated source areas. The flt.zero_snrlo should be lower than
#		the flt.zero_snr value.
flt.zero_snrlo = <undef>

#-----------------------------------------------------------------
#  Name: 	flt.zero_union
#  Type: 	integer
#  Default: 	1
#  Purpose: 	Controls how multiple FLT masks are combined.
#  Description: If more than one FLT mask is specified (for instance, if
#		values are supplied for both parameter "flt.zero_lowhits"
#		and parameter "flt.zero_snr"), then they are combined
#		into a single mask. If flt.zero_union is true (i.e.
#		non-zero), then the source region in the combined mask is
#		the union of the source regions in the individual masks.
#		If flt.zero_union is false (i.e. zero), then the source
#		region in the combined mask is the intersection of the
#		source regions in the individual masks.
flt.zero_union = 1

#-----------------------------------------------------------------
#  Name: 	flt.zeropad
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Avoid unnecessary loss of data due to apodisation.
#  Description: If flt.zeropad is non-zero, the extra samples used to pad
#		each end of the data streams are set to 0 prior to
#		filtering within the FLT model, and apodization is used to
#		slowly roll-off the ends of the time series to 0 (see
#		parameter "flt.apod"). If flt.zeropad is zero, a cubic
#		polynomial is used to interpolate smoothly between the end
#		of the time series and the beginning of the time series,
#		ensuring continuity in both the value and first derivative.
#		In both cases, the purpose is to remove sharp edges that may
#		cause ringing in the FFT filtering steps.
flt.zeropad = 0

#-----------------------------------------------------------------
#  Name: 	flt.zeropad_last
#  Type: 	integer
#  Default: 	<undef>
#  Purpose: 	Avoid unnecessary loss of data due to apodisation on the
#               last iteration.
#  Description: This is the value to be used for parameter "flt.zeropad"
#               on the last iteration. If it is "<undef>", then the same value
#               will be used as for earlier iterations.
flt.zeropad_last = <undef>

#-----------------------------------------------------------------
#  Name: 	importlut
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Controls the creation of the LUT model.
#  Description: If non-zero, import the the LUT model (the map pixel index
#               associated with each data sample) from an NDF created by a
#               previous run of makemap. The NDF is expected to have the same
#               name as would be created by setting parameter "exportNDF" to
#               "(lut)" in the makemap configuration.
importlut = 0

#-----------------------------------------------------------------
#  Name: 	hitslimit
#  Type: 	real
#  Default: 	0.01
#  Purpose: 	Rejects map pixels that receive very few samples.
#  Description: If non-zero, pixels that receive very few bolometer samples
#               are set to bad in the final map. The limiting number of
#               bolometer samples is equal to "hitslimt" times the mean
#               number of hits per pixel, averaged over the map pixels
#               that recieve at least one bolometer sample.
hitslimit = 0.01

#-----------------------------------------------------------------
#  Name: 	importsky
#  Type: 	integer or string
#  Default: 	0
#  Purpose: 	Allow a map created by a previous run of makemap to be
#		used as the inital estimate of the sky.
#  Description: If importsky is set to one of "REF", "MASK2" or "MASK3" then
#		an NDF will be obtained using the specified ADAM parameter
#		(REF, MASK2 or MASK3) and used as the initial estimate of
#		the sky. The image value at the position of each bolometer
#		sample will be found and subtracted from the bolometer value
#		immediately before the start of the first iteration. In
#		addition, the supplied image will be added back onto the map
#		esimated at the end of the first iteration, before using the
#		map to determine the AST model. Setting importsky to an integer
#		value larger than zero has the same effect as setting it to
#		"REF". Setting it to an integer less than or equal to zero
#		results in no inital sky being removed. Note, using "REF"
#		ensures that the mask and the output image of MAKEMAP are on
#		the same pixel grid - using "MASK2" or "MASK3" does not provide
#		this guarantee (it is then the users responsibility to ensure
#		that the supplied maps are aligned with the output map in pixel
#		coordinates).
importsky = 0

#-----------------------------------------------------------------
#  Name: 	ipmodel
#  Type: 	string
#  Default: 	"pl2"
#  Purpose: 	Selects the Instrumental Polarisation model to use.
#  Description: This parameter is only used when processing POL2 Q or U
#               time-streams as created by SMURF:CALCQU, and if a value
#               is supplied for ADAM parameter IPREF. It specifies the
#               model to be used for IP corection. It can be "JK" for the
#               Johnstone-Kennedy model based on analysis skydip data (see
#               parameter "jkdata"), "PL1" for the first model based
#               on analysis of planet data (see parameter "pl1data"),
#               or "PL2" for the second model based on analysis of planet
#               data (see parameter "pl2data").
ipmodel = pl2

#-----------------------------------------------------------------
#  Name: 	itermap
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Create NDFs holding the map created by each iteration.
#  Description: If itermap is set to a positive value, the map from each iteration
#               of each chunk will be stored in an output NDF. If itermap is set
#               to a negative value, only the final iteration will be written from
#               each chunk. If its absolute value is larger than 1, then each
#               itermap will include a quality component that reflects the AST
#               mask in use.
#
#               By default, each itermap NDF will be stored in an extension
#		called .MORE.SMURF.ITERMAPS in the main output NDF. However,
#               an alternative location can be specified by supplying a value
#               for ADAM parameter ITERMAPS. This is useful as it allows you
#               to look at earlier itermaps whilst makemap is still running.
itermap = 0

#-----------------------------------------------------------------
#  Name: 	jkdata
#  Type: 	string
#  Default: 	$STARLINK_DIR/share/smurf/ipdata.sdf
#  Purpose: 	Defines the Johnstone-Kennedy IP model for POL2 data.
#  Description: This should be the path to an HDS container file holding
#               the parameters required for the Johnstone/Kennedy IP model
#               for POL2 data. Only used when processing POL2 Q or U
#               time-streams as created by SMURF:CALCQU, and if parameter
#               "ipmodel" is set to "JK".
jkdata = $STARLINK_DIR/share/smurf/ipdata.sdf

#-----------------------------------------------------------------
#  Name: 	maplag
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Specifies the degree of lagging between iterations
#  Description: If maplag is non-zero, then the map created at the end of
#               each iteration is replaced by a weighted mean of the new
#               map and the map from the previous iteration. The "maplag"
#               parameter gives the weight for the previous map, and
#               should be in the range 0.0 to 1.0. The weight for the
#               new map is (1.0-maplag). Thus if maplag=0.0 (the
#               default), no change is made to the new map. Using a
#               non-zero value for maplag may help to prevent oscillations
#               in the SNR mask from iteration to iteration.
maplag = 0.0

#-----------------------------------------------------------------
#  Name: 	maptol
#  Type: 	real
#  Default: 	0.05
#  Purpose: 	Specifies when to stop iterating.
#  Description: If the normalised change (either the mean or maximum change -
#               see parameter "maptol_mean") between the maps created on
#               subsequent iterations falls below the value of maptol, then the
#               map-maker performs one more iteration and then terminates. Only
#               used if parameter "numiter" is negative. The normalised mean
#               (or maximum) change between maps is defined as the mean (or
#               maximum) of the absolute change in map pixel value, taken
#               over all pixels within the region of the mask specified by
#               parameter "maptol_mask", and normalised by the RMS of the
#               square root of the pixel variances. Compared to parameter
#               "chitol", this is much more like a "by eye" test, that will
#               stop the solution when the map stops changing.
maptol = 0.05

#-----------------------------------------------------------------
#  Name: 	maptol_box
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Specifies when to stop iterating.
#  Description: If greater than zero, the array holding the normalised change
#               at each map pixel is smoothed using a box filter before
#               estimating the mean or max value (as determined by parameter
#               "maptol_mean"). The box size is specified in arc-seconds.
#               This will have little effect if "maptol_mean" is non-zero
#               (i.e. if the mean map change is being used as the stopping
#               criterion), but will tend to produce smoother convergence
#               if "maptol_mean" is zero (i.e. if the maximum map change
#               is being used as the stopping criterion).
maptol_box = 0.0

#-----------------------------------------------------------------
#  Name: 	maptol_hits
#  Type: 	real
#  Default: 	[hitslimit]
#  Purpose: 	Specifies when to stop iterating.
#  Description: If non-zero, pixels that receive very few bolometer samples
#               are not included in the estimate of the mean or max map
#               change between iterations. The limiting number of
#               bolometer samples is equal to "maptol_hits" times the mean
#               number of hits per pixel, averaged over the map pixels
#               that recieve at least one bolometer sample. The default
#               value for "maptol_hits" is the value of parameter "hitslimit".
maptol_hits = <undef>

#-----------------------------------------------------------------
#  Name: 	maptol_mask
#  Type: 	string
#  Default: 	AST
#  Purpose: 	Specifies when to stop iterating.
#  Description: This parameter specifies the mask that defines the area
#               over which the normalised map change should be calculated
#               when determining the mean or maximum map change at the end of
#               each iteration. See parameter "maptol". The supplied value can
#               be "AST", "FLT", "COM", "PCA" or "<undef>". If the specifies
#               mask is not defined, or if "<undef>" is supplied, then the
#               map change is determined over the entire map.
maptol_mask = AST

#-----------------------------------------------------------------
#  Name: 	maptol_mean
#  Type: 	integer
#  Default: 	1
#  Purpose: 	Specifies when to stop iterating.
#  Description: If this value is non-zero, then the value specified by
#               parameter "maptol" defines a target value for the mean
#               change in normalised pixel value between iterations.
#               Otherwise, "maptol"  defines a target value for the
#               maximum change in normalised pixel value between iterations.
maptol_mean = 1

#-----------------------------------------------------------------
#  Name: 	maptol_rate
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	Specifies when to stop iterating.
#  Description: The normalised mean change in pixel value (see parameter
#               "maptol") con sometimes settle down to a constant value,
#               and thus never drop to the target "maptol" value. This may
#               be the case for instance, if every iteration adds a fixed
#               error map onto the current astronomical signal (see parameter
#               "epsin"). Specifying a value for "maptol_rate" causes the
#               iterative loop to be left if the normalised mean change
#               seems to settle down to a fix value. The supplied value for
#               "maptol_rate" should be a fraction in the range 0.0 to 1.0,
#               and gives the minimum required fractional change in "normalised
#               mean change" between iteration. If the actual value falls
#               below this minimum value, the iterative loop is left.
maptol_rate = <undef>

#-----------------------------------------------------------------
#  Name: 	maxlen
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Determines how the input time-series data is split into chunks
#  Description: The maximum length (in seconds) for a single chunk of
#		concatenated data. If 0 is supplied, attempt to concatenate
#		entire continuous chunks.
maxlen = 0

#-----------------------------------------------------------------
#  Name: 	memcheck
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Indicates what should happen if chunking is detected.
#  Description: This parameter indicates what should happen if the
#               available memory is too low to process the supplied
#               time-series data without splitting it into chunks. It can
#               take any of the following values:
#
#               0 - A warning is issued but makemap then continues to
#               produce a map from the chunked data.
#
#               1 - An error is reported with status SMF__NOMEM and no
#               map is created. The output map is created as normal if
#               the available memory is sufficient to avoid chunking.
#
#               2 - An error is reported with status SMF__NOMEM and
#               no map is created. In addition, an error is also reported
#               with status SMF__MEMCHK and no output map is created if the
#               available memory is sufficient to avoid chunking. Thus if
#               memcheck is 2, no map is ever created. This is intended as
#               a means to check whether chunking would or would not be used
#               if makemap was to be used subsequently to create a map.
#
#               Note, in either case the SMF__NOMEM error is reported only
#               if chunking is caused by lack of memory, not if it is caused
#               by the supplied data being discontiguous.
memcheck=0

#-----------------------------------------------------------------
#  Name: 	modelorder
#  Type: 	list of strings
#  Default: 	(com,gai,ext,flt,ast,noi)
#  Purpose: 	Specifies which models to include in the iterative
#		process, and the order in which they are evaluated.
#  Description: This should be a comma-separated list, in parentheses,
#		containing one or more of the following model names, in the
#		order in which they should be evaluated. Note: components
#		specified AFTER 'ast' will not be calculated for the first
#		time until the second iteration:
#
#  		- dks: fit and remove dark squid for the column
#
#		- com: remove common-mode signal
#
#		- gai: if com specified, fit gain/offset of common mode
#
#		- ext: apply extinction correction
#
#		- ast: estimate the map and astronomical signal
#
#		- flt: apply filter to time streams
#
#		- noi: estimate time-domain variance
#
#		- smo: time series smoothing using a median or mean boxcar filter
#
#		- ssn: scan-synchronous (i.e. azimuth dependent) noise removal
#
#		- pln: remove plane from each time slice
#
#		- tmp: remove externally define template such as azimuth
modelorder = (com,gai,ext,flt,ast,noi)

#-----------------------------------------------------------------
#  Name: 	noexportsetbad
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Controls contents of diagnostic maps
#  Description: Normally all data points in exported model components (see
#		parameter "exportndf") are set to the Starlink "bad" value
#		wherever there is a bad bolometer established during map-making.
#		Set this flag to a non-zero value to prevent this behaviour.
noexportsetbad = 0

#-----------------------------------------------------------------
#  Name: 	noi.box_size
#  Type: 	real
#  Default: 	-15
#  Purpose: 	Allow finer estimation of the noise levels in the time-series
#		data.
#  Description: Specifies the number of time slices used to determine the
#		noise level in a section of a bolometer time stream. If zero,
#		then the whole bolometer time stream is used, and each
#		bolometer has only one variance value. If non-zero, each
#		bolometer time stream is divided up into boxes containing the
#	  	specified number of time slices, and a separate variance
#  		is found for each box. This variance is then used for each
#		sample in the box, so each bolometer ends up with a variance
#		for every time slice. Negative values are interpreted as number
#		of seconds, and positive values as a number of down-sampled
#		time slices. Note, very small box sizes may produce
#		unrepresentative noise levels, and there is a hard minimum
#		of 101 on the number of downsampled time slices in a noise
#		box. Also, if the number of time slices in the data is smaller
#		than two times the requested box size, then a single noise
#		value is used for each bolometer.
noi.box_size = -15

#-----------------------------------------------------------------
#  Name: 	noi.box_type
#  Type: 	integer
#  Default: 	1
#  Purpose: 	Determines how the noise in each box is found.
#  Description: If this is zero, the noise in each box (see parameter
#               "noi.box_size") is found by taking Fourier transform of the
#               residuals in each box and then using the mean power in the
#               range 2 to 10 Hz as the noise. If it is non-zero, the noise
#               for each residual is set to the variance of the neighbouring
#               residuals in a box centred on the residual. Using this
#               scheme causes the noise values to vary continuously with
#               time, whereas the FFT scheme produced blocks of equal
#               noise values. When using a small box size, "noi.box_type=1"
#               will often result in far fewer samples being flagged as
#               unusable. Note, if "noi.box_size" is set to zero, then the
#               value of "noi.box_type" is ignored and the noise is always
#               calculated on the basis of the mean power in the 2 to 10
#               Hz band.
noi.box_type = 1

#-----------------------------------------------------------------
#  Name: 	noi.calcfirst
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Determines when the noise in each bolometer is estimated.
#  Description: If a non-zero value is supplied, the bolometer noise levels are
#		calculated immediately after pre-conditioning. Otherwise, they
#		calculated at the end of the first iteration. The former can
# 		reduce execution time if parameter "noiseclip" is also set
#		since both operations share a single FFT.
noi.calcfirst = 0

#-----------------------------------------------------------------
#  Name: 	noi.dcfitbox
#  Type: 	real
#  Default: 	0
#  Purpose: 	Controls the detection and correction of steps within the
#		NOI model.
#  Description: This gives the box size over which to fit data with a
#		straight line on either side of a potential DC jump,
#		prior to estimating the bolometer noise levels in the NOI
#		model. If positive, in units of samples. If negative, in
# 		units of seconds. If zero, do not perform step correction
#		during estimation of the NOI model.
noi.dcfitbox = 0

#-----------------------------------------------------------------
#  Name: 	noi.dclimcorr
#  Type: 	integer
#  Default: 	10
#  Purpose: 	Controls the detection and correction of steps within the
#               NOI model.
#  Description: If more than DCLIMCORR bolometer have a step at a given
#		time, then all bolometers are corrected for a step at that
#		time, using lower thresholds. A value of zero switches off
#		the correction of correlated steps within the NOI model.
#		Only used if parameter "noi.dcfitbox" is non-zero.
noi.dclimcorr = 10

#-----------------------------------------------------------------
#  Name: 	noi.dcmaxsteps
#  Type: 	integer
#  Default: 	10
#  Purpose: 	Controls the detection and correction of steps within the
#               NOI model.
#  Description: The maximum number of steps that can be corrected in each
#		minute of good data (i.e. per 12000 samples) from a bolometer
#		before the entire bolometer is flagged as bad. A value of zero
#		will cause a bolometer to be rejected if any steps are found in
#		the bolometer data stream. Only used if parameter "noi.dcfitbox"
#		is non-zero.
noi.dcmaxsteps = 10

#-----------------------------------------------------------------
#  Name: 	noi.dcsmooth
#  Type: 	real
#  Default: 	50
#  Purpose: 	Controls the detection and correction of steps within the
#               NOI model.
#  Description: The width of the median filter used to smooth a bolometer
#		data stream prior to finding DC jumps. If positive, in units
#		of samples. If negative, in units of seconds. Only used if
#		parameter "noi.dcfitbox" is non-zero.
noi.dcsmooth = 50

#-----------------------------------------------------------------
#  Name: 	noi.dcthresh
#  Type: 	real
#  Default: 	25.0
#  Purpose: 	Controls the detection and correction of steps within the
#               NOI model.
#  Description: The SNR threshold at which to detect DC steps. Note, this
#		refers to the noise level in the bolometer data after it has
#		been smoothed with a median filter of width given by
#		parameter "noi.dcsmooth". In order to find the equivalent
#		threshold in the unsmoothed data, multiply the noi.dcthresh
#		value by 1.25/sqrt(noi.dcsmooth). For instance, the default
#		values for noi.dcsmooth (50) and noi.dcthresh (25) correspond
#		to a threshold of 25*1.25/sqrt(50) = 4.4 sigma in the
#		unsmoothed data.
noi.dcthresh = 25.0

#-----------------------------------------------------------------
#  Name: 	noi.export
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Controls the exporting of the NOI model.
#  Description: If set to a non-zero value, export the values in the NOI
#               model to an NDF. The name of the NDF is similar to that
#               used by parameter "exportndf", but with a trailing
#               suffix of "_noi" instead of "_res". Unlike "exportndf",
#               the NOI values are stored in the "Data" array of the NDF,
#               and only one value is stored for each box in the NOI model
#               (see parameter "noi.box_size"). This makes the NDF much
#               smaller than that produced by "exportndf". The box size
#               (in samples) is stored in the NOI_BOXSIZE item in the
#               SMURF extension of the NDF.
noi.export = 0

#-----------------------------------------------------------------
#  Name: 	noi.fillgaps
#  Type: 	integer
#  Default: 	1
#  Purpose: 	Controls handling of missing data within NOI FFT code
#  Description: If non-zero, fill vicinity of spikes / DC steps with
#		constrained realization of noise.
noi.fillgaps = 1

#-----------------------------------------------------------------
#  Name: 	noi.import
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Controls the noise values used in the NOI model.
#  Description: If set to a non-zero value, import the noise values to use
#               in the NOI model from an NDF created by a previous run of
#               makemap, rather than calculating them from scratch. The
#               NDF should have been created by setting parameter "noi.export"
#               to 1 in the configuration for a previous run of makemap.
#               (the file should end in "_noi.sdf"). Note, the parameter
#               "noi.box_size" must be set to the same value it had in the
#               previous run of makemap.
noi.import = 0

#-----------------------------------------------------------------
#  Name: 	noi.spikebox
#  Type: 	real
#  Default: 	50
#  Purpose: 	Controls time-based spike detection within NOI model.
#  Description: Size of filter box for the sigma-clipper within the NOI model,
#		in units of samples if positive and seconds if negative.
#		For instance, setting noi.spikebox to 50 will check for
#		excursions from a rolling median filter in a box of length
#		50 samples. Also see parameter "noi.spikethresh".
noi.spikebox = 50

#-----------------------------------------------------------------
#  Name: 	noi.spikethresh
#  Type: 	real
#  Default: 	0
#  Purpose: 	Controls time-based spike detection within NOI model.
#  Description: The SNR value at which to flag spikes within the
#		sigma-clipper used by the NOI model. Also see parameter
#		"noi.spikebox". No de-spiking is performed by the NOI
#		model if a value of zero is supplied.
noi.spikethresh = 0

#-----------------------------------------------------------------
#  Name: 	noi.usevar
#  Type: 	int
#  Default: 	0
#  Purpose: 	Controls how the NOI model is created.
#  Description: If non-zero, then the NOI model is created prior to the
#               first iteration from the variance values in the supplied
#               data files. Otherwise, it is found by analysing the
#               residual bolometer values in the manner specified by
#               parameter "noi.box_type".
noi.usevar = 0

#-----------------------------------------------------------------
#  Name: 	noi.zeropad
#  Type: 	real
#  Default: 	0
#  Purpose: 	Controls how the NOI model handles missing data.
#  Description: See parameter "flt.zeropad".
noi.zeropad = 0

#-----------------------------------------------------------------
#  Name: 	numiter
#  Type: 	real
#  Default: 	-5
#  Purpose: 	Specifies when to stop iterating.
#  Description: If a positive number is supplied, the specified number of
#		iterations will always be performed. If a negative number is
#		supplied, the absolute value gives the maximum number of
#		iterations to perform. Fewer iterations will be performed if
#		the termination criteria specified by parameter "maptol" and
#		parameter "chitol" are both met before "-numiter"
#		iterations have been performed.
numiter = -5

#-----------------------------------------------------------------
#  Name: 	pad
#  Type: 	integer
#  Default: 	<undef>
#  Purpose: 	Specifies the length of padding to add to the start and
#		end of each time series.
#  Description: Specifies the length, in down-sampled time slices, of the
#		padding to add the the start and end of each time series to
#		prevent wrap-around effects between the start and end of
#		the data streams when taking the FFT. If <undef>, a
#		default value is used which is determined from the
#		filtering being performed by the FFT. See also parameter
#		"zeropad".
pad = <undef>

#-----------------------------------------------------------------
#  Name: 	pl1data
#  Type: 	float[3]
#  Default: 	( 3.288E-3, 2.178E-2, -1.156E-2 )
#  Purpose: 	The numerical parameters of the PL1 IP model for POL2 data.
#  Description: This should be a vector of three values, being the
#               coefficients of a quadratic polynomial that gives the fractional
#               polarisation produced by instrumental polarisation, as a
#               function of elevation (in radians):
#
#               fractional IP = A + B*elev + C*elev*elev
#
#               where the vector (A,B,C) is given by "pl1data".  The PL1 model
#               assumes that the IP is parallel to the elevation axis at all
#               elevations. Only used when processing POL2 Q or U time-streams
#               as created by SMURF:CALCQU, and if parameter "ipmodel" is set
#               to "PL1".
pl1data = ( 3.288E-3, 2.178E-2, -1.156E-2 )


#-----------------------------------------------------------------
#  Name: 	pl2data
#  Type: 	float[4]
#  Default: 	( 4.021E-3, 2.263E-2, -1.243E-2, -3.361E-2 )
#  Purpose: 	The numerical parameters of the PL2 IP model for POL2 data.
#  Description: This should be a vector of four values. The first three are
#               the coefficients of a quadratic polynomial that gives the
#               fractional polarisation produced by instrumental polarisation,
#               as a function of elevation (in radians):
#
#               fractional IP = A + B*elev + C*elev*elev
#
#               where the vector (A,B,C,D) is given by "pl1data". The
#               fourth value (D) gives the angle between the IP and the
#               elevation axis, in radians. The PL2 model assumes that the
#               IP is at a constant angle to the elevation axis at all
#               elevations (given by D). Only used when processing POL2 Q or
#               U time-streams as created by SMURF:CALCQU, and if parameter
#               "ipmodel" is set to "PL2".
pl2data = ( 4.021E-3, 2.263E-2, -1.243E-2, -3.361E-2 )

#-----------------------------------------------------------------
#  Name: 	pln.notfirst
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Controls the PLN model.
#  Description: If non-zero, the PLN model is skipped on the first
#		iteration.
pln.notfirst = 0

#-----------------------------------------------------------------
#  Name: 	pol2fp
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Controls creation of maps holding POL2 Q/U values.
#  Description: If zero, an error is reported if an attempt is made to
#               create a map from Q or U time series that uses the focal
#               plane Y axis as the reference direction. Normally, maps
#               should be made from Q/U values that use celestial north
#               as the reference direction in order to avoid problems
#               caused by sky rotation. However, if "pol2fp" is set
#               non-zero, then no error will be reported if the Q/U
#               time series uses focal plane Y as the reference direction.
#               This may be necessary, for instance, when processing data
#               to determine the parameters of the IP (Instrumental
#               Polarisation) model. Note, in such cases the output map
#               will not contain a POLANAL Frame in the WCS FrameSet, and
#               so will be unusable with any POLPACK applications.
pol2fp = 0

#-----------------------------------------------------------------
#  Name: 	sampcube
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Provides extra diagnostic information.
#  Description: If non-zero, then an extension called .MORE.SMURF.SAMPCUBES
#		is added to the output map NDF, holding data cubes of data
#		samples that go into each map pixel.
sampcube = 0

#-----------------------------------------------------------------
#  Name: 	shortmap
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Create NDFs holding the map made form a short chunk of data.
#  Description: If non-zero, then an extension called .MORE.SMURF.SHORTMAPS
#               is added to the output map NDF, holding maps made from every
#		group of "shortmap" adjacent time slices. Alternatively, set
#		to -1 to produce a map each time the TCS_INDEX value within
#		the JCMTSTATE extension is incremented (i.e., each time a full
#		pass through the scan pattern has been completed). Any other
#		negative value is interpreted as a duration in seconds, and is
#		converted to time slices using the (possibly down-sampled)
#		sample frequency of the data being mapped.
shortmap = 0

#-----------------------------------------------------------------
#  Name: 	smo.boxcar
#  Type: 	real
#  Default: 	-10 (for 450 um), -3 (for 850 um)
#  Purpose: 	Controls the SMO model.
#  Description: The width of the smoothing box used by the SMO model. This is
#		roughly equivalent to FLT with a high-pass filter at cutoff
#		frequencies 0.1 and 0.3 Hz for 450 and 850 respectively). If
#		positive, value is in samples. If negative, value is in seconds.
450.smo.boxcar = -10
850.smo.boxcar = -3

#-----------------------------------------------------------------
#  Name: 	smo.notfirst
#  Type: 	integer
#  Default: 	1
#  Purpose: 	Controls the SMO model.
#  Description: If non-zero, skip the SMO model on the first iteration.
smo.notfirst = 1

#-----------------------------------------------------------------
#  Name: 	smo.type
#  Type: 	string
#  Default: 	median
#  Purpose: 	Controls the SMO model.
#  Description: The type of filter used by the SMO model: median or mean.
smo.type = median

#-----------------------------------------------------------------
#  Name: 	ssn.binsize
#  Type: 	real
#  Default: 	-4
#  Purpose: 	Controls the Scan Synchronous Noise model.
#  Description: ssn.binsize gives the size of the azimuth bins used to
#               form the profile of bolometer value against azimuth offset.
#               If zero is zupplied , the map pixel size is used. If a
#               negative value is supplied, the bin size is specified as a
#               multiple of the map pixel size. If a positive value is
#               suppled, it is given directly in arc-seconds.
ssn.binsize = -4

#-----------------------------------------------------------------
#  Name: 	ssn.ksigma
#  Type: 	real
#  Default: 	1.0
#  Purpose: 	Controls the Scan Synchronous Noise model.
#  Description: If ssn.ksigma is greater than zero, then the profile that
#               gives the scan-synchronous noise for each bolometer is
#               smoothed with a Gaussian kernel before being used. The
#               value supplied for ssn.ksigma is the standard deviation
#               of the kernel in units of azimuth bins (see parameter
#               "ssn.binsize").
ssn.ksigma = 1.0

#-----------------------------------------------------------------
#  Name: 	ssn.notfirst
#  Type: 	integer
#  Default: 	0
#  Purpose: 	May improve convergence by avoiding the use of a scan
#               sychronous noise model on the first iteration.
#  Description: If this is non-zero, then scan synchronous noise will not
#		be removed from the time streams on the first iteration.
ssn.notfirst = 0

#-----------------------------------------------------------------
#  Name: 	ssn.seclen
#  Type: 	float
#  Default: 	10
#  Purpose: 	Controls the Scan Synchronous Noise model.
#  Description: If this is non-zero, then each bolometer time stream
#               is split into sections and a separate SSN model is
#               calculated for each section. The value of ssn.seclen
#               determines the length of each section, and should be
#               supplied as a multiple of the basic azimuth period of the
#               scan pattern. For instance, a value of "5" will result in
#               each section containing five azimuth periods (a period is
#               twice the time taken for the boresight to pass through
#               zero azimuth offset).
ssn.seclen = 10


#-----------------------------------------------------------------
#  Name: 	ssn.thresh
#  Type: 	float
#  Default: 	0
#  Purpose: 	Controls the Scan Synchronous Noise model.
#  Description: If this is non-zero, then bolometers for which the
#               magnitude of the scan synchronous noise is less that
#               the specified multiple of the noise level are assumed to
#               have zero scan synchronous noise. Raising the value will
#               result in only the bolometers with the strongest SSN being
#               corrected. Bolometers with weaker SSN are left uncorrected.
ssn.thresh = 0

#-----------------------------------------------------------------
#  Name: 	ssn.zero_accum
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Prevents unstable SNR masks halting convergence.
#  Description: Masks defined by SNR limits can show instabilities in which
#               pixels can repeatedly enter the mask on one iteration and
#               leave it on the next. Such oscillating pixels tend to
#               occur around the edges of source areas in the mask, and
#               can prevent convergence of the iterative map-making process.
#               Setting SSN.ZERO_ACCUM to a non-zero value can prevent
#               this by forcing source pixels to be accumulated rather
#               than replaced on successive iterations. Thus, if
#               SSN.ZERO_ACCUM is non-zero, any map pixel which is flagged
#               as a source pixel on some iteration will never be
#               unflagged - once a source pixel, always a souce pixel.
ssn.zero_accum = 0

#-----------------------------------------------------------------
#  Name: 	ssn.zero_circle
#  Type: 	real
#  Default: 	<undef>
#  Purpose: 	May speed up convergences by excluding sources within a
#               circle of given radius from the SSN estimate.
#  Description: Using ssn.zero_circle causes any samples falling within a
#		specified circle on the map to be excluded from the
#		estimation of the SSN model.
ssn.zero_circle = <undef>

#-----------------------------------------------------------------
#  Name: 	ssn.zero_freeze
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Prevent the SSN mask from changing after a given number
#		of iterations. This can help convergence.
#  Description: If ssn.zero_freeze is 1.0 or more, the SSN mask will be
#               frozen after the specified number of iterations (the
#               nearest integer value is used). Note, any initial iterations
#               specified by parameter "ast.skip" are not included in the
#               count of iterations. If ssn.zero_freeze is greater than
#               zero but less than 1.0, the SSN mask will be frozen when
#               the normalized change in the map between iterations drops
#               below the ssn.zero_freeze value. A value less than or
#               equal to zero means that the mask is never frozen.
ssn.zero_freeze = 0.0

#-----------------------------------------------------------------
#  Name: 	ssn.zero_lowhits
#  Type: 	real
#  Default: 	0
#  Purpose: 	Experimental.
#  Description: Using ssn.zero_lowhits causes samples to be excluded from
#               the estimation of the SSN model if they fall in
#               regions of the map where the number of samples falling in each
#               pixel is higher than ssn.zero_lowhits times the mean number
#               of samples per pixel, averaged over the map. A value of
#               zero means that no masking of low hits regions is
#               performed. The mask is updated on each iteration.
ssn.zero_lowhits = 0

#-----------------------------------------------------------------
#  Name: 	ssn.zero_mask
#  Type: 	integer or string
#  Default: 	0
#  Purpose: 	May speed up convergences by excluding sources within a
#               region specified by an external mask file from the
#               estimation of the SSN model.
#  Description: If ssn.zero_mask is set to one of "REF", "MASK2" or
#		"MASK3" then an NDF will be obtained using the specified
#		ADAM parameter (REF, MASK2 or MASK3) and used as a
#		user-defined mask. Setting ssn.zero_mask to an integer value
#		larger than zero has the same effect as setting it to "REF".
#		Setting it to an integer less than or equal to zero results
#		in no external mask being used with the COM model. Note,
#		using "REF" ensures that the mask and the output image of
#		MAKEMAP are on the same pixel grid - using "MASK2" or "MASK3"
#		does not provide this guarantee (it is then the users
#		responsibility to ensure that the supplied masks are aligned
# 		with the output image in pixel coordinates). The pixels in
#		the map that are to be included in the estimation of the
#               SSN model should be set to the bad value in the mask. All
#               other pixels will be excluded from the model.
ssn.zero_mask = 0

#-----------------------------------------------------------------
#  Name: 	ssn.zero_niter
#  Type: 	int
#  Default: 	2
#  Purpose: 	Allows SSN masking to be switched off after a given
#		number of iterations.
#  Description: If ssn.zero_niter is non-zero, it gives the number of
#		iterations for which the SSN model should be masked.
#		Subsequent iterations are not masked. A value of zero
#		means "mask on all iterations". However, if parameter
#		"ssn.zero_notlast" is set, the mask will will not be applied
#		on the last iteration, even if ssn.zero_niter is zero.
#		Note, using SSN masking on many iterations can inhibit
#		convergence. Also, any initial iterations specified by
#               parameter "ast.skip" are not included in the count of
#               iterations.
ssn.zero_niter = 2

#-----------------------------------------------------------------
#  Name: 	ssn.zero_notlast
#  Type: 	int
#  Default: 	1
#  Purpose: 	Prevent SSN masking being performed on the last iteration.
#  Description: If ssn.zero_notlast is 1, then the SSN model is not masked on
# 		the final iteration.
ssn.zero_notlast = 1

#-----------------------------------------------------------------
#  Name: 	ssn.zero_snr
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	May speed up convergences by excluding samples that
#               correspond to high SNR pixels in the map.
#  Description: Setting the ssn.zero_snr parameter will prevent samples
#		contributing to the SSN model if they fall within map pixels
#		that have SNR values greater than ssn.zero_snr. A ssn.zero_snr
#		value of zero means no SNR mask is used. See also parameter
#               "ssn.zero_snr_ffclean".
#
#               Note, the SNR values are only available once a map has been
#               created, and so using this parameter results in no SSN masking
#               on the first iteration. Consequently the map at the end of the
#               first iteration may have noticable straight lines aligned
#               with azimuth that pass through bright sources, since no SSN
#               masking was done. Normally, these lines would polute the AST
#               model derived from the map, and thus polute the residuals on
#               the next iteration, resulting in the lines remaining in later
#               maps. To avoid this, parameter "ast.skip" can be set to a
#               positive value. This causes the AST model to be skipped (i.e.
#               no AST signal is subtracted from the residuals) for the first
#               "ast.skip" iterations. This means that a good SSN mask can be
#               formed from these initial iterations before any AST model is
#               calculated and used.
ssn.zero_snr = 0

#-----------------------------------------------------------------
#  Name: 	ssn.zero_snr_ffclean
#  Type: 	int
#  Default: 	0
#  Purpose: 	Provides alternative method for SNR masking.
#  Description: Setting this parameter to a non-zero value causes the
#               SNR mask requested by parameter "ssn.zero_snr" to be
#               created using an algorithm like that used by the KAPPA
#               command "FFCLEAN" (see SUN/95), instead of using a simple
#               thresholding of the SNR map. The parameter "ssn.zero_snr"
#               gives the clipping level of the ffclean algorithm, and the
#               parameter "ssn.zero_snr_hipass" gives the box size. Using
#               an ffclean algorithm prevents the source regions within
#               the mask being larger than the box size, and may thus
#               produce faster convergence and avoid blobs developing.
ssn.zero_snr_ffclean = 0

#-----------------------------------------------------------------
#  Name: 	ssn.zero_snr_hipass
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Flatten map before making SNR mask
#  Description: Setting this parameter to a positive value causes the
#               SNR mask requested by parameter "ssn.zero_snr" to be
#               based on a copy of the SNR map that has been high-pass
#               filtering to remove structures larger than the number of
#               arc-seconds given by ssn.zero_snr_hipass. This will in
#               general reduce the number of source pixels in the mask.
#               See also parameter "ssn.zero_snr_ffclean".
ssn.zero_snr_hipass = 0.0

#-----------------------------------------------------------------
#  Name: 	ssn.zero_snr_lopass
#  Type: 	real
#  Default: 	0.0
#  Purpose: 	Smooths map before making SNR mask
#  Description: Setting this parameter to a positive value causes the
#               SNR mask requested by parameter "ssn.zero_snr" to be
#               based on a copy of the SNR map that has been low-pass
#               filtering (i.e smoothed) to remove noise and other
#               features smaller than the number of map pixels given
#               by ssn.zero_snr_lopass. This may help to prevent pixels
#               oscillating in and out of the mask on successive
#               iterations, and thus aid smoother convergence.
ssn.zero_snr_lopass = 0.0

#-----------------------------------------------------------------
#  Name: 	ssn.zero_snrlo
#  Type: 	real
#  Default: 	0
#  Purpose: 	May speed up convergences by increasing the size of the
#               SNR mask without introducing noise.
#  Description: If values are supplied for ssn.zero_snrlo and
#		parameter "ssn.zero_snr", then the basic mask created by
#		thresholding at the SNR value specified by ssn.zero_snr is
#		modified by expanding each un-masked "source" area down to
#		an SNR equal to ssn.zero_snrlo, without introducing any new
#		isolated source areas. The ssn.zero_snrlo should be lower than
#		the ssn.zero_snr value.
ssn.zero_snrlo = <undef>

#-----------------------------------------------------------------
#  Name: 	ssn.zero_union
#  Type: 	integer
#  Default: 	1
#  Purpose: 	Controls how multiple SSN masks are combined.
#  Description: If more than one SSN mask is specified (for instance, if
#		values are supplied for both parameter "ssn.zero_lowhits"
#		and parameter "ssn.zero_snr"), then they are combined
#		into a single mask. If ssn.zero_union is true (i.e.
#		non-zero), then the source region in the combined mask is
#		the union of the source regions in the individual masks.
#		If ssn.zero_union is false (i.e. zero), then the source
#		region in the combined mask is the intersection of the
#		source regions in the individual masks.
ssn.zero_union = 1

#-----------------------------------------------------------------
#  Name: 	tmp.docos
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Controls the TMP model.
#  Description: Indicates that the cosine of the template should be
#		taken before fitting the TMP model. It is assumed that
#		the template quantities are in radians.
tmp.docos = 0

#-----------------------------------------------------------------
#  Name: 	tmp.dosin
#  Type: 	integer
#  Default: 	0
#  Purpose: 	Controls the TMP model.
#  Description: Indicates that the sine of the template should be
#		taken before fitting the TMP model. It is assumed that
#		the template quantities are in radians.
tmp.dosin = 0

#-----------------------------------------------------------------
#  Name: 	tmp.source
#  Type: 	string
#  Default: 	<undef>
#  Purpose: 	Controls the TMP model.
#  Description: The TMP model fits an externally defined template to each
#		bolometer time-series. The tmp.source parameter defines
#		what that template is. Presently the only two valid options
#		are "state_az" and "state_el" to use the telescope azimuth
#		and elevation respectively. The former seems to be a good
#		way for removing magnetic field pickup.
tmp.source = <undef>

#-----------------------------------------------------------------
#  Name: 	tmp.trigoffset
#  Type: 	real
#  Default: 	0
#  Purpose: 	Controls the TMP model.
#  Description: Indicates an offset that is to be added to the TMP model
#		template.
tmp.trigoffset = 0

#-----------------------------------------------------------------
#  Name: 	tstep
#  Type: 	real
#  Default: 	-0.5
#  Purpose: 	Determines the accuracy of each sample location within
#		the map.
#  Description: The gap (in time slices if positive and seconds if
#		negative) between full calculations of the output map
#		bolometer positions. Setting a larger value for this will
#		speed up the map maker but will introduce larger spatial
# 		errors. The default value of -0.5 (i.e. 100 samples at a
#		sample rate of 200 Hz) seems to produce spatial errors of
#		under 0.1 arc-sec. This level of errors seems to cause about
#		1% of bolometers samples to be pushed into a neighouring map
#		pixel. For tstep=100, the calculation of bolometer positions
#		speeds up by about a factor of 60. Setting tstep to 1 (or
#		zero) causes all bolometer positions to be calculated in full,
# 		without any approximation.
tstep = -0.5

#-----------------------------------------------------------------
#  Name: 	two.amap
#  Type: 	string
#  Default: 	<undef>
#  Purpose: 	Controls the TWO model.
#  Description: The "A" map to be used in the TWO model
two.amap = <undef>

#-----------------------------------------------------------------
#  Name: 	two.amap
#  Type: 	string
#  Default: 	<undef>
#  Purpose: 	Controls the TWO model.
#  Description: The "B" map to be used in the TWO model
two.bmap = <undef>

#-----------------------------------------------------------------
#  Name: 	validate_scans
#  Type: 	integer
#  Default: 	1
#  Purpose: 	Controls the rejection of bad scan patterns
#  Description: If non-zero, each raw data file is checked to see if the
#               telescope goes crazy during the subscan (i.e. spends a
#               significant amount of time outside the expected map area).
#               If it does, a warning message is issued and the pointing
#               information associated with the subscan is set blank so
#               that the subscan is excluded from the map. It may be
#               necessary to set this value to zero (i.e. inhibit the
#               check) if any subscans intentionally spend a significant
#               amount of time outside the expected map area.
#
#               The expected map area is defined by the MAP_HGHT and
#               MAP_WDTH FITS headers, and is assumed to be centred on
#               the tracking centre. If more than 10% of the frames are
#               outside this area, the whole subscan is rejected.
validate_scans = 1

#-----------------------------------------------------------------
#  Name: 	varmapmethod
#  Type: 	integer
#  Default: 	1
#  Purpose: 	Controls how the map variance values are found.
#  Description: If zero, propagate variances from the time-domain noise
#		esimates (requires the NOI model component to be present in
#		parameter "modelorder"). Otherwise, use the sample variance
#		of the data values that land in each pixel.
varmapmethod = 1







#  The following parameters control the experimental PCA iterative
#  model, which is primarily intended for use when reducing POL2 scan
#  and spin data. They should be documented properly if use of a PCA
#  model turns out to be a useful thing.
pca.pcathresh = 4
pca.pcathresh_freeze = 0.0
pca.comfill = 0

#  Following are PCA masking parameters that are common to all models.
pca.zero_accum = 0
pca.zero_circle = <undef>
pca.zero_freeze = 0.0
pca.zero_lowhits = 0
pca.zero_mask = 0
pca.zero_niter = 0
pca.zero_notlast = 1
pca.zero_snr = 0.0
pca.zero_snr_ffclean = 0
pca.zero_snr_hipass = 0.0
pca.zero_snr_lopass = 0.0
pca.zero_snr_fwhm = 0
pca.zero_snr_low = -1.1
pca.zero_snrlo = <undef>
pca.zero_union = 1

#  Following are parameters of the COM model that are inherited by the
#  PCA model (PCA uses COM internally).
pca.boxcar = 0
pca.boxcard = 0
pca.boxfact = 0
pca.boxmin = 0
pca.corr_abstol = 0.2
pca.corr_tol = 5
pca.fill = 0
pca.fit_box = <undef>
pca.freeze_flags = 0
pca.gain_abstol = 3
pca.gain_box = -30.0
pca.gain_fgood = 0.25
pca.gain_is_one = 0
pca.gain_positive = 1
pca.gain_rat = 4
pca.gain_tol = 10
pca.niter = 1
pca.noflag = 0
pca.noremove = 0
pca.notfirst = 0
pca.nsigma = 3
pca.offset_is_zero = 0
pca.oldalg = 0
pca.perarray = 1
pca.perarray_last = <undef>
pca.sig_limit = 0
pca.sig_wing = 1.0
pca.weight = 0
