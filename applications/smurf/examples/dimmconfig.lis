# Number of iterations
#  postive number  = fixed number of iterations
#  negative number = maximum iterations if using chi^2 stopping criteria
numiter = -5

# chi^2 tolerance in negative-numiter case (requires noi model component)
chitol = 1e-3

# method of estimating variance map
#  0 = propagate from the time-domain noise (requires noi model component)
#  1 = sample variance of data that land in each pixel
varmapmethod = 1

# Perform iterations in memory?
memiter = 1

# Delete temporary .DIMM files if memiter=0?
deldimm = 1

# If performing iterations in memory, maximum length (seconds) for concatenated
# data. If 0 attempt to concatenate entire continuous chunks.
maxlen = 0

# Model components/order (comma separated list in brackets)
# Note: components specified AFTER 'ast' will not be calculated for the
# first time until the second iteration.
#  dks = fit and remove dark squid for the column
#  com = remove common-mode signal
#  gai = if com specified, fit gain/offset of common mode
#  ext = apply extinction correction
#  ast = estimate the map and astronomical signal
#  flt = apply filter to time streams
#  noi = estimate time-domain variance
#  smo = time series smoothing using a median or mean boxcar filter
#  pln = remove plane from each time slice

modelorder = (com,gai,ext,flt,ast,noi)

# Export model files as NDF?

# Specify a value of 1 or 0 to export all or none of the components
# You can also specify an array of components to export using the same
# format as modelorder. Note that you can specify additional
# components 'res' and 'qua' to what may be provided to modelorder if
# you wish to export the residual model or quality arrays
# respectively. Exportation of 'res' is implied if 'noi' is specified
# as it becomes the variance components of the resulting NDF for
# 'res'. 'qua' will become the quality component of any full 3-dimensional
# model (e.g. 'res', 'ast', 'flt', 'ext'), but no quality will be
# written to model components with different dimensions.

exportndf = 0
#exportndf = (com,gai,ast,flt,dks,smo,pln,res,noi,qua)

# Normally all data points in exported model components are set to BAD values
# wherever there is a bad bolometer established during map-making. Set
# this flag to prevent this behaviour.

#noexportsetbad = 1

# Create .MORE.SMURF.ITERMAPS extensions after each iteration?
#itermap = 1

# Create .MORE.SMURF.BOLOMAPS single-beam map extensions?
#bolomap = 1

# Create .MORE.SMURF.SHORTMAPS extensions containing maps of every "shortmap"
# time slices?
#shortmap=1000

# Apply the flatfield if loading raw data? Default is 1 (true) -- you must
# explicitly set this to 0 if you want to produce a map in raw DAC units (and
# also supply raw data).

# ensureflat=0

# The gap (in time slices) between full calculations of the output map
# bolometer positions. Setting a larger value for this will speed up
# the map maker but will introduce larger spatial errors. The default
# value of 100 seems to produce spatial errors of under 0.1 arc-sec. This
# level of errors seems to cause about 1% of bolometers samples to be
# pushed into a neighouring map pixel. For tstep=100, the calculation of
# bolometer positions speeds up by about a factor of 60. Setting tstep to
# 1 (or zero) causes all bolometer positions to be calculated in full,
# without any approximation.
#tstep = 100

# ----------------------------------------------------------------------------
# The following parameters control data-cleaning before iterations start
# ----------------------------------------------------------------------------

# set this to 0 to turn off all of the pre-mapmaking data cleaning

#doclean = 0

# Export the data immediately after data cleaning / before map-making?
# The file name will be the same as model components, except with the
# suffix "_cln". Even if doclean=0, the data will be exported immediately
# before map-making.

#exportclean = 1

# --- Mean subtraction is fairly useful ---

# subtract a baseline polynomial of this order
order = 0

# Use default apodisation based on filter frequency. This over-rides the default
# of zero in smurf_sc2clean.def. Keep the <undef> default for PAD which is set up
# in smurf_makemap.def.
apod = <undef>

# --- badfrac ensures that bad data from DA system are ignored ---

# fraction of samples to be bad to flag entire bolo as dead
badfrac = 0.05


# --- flag data when we're stationary because insensitive to sky signal ---

# Flag data taken while telescope was stationary (value is a threshold
# slew velocity (arcsec/sec) measured in tracking coordinates
flagstat = 2


# --- Many of the following may not be useful ---

# S/N threshold to detect DC steps. Note, this refers to the noise level
# in the bolometer data after it has been smoothed with a median filter of
# width given by DCSMOOTH. In order to find the equivalent threshold in
# the unsmoothed data, multiply the DCTHRESH value by # 1.25/sqrt(DCSMOOTH).
# For instance, the default values for DCSMOOTH (50) and DCTHRESH (25)
# correspond to a threshold of 25*1.25/sqrt(50) = 4.4 sigma in the
# unsmoothed data.
dcthresh = 25.0

# box size over which to fit data with a straight line on either side of
# a potential DC jump.
dcfitbox = 30

# The maximum number of steps that can be corrected in each minute of
# good data (i.e. per 12000 samples) from a bolometer before the entire
# bolometer is flagged as bad. A value of zero will cause a bolometer to
# be rejected if any steps are found in the bolometer data stream.
dcmaxsteps = 10

# The width of the median filter used to smooth a bolometer data stream
# prior to finding DC jumps
dcsmooth = 50

# S/N ratio to flag spikes with sigma-clipper
# spikethresh = 5

# Size of filter box for sigma-clipper
# spikebox = 50

# Fill vicinity of spikes / DC steps with constrained realization of
# noise
fillgaps = 1

# The following filters are applied *before* the iterative loop. It is
# probably a better idea in general to do filtering with the 'flt'
# model component as described in the next section.

# Hard-edge high-pass frequency-domain filter
#   e.g. keep only frequencies >= 0.1 Hz
# filt_edgehigh = 0.1

# Hard-edge low-pass frequency-domain filter
#   e.g. keep only frequencies <= 90 Hz
# filt_edgelow = 90

# Hard-edge band-cut frequency-domain notch filters.
# filt_notchlow gives lower edges of frequencies to cut in Hz
# filt_notchhigh gives upper edges of frequencies to cut in Hz
#   e.g. remove 25--35 Hz  and 55--65 Hz
#filt_notchlow  = (25,55)
#filt_notchhigh = (35,65)

# Clip bolometers based on their noise. This parameter will remove
# any bolometers noisier than noiseclip standard deviations above
# the mean.
noiseclip = 4.0

# ----------------------------------------------------------------------------
# A number of analagous parameters to clean dark squid signals before fitting
# them to the data (only relevant if DKS is specified as a model component).
# Note that if padding has been added to the bolometer data, it is
# automatically added to the dark squids as well (i.e. there is no
# cleandk.padstart/padend).
# ----------------------------------------------------------------------------

cleandk.apod=<undef>
cleandk.badfrac = 0.05
cleandk.dcfitbox = 30
cleandk.dcmaxsteps = 10
cleandk.dcthresh = 25.0
cleandk.dcsmooth = 50
cleandk.fillgaps = 1
#cleandk.filt_edgelow = 0
#cleandk.filt_edgehigh = 0
#cleandk.filt_notchlow = <undef>
#cleandk.filt_notchhigh = <undef>
cleandk.order = 0
#cleandk.spikethresh = 0
#cleandk.spikebox = 50

# ----------------------------------------------------------------------------
# These parameters control the iterative model components
# ----------------------------------------------------------------------------

# delay calculation of COM until after the first iteration? (good if
# the astronomical signal is expected to dominate the sky signal)

#com.notfirst = 1

# low-pass boxcar filter on COM (samples) to assist with convergence
# if boxfact set reduce width of boxcar by this factor each iteration
# boxmin specifies a minimum width below which it can't be reduced

com.boxcar = 10
#com.boxcar  = 400
#com.boxfact = 0.5
#com.boxmin  = 10

# the following COM parameters control the rejection of bad detectors
# based on the gain and correlation coefficients for the fit of the
# common-mode signal to each detector (good at identifying bolo signals
# with bizarre gains, or shapes if they have for example steps in them). These
# are basically sigma-clippers; outliers are removed at the given threshold
# and then new means and sample standard deviations are measured until
# convergence. The time axis is divided up into one or more equal sized boxes,
# and a separate fit is performed for each box.
#
# com.gain_box: the number of time slices in a box
# com.corr_tol: n-sigma away from mean correlation coefficient tolerance
# com.corr_abstol: the absolute lower limit of acceptable correlation
# com.gain_tol: n-sigma away from mean gain coefficient tolerance
# com.gain_abstol: absolute factor away from mean gain coefficient tolerance
# com.gain_fgood: minimum fraction of good boxes for a usable bolometer
# com.gain_rat: ratio of largest usable gain to mean gain for a bolometer

com.corr_tol = 5
com.gain_tol = 5
com.gain_abstol = 3

# Do not set com.gain_box lower than about 6000 which corresponds to
# 30s, or roughly the fridge oscillation period.
com.gain_box = 6000
#com.corr_abstol = 0.2
#com.gain_fgood = 0.25
#com.gain_rat = 4.0

# low-pass filter dark squid signals using boxcar of this width (if dks
# model is specified)
dks.boxcar = 100

# if set, replace dead dark squids with average of working dark squids
dks.replacebad = 0

# additional despiking / DC step finding after each iteration within noi
# calculation. Setting noi.spikebox to 50 will check for excursions
# from a rolling median filter in a box of length 50 samples.
noi.spikethresh = 10
noi.spikebox = 50
noi.fillgaps = 1

# explicitly turn off iterative DC step finding for now
noi.dcfitbox = 0

#  Use default apodisation based on filter frequency
flt.apod = <undef>

# iterative filter.
450.flt.filt_edgehigh = 0.1
850.flt.filt_edgehigh = 0.3

#flt.filt_edgelow = 90
#flt.filt_notchlow  = (25,55)
#flt.filt_notchhigh = (35,65)

# delay calculation of FLT until after the first iteration? May help
# with negative structure around bright sources

#flt.notfirst = 1

# extinction correction (see EXTINCTION task for further information)
# Best is to use WVM, uses continuously varying measurements as a
# function of time stored with each observation. This is the default if
# nothing is specified.
#
# tausrc   : auto, wvmraw, csotau, filtertau
# taumethod: adaptive, full, quick

# filtertau "tausrc" requires a filtertau entry
# csotau is optional for "auto" and "csotau" tausrc. If not provided
# the value will be calculated from the header.

# csotau   : use value only if tausrc=csotau
# filtertau: use only if tausrc=filtertau

ext.tausrc    =auto
ext.taumethod =adaptive
#ext.csotau    = 0.2
#ext.filtertau = 0.2

# Use the GAIn/COMmon mode to re-calculate the flatfield? Probably a
# good idea in most cases, but dangerous for short scans of very bright
# sources because the astronomical signal may completely dominate
# sky signal.

#gai.flatfield = 1

# Constrain regions of the map to 0.
#
# Using ast.zero_lowhits will set a threshold region where
# the hits are this fraction lower than the mean.
#
# Using ast.zero_circle defines a circle on the map outside of which
# the map will be constrained to zero. The 3 parameters are:
# Longitude, Latitude, Radius of the circle, in decimal degrees, in
# the coordinate system of the map (e.g., RA and Dec.).
#
# The ast.zero_snr parameter will create a mask based on map SNR. For
# example, if it is set to 5, after each iteration all pixels with a
# SNR below this threshold will be set to 0.
#
# If ast.zero_notlast is set, on the final iteration this boundary
# condition will not be applied. This feature will probably be useful
# for deep point-source observations for which the large-scale noise
# is not as important, but keeping as much data around the edges of
# the map is.

#ast.zero_circle = (70.72333,36.115,0.0083333)
#ast.zero_lowhits = 0.1
#ast.zero_notlast = 1
#ast.zero_snr = 5

# Smooth the time series

# don't smooth on the first iteration
smo.notfirst = 1

# Type of filter: mean or median
smo.type = median

# width of smoothing box (roughly equivalent to FLT with a high-pass
# filter at cutoff frequencies 0.1 and 0.3 Hz for 450 and 850
# respectively)
450.smo.boxcar = 2000
850.smo.boxcar = 600
