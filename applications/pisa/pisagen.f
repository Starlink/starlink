      SUBROUTINE PISAGEN( STATUS )
*+
*  Name:
*     PISAGEN

*  Purpose:
*     PISAGEN generates a frame of model objects.

*  Language:
*     Starlink Fortran 77

*  Type of Module:
*     ADAM A-task

*  Invocation:
*     CALL PISAGEN( STATUS )

*  Usage:
*     PISAGEN INPUT POSITIONS OUTPUT GSIGM CROSS COMIX NOISE { SIGMA
*                                                            { ADU

*  Description:
*     PISAGEN generates objects using the PISA profile model function.
*     Input data are a list which should have been generated by
*     PISAFIND in the profiling mode, or be of the same general form,
*     for at least the first four columns (i.e. index, X position,
*     Y position and integrated intensity).  An optional input frame
*     can be given, this is used to determine the size of the output
*     frame. If this is not given then the input list is scanned to
*     generate a suitable default size for the output frame. The
*     output objects from PISAGEN can have the flux within each pixel
*     integrated to give a improved estimate of the actual flux.
*
*     The PISA profiling function model parameters can be read from
*     GLOBAL parameters as set up by the program PISAFIT. Additional
*     parameters allow the output stars to be elliptical. The model may
*     be generated on a background value and can be saturated. Noise
*     can be added to the data to simulate real data for test purposes.
*

*  ADAM Parameters:
*     ADU = REAL (Read)
*        The scaling factor to convert the data output values into
*        counts for which poisson statistics are required.  This is the
*        analogue to data units conversion factor for unmodified CCD
*        frames. [1.0]
*     ANGLE = _REAL (Read)
*        The positional angle of the major axis of the stellar ellipses
*        measured in degrees anti-clockwise from the y-axis
*        (i.e. as per PISAFIND). [0.0]
*     BACKGROUND = _REAL (Read)
*        The background value for the output frame. [0.0]
*     COMIX = _REAL (Read)
*        The mixture coefficient, as a fraction, which defines how the
*        Lorentzian function, at each point in the analytical profile
*        is added to the Gaussian or Exponential. [Global]
*     CROSS = _REAL (Read)
*        The crossover point, as a percentage of the Gaussian peak,
*        where an exponential fall-off in the analytical stellar
*        profile takes over from the Gaussian core. The exponential
*        function is joined on smoothly to the Gaussian. [Global]
*     ELLIP = _REAL (Read)
*        The ellipticity of the output objects. [0.0]
*     GSIGM = _REAL (Read)
*        The standard deviation, in pixels, of the Gaussian core of the
*        analytical stellar profile. [Global]
*     INPUT = NDF (Read)
*        An NDF containing a data array which is the same size as the
*        required output data array.
*     NOISE = LITERAL (Read)
*        The noise contribution to be added to output data. Can be
*        Poisson, Gaussian or None. [NONE]
*     NSIGMA = _REAL (Read)
*        The number of gaussian sigma to generate the output objects
*        to. [10.0]
*     OUTPUT = NDF (Write)
*        The output NDF to contain the model objects.
*     POSITIONS =  FILENAME (Read)
*        Input list of star positions and intensities (see
*        description). [PISAFIND.DAT]
*     SAT = _REAL (Read)
*        The saturation value for output stars. [32767]
*     SCALE = _INTEGER (Read)
*        if scale is greater than one then each output object pixel
*        value is determined by the integration of the function values
*        at scale*scale equidistant parts within the pixel. This
*        simulates an integration of the flux within each pixel. Using
*        this option increases the accuracy of the output pixel
*        intensities, this may be important in areas with large
*        intensity gradients. [Dynamic]
*     SIGMA = REAL (Read)
*        The standard deviation of the Gaussian noise contribution.
*        [1.0]
*     TITLE = LITERAL (Read)
*        Title for the output frame. [Output from PISAGEN]
*     XHIGH = _INTEGER (Read)
*        If an input frame is not given then this value defines the
*        upper limit of the output data array X-axis. [Dynamic]
*     XLOW = _INTEGER (Read)
*        If an input frame is not given then this value defines the
*        origin of the output data array X-axis. [Dynamic]
*     YHIGH = _INTEGER (Read)
*        If an input frame is not given then this value defines the
*        upper limit of the output data array Y-axis. [Dynamic]
*     YLOW = _INTEGER (Read)
*        If an input frame is not given then this value defines the
*        origin of the output data array Y-axis. [Dynamic]

*  Examples:
*     PISAGEN INPUT=FRAME POSITIONS=FRAME.STARS_ACC OUTPUT=STARS
*        BACKGROUND=100.0 SAT=32767 NOISE=NONE \
*        Generates an output NDF STARS of the same size as FRAME. The
*        objects are placed at the positions defined in
*        FRAME.STARS_ACC. The model parameterisations are those stored
*        in the adam_user:GLOBAL.SDF file, with the names PISA_GSIGM,
*        PISA_CROSS and PISA_COMIX, these values were probably
*        generated by PISAFIT.

*  Implementation Status:
*     As in all PISA applications this program will not handle
*     bad pixels.

*  Arguments:
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     PDRAPER: Peter Draper (STARLINK)
*     {enter_new_authors_here}

*  History:
*     18-SEP-1990 (PDRAPER):
*        Original version.
*     11-DEC-1990 (PDRAPER):
*        Changed to use real arrays and added noise facility.
*     17-DEC-1990 (PDRAPER):
*        Changed to use pixel averaging.
*     11-AUG-1992 (PDRAPER):
*        Enabled simple NDFs.
*     07-SEP-2004 (PDRAPER):
*        Changed to use CNF_PVAL.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-

*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'PAR_ERR'          ! PAR error codes
      INCLUDE 'FIO_ERR'          ! FIO error codes
      INCLUDE 'DAT_PAR'          ! HDS/DAT constants
      INCLUDE 'CNF_PAR'          ! CNF functions

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      CHARACTER BUF*132          ! buffer to read lines into
      CHARACTER NTYPE*20         ! the noise type required
      CHARACTER LOCEX*( DAT__SZLOC ) ! locator for the PISA extension
      INTEGER EL                 ! number of pixels in input frame
      INTEGER IDIM( 2 )          ! actual dimensions of data array
      INTEGER IFS                ! file descriptor
      INTEGER IPVAR              ! pointer to variance component
      INTEGER LBND( 2 )          ! lower bounds of data array
      INTEGER NDFIN              ! Input NDF identifier
      INTEGER NDFOUT             ! Output NDF identifier
      INTEGER NDIM               ! number of dimensions of input frame
      INTEGER NNN                ! dummy
      INTEGER NOBJ               ! number of objects to model
      INTEGER PNTR               ! pointer to output frame
      INTEGER SCALE              ! scaling factor for integrating flux
      INTEGER UBND( 2 )          ! upper bounds of data array
      LOGICAL ADDNOI             ! set to true if noise is to bed added
      LOGICAL GOTIN              ! flag to indicate if an input file is
                                 ! given
      LOGICAL POISON             ! set to true if poisson noise is to
                                 ! be added, other wise gaussian
      LOGICAL OPEN               ! Set when input data file opened
      REAL ADU                   ! the conversion factor from data
                                 ! values to counts for the output
                                 ! data ( same as the measured data ).
      REAL ANGLE                 ! position angle of ellipse
      REAL BACK                  ! the background value for frame
      REAL COMIX                 ! mixing fraction
      REAL CROSS                 ! percentage cross over value
      REAL ELLIP                 ! ellipiticity of objects
      REAL GSIGM                 ! gaussian sigma
      REAL MAG                   ! intensity of object
      REAL NSIGMA                ! number of gaussian sigma to generate
                                 ! objects out to
      REAL SAT                   ! the maximum value for an output
                                 ! object
      REAL SIGMA                 ! the standard deviation of the
                                 ! gaussian noise
      REAL XLIM( 2 )             ! file derived limits for output frame
      REAL YLIM( 2 )
      REAL XOUT                  ! x position of object
      REAL YOUT                  ! y position of object

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Start up NDF context
      CALL NDF_BEGIN

*  Attempt to access an input NDF, to get the size etc.
      GOTIN = .TRUE.
      CALL NDF_ASSOC( 'INPUT', 'READ', NDFIN, STATUS )
      IF ( STATUS .EQ. PAR__NULL ) THEN

*  No file given annul error and set flag
         CALL ERR_ANNUL( STATUS )
         GOTIN = .FALSE.
      END IF

*  need scaling factor if pixel averaging is required,
*  not just a centre assignment.
      SCALE = 1
      CALL PAR_DEF0I( 'SCALE', SCALE, STATUS )
      CALL PAR_GET0I( 'SCALE', SCALE, STATUS )

*  Access the input list of positions
      CALL PSA1_ASFIO( 'POSITIONS', 'READ', 'LIST', 0, IFS, OPEN,
     :                 STATUS )
      IF ( STATUS .NE. SAI__OK ) GO TO 999

*  Read in the data from this file until EOF is reached. The object
*  is to count the number of entries and to obtain runtime output
*  frame limits

      NOBJ=0
      XLIM( 1 ) = 1.0E20
      XLIM( 2 ) = -1.0E20
      YLIM( 1 ) = 1.0E20
      YLIM( 2 ) = -1.0E20
1     CONTINUE
         CALL PXYGT2( IFS, BUF, NNN, XOUT, YOUT, MAG, STATUS )
         IF ( STATUS .NE. SAI__OK ) GO TO 2
         NOBJ = NOBJ + 1
         XLIM( 1 ) = MIN( XLIM( 1 ), XOUT + 0.5 )
         XLIM( 2 ) = MAX( XLIM( 2 ), XOUT + 0.5 )
         YLIM( 1 ) = MIN( YLIM( 1 ), YOUT + 0.5 )
         YLIM( 2 ) = MAX( YLIM( 2 ), YOUT + 0.5 )
      GO TO 1

*  End of file
2     CONTINUE

*  May have status other than end-of-file, check for this
      IF ( STATUS .EQ. FIO__EOF ) THEN
          CALL ERR_ANNUL( STATUS )

*  Rewind file
          CALL FIO_RWIND( IFS, STATUS )
      ELSE IF ( STATUS .NE. SAI__OK ) THEN

*  Unexpected error, exit
          GO TO 999
      ENDIF

*  If no objects have been found then exit
      IF ( NOBJ .EQ. 0 ) THEN
         STATUS = SAI__ERROR
         CALL ERR_REP( 'PISAGEN_ERR',
     :                 'PISAGEN: input file contains no entries',
     :                 STATUS )
         GO TO 999
      ENDIF

*  Determine size of input frame if given
      IF ( GOTIN ) THEN
         CALL NDF_BOUND( NDFIN, 2, LBND, UBND, NDIM, STATUS )
         IDIM( 1 ) = UBND( 1 ) - LBND( 1 ) + 1
         IDIM( 2 ) = UBND( 2 ) - LBND( 2 ) + 1

*  Propagate the NDF.
         CALL NDF_PROP( NDFIN, 'Data', 'OUTPUT', NDFOUT, STATUS )

*  Force the type to _REAL if necessary
         CALL NDF_STYPE( '_REAL', NDFOUT, 'Data,Variance', STATUS )
      ELSE

*  Set dynamic defaults for output frame size, and get the actual size
         LBND( 1 ) = 1
         CALL PAR_DEF0I( 'XLOW',  NINT( XLIM( 1 )), STATUS )
         CALL PAR_GET0I( 'XLOW',  LBND( 1 ), STATUS )
         CALL PAR_DEF0I( 'XHIGH', NINT( XLIM( 2 )), STATUS )
         CALL PAR_GET0I( 'XHIGH', UBND( 1 ), STATUS )
         LBND( 2 ) = 1
         CALL PAR_DEF0I( 'YLOW',  NINT( YLIM( 1 )), STATUS )
         CALL PAR_GET0I( 'YLOW',  LBND( 2 ), STATUS )
         CALL PAR_DEF0I( 'YHIGH', NINT( YLIM( 2 )), STATUS )
         CALL PAR_GET0I( 'YHIGH', UBND( 2 ), STATUS )

*  Form the sizes of the sides of the array component
         IDIM( 1 ) = UBND( 1 ) - LBND( 1 ) + 1
         IDIM( 2 ) = UBND( 2 ) - LBND( 2 ) + 1

*  Create a new NDF
         CALL NDF_CREAT( 'OUTPUT', '_REAL', 2, LBND, UBND, NDFOUT,
     :                    STATUS )
      END IF

*  Map in the output data array
      CALL NDF_MAP( NDFOUT, 'Data', '_REAL', 'WRITE', PNTR, EL,
     :              STATUS )

*  Get the model parameters
      CALL PAR_GET0R( 'GSIGM', GSIGM, STATUS )
      CALL PAR_GET0R( 'CROSS', CROSS, STATUS )
      CALL PAR_GET0R( 'COMIX', COMIX, STATUS )

*  Get the ellipticity and the associated position angle
*  Add 90 to the position angle to orient as the output from PISAFIND
      CALL PAR_GET0R( 'ELLIP', ELLIP, STATUS )
      CALL PAR_GET0R( 'ANGLE', ANGLE, STATUS )
      ANGLE = ( ANGLE + 90.0 )
      ANGLE = MOD( ANGLE , 180.0 )

*  Get the background and saturation values
      BACK = 0.0
      CALL PAR_GET0R( 'BACKGROUND', BACK, STATUS )
      SAT = 1.0E20
      CALL PAR_GET0R( 'SAT', SAT, STATUS )

*  Number of gaussian sigma, to fit stars out to
      CALL PAR_GET0R( 'NSIGMA', NSIGMA, STATUS )

*  Find out if noise is to be added and if so what sort
      CALL PAR_GET0C( 'NOISE', NTYPE, STATUS )
      CALL CHR_UCASE( NTYPE )
      POISON = .FALSE.
      IF ( NTYPE(1:1) .EQ. 'P' .OR. NTYPE(1:1) .EQ. 'G' ) THEN

*  want poisson or gaussian noise
         ADDNOI = .TRUE.

*  add a variance component to the output NDF
         CALL NDF_MAP( NDFOUT, 'Variance', '_REAL', 'WRITE', IPVAR,
     :                 EL, STATUS )
         IF ( NTYPE(1:1) .EQ. 'P' ) THEN
            POISON = .TRUE.

*  find the ADU conversion factor
            CALL PAR_GET0R( 'ADU', ADU, STATUS )
         ELSE

*  get the sigma for the noise
            CALL PAR_GET0R( 'SIGMA', SIGMA, STATUS )
         END IF
      ELSE
         ADDNOI = .FALSE.
      END IF

*  Now in a position to add the model stars
      IF ( STATUS .EQ. SAI__OK ) THEN
         CALL ADDMOD( %VAL( CNF_PVAL( PNTR ) ), IDIM( 1 ), IDIM( 2 ),
     :                LBND( 1 ), LBND( 2 ), IFS, NOBJ, GSIGM, CROSS,
     :                COMIX, ELLIP, ANGLE, BACK, SAT, NSIGMA, .FALSE.,
     :                SCALE, STATUS )
      END IF

*  Add some noise to the data, if required
      IF ( ADDNOI ) THEN
         CALL ANOISE( %VAL( CNF_PVAL( PNTR ) ), IDIM( 1 ) * IDIM( 2 ),
     :                POISON, SIGMA, ADU, %VAL( CNF_PVAL( IPVAR ) ),
     :                STATUS )
      END IF

*  Add title to the output frame.
      BUF = 'Output from PISAGEN'
      CALL NDF_CPUT( BUF, NDFOUT, 'TITLE', STATUS )

*  create PISA extension
      CALL NDF_XNEW( NDFOUT, 'PISA', 'PISA_EXTENSION', 0, 0, LOCEX,
     :                  STATUS )

*  Add a scale component and write the scale value into it
      CALL CMP_MOD( LOCEX, 'SCALE', '_INTEGER', 0, 0, STATUS )
      CALL CMP_PUT0I( LOCEX, 'SCALE', SCALE, STATUS )
      CALL DAT_ANNUL( LOCEX, STATUS )
999   CONTINUE

*  End NDF context
      CALL NDF_END( STATUS )
      IF ( STATUS .NE. SAI__OK ) THEN

*  Close data file.
      IF ( OPEN ) THEN
         CALL FIO_CLOSE( IFS, STATUS )
         CALL FIO_CANCL( 'POSITIONS', STATUS )
       END IF

*  Report error identifying this task
         CALL ERR_REP( 'PISAGEN_ERR',
     :                 'PISAGEN: error generating model star frame.',
     :                  STATUS )
      END IF
      END
* $Id$
