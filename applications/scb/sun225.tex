\documentclass[twoside,11pt]{article}

% ? Specify used packages
% \usepackage{graphicx}        %  Use this one for final production.
% \usepackage[draft]{graphicx} %  Use this one for drafting.
\usepackage[english]{babel}    %  Ensure sensible hyphenation (esp. linux)
% ? End of specify used packages

\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocsource}    {sun\stardocnumber}

% Variable part - replace [xxx] as appropriate.
\newcommand{\stardocnumber}    {225.2}
\newcommand{\stardocauthors}   {M.\ B.\ Taylor}
\newcommand{\stardocdate}      {10 December 1999}
\newcommand{\stardoctitle}     {SCB --- Source Code Browser}
\newcommand{\stardocversion}   {1.1-0}
\newcommand{\stardocmanual}    {Use and installation guide}
\newcommand{\stardocabstract}  {
This document describes the installation and use of SCB,
the Starlink Source Code Browser.
The package consists of two parts, an indexer program and an
extractor program.
The indexer need only be run infrequently (when the source code collection
changes), and the extractor can be run to extract a source file
by file- or function-name, either in plain text to the command line,
or in HTML including hyperlinks to called routines, viewable
using a WWW browser.  In the latter case, the extractor program
must be installed as a CGI script.
}
% ? End of document identification
% -----------------------------------------------------------------------------

% +
%  Name:
%     sun.tex
%
%  Purpose:
%     Template for Starlink User Note (SUN) documents.
%     Refer to SUN/199
%
%  Authors:
%     AJC: A.J.Chipperfield (Starlink, RAL)
%     BLY: M.J.Bly (Starlink, RAL)
%     PWD: Peter W. Draper (Starlink, Durham University)
%     MBT: Mark Taylor (Starlink, IoA)
%
%  History:
%     17-JAN-1996 (AJC):
%        Original with hypertext macros, based on MDL plain originals.
%     16-JUN-1997 (BLY):
%        Adapted for LaTeX2e.
%        Added picture commands.
%     13-AUG-1998 (PWD):
%        Converted for use with LaTeX2HTML version 98.2 and
%        Star2HTML version 1.3.
%     11-NOV-1998 (MBT):
%        Instantiated as SUN/225.
%     {Add further history here}
%
% -

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markboth{\stardocname}{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %begin{latexonly} and %end{latexonly} lines (used by
%  LaTeX2HTML to signify text it shouldn't process).
%begin{latexonly}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

\newenvironment{latexonly}{}{}
\newcommand{\latex}[1]{#1}
\newcommand{\html}[1]{}
\newcommand{\latexhtml}[2]{#1}
\newcommand{\HTMLcode}[2][]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{\LaTeX2\texttt{HTML}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\renewcommand{\_}{\texttt{\symbol{95}}}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
%end{latexonly}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.
% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / {\textsc Rutherford Appleton Laboratory} \hfill {\textbf \stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Huge\textbf  \stardoctitle \\ [2.5ex]}
   {\LARGE\textbf \stardocversion \\ [4ex]}
   {\Huge\textbf  \stardocmanual}
   \end{center}
   \vspace{5mm}

% ? Add picture here if required for the LaTeX version.
%   e.g. \includegraphics[scale=0.3]{filename.ps}
% ? End of picture

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\textbf Abstract}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1 ALIGN=CENTER> \end{rawhtml}
      \stardoctitle\\
      \stardocversion\\
      \stardocmanual
   \begin{rawhtml} </H1> <HR> \end{rawhtml}

% ? Add picture here if required for the hypertext version.
%   e.g. \includegraphics[scale=0.7]{filename.ps}
% ? End of picture

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory\ \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC}{http://www.cclrc.ac.uk} /
      \htmladdnormallink{Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk/ral} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://www.starlink.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://www.starlink.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents.
%  ================================
%  Add table of contents header and a navigation button to return to this
%  point in the document (this should always go before the abstract \section).
  \label{stardoccontents}
  \begin{rawhtml}
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}
% ? End of new section for abstract
\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%  ==================
\stardocabstract
% ? End of document abstract
% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
  \newpage
  \begin{latexonly}
    \setlength{\parskip}{0mm}
    \tableofcontents
    \setlength{\parskip}{\medskipamount}
    \markboth{\stardocname}{\stardocname}
  \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------
\cleardoublepage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

% ? Main text

\section{\xlabel{sec:introduction}\label{sec:introduction}Introduction}

The programs in the Starlink software collection
consist of a few million lines of source code, mainly in
Fortran 77 and C.
Finding the source code of interest given the name of a
user task, a function, or even a source file can be non-trivial;
the name of the file containing a routine definition,
the package/directory/tar archive in which the file resides,
and the position in the file at which the routine is defined
may all be difficult pieces of information to obtain if one is
unfamiliar with the package in question.

This package seeks to enable fast navigation around the Starlink
source code in two ways.  In the first place it can locate a routine
or file based on an explicit user query (giving the exact or
approximate name of the routine or file and optionally the Starlink
package in which it resides).  In the second place, it can present
the source code as HTML, suitable for viewing with any WWW browser,
with references to external routines presented as hyperlinks so
that call chains can be followed conveniently.
This second mode of use is clearly much more powerful than the first.

There are two principal components of the system: an indexing program
which is run once to locate and store all the files and routine
definitions, and subsequently only when the source code is changed,
and an extractor program which interrogates the index to locate
and output a requested file.

Typically the index
will be generated by the system manager and stored centrally,
and the extractor installed
as a CGI script to serve HTML over the network (if security is
a concern it is possible to restrict access to local users in the
usual ways).  Simultanously, local users will be able to locate
or extract source files from the command line without using the
WWW interface.
There are other possibilities however: the extractor need not be
installed as a CGI script at all so that only command-line use
is available, and users may have their own private indexes
which combine some or all of the main source code collection
with their own development versions of packages.

The remainder of this document describes installation and use of
the package, and some details of its internal workings.
Its operation should be fairly intuitive however,
and it is perfectly possible to learn to use it just by playing around,
perhaps with reference to section \ref{BROWSER-HELP}.




\section{\xlabel{sec:install}\label{sec:install}Installation and setup}

\subsection{\xlabel{sec:install-pack}\label{sec:install-pack}Installing the package}

The files comprising SCB should be obtained and installed into
the Starlink tree in more or less the usual way.
There are some environment variables which affect the
installation, determining for instance the locations of the
indexes and temporary directories.
All default to sensible values, but
you can tailor them to your requirements by setting them at
installation time.
Additionally, the install-time values can be overridden by
setting the same environment variables at run time.
These variables are as follows:
\begin{description}
\item[SCB\_SOURCES]
The directory containing the Starlink source code.
This directory should contain only Starlink source packages,
each of which must be {\em either\/} in a directory named after the package
{\em or\/} in a tar file named {\tt package.tar}, optionally compressed
using {\tt compress} or {\tt gzip} (and named with a suffix .Z or .gz
respectively).
The former of these is the usual format if the sources are in
their usual location, {\tt /star/sources}.
If undefined at install time and run time, SCB\_SOURCES
defaults to {\tt \$STARLINK/sources}.
\item[SCB\_INDEX]
The directory containing the index files (around 5--10 Mbyte for the full
Starlink source collection).
If undefined at install time and run time, SCB\_INDEX defaults to
{\tt \$INSTALL/etc/scb}.
\item[SCB\_BROWSER\_TMP]
The directory used by the browser program to store temporary files.
If undefined at install time and run time, SCB\_BROWSER\_TMP defaults to
{\tt /usr/tmp/scb}.
\item[SCB\_INDEXER\_TMP]
The directory used by the indexer program to store temporary files.
If undefined at install time and run time, SCB\_INDEXER\_TMP defaults to
{\tt /usr/tmp/scb}.
\item[HTX\_SERVER]
The URL of an HTTP server which will provide HTX versions of the Starlink
documents (see \xref{SUN/188}{sun188}{remote_document_servers}).
In fact this does not have to be a proper HTX server; as long as it
can serve the documents it will not need to resolve {\tt xref\_}-type
cross-references.
Thus if the {\tt /star/docs} directory is being served, the URL of
the top of that tree will do.
If undefined at build time, HTX\_SERVER defaults to
{\tt http://www.starlink.ac.uk/cgi-bin/htxserver/}.
\end{description}
It is possible to change the defaults from the installed values by
modifying the file {\tt \$SCB\_DIR/Scb.pm}.

An example site installation from source files might go as follows:
\begin{quote}
\begin{verbatim}
% zcat scb.tar.Z | tar xf -
% mk build
    ...
% setenv SCB_BROWSER_TMP /scratch/scb/browser
% setenv SCB_INDEXER_TMP /scratch/scb/indexer
% setenv INSTALL /star
% mk install
    ...
% mk test
    ...
*** Installation test for the SCB package has been run
\end{verbatim}
\end{quote}

The program uses a DBM file to store the indexes on disk.
There will always be at least one library available on your system
which Perl can use to do this, and there may be
several --- different implementations each have their own pros and cons.
SCB will try to find
the BSD DB library or the Gnu DBM library.
If these are not available then it will use one of the implementations
that is.  For most purposes this will work without any problems, but
these other implementations often impose limits which interfere slightly
with SCB's operation.
In practice, the only effect of this is likely to be that the
{\tt makefile} entry for a few of the packages cannot be written ---
if this is the case, then warning messages like
\begin{quote}
\begin{verbatim}
!!! Failed to write makefile => package#makefile (block size limit?)
\end{verbatim}
\end{quote}
will be written by {\tt scbindex.pl}.
This is not a very serious handicap, but can be fixed by
installing GDBM or BSD DB, which are available in the public domain.
Typically, BSD DB will be installed on a Linux or Digital Unix system,
but a Solaris system may lack all of the preferred implementations.


\subsection{\xlabel{sec:install-cgi}\label{sec:install-cgi}Installing the CGI script}

This part of the installation can normally only be done by
the system manager.

In order to use this package to browse source code using a
World Wide Web browser, the browser script {\tt scb.pl}
must be installed as a CGI (Common Gateway Interface) program
on a computer running an HTTP server.
For this purpose, the browser script is copied by the package
installation process (the {\tt mk install} step)
into INSTALL{\tt /bin/cgi} as well as into INSTALL{\tt /bin}.

A full discussion of the setup of CGI programs is
beyond the scope of this document, but by way of example,
if the HTTP server being used is
\htmladdnormallink{Apache}{http://www.apache.org/},
it will typically
be necessary to
add a stanza like the following to Apache's {\tt conf/access.conf} file:
\begin{quote}
\begin{verbatim}
<Directory /star/bin/cgi>
Options ExecCGI
</Directory>
\end{verbatim}
\end{quote}
and a line like the following to the {\tt conf/srm.conf} file:
\begin{quote}
\begin{verbatim}
ScriptAlias /cgi-bin/star/ /star/bin/cgi/
\end{verbatim}
\end{quote}
Alternatively, the script INSTALL{\tt /bin/cgi/scb.pl} may be copied
into an existing CGI directory;
if correctly installed it should still work if its name or location
are changed.

Every attempt has been made to make the CGI script secure against
abuse by users of the browsing facility,
but provision of any CGI program is an inherently risky business.
It should also be noted that the browser
program can use significant system resources which might
make it possible for users of the service intentionally or
unintentionally to degrade performance of the server.
In particular, heavy use may be made of the following resources:
\begin{description}
\item[CPU time]
Parsing source files to add the HTML tags is done on the fly by
the browser program.
On the whole this is pretty fast - few will take more than a couple of
seconds to serve, but very large source files, or very many concurrent
requests, might put a significant load on the system.
\item[Memory]
Again memory use should be fairly modest, but if the browser gets into
trouble tagging a large source file it might briefly take a big
chunk of memory.
\item[Temporary disk space]
Temporary files will created in the SCB\_BROWSER\_TMP directory
if it is necessary to unpack tar archives.  The problem is most acute
when tar files are contained in other tar files (usually only the
case if the whole source archive for each package is stored as a tar file,
rather than unpacked as is more usual).
You may wish to
unpack all the tar files within the source archive in place,
for instance using a C-shell sequence like
\begin{quote}
\begin{verbatim}
setenv SCB_SOURCES /star/sources
foreach tarfile (`find $SCB_SOURCES -name \*.tar -print`)
   cd $tarfile:h
   tar xf $tarfile:t
end
\end{verbatim}
\end{quote}
In this case no temporary disk space will be used, and much reduced disk
activity will be required by the browser program.
The disadvantage of doing this is increased use of disk space
in the SCB\_SOURCES directory
(by around 250MB for the full unbuilt source code collection).
\end{description}


\subsection{\xlabel{sec:startup}\label{sec:startup}Using the commands}

If you are going to use any of the commands in the package from the
Unix C shell you should issue the command
\begin{quote}
\begin{verbatim}
% source $INSTALL/scb/scb.csh
\end{verbatim}
\end{quote}
or just
\begin{quote}
\begin{verbatim}
% scb
\end{verbatim}
\end{quote}
This sets up aliases for the package commands
({\tt scbindex}, {\tt scb}, {\tt dbmcat} and {\tt scbcp})
and also sets up, and informs you of, some of
the important environment variable settings, as follows:
\begin{quote}
\begin{verbatim}
   Source Code Browser (SCB) version 1.1-0.  See SUN/225 for help.

   Environment variable settings:
      SCB_INDEX         /star/etc/scb
      SCB_SOURCES       /stardev/sources
      SCB_BROWSER_TMP   /usr/tmp/scb
      SCB_INDEXER_TMP   /usr/tmp/scbindexer
\end{verbatim}
\end{quote}
These can be changed if you want, for instance, to build an index in
a different place to the default.
The exact meaning of these environment variables is explained in
section \ref{sec:install}.




\section{\xlabel{sec:indexing}\label{sec:indexing}Generating the index
         ({\tt scbindex})}

In order for the browser to work, indexes of the source files must be
generated.  This is done by the script {\tt scbindex}, installed
by default in {\tt /star/bin}.
The following subsections explain how to use this program to
build an index.  In most cases, only an index of the whole Starlink
collection will be required, but people modifying or developing
their own copies of packages may wish to generate a personalised index.


\subsection{\xlabel{sec:indexing-all}\label{sec:indexing-all}Indexing the whole Starlink collection}

To index the whole of the source collection, simply invoke the
indexer program as follows:
\begin{quote}
\begin{verbatim}
% scbindex
\end{verbatim}
\end{quote}
This will
read the source files from the directory specified in SCB\_SOURCES,
write the index files to the directory specified in SCB\_INDEX,
and print to the screen each index entry as it is encountered.
If the entire Starlink source code collection is installed,
this will typically take around about an hour of elapsed time.
Some indication of how far the indexing
has progressed can be seen by looking at which package is currently
being indexed (the package name is given before the `{\tt \#}' sign on the
printed lines, e.g. lines which look like
\begin{quote}
\begin{verbatim}
cmp_activ.f          =>  hds#hds_source.tar>cmp_activ.f
cmp_blk.f            =>  hds#hds_source.tar>cmp_blk.f
cmp_cct              =>  hds#hds_source.tar>cmp_cct
\end{verbatim}
\end{quote}
indicate that the HDS package is being indexed).
The packages are dealt with in alphabetical order, so by seeing how
far the package currently being examined is through the list of files
in the directory SCB\_SOURCES you can get a rough idea of how much remains
to be done.

If only one or a few packages have been changed
since the last indexing,
then the index can be updated rather than being regenerated from scratch.
In this case only the changed packages are named on the command line,
e.g.
\begin{quote}
\begin{verbatim}
% scbindex ast polpack ndf
\end{verbatim}
\end{quote}
The packages so named will be taken from the SCB\_SOURCES directory in
the same way as if the whole source tree is being indexed.

Alternatively the {\tt -update} flag can be used:
\begin{quote}
\begin{verbatim}
% scbindex -update
\end{verbatim}
\end{quote}
This will look through the packages in SCB\_SOURCES and update the index
for only those packages which appear (on the basis of the modification
times of the files in the top level of the directory) to have been
changed since the last time an was built for them.

Since indexing the whole Starlink source collection can take a long time, i
t will probably be preferable to
run it in the background, possibly {\tt renice}d, with the output
redirected elsewhere, e.g.:
\begin{quote}
\begin{verbatim}
% nice +4 scbindex >& scbindex.log &
\end{verbatim}
\end{quote}
If the machine will be used by other people while the indexing
is running, then you should seek advice from your system manager
about the nice level that ought to be used.

While the indexing is taking place, the index files {\it may\/}
(depending on the implementation of the database libraries on
your system)
be unreadable, so that the browser program ceases to work.
To maintain the browser service during an update of the index in this
case, it will be necessary to update a copy, and write it over the
original when it is complete, like this:
\begin{quote}
\begin{verbatim}
% setenv SCB_INDEX /usr/tmp/tmp_index
% mkdir $SCB_INDEX
% scbcp /star/etc/scb $SCB_INDEX
% scbindex pack1 pack2
% scbcp $SCB_INDEX /star/etc/scb
\end{verbatim}
\end{quote}
Use of the {\tt scbcp} utility is explained in
section \ref{sec:scbcp}.

The index files created in the SCB\_INDEX directory should
total around 5--10 Mb for the whole Starlink source code set.
On some operating systems the index files may be
sparse, and {\em appear} much bigger than they are,
so that {\tt ls~-l} makes them look very large,
while {\tt du} or {\tt ls~-s} gives their true size.
Copying the indexes should be done using the supplied utility
{\tt scbcp} (see section \ref{sec:scbcp}),
not the Unix {\tt cp} command; the latter would
work, but might result in inefficient use of disk space.


\subsection{\xlabel{sec:personalise}\label{sec:personalise}Creating a personalised index}

As well as examining all the source files from their natural home
in the main Starlink source tree (the SCB\_SOURCES directory),
it is also possible to index source code from elsewhere,
by giving the pathname of the directory
or tarfile containing the source.
In this way a personalised index can be created:
suppose that {\tt scbindex} has already been run
on all the source code in {\tt /star/sources},
writing index files in {\tt /star/etc/scb}, as described in
the previous section,
and that you have a personal source copy (under development say) of
Figaro in \verb|~/star/sources/figaro|.
To create your own index in \verb|~/star/etc/scb|,
which will for the most part match the global index
but contain your version of Figaro,
you can do the following:
\begin{quote}
\begin{verbatim}
% setenv SCB_INDEX ~/star/etc/scb
% scbcp /star/etc/scb $SCB_INDEX
% scbindex ~/star/sources/figaro
\end{verbatim}
\end{quote}
--- first a private copy is made of the global indexes using
the supplied {\tt scbcp} utility (see section \ref{sec:scbcp}),
and then the Figaro parts are overwritten using {\tt scbindex}.
If the modified sources were
in a compressed tar file in the current directory,
rather than in \verb|~/star/sources|,
then the last line above could be replaced by
\begin{quote}
\begin{verbatim}
% scbindex ./figaro.tar.Z
\end{verbatim}
\end{quote}
It would be possible to make a personal index containing Figaro only,
in which case the copying step could be avoided,
but then hyperlinks to routines in other Starlink packages
would not work.

To make use of the personalised index, rather than the one set as
the default at install time, the following must be done:
\begin{description}
\item[Command line use]
For using the extractor program {\tt scb} from the command line,
set the environment variable SCB\_INDEX to the directory containing
the indexes, in the same way as during the index build as described
above.
\item[CGI browser use]
For using {\tt scb} in HTML mode, then append
`{\tt ?indexdir=directoryname}' to the script's URL.
Thus if your index is in {\tt /home/user/star/etc/scb}
and the browser is installed in {\tt /cgi-bin/star/} on server
host.domain, then to use the default index (as defined when the
package was installed) you should point
your browser at
\begin{quote}
\begin{verbatim}
http://host.domain/cgi-bin/star/scb.pl
\end{verbatim}
\end{quote}
and to use your personal index you should point it at
\begin{quote}
\begin{verbatim}
http://host.domain/cgi-bin/star/scb.pl?indexdir=/home/user/star/etc/scb
\end{verbatim}
\end{quote}
Note the index directory must be the path of the index as seen by
the web server.
\end{description}


\section{\xlabel{sec:extract}\label{sec:extract}Viewing the source code
         ({\tt scb})}

This section explains how to use the extractor program, {\tt scb},
to view source code from the Starlink source tree,
assuming that an index has been built as explained in
section \ref{sec:indexing}.
The browser system tries to come up with the requested section of
source code, but for one reason and another sometimes fails to
do so.
For more insight into why it behaves as it does, and
how it might be coaxed into behaving otherwise,
section \ref{sec:internals} gives some explanation of how the
indexing and extraction is done.


\subsection{\xlabel{sec:extract-commandline}\label{sec:extract-commandline}Command line operation}

Whether or not the package has been installed as a CGI script,
it should be
possible to use the extractor program, {\tt scb},
to view the source code from the Unix shell.

\subsubsection{\xlabel{sec:extract-name}\label{sec:extract-name}{\tt name} argument (basic use)}

At its simplest, a file is extracted by giving just the
requested filename or routine as an argument to the extractor:
\begin{quote}
\begin{verbatim}
% scb name=dsa_data_size
\end{verbatim}
\end{quote}
or equivalently:
\begin{quote}
\begin{verbatim}
% scb dsa_data_size
\end{verbatim}
\end{quote}
finds the file which contains the routine `{\tt dsa\_data\_size}'
and prints it to standard output.  It also
prints to standard error the location of this file.
The file can therefore be viewed using {\tt more}, or printed,
or saved to a local file, or searched with {\tt grep}, or
generally used in the usual Unix ways.
For instance to save it to a local file {\tt file.f}:
\begin{quote}
\begin{verbatim}
% scb dsa_data_size >file.f
figaro#figaro_dsa.tar>dsa/dsa_dat_sz.f
\end{verbatim}
\end{quote}
the second line here is the line printed to standard error
by the program indicating the file in which the routine was found;
it means that the file is part of the package FIGARO,
is contained in the tar archive {\tt figaro\_dsa.tar}, and
within that archive is called {\tt dsa/dsa\_dat\_sz.f}.
Files can be extracted by their filename instead,
so that
\begin{quote}
\begin{verbatim}
% scb dsa_dat_sz.f >file.f
figaro#figaro_dsa.tar>dsa/dsa_dat_sz.f
\end{verbatim}
\end{quote}
has exactly the same effect as the former example.

Routine names are indexed by the names the Unix linker gives them.
For C functions, this means the name of the function as in the
source code should be used.
For Fortran functions and subroutines, the indexed name is
formed by appending an underscore to the lower case name of the
routine.
If the underscore is omitted however, and no routine by that name
can be found, the extractor program will look for a routine with
the underscore appended.


\subsubsection{\xlabel{sec:extract-package}\label{sec:extract-package}{\tt package} argument}

If the extractor can find a Fortran subroutine or function,
or a C function or macro definition, with the name supplied on
the command line, it will extract the relevant source file.
However it is sometimes necessary to restrict the search
further, since there may be more than one source file answering
to that description.  So it is also possible to specify the
package in which you expect to find the file or routine.
For instance, there is one file called `{\tt help.f}' in
package HLP and another in POLMAP.
To ensure that you get the one in HLP, specify it on the
command line using the `{\tt package=}' argument:
\begin{quote}
\begin{verbatim}
% scb help.f package=hlp
\end{verbatim}
\end{quote}
Note that the package argument only serves as a hint to the
extractor program: if the requested file/routine occurs in the
specified package, then that one is retrieved.  If it does not,
but it does exist in another package, then that one is retrieved.
Thus, given that there is no file {\tt help.f} in CCDPACK,
\begin{quote}
\begin{verbatim}
% scb help.f package=ccdpack
\end{verbatim}
\end{quote}
and
\begin{quote}
\begin{verbatim}
% scb help.f
\end{verbatim}
\end{quote}
will give the same result, which is one or other of the {\tt help.f}
files from either POLMAP or HLP (picked more or less at random).

The `{\tt package=}' part may be omitted, so that
\begin{quote}
\begin{verbatim}
scb help.f hlp
\end{verbatim}
\end{quote}
is equivalent to
\begin{quote}
\begin{verbatim}
scb help.f package=hlp
\end{verbatim}
\end{quote}


\subsubsection{\xlabel{sec:extract-type}\label{sec:extract-type}{\tt type} argument, and pattern matching}

It is also possible to specify whether the requested search
term is a routine/function or a file, by specifying `{\tt type=func}'
or `{\tt type=file}' respectively on the command line.  This is not
normally necessary, since the names of functions rarely clash with
the names of routines.

A third possibility is `{\tt type=regex}', in which case the
search term is interpreted as a case-insensitive
Perl regular expression, and
all function names and all file names are checked for matches.
All the matching terms, along with file locations, are then printed out
(first files, then routines).
In this case no source file is extracted.
The same format of regular expression as used by the Unix {\tt grep}
utility can be used
(although the many additional pattern matching facilities
offered by Perl are also allowed).
Thus to find, for instance, the locations of
all the files and routines whose names contain `fit' followed
by `gauss', the following command can be used:
\begin{quote}
\begin{verbatim}
% scb 'fit.*gauss' type=regex

Files:
ech_fit_gaussian.f       => echomop#echomop_source.tar>ech_fit_gaussian.f
fitgauss.f               => figaro#figaro_appca.tar>appca/fitgauss.f
fitgauss.ifl             => figaro#figaro_source.tar>fitgauss.ifl
sculib_fit_2d_gaussian.f => surf#surf_sculib.tar>sculib_fit_2d_gaussian.f
fit_mgauss.f             => twodspec#twodspec_opt.tar>opt/fit_mgauss.f

Routines:
ech_fit_gaussian_        => echomop#echomop_source.tar>ech_fit_gaussian.f
fitgauss_                => figaro#figaro_appca.tar>appca/fitgauss.f
sculib_fit_2d_gaussian_  => surf#surf_sculib.tar>sculib_fit_2d_gaussian.f
fit_mgauss_              => twodspec#twodspec_opt.tar>opt/fit_mgauss.f
\end{verbatim}
\end{quote}
If the {\tt package} argument is given as well as the {\tt type=regex}
argument, then only the package specified will be searched.

More flexible pattern matching searches are possible
with inventive use of the {\tt dbmcat} command described
in section \ref{sec:dbmcat}.



\subsubsection{\xlabel{sec:extract-flags}\label{sec:extract-flags}Command line flags}

There are two command line flags which can be supplied to {\tt scb}.
Neither is required very often, but they are documented here for completeness.
\begin{description}
\item[-html]
If the {\tt -html} flag is included on the command line,
then HTML is written, in the same way as if the extractor were
being invoked as a CGI script.  This is not particularly useful,
except for debugging purposes.
\item[-exact]
Normally the extractor program, if it fails to find the file or
function exactly as specified, tries a few variations like appending
underscores or folding the case of the given argument.
If the {\tt -exact} flag is given then these variations are not attempted.
\end{description}




\subsection{\xlabel{sec:extract-cgi}\label{sec:extract-cgi}Browsing using HTML}

If the extractor program {\tt scb} has been installed
as a CGI program as described in section \ref{sec:install-cgi}
then the Starlink source code can be browsed as a set of
hypertext pages hyperlinked together
at function/subroutine calls and file includes.
Using the pages generated should be quite intuitive,
so the following discussion does not give exact instructions
but clears up a few points.
The best way to see how it works is to play with it.

The URL of the source code browser will depend on exactly how
the installation has been performed, but it will look something
like {\tt http://host.domain/cgi-bin/star/scb.pl}
(although see the note in section \ref{sec:personalise}
if you have built your own index).


\subsubsection{\xlabel{BROWSER-HELP}\label{BROWSER-HELP}Locating a source file}



The top level page of the source code browser is a form
which can be filled in to request a particular source file.
It consists of the following parts:
\begin{description}
\item[Name of item]
The name of the file or function/subroutine to locate,
or a regular expression matching a file or routine
(more detail in section \ref{sec:extract-name}).
\item[Type of item]
Describes how to interpret the ``Name of item'' box.  Select one of:
\begin{description}
   \item[Routine]
   The item is a Fortran or C function or subroutine.
   This is case sensitive.
   For C use the name of the function exactly as it occurs in the source code.
   For Fortran, use the routine's name in lower case with an
   underscore appended;
   however, if the case is wrong or the underscore is omitted the
   browser will still probably
   find the right routine.
   \item[File]
   The item is a filename.  This is case sensitive.
   \item[Either]
   The browser will try both of the above options (File and Routine).
   \item[Regular expression]
   The item name is a Perl 5 regular expression,
   interpreted case-insensitively,
   to match the name of a file or function/subroutine
   (note it does {\em not\/} match the full text of source files).
   For most practical purposes, Perl regular expressions are a superset
   of ordinary regular expressions, so they can be treated like the
   argument of a `{\tt grep -i}' command.
   % A case sensitive search can be achieved by prepending `{\tt (?-i)}' to the
   % regular expression; however this requires Perl 5.005.
\end{description}
(More detail in section \ref{sec:extract-type}).
\item[Name of package (optional)]
If one of the listed packages is selected, it serves
as a hint about where the file or routine being searched for might be.
It is used as follows: if a file or routine of the given name is found
in the package specified, then that one will be presented.
If it is not in that package, or if no package is specified,
then any such item in the whole source tree will be presented.
In particular, this means that even when one package is specified here,
a routine from another package may be presented.\\
If the Type of item is ``Regular expression'' however, then filling in this
field will restrict the search to the named package.
(More detail in section \ref{sec:extract-package}).
\end{description}
If the type of item is ``Routine'' or ``File'', then submitting
the form will take you to the unit requested, or a message
that no such unit can be found
(note that these will take you to the top of the file,
not necessarily where the requested routine begins ---
if this makes it hard to find the right place, you can browse the
package and follow a link to the routine, as described below).
If the type of item is ``Regular expression'',
it will present a list of links to
matching files.

Instead of entering the name of the file or routine you wish to
see, you can browse the contents of a given package.
Below the form is a list of links to all the available packages.
Following one of these links (or equivalently selecting the package
name in the `Name of package' box without filling in the `Name of item'
field) will take you to a page giving more information about the
package requested.
This will contain the same form at the top,
but below it are links to files from the package grouped by category:
\begin{description}
\item[Files]
Links to every file in the package.
\item[Routines]
Links to every C and Fortran function and subroutine definition
identified in the source files.
\item[Starlink documents]
Links to any SUNs and SSNs which form part of the package
(although not necessarily all those {\it relevant\/} to the package).
\item[Tasks]
Links to `tasks' in the package.
This is rather loosely defined, but it is intended to be
the names of commands which can be invoked from the Unix shell or ICL.
Because the way these are identified is rather ad hoc,
the list may be incomplete and/or contain spurious entries.
\end{description}
Sometimes the ``Files'' or ``Routines'' heading is a hyperlink to
the actual lists of links, rather than having the list on the page.

Following any of the listed links
will take you to one of the files in the package.

\subsubsection{\xlabel{sec:view}\label{sec:view}Viewing a source file}

A file from a package is normally presented as text in the browser.
If it is C or Fortran source code, then each call of a function or
subroutine should be a hyperlink to the appropriate definition.
Similarly, included files (Fortran {\tt INCLUDE} or C {\tt \#include})
are hyperlinked to the right place.
If any part of the source text is in bold face,
this indicates that it ought to be a link,
but that the routine or file in question cannot be found.
This can happen because the program has misinterpreted the source code,
or the index is out of date, or for other reasons.
The program tries to link to the correct place,
but cannot guarantee to do so; for instance if there are two
routines with the same name in different packages outside the
package containing the current file, the link might point to
the wrong one.
Most types of file other than C or Fortran source are
simply presented as plain text, although some types
(e.g.\ postscript)
will be presented using a viewer appropriate to the type.

The title of the HTML document
(normally displayed in the title bar of your browser)
is the location of the file in
the source tree.  The notation is specific to this package,
but quite easy to understand:
it's like a Unix pathname except that
a `{\tt \#}' sign denotes inclusion in a package,
and a
`\verb|>|'
sign denotes inclusion in a tar file.
So for instance the location
\begin{quote}
\begin{verbatim}
figaro#figaro_dsa.tar>dsa/dsa_dat_sz.f
\end{verbatim}
\end{quote}
means that the file is part of the package FIGARO,
is contained in the tar archive {\tt figaro\_dsa.tar}, and
within that archive is called {\tt dsa/dsa\_dat\_sz.f}.

At the bottom of each file is a copyright notice,
a link to the list of all items in the current file's package,
and a link to the top level of the browser.


\section{\xlabel{sec:internals}\label{sec:internals}Internal workings}

The code is mainly documented by in-line comments,
but an overview of its operation is given here so
that the interested reader can gain more insight into
the capabilities and limitations of the package.
This overview will also prove useful as an introduction to
the code for anyone wishing to modify or extend it,
for instance by adding or replacing modules for indexing
given source code languages.

This section is not required reading for users of the package.

\subsection{\xlabel{sec:internals-indexes}\label{sec:internals-indexes}Index files}

The indexing program {\tt scbindex} builds disk-based indexes, and the
extractor program, which is the same as the browser program  {\tt scb},
interrogates them.  There are three indexes:
\begin{description}
\item[Tasks]
For each package, a list of all the tasks which have been identified
is kept (the definition of what constitutes a task is rather
loose, but it is intended to be programs which can be invoked by
typing their names from the Unix shell, ICL, or other external
environment).
Only the name of each task is stored here;
for each task there will be a corresponding entry giving its location within
that package in the Routines index.
This index also serves as a list of all the
packages which have been indexed.
%
\item[Files]
An index of every file which makes up the indexed source code set,
indexed by bare filename (i.e.\ the tail of the filename, excluding
path information).
This index also holds one special entry for each package
recording where the source code is stored.
%
\item[Routines]
An index of every C and Fortran function and subroutine,
indexed by the name used by the Unix linker on the supported systems;
thus C functions are indexed by their function names
as written in the source code, and Fortran routines by the function
or subroutine name in lower case, followed by a single underscore.
C preprocessor macro functions are also indexed,
but Fortran statement functions are not.
The location stored for each function gives only the file in
which it can be found, not the position within that file.
\end{description}

The Tasks index is stored in a plain text file called {\tt tasks};
being line formatted it has, in general,
to be read in its entirety to find any
required piece of information.
Since it is plain text
it can be examined using a normal text editor
(although some of the lines may be rather long).

The File and Routine indexes
each resemble a table which
maps a key (name of the routine or file), and optionally a
Starlink package name, to a location in the source tree.
For each name which occurs at all,
the index contains a list of one or more locations,
one for each package in which it occurs.
The index can be interrogated by requesting any location for a given name,
or by requesting a location which is preferentially within a given package
(using the `name' and `package' arguments of the CGI script respectively).
An important upshot of this is that if there are two instances of
the same file name or of the same function/routine name
{\em in the same package\/}, only one will be indexed, so that the
browser program will never access the other.
The same routine name may crop up in different packages without causing
clashes however.

The File and Routine indexes are
handled by the program as StarIndex
objects (named {\tt file} and {\tt func} respectively),
i.e.\ are of a type
defined in the supplied module {\tt StarIndex.pm}.
The corresponding files are much larger than the Tasks file
(a couple of megabytes or more each),
but because of the way they are implemented
(as a hash of flattened lists tied to a DBM file of some sort),
any given entry can be accessed by key very quickly.
The design of these objects was dictated chiefly by the requirements
of the browser program, as explained in
section \ref{sec:internals-extractor}).
More detailed documentation of the implementation of these indexes
can be found in the {\tt StarIndex.pm} module itself.

It is possible to examine the File and Routines indexes
directly from the command line by using the supplied {\tt dbmcat}
utility (see section \ref{sec:dbmcat}).



\subsection{\xlabel{sec:internals-tagging}\label{sec:internals-tagging}Parsing and tagging source code}

Both the indexer and the extractor need to be able to parse the
source code: the indexer needs to know which
functions/subroutines are indexed in each source file so that
it can write the Routines index, and the extractor needs to know
what is a reference to another file so that it can generate
hyperlinks, as well as the position of function/subroutine
definitions so that references can point to the right place in
source files (via {\tt <a~name='...'>} tags).

Both programs therefore use the same parsing routines.
A detailed description of how these interface with
the indexer and extractor programs are given in the
module {\tt Scb.pm}, but the basic idea is that these routines
take as input the raw source code and output the same text
with added HTML-like tags indicating where functions are defined
and where they are called.

One routine is supplied for tagging C source and one for Fortran.
These are currently implemented as external programs
written using {\tt lex} and {\tt yacc}, with rather simplified
views of the grammars of the languages.
A previous version of the package contained tagging routines written
in Perl, and contained supporting routines to assist in writing new
taggers in Perl; this is no longer distributed but can
be made available on request.

The SCB package has been designed to make
replacing one of the language-specific tagging modules
(for instance with a more efficient or more accurate one),
or adding a new one (for instance for a different language),
fairly easy --- aspects of this
procedure are documented in the module {\tt Scb.pm}.

The existing tagging routines are good enough to generate
accurate indexing information and hypertext
for a large majority of the source files in the
Starlink software collection, but they are not perfectly accurate,
and could no doubt be improved upon.
It is however impossible to do it perfectly without walking the
include files, which would make the browser far too slow.



\subsection{\xlabel{sec:internals-indexer}\label{sec:internals-indexer}Operation of the indexer program}

The function of the indexer program {\tt scbindex}
is to go through
each of the Starlink packages in turn, writing the name and
location of each task, file and function into the appropriate
indexes.

For each package, the indexer program examines
every file in the package directory or tar archive,
and in any subdirectories or subarchives thereof.
Any file within a tar archive
is written to the Files index
(files which only occur outside tar files are omitted
from that index since they are probably intermediate files
generated as the result of building the package, although
a few explicit exceptions to this rule are made
including makefiles and Starlink documents).
Any file for which a
source code tagging routine exists
is passed through the tagging routine;
the output is examined for any function definitions
(tags of the form {\tt <a~name='...'>}),
and an entry is written to the Routines index for each of these.

Finally various heuristics are pursued to identify
keys from the Routine index which also appear to be tasks,
and an entry is written to the Tasks index containing these.
Even if no tasks are found, an entry containing just the package
name is written to the Tasks index to serve as a record that
the current package has been indexed.


\subsection{\xlabel{sec:internals-extractor}\label{sec:internals-extractor}Operation of the extractor program}

The extractor program {\tt scb} functions in two main modes;
as a normal program which can be invoked from the Unix shell and
outputs plain text (described in section \ref{sec:extract-commandline}),
and as a CGI program which is run under the control of an HTTP server
to produce (predominantly) HTML output (described in \ref{sec:extract-cgi}).

In command line mode, the main function of the extractor
program is to locate and output
the file or routine requested using whatever arguments it
has been given (see section \ref{sec:extract-commandline}),
which may require pulling it out from within tar archives.
If no such file can be found, an error message is written.

In CGI mode, the program has two additional responsibilities.
Firstly, if invoked without sufficient arguments to identify
a file for output, it must present some useful alternative in HTML.
Secondly, when presenting source code, it must mark up
appropriate words as HTML anchors.

When supplied with insufficient arguments it may simply present
a formatted (and hopefully informative) error message.
More commonly however, for instance if invoked with no arguments
at all, it will present a form and/or a series of links
enabling the user to re-invoke the program
in such a way as to present the source file required,
or get closer to being able to do that.

Marking the source code up with HTML anchor tags
is done partly by the extractor program itself,
and partly by separate language-specific tagging routines.
Having extracted the source code, the extractor
checks whether a suitable tagging routine exists.
If not, then some basic markup is done and the file written
more or less raw.
If such a routine does exist however, it is called,
which adds
HTML-like tags indicating the positions of routine definitions
and code references.
The extractor program goes through this, and converts it to
actual HTML before writing it out.
The following example should clarify this.
If the original code is:
%
% This is rather ugly LaTeX, sorry - I think it's worthwhile if you're
% looking at the (latex2html'd) results in HTML though.
%
\begin{quote}
{\tt
\#include "header.h" \\
int code (int argc, char **argv) \{ \\
\mbox{}~~~do\_stuff(); \\
\}
}
\end{quote}
it will be changed by the tagging routine to read:
\begin{quote}
{\tt
\#include "{\bf $<$a href='INCLUDE-header.h'$>$}header.h{\bf $<$/a$>$}" \\
int {\bf $<$a name='code'$>$}code{\bf $<$/a$>$} (int argc, char **argv) \{ \\
\mbox{}~~~{\bf $<$a href='do\_stuff'$>$}do\_stuff{\bf $<$/a$>$}(); \\
\}
}
\end{quote}
which, assuming the code appears within a package named ``pack'',
will finally be modified for output by the extractor to look something like:
\begin{quote}
{\tt
\#include "{\bf $<$a href='scb.pl?header.h\&package=pack\&type=file'$>$}header.h{\bf $<$/a$>$}" \\
int {\bf $<$a name='code'$>$}code{\bf $<$/a$>$} (int argc, char **argv) \{ \\
\mbox{}~~~{\bf $<$a~href='scb.pl?do\_stuff\&package=pack\&type=func\#do\_stuff'$>$}do\_stuff{\bf $<$/a$>$}(); \\
\}
}
\end{quote}
The hyperlinks written by the browser program are thus such
(see section \ref{sec:extract-commandline})
that they effectively point to a routine or file of the given name from
the current package if one exists, but if it does not, will resolve to
one from another package.
This can sometimes resolve to the wrong routine---for instance
if there are multiple routines of the same name inside the
package, or none inside but one in each of several external packages.
However, it has a good chance of resolving to the right routine,
especially for routines named in the usual Starlink way of
{\tt pre\_name}, and importantly it has no need to attempt to
understand the contents of include files, link scripts or makefiles, which
would make the whole business a great deal more complicated.

Note that the link to the function (although not to the include file)
includes specification of a fragment within the document
(the part after the `{\tt \#}' symbol),
which is important if the referenced function is just one of many within a
large source file (frequently true in C source, although less so in Fortran).
Links to locations within a file work because of the
{\tt $<$a~name='...'$>$} tags at function definitions.

A couple of other subtleties are observed in creating these hyperlinks.
Firstly, if no file or routine of the given name exists for any package,
the link is not created, but the word which would otherwise have
been a link is output in bold to indicate that it looks
like it ought to reference another file but does not.
Secondly, if the referenced item exists in the same source file,
a truncated URL giving only the fragment position in the same
file is written.  This prevents the behaviour (which smart browsers
may in any case avoid) of having to reload the same file when all
that is required is to move around in it.


\section{\xlabel{sec:utilities}\label{sec:utilities}Additional utilities}

As well as the principal programs
{\tt scbindex} (section \ref{sec:indexing})
and
{\tt scb} (section \ref{sec:extract}),
a couple of additional utilities are supplied with the package.
These are not necessary for normal operation
of the package but may prove useful to those making more
involved use of it.




\subsection{\xlabel{sec:dbmcat}\label{sec:dbmcat}{\tt dbmcat}}

The {\tt dbmcat} utility directly examines the DBM files
in which the File and Routine indexes are kept
(see section \ref{sec:internals-indexes}.

Source documentation is as follows:
\begin{verbatim}
#  Name:
#     dbmcat.pl

#  Purpose:
#     Examine StarIndex files.

#  Language:
#     Perl 5

#  Invocation:
#     dbmcat.pl filename
#     dbmcat.pl filename key ...

#  Description:
#     This utility is for examining the DBM files representing StarIndex
#     objects used to store the indexes used by the SCB package for
#     indexing files and routines.
#
#     It is not required for any part of the package operation, but is
#     provided for manual examination of these files.  It will mainly
#     be useful for debugging, but may also be useful (in combination
#     with, for instance, grep(1)) for making more flexible queries
#     of the index files than are permitted by the 'type=regex'
#     argument of the scb.pl extractor program.
#
#     It can be used in two modes: if the name of the index only is
#     specified, then every record in the index is printed (in an
#     unpredictable order); the format is
#
#        key    => value value value ...
#
#     where the values are file locations using the logical pathnames
#     as used in the rest of the SCB package.  There may be one or more
#     values, and they are separated by spaces.

#  Arguments:
#     filename
#        Name of the index file.  This is the name of the index as
#        submitted to the StarIndex::new() routine, i.e. without
#        whatever file extensions (.db, .dir, ...) may appear when
#        the file is actually written.  The full path must be given.
#     key
#        One or more keys of the index may be specified.  They must be
#        exact.
\end{verbatim}
Thus to examine the whole index (note that records are printed in
no particular order):
\begin{quote}
\begin{verbatim}
% dbmcat.pl $SCB_INDEX/file
ary1_gt1d.f          => ary#ary_source.tar>ary1_gt1d.f
test_abbrv.f         => chr#chr_source.tar>test_abbrv.f
ech_read_type.f      => echomop#echomop_source.tar>ech_read_type.f
optextract.hlp       => figaro#figaro_iraf.tar>doc/optextract.hlp
    . . .
\end{verbatim}
\end{quote}
and to examine named entries:
\begin{quote}
\begin{verbatim}
% dbmcat.pl /star/etc/scb/func add_ rec_unlock
add_                 => img#img_source.tar>add.f kappa#kappa_sub.tar>add.f
rec_unlock           => hds#hds_source.tar>rec_unlock.c
\end{verbatim}
\end{quote}



\subsection{\xlabel{sec:scbcp}\label{sec:scbcp}{\tt scbcp.pl}}

The {\tt scbcp.pl} utility copies all the indexes which have
been written by {\tt scbindex.pl} (see section \ref{sec:internals-indexes})
from one directory to another.

Source documentation is as follows:
\begin{verbatim}
#  Name:
#     scbcp.pl

#  Purpose:
#     Copy SCB indexes from one directory to another.

#  Language:
#     Perl 5

#  Invocation:
#     scbcp.pl $dir1 $dir2

#  Description:
#     This utility copies all the index files used by the SCB package
#     from one directory to another.  It is an improvement on copying
#     the files using cp in two ways:
#
#        1) It knows which files to copy.
#        2) It will copy sparse files in a sparse way.
#
#     The second may be important depending on the implementation of
#     DBM being used.  Some DBMs can create sparse files, that is ones
#     with large 'holes' in them, which occupy few disk blocks but
#     when copied in any of the usual ways (for instance with cp(1))
#     produce files which occupy many more blocks.  Whether a file is
#     sparse can be determined by comparing the output of 'ls -l' and
#     'ls -s'.
#
#     During operation, the utility reports the copies being carried out.
#
#     This utility is not required for normal operation of the package,
#     it is provided for optional use.

#  Arguments:
#     dir1
#        Source directory containing SCB indexes.
#     dir2
#        Target directory into which SCB indexes are to be copied.
\end{verbatim}
Thus to create a private copy of the SCB indexes, for instance
in order to create a modified personal index, a command like the
following would be used:
\begin{quote}
\begin{verbatim}
% scbcp.pl /star/etc/scb ~/star/etc/scb
/star/etc/scb/tasks -> /home/user/star/etc/scb/tasks
/star/etc/scb/func -> /home/user/star/etc/scb/func
/star/etc/scb/file -> /home/user/star/etc/scb/file
\end{verbatim}
\end{quote}


% ? End of main text
\end{document}

% $Id$
