*  History:
*     19 Nov 1993 (hme):
*        Remove TABs.
*     20 Sep 2000 (ajc):
*        Declare DATA and N assumed size array
*-----------------------------------------------------------------------
            SUBROUTINE FOUR2 (DATA,N,NDIM,ISIGN,IFORM)
C     COOLEY-TUKEY FAST FOURIER TRANSFORM IN USASI BASIC FORTRAN.
C     MULTI-DIMENSIONAL TRANSFORM, EACH DIMENSION A POWER OF TWO,
C     COMPLEX OR REAL DATA.
C     TRANSFORM(K1,K2,...) = SUM(DATA(J1,J2,...)*EXP(ISIGN*2*PI*SQRT(-1)
C     *((J1-1)*(K1-1)/N(1)+(J2-1)*(K2-1)/N(2)+...))), SUMMED FOR ALL
C     J1 AND K1 FROM 1 TO N(1), J2 AND K2 FROM 1 TO N(2),
C     ETC. FOR ALL NDIM SUBSCRIPTS.  NDIM MUST BE POSITIVE AND
C     EACH N(IDIM) MUST BE A POWER OF TWO.  ISIGN IS +1 OR -1.
C     LET NTOT = N(1)*N(2)*...*N(NDIM).  THEN A -1 TRANSFORM
C     FOLLOWED BY A +1 ONE (OR VICE VERSA) RETURNS NTOT
C     TIMES THE ORIGINAL DATA.  IFORM = 1, 0 OR -1, AS DATA IS
C     COMPLEX, REAL OR THE FIRST HALF OF A COMPLEX ARRAY. TRANSFORM
C     VALUES ARE RETURNED TO ARRAY DATA.  THEY ARE COMPLEX, REAL OR
C     THE FIRST HALF OF A COMPLEX ARRAY, AS IFORM = 1, -1 OR 0.
C     THE TRANSFORM OF A REAL ARRAY (IFORM = 0) DIMENSIONED N(1) BY N(2)
C     BY ... WILL BE RETURNED IN THE SAME ARRAY, NOW CONSIDERED TO
C     BE COMPLEX OF DIMENSIONS N(1)/2+1 BY N(2) BY ....  NOTE THAT IF
C     IFORM = 0 OR -1, N(1) MUST BE EVEN, AND ENOUGH ROOM MUST BE
C     RESERVED.  THE MISSING VALUES MAY BE OBTAINED BY COMPLEX CONJUGA-
C     TION. THE REVERSE TRANSFORMATION, OF A HALF COMPLEX ARRAY DIMEN-
C     SIONED N(1)/2+1 BY N(2) BY ..., IS ACCOMPLISHED BY SETTING IFORM
C     TO -1.  IN THE N ARRAY, N(1) MUST BE THE TRUE N(1), NOT N(1)/2+1.
C     THE TRANSFORM WILL BE REAL AND RETURNED TO THE INPUT ARRAY.
C     RUNNING TIME IS PROPORTIONAL TO NTOT*LOG2(NTOT), RATHER THAN
C     THE NAIVE NTOT**2.  FURTHERMORE, LESS ERROR IS BUILT UP.
C     WRITTEN BY NORMAN BRENNER OF MIT LINCOLN LABORATORY, JUNE 1968.
C     SEE-- IEEE AUDIO TRANSACTIONS (JUNE 1967), SPECIAL ISSUE ON FFT.
      DIMENSION DATA(*), N(*)
      NTOT=1
      DO 10 IDIM=1,NDIM
 10   NTOT=NTOT*N(IDIM)
      IF (IFORM) 70,20,20
 20   NREM=NTOT
      DO 60 IDIM=1,NDIM
      NREM=NREM/N(IDIM)
      NPREV=NTOT/(N(IDIM)*NREM)
      NCURR=N(IDIM)
      IF (IDIM-1+IFORM) 30,30,40
 30   NCURR=NCURR/2
 40   CALL BOTRV (DATA,NPREV,NCURR,NREM)
      CALL COOL2 (DATA,NPREV,NCURR,NREM,ISIGN)
      IF (IDIM-1+IFORM) 50,50,60
 50   CALL FOXRL (DATA,N(1),NREM,ISIGN,IFORM)
      NTOT=(NTOT/N(1))*(N(1)/2+1)
 60   CONTINUE
      RETURN
 70   NTOT=(NTOT/N(1))*(N(1)/2+1)
      NREM=1
      DO 100 JDIM=1,NDIM
      IDIM=NDIM+1-JDIM
      NCURR=N(IDIM)
      IF (IDIM-1) 80,80,90
 80   NCURR=NCURR/2
      CALL FOXRL (DATA,N(1),NREM,ISIGN,IFORM)
      NTOT=NTOT/(N(1)/2+1)*N(1)
 90   NPREV=NTOT/(N(IDIM)*NREM)
      CALL BOTRV (DATA,NPREV,NCURR,NREM)
      CALL COOL2 (DATA,NPREV,NCURR,NREM,ISIGN)
 100  NREM=NREM*N(IDIM)
      RETURN
      END
      SUBROUTINE FOXRL (DATA,N,NREM,ISIGN,IFORM)
C     FOR IFORM = 0, CONVERT THE TRANSFORM OF A DOUBLED-UP REAL ARRAY,
C     CONSIDERED COMPLEX, INTO ITS TRUE TRANSFORM.  SUPPLY ONLY THE
C     FIRST HALF OF THE COMPLEX TRANSFORM, AS THE SECOND HALF HAS
C     CONJUGATE SYMMETRY.  FOR IFORM = -1, CONVERT THE FIRST HALF
C     OF THE TRUE TRANSFORM INTO THE TRANSFORM OF A DOUBLED-UP REAL
C     ARRAY.  N MUST BE EVEN.
C     USING COMPLEX NOTATION AND SUBSCRIPTS STARTING AT ZERO, THE
C     TRANSFORMATION IS--
C     DIMENSION DATA(N,NREM)
C     ZSTP = EXP(ISIGN*2*PI*I/N)
C     DO 10 I2=0,NREM-1
C     DATA(0,I2) = CONJ(DATA(0,I2))*(1+I)
C     DO 10 I1=1,N/4
C     Z = (1+(2*IFORM+1)*I*ZSTP**I1)/2
C     I1CNJ = N/2-I1
C     DIF = DATA(I1,I2)-CONJ(DATA(I1CNJ,I2))
C     TEMP = Z*DIF
C     DATA(I1,I2) = (DATA(I1,I2)-TEMP)*(1-IFORM)
C 10  DATA(I1CNJ,I2) = (DATA(I1CNJ,I2)+CONJ(TEMP))*(1-IFORM)
C     IF I1=I1CNJ, THE CALCULATION FOR THAT VALUE COLLAPSES INTO
C     A SIMPLE CONJUGATION OF DATA(I1,I2).
      DIMENSION DATA(*)
      TWOPI=6.283185307*FLOAT(ISIGN)
      IP0=2
      IP1=IP0*(N/2)
      IP2=IP1*NREM
      IF (IFORM) 10,70,70
C     PACK THE REAL INPUT VALUES (TWO PER COLUMN)
 10   J1=IP1+1
      DATA(2)=DATA(J1)
      IF (NREM-1) 70,70,20
 20   J1=J1+IP0
      I2MIN=IP1+1
      DO 60 I2=I2MIN,IP2,IP1
      DATA(I2)=DATA(J1)
      J1=J1+IP0
      IF (N-2) 50,50,30
 30   I1MIN=I2+IP0
      I1MAX=I2+IP1-IP0
      DO 40 I1=I1MIN,I1MAX,IP0
      DATA(I1)=DATA(J1)
      DATA(I1+1)=DATA(J1+1)
 40   J1=J1+IP0
 50   DATA(I2+1)=DATA(J1)
 60   J1=J1+IP0
 70   DO 80 I2=1,IP2,IP1
      TEMPR=DATA(I2)
      DATA(I2)=DATA(I2)+DATA(I2+1)
 80   DATA(I2+1)=TEMPR-DATA(I2+1)
      IF (N-2) 200,200,90
 90   THETA=TWOPI/FLOAT(N)
      SINTH=SIN(THETA/2.)
      ZSTPR=-2.*SINTH*SINTH
      ZSTPI=SIN(THETA)
      ZR=(1.-ZSTPI)/2.
      ZI=(1.+ZSTPR)/2.
      IF (IFORM) 100,110,110
 100  ZR=1.-ZR
      ZI=-ZI
 110  I1MIN=IP0+1
      I1MAX=IP0*(N/4)+1
      DO 190 I1=I1MIN,I1MAX,IP0
      DO 180 I2=I1,IP2,IP1
      I2CNJ=IP0*(N/2+1)-2*I1+I2
      IF (I2-I2CNJ) 150,120,120
 120  IF (ISIGN*(2*IFORM+1)) 130,140,140
 130  DATA(I2+1)=-DATA(I2+1)
 140  IF (IFORM) 170,180,180
 150  DIFR=DATA(I2)-DATA(I2CNJ)
      DIFI=DATA(I2+1)+DATA(I2CNJ+1)
      TEMPR=DIFR*ZR-DIFI*ZI
      TEMPI=DIFR*ZI+DIFI*ZR
      DATA(I2)=DATA(I2)-TEMPR
      DATA(I2+1)=DATA(I2+1)-TEMPI
      DATA(I2CNJ)=DATA(I2CNJ)+TEMPR
      DATA(I2CNJ+1)=DATA(I2CNJ+1)-TEMPI
      IF (IFORM) 160,180,180
 160  DATA(I2CNJ)=DATA(I2CNJ)+DATA(I2CNJ)
      DATA(I2CNJ+1)=DATA(I2CNJ+1)+DATA(I2CNJ+1)
 170  DATA(I2)=DATA(I2)+DATA(I2)
      DATA(I2+1)=DATA(I2+1)+DATA(I2+1)
 180  CONTINUE
      TEMPR=ZR-.5
      ZR=ZSTPR*TEMPR-ZSTPI*ZI+ZR
 190  ZI=ZSTPR*ZI+ZSTPI*TEMPR+ZI
C     RECURSION SAVES TIME, AT A SLIGHT LOSS IN ACCURACY. IF AVAILABLE,
C     USE DOUBLE PRECISION TO COMPUTE ZR AND ZI.
 200  IF (IFORM) 270,210,210
C     UNPACK THE REAL TRANSFORM VALUES (TWO PER COLUMN)
 210  I2=IP2+1
      I1=I2
      J1=IP0*(N/2+1)*NREM+1
      GO TO 250
 220  DATA(J1)=DATA(I1)
      DATA(J1+1)=DATA(I1+1)
      I1=I1-IP0
      J1=J1-IP0
 230  IF (I2-I1) 220,240,240
 240  DATA(J1)=DATA(I1)
      DATA(J1+1)=0.
 250  I2=I2-IP1
      J1=J1-IP0
      DATA(J1)=DATA(I2+1)
      DATA(J1+1)=0.
      I1=I1-IP0
      J1=J1-IP0
      IF (I2-1) 260,260,230
 260  DATA(2)=0.
 270  RETURN
      END
      SUBROUTINE BOTRV(DATA,NPREV,N,NREM)
C       SHUFFLE THE DATA BY 'BIT REVERSAL'.
C       DIMENSION DATA(NPREV,N,NREM)
C       DATA(I1,I2REV,I3) = DATA(I1,I2,I3), FOR ALL I1 FROM 1 TO
C       NPREV, ALL I2 FROM 1 TO N (WHICH MUST BE A POWER OF TWO), AND
C       ALL I3 FROM 1 TO NREM, WHERE I2REV-1 IS THE BITWISE REVERSAL
C       OF I2-1.  FOR EXAMPLE, N = 32, I2-1 = 10011 AND I2REV-1 =
C       11001.
C
      DIMENSION DATA(*)
      COMPLEX DATA,TEMP
      IP0=1
      IP1=IP0*NPREV
      IP4=IP1*N
      IP5=IP4*NREM
      I4REV=1
      I4MAX=IP4
      DO 60 I4=1,I4MAX,IP1
      IF(I4-I4REV)10,30,30
   10 I1MAX=I4+IP1-IP0
      DO 20 I1=I4,I1MAX,IP0
      DO 20 I5=I1,IP5,IP4
      I5REV=I4REV+I5-I4
      TEMP=DATA(I5)
      DATA(I5)=DATA(I5REV)
   20 DATA(I5REV)=TEMP
   30 IP2=IP4/2
   40 IF(I4REV-IP2)60,60,50
   50 I4REV=I4REV-IP2
      IP2=IP2/2
      IF(IP2-IP1)60,40,40
   60 I4REV=I4REV+IP2
      RETURN
      END
      SUBROUTINE COOL2(DATA,NPREV,N,NREM,ISIGN)
C       FOURIER TRANSFORM, LENGTH N, BY THE COOLEY-TUKEY ALGORITHM, IN
C       PLACE, BIT-REVERSED TO NORMAL ORDER, SANDE-TUKEY PHASE SHIFTS.
C       COMPLEX DATA
C       DIMENSION DATA(NPREV,N,NREM)
C       DATA(I1,J2,I3) = SUM(DATA(I1,I2,I3)CEXP(ISIGNC2CPICIC((I2-1)C
C       (J2-1)/N))), SUMMED OVER I2 = 1 TO N FOR ALL I1 FROM 1 TO
C       NPREV, J2 FROM 1 TO N AND I3 FROM 1 TO NREM.  N MUST BE A
C       POWER OF TWO.  FACTORING N BY FOUR'S DECREASES RUNNING TIME
C       BY ABOUT TWENTY FIVE PERCENT OVER FACTORING BY TWO'S.
C       GENERATING THE PHASE SHIFT FACTORS BY RECURSION SAVES ABOUT
C       TWENTY FIVE PERCENT OVER COMPUTING THEM, WHILE TABLING THEM
C       IS UNLIKELY TO SAVE MORE THAN ANOTHER TEN PERCENT.
C
C
      DIMENSION DATA(*)
      COMPLEX DATA,TEMP,WSTP,W,W2,W3,T0,T1,T2,T3
      TWOPI=6.28318530717958647692*FLOAT(ISIGN)
      IP0=1
      IP1=IP0*NPREV
      IP4=IP1*N
      IP5=IP4*NREM
      IP2=IP1
      NPART=N
   10 IF(NPART-2)50,30,20
   20 NPART=NPART/4
      GO TO 10
C
C       DO A FOURIER TRANSFORM OF LENGTH TWO
C
   30 IP3=IP2*2
      I1MAX=IP1
      DO 40 I1=1,I1MAX,IP0
      DO 40 I5=I1,IP5,IP3
      I3A=I5
      I3B=I3A+IP2
      TEMP=DATA(I3B)
      DATA(I3B)=DATA(I3A)-TEMP
   40 DATA(I3A)=DATA(I3A)+TEMP
      GO TO 140
C
C       DO A FOURIER TRANSFORM OF LENGTH FOUR (WITHOUT BIT REVERSAL)
C
   50 IP3=IP2*4
      THETA=TWOPI/FLOAT(IP3/IP1)
      SINTH=SIN(THETA/2.)
      WSTP=CMPLX(-2.*SINTH*SINTH,SIN(THETA))
C
C       COS(THETA)-1, FOR ACCURACY
C
      W=1.
      DO 130 I2=1,IP2,IP1
      IF(I2-1)70,70,60
   60 W2=W*W
      W3=W2*W
   70 I1MAX=I2+IP1-IP0
      DO 120 I1=I2,I1MAX,IP0
      DO 120 I5=I1,IP5,IP3
      I3A=I5
      I3B=I3A+IP2
      I3C=I3B+IP2
      I3D=I3C+IP2
      IF(I2-1)90,90,80
C
C       MULTIPLY BY THE PHASE SHIFT FACTORS
C
   80 DATA(I3B)=W2*DATA(I3B)
      DATA(I3C)=W*DATA(I3C)
      DATA(I3D)=W3*DATA(I3D)
   90 T0=DATA(I3A)+DATA(I3B)
      T1=DATA(I3A)-DATA(I3B)
      T2=DATA(I3C)+DATA(I3D)
      T3=DATA(I3C)-DATA(I3D)
      DATA(I3A)=T0+T2
      DATA(I3C)=T0-T2
      TEMP=(0.,1.)*T3
      IF(ISIGN)100,100,110
  100 TEMP=-TEMP
  110 DATA(I3B)=T1+TEMP
  120 DATA(I3D)=T1-TEMP
  130 W=W*WSTP+W
  140 IP2=IP3
      IF(IP3-IP4)50,150,150
  150 RETURN
      END
