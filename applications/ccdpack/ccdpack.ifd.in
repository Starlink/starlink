package ccdpack {
#+
#  Name:
#     ccdpack.ifd

#  Purpose:
#     Specify interface files and package structure for CCDPACK.

#  Language:
#     Tcl

#  Type of Module:
#     Full IFD file.

#  Invocation:
#     ifd2star ccdpack
#     ifd2iraf ccdpack

#  Description:
#     This file controls the generation of all the interface files for
#     the CCDPACK package (.ifl files for the ADAM environment and .par
#     files for interoperability with IRAF).  By processing it using
#     IFD commands (see SSN/68) all of the following files are produced
#     without further intervention:
#
#        ifd2star:
#           task.ifl (for each task)
#           monolith.ifl (for each monolith)
#           ccdpack.csh
#           ccdpack.icl
#
#        ifd2iraf:
#           task.par (for each task)
#           monolith.tcl (for each monolith)
#           ccdpack.par
#           ccdpack.cl
#
#     The task and monolith files are generated by including individual
#     .ifd files (using the tcl core command 'source') to make source
#     control easier.  The ccdpack.{csh,icl,cl} files are generated to
#     some extent automatically from the contents of the individual task
#     .ifd files included here, but additional sections are added using
#     the csh, icl and cl commands in this file.

#  Notes:
#     The files generated by processing this file (as listed above) are
#     to be included without modification in the built CCDPACK package
#     with the following exceptions:
#
#        ccdpack.par:
#           is not required in the built CCDPACK package.
#
#        monolith.tcl:
#           The DynParList associative array elements created by these
#           files should be overridden (the elements should be deleted)
#           if the environment variable CCDPACK_GLOBALS does not equal
#           "yes" at run time.  This can be achieved by appending the
#           following to each monolith.tcl file:
#              global env
#              if { ! ( [info exists env(CCDPACK_GLOBALS)] && \
#                       $env(CCDPACK_GLOBALS) == "yes" ) } {unset DynParList}
#
#        ccdpack.{csh,icl,cl}:
#           Entries are generated in these files for the tasks PICINFO
#           CCDIMP and CCDEXP, which are intended for private use within
#           CCDPACK and not as user applications.  The entries in
#           question are commands 'alias' in ccdpack.csh, 'define' and
#           'defhelp' in ccdpack.icl and 'task' in ccdpack.cl (this last
#           should be there anyway?).  It is not a serious problem to
#           leave these in.
#
#     This file is tcl source code.

#  Copyright:
#     Copyright (C) 1999, 2001 Central Laboratory of the Research
#     Councils. All Rights Reserved.

#  Licence:
#     This program is free software; you can redistribute it and/or
#     modify it under the terms of the GNU General Public License as
#     published by the Free Software Foundation; either version 2 of
#     the License, or (at your option) any later version.
#
#     This program is distributed in the hope that it will be
#     useful, but WITHOUT ANY WARRANTY; without even the implied
#     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#     PURPOSE. See the GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program; if not, write to the Free Software
#     Foundation, Inc., 51 Franklin Street,Fifth Floor, Boston, MA
#     02110-1301, USA

#  Authors:
#     MBT: Mark Taylor (STARLINK)
#     {enter_new_authors_here}

#  History:
#     7-MAY-1999 (MBT):
#        Original version.  Includes pieces of code from the previously
#        existing files ccdpack.csh, ccdpack.icl, ccdpack.cl.
#     21-SEP-1999 (MBT):
#        Added inclusion of drizzle.ifd
#     6-FEB-2001 (MBT):
#        Added entries for DRAWNDF, MAKESET, SHOWSET.
#     {enter_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

   version @PACKAGE_VERSION@
   prefix ccd

#  The following definition allows the flagging text "[G]" to appear
#  appended to prompt strings in IRAF contexts only.  It is invoked by
#  including the Tcl command substitution "[ccd_global]" in the relevant
#  prompt strings.  Note in this case that the prompt strings must be
#  delimited by double quotes, not braces.
   proc ccd_global {} { return {} }
   iraf: { proc ccd_global {} { return { [G]} } }

   executable ccdpack_red {
      source makebias.ifd
      source debias.ifd
      source makecal.ifd
      source calcor.ifd
      source makeflat.ifd
      source flatcor.ifd
   }

   executable ccdpack_reg {
      source findcent.ifd
      source idicurs.ifd
      source findobj.ifd
      source register.ifd
      source tranlist.ifd
      source plotlist.ifd
      source findoff.ifd
      source pairndf.ifd
      source ccdedit.ifd
      source makemos.ifd
      source tranndf.ifd
      source drizzle.ifd
      source astimp.ifd
      source astexp.ifd
      source wcsedit.ifd
      source wcsreg.ifd
      source drawndf.ifd
   }

   executable ccdpack_res {
      source ccdsetup.ifd
      source ccdclear.ifd
      source ccdnote.ifd
      source ccdshow.ifd
      source ccdndfac.ifd
      source ccdgenerate.ifd
      source import.ifd
      source present.ifd
      source schedule.ifd
      source picinfo.ifd
      source ccdimp.ifd
      source ccdexp.ifd
      source makeset.ifd
      source showset.ifd
   }

   executable ccdpack_scr {
      source reduce.ifd
      source ccdalign.ifd
      source xreduce.ifd
   }

   command nagmakemos {
      obsolete {  Command NAGMAKEMOS has been withdrawn - use MAKEMOS instead.}
   }

   adam: {
      executable ccdhelp {
         source ccdhelp.ifd
      }
   }

#  Display informational message.
   display {
   CCDPACK commands are now available -- (Version @PACKAGE_VERSION@)
   }

   # Specific additions for hte package.sh file
   # Note that we define the aliases explicitly here as the
   # ICL script will define an ICL version.
   sh {
      # Script aliases
      ccdexercise () { $CCDPACK_DIR/ccdexercise ${1+"$@"}; }
      ccd_ccdexercise () { $CCDPACK_DIR/ccdexercise ${1+"$@"}; }

      ccdfork () { $CCDPACK_DIR/ccdfork ${1+"$@"}; }
      ccd_ccdfork () { $CCDPACK_DIR/ccdfork ${1+"$@"}; }

      setexercise () { $CCDPACK_DIR/setexercise ${1+"$@"}; }
      ccd_setexercise () { $CCDPACK_DIR/setexercise ${1+"$@"}; }

      wcsexercise () { $CCDPACK_DIR/wcsexercise ${1+"$@"}; }
      ccd_wcsexercise () { $CCDPACK_DIR/wcsexercise ${1+"$@"}; }

      ccdwish () { $CCDPACK_DIR/ccdwish ${1+"$@"}; }
      ccd_ccdwish () { $CCDPACK_DIR/ccdwish ${1+"$@"}; }

      ccdwww () { $CCDPACK_DIR/ccdwww ${1+"$@"}; }
      ccd_ccdwww () { $CCDPACK_DIR/ccdwww ${1+"$@"}; }

      #  Setup conversion of header information for when using foreign data
      #  access.
      if test ! -z "$NDF_XTN"; then
          # see if the environment variable already include CCDPACK
          # else append CCDPACK
          case $NDF_XTN in
              *CCDPACK*)
                  ;;
              *) export NDF_XTN=${NDF_XTN},CCDPACK
                  ;;
          esac
      else
          export NDF_XTN=CCDPACK
      fi
      export NDF_IMP_CCDPACK='$CCDPACK_DIR/ccdimp.sh ^ndf'
      export NDF_EXP_CCDPACK='$CCDPACK_DIR/ccdexp.sh ^ndf'

#  For IRAF data we really do need to keep hold of the bad pixels
#  so make sure of this, unless the NDF_TO_IRAF_PARS variable
#  is already set. In this case we assume that the user knows what
#  they are doing.
      if test -z "$NDF_TO_IRAF_PARS" ; then
         export NDF_TO_IRAF_PARS='FILLBAD=\!'
      fi
      #  Explain how to get help.
      echo "  For help use the commands ccdhelp or ccdwww"
      echo " "
   }

#  Specific additions for the package.csh file.
   csh {

#  Set up aliases for scripts.
      alias ccdexercise $CCDPACK_DIR/ccdexercise
      alias ccd_ccdexercise $CCDPACK_DIR/ccdexercise

      alias ccdfork $CCDPACK_DIR/ccdfork
      alias ccd_ccdfork $CCDPACK_DIR/ccdfork

      alias setexercise $CCDPACK_DIR/setexercise
      alias ccd_setexercise $CCDPACK_DIR/setexercise

      alias wcsexercise $CCDPACK_DIR/wcsexercise
      alias ccd_wcsexercise $CCDPACK_DIR/wcsexercise

      alias ccdwish $CCDPACK_DIR/ccdwish
      alias ccd_ccdwish $CCDPACK_DIR/ccdwish

      alias ccdwww $CCDPACK_DIR/ccdwww
      alias ccd_ccdwww $CCDPACK_DIR/ccdwww

#  Setup conversion of header information for when using foreign data
#  access.
      if ( $?NDF_XTN ) then
         switch ($NDF_XTN)
            case *CCDPACK*:
               breaksw
            default:
               setenv NDF_XTN ${NDF_XTN},CCDPACK
         endsw
      else
         setenv NDF_XTN CCDPACK
      endif
      setenv NDF_IMP_CCDPACK '$CCDPACK_DIR/ccdimp.sh ^ndf'
      setenv NDF_EXP_CCDPACK '$CCDPACK_DIR/ccdexp.sh ^ndf'

#  For IRAF data we really do need to keep hold of the bad pixels
#  so make sure of this, unless the NDF_TO_IRAF_PARS variable
#  is already set. In this case we assume that the user knows what
#  they are doing.
      if ( ! $?NDF_TO_IRAF_PARS ) then
         setenv NDF_TO_IRAF_PARS 'FILLBAD=\!'
      endif

#  Explain how to get help.
      echo "  For help use the commands ccdhelp or ccdwww"
      echo " "
   }

#  Specific additions for the package.icl file.
   icl {

\{  Add definitions for scripts.
      defproc   ccdexercise $CCDPACK_DIR/ccdexercise
      defproc   wcsexercise $CCDPACK_DIR/wcsexercise
      defproc   ccdfork     $CCDPACK_DIR/ccdfork

\{  Add some help definitions.
      defhelp   ccdpack     $CCDPACK_HELP 0
      defhelp   ccdfork     $CCDPACK_HELP
      defstring ccdhelp     help ccdpack
      defstring ccdwww      !$CCDPACK_DIR/ccdwww

\{  Setup conversion of header information for when using foreign data
\{  access.
      hidden proc ccdpack_xtn_set
         ndf_xtn = getenv("NDF_XTN")
         xtn_index = index( ndf_xtn, "CCDPACK" )
         if xtn_index=0
            if ndf_xtn = ""
               setenv NDF_XTN "CCDPACK"
            else
               setenv NDF_XTN (ndf_xtn)",CCDPACK"
            end if
         end if
         setenv NDF_IMP_CCDPACK "$CCDPACK_DIR/ccdimp ^ndf"
         setenv NDF_EXP_CCDPACK "$CCDPACK_DIR/ccdexp ^ndf"
      end proc
      ccdpack_xtn_set

\{  For IRAF data we really do need to keep hold of the bad pixels
\{  so make sure of this, unless the NDF_TO_IRAF_PARS variable
\{  is already set. In this case we assume that the user knows what
\{  they are doing.
      hidden proc ccdpack_iraf_pars_set
         pars = getenv("NDF_TO_IRAF_PARS")
         if pars = ""
            setenv NDF_TO_IRAF_PARS "FILLBAD=!"
         end if
      end proc
      ccdpack_iraf_pars_set

\{  Explain how to get help.
      print "   For help use the commands help ccdpack or ccdwww"
      print " "
   }

#  Specific additions for the IRAF .cl file.

#  The quoting in the first part is rather verbose to work round the
#  fact that tcl always expands a '\' at the end of a line before any
#  other substitution.
   cl "
#  Change the following to allow fillbad to be set to ! and preserve
#  bad pixels.
      reset ndf2iraf='eval cvt() { \134
             unset ICL_TASK_NAME;\134
             x=\\\"`\$CONVERT_DIR/ndf2iraf out=\$2\$3 fillbad=! in=\$1`\\\";\134
             if test -n \\\"\$x\\\"; then \134
                rm -f \$3.imh;\134
                echo \\\"\$x\\\" >&2;\134
                exit 1;\134
             else \134
                exit 0;\134
             fi; \134
          }'
   "

   cl {
#  Say we're here.
      print ""
      print "   CCDPACK commands are now available -- (Version @PACKAGE_VERSION@)"
      print ""

#  IRAF specific tasks
      task use_globals = "ccdpack$use_globals.cl"

#  IRAF environment variables
      set CCDPACK_GLOBALS="yes"

#  Exercise script.
      task ccdexercise = ccdpack$ccdexercise.cl

#   Setup conversion of header information for when using foreign data
#   access.
      s1 = "NONE"
      show | match ("NDF_XTN=", stop=no ) | scan (s1)
      if ( s1 == "NONE") {
         set NDF_XTN="CCDPACK"
      } else {
         set NDF_XTN=(envget("NDF_XTN")//",CCDPACK")
      }
      set NDF_IMP_CCDPACK="$CCDPACK_DIR/ccdimp.sh ^ndf"
      set NDF_EXP_CCDPACK="$CCDPACK_DIR/ccdexp.sh ^ndf"

#  For IRAF data we really do need to keep hold of the bad pixels
#  so make sure of this, unless the NDF_TO_IRAF_PARS variable
#  is already set. In this case we assume that the user knows what
#  they are doing.
      s1 = "NONE"
      show | match ("NDF_TO_IRAF_PARS=", stop=no ) | scan (s1)
      if ( s1 == "NONE") {
         set NDF_TO_IRAF_PARS="FILLBAD=!"
      } else {
      }
   }

}
# $Id$
