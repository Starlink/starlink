      SUBROUTINE MAKESET( STATUS )
*+
*  Name:
*     MAKESET

*  Purpose:
*     Writes Set header information to NDFs.

*  Language:
*     Starlink Fortran 77

*  Type of Module:
*     ADAM A-task

*  Invocation:
*     CALL MAKESET( STATUS )

*  Arguments:
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description:
*     This routine is used to group NDFs into a Set so that they can be
*     processed together.  It is usually used when you have CCD data from
*     a single exposure in multiple files because they were generated
*     from multiple CCDs in a mosaic camera, or from multiple amplifiers
*     in the same CCD, or both.  When this program is run on a group
*     of files, header information is written to each one so that
*     other CCDPACK routines will know about the relationship between
*     them.
*
*     MAKESET writes the following items of data to the .MORE.CCDPACK.SET
*     extension of each NDF:
*        1. The Set NAME (a string identifying all NDFs in the same Set)
*        2. The Set INDEX (an integer identifying the NDF's position
*           within the Set)
*
*     and it will also optionally (if ADDWCS is set true) write:
*        3. The Set coordinate system (a coordinate frame in the NDF's
*           WCS component with the Domain 'CCD_SET').
*
*     Normally by just presenting a list of NDF names to the program the
*     values of these attributes will be taken care of automatically,
*     but various options exist to tune how it is done.

*  Usage:
*     makeset in mode

*  ADAM Parameters:
*     ADDWCS = _LOGICAL (Read)
*        If ADDWCS is true, then MAKESET will attach a new coordinate
*        system to the WCS component of the image.  The new coordinate
*        frame will be a copy of the Current coordinate frame of
*        the image, and will have the Domain name of 'CCD_SET';
*        CCDPACK tasks concerned with registration know about this
*        name and will use those coordinates on the assumption that
*        they constitute a correct registration of images if they
*        are present.  Therefore this parameter should be set true
*        if the images which will form a Set are known to be aligned
*        in their common Current coordinate system.
*
*        If MODE=SPLIT, this parameter is ignored and a new CCD_SET
*        coordinate system which is a copy of the Pixel coordinate
*        system will be added in any case.
*        [TRUE]
*     ASTFILE = LITERAL (Read)
*        If this parameter is supplied, it gives the name of a file
*        containing Set coordinate information.  A new coordinate
*        frame will accordingly be written into the WCS component
*        of each image, with the Domain name 'CCD_SET'; CCDPACK
*        tasks concerned with registration know about this name
*        and will use those coordinates on the assumption that they
*        constitute a correct registration of images if they are
*        present.  The newly added coordinate system will become
*        the Current coordinate system of the image.
*
*        The file named by this parameter will normally have been
*        written by the ASTEXP program, saving a known correct
*        alignment of images within a Set that corresponds to
*        the one being created by this program.  This parameter
*        is ignored if MODE=SPLIT.
*        [!]
*     FITSINDEX = LITERAL (Read)
*        The name of the FITS header card whose value will determine
*        the Set Index attribute of each file.  The Set Index
*        header value itself is determined from the value of the
*        chosen FITS header card and the value of the INDEXVALS
*        parameter.  Only used if MODE=FITS.
*     FITSNAME = LITERAL (Read)
*        The name of the FITS header card whose value will determine
*        the Set Name attribute of each file.  The Set Name header
*        value is taken directly from the chosen FITS header card.
*        Only used if MODE=FITS.
*     IN = LITERAL (Read)
*        A group expression giving a list of NDFs to group into one
*        or more Sets.  The order in which they are listed will
*        normally determine their INDEX values (but see the INDICES
*        parameter), so that the Sets should be generated by
*        presenting NDFs in a consistent order; the one from CCD1
*        first, the one from CCD2 second...
*     INDEXVALS( * ) = LITERAL (Read)
*        A list of strings to map the value of the
*        FITS header card indicated by the FITSINDEX parameter to
*        the Set Index value; if the header value matches the Nth
*        element of this list the file will be given a Set Index
*        value of N.  This parameter will dynamically default to
*        a sorted list of all the values of the chosen parameter
*        which exist in all the input files presented.  This will
*        usually be a suitable value if at least one complete Set
*        is being considered.  Note that each value must in general
*        be surrounded by double quotes.  Only used if MODE=FITS.
*     INDICES( * ) = _INTEGER  (Read)
*        This parameter is a list of positive integers with SETSIZE
*        elements (SETSIZE will normally be the same as the number of
*        NDFs accessed by the IN parameter).  It indicates, for each
*        NDF in the list, what value the Set INDEX attribute should
*        take.  If set to the null value (!) then INDEX attributes
*        will be assigned in order (1, 2, 3, ...) for the members of
*        each Set.  Only used if MODE=LIST.
*        [!]
*     LOGFILE = FILENAME (Read)
*        Name of the CCDPACK logfile.  If a null (!) value is given for
*        this parameter then no logfile will be written, regardless of
*        the value of the LOGTO parameter.
*
*        If the logging system has been initialised using CCDSETUP
*        then the value specified there will be used. Otherwise, the
*        default is "CCDPACK.LOG".
*        [CCDPACK.LOG]
*     LOGTO = LITERAL (Read)
*        Every CCDPACK application has the ability to log its output
*        for future reference as well as for display on the terminal.
*        This parameter controls this process, and may be set to any
*        unique abbreviation of the following:
*           -  TERMINAL  -- Send output to the terminal only
*           -  LOGFILE   -- Send output to the logfile only (see the
*                           LOGFILE parameter)
*           -  BOTH      -- Send output to both the terminal and the
*                           logfile
*           -  NEITHER   -- Produce no output at all
*
*        If the logging system has been initialised using CCDSETUP
*        then the value specified there will be used. Otherwise, the
*        default is "BOTH".
*        [BOTH]
*     MODE = LITERAL (Read)
*        Determines exactly how Set header information should be written
*        to the IN files.  It may take one of the following values:
*           - LIST
*           - CONTAINER
*           - FITS
*           - SPLIT
*
*        When MODE=LIST, new Sets will be formed according to the
*        order in which NDFs are named in the IN list.
*        In the most straightforward case, all the named files will
*        become part of the same new Set, with a Set Name derived
*        from the name of the first file in the list and consecutive
*        Set Index values 1, 2, 3, ....  The SETSIZE and INDICES
*        parameters can be used to create multiple sets in one
*        invocation and to modify the ordering.
*
*        When MODE=CONTAINER, one new Set will be formed for each HDS
*        container file; thus each NDF will be grouped with the
*        other NDFs in the same container file, being given a Set
*        Name based on the name of the container file and a Set Index
*        based on its position within it.  HDS container files
*        suitable for feeding to MAKESET with MODE=CONTAINER are often
*        the result of converting multi-extension FITS files to NDF
*        format.
*
*        When MODE=FITS the Set attributes of each NDF are determined
*        by the value of FITS header cards with keywords given by
*        the FITSINDEX and FITSNAME parameters.  The Set Name
*        attribute is given directly by the value of the FITSNAME-
*        chosen header.  The Set Index attribute is given by the
*        position of the value of the FITSINDEX-chosen header in
*        the list determined by the INDEXVALS parameter.
*        Note this can only be used if both a Name-like and an
*        Index-like header card is available in the FITS header of
*        each file.
*
*        When MODE=SPLIT, a new Set is created for each of the members
*        of the IN list.  Each Set will consist of the data from the
*        input image split up into pieces according to the XSTART
*        and YSTART parameters, or the SECTIONS parameter.
*        A new HDS container file will be written for
*        each IN file, with a name given by the OUT parameter.  Each
*        split piece of the input file will be written as a separate
*        NDF in the container file, with a Set Name given by the
*        name of the original NDF and a Set Index given by the
*        position in the list of pieces.  Unlike the other modes,
*        this does not alter the input file, but creates a new output
*        file to contain the rearranged data.
*        [LIST]
*     NAME = LITERAL (Read)
*        The NAME parameter is used to determine the Set NAME attribute
*        which the grouped NDFs will have; all NDFs in the same Set
*        have the same NAME.  The value of this parameter should be
*        a group expression containing the same number of elements
*        as the number of Sets being created; if it contains
*        modification elements such as "*" they are applied to the
*        name of the first NDF in each Set.
*
*        The default value is "*", which means the Set NAME is the
*        same as the name of the NDF first entered into each Set
*        (if MODE=LIST) or the name of the HDS container file
*        (if MODE=CONTAINER).  If MODE=FITS it is ignored.  There
*        is normally no need to use a value other than the default.
*        [*]
*     OUT = LITERAL (Read)
*        If MODE=SPLIT, this parameter gives the names to use for the
*        output HDS container files; one output filename must be
*        specified for each input NDF.  These may be given as a
*        comma-separated list of names, using indirection if required,
*        or as a single modification element (of the input names).
*        A common modification element is '*', meaning the same name
*        as the input file, so out="*-set" would create output
*        files with the same name as the input files but with "-set"
*        appended.
*
*        If MODE is not SPLIT then no new output files are created, so
*        this parameter is ignored.
*     SECTIONS( * ) = LITERAL (Read)
*        If MODE=SPLIT, this parameter may be used to give a list
*        of NDF section specifiers from which to form the members of
*        the newly created Set.  Each element may optionally be
*        enclosed in parentheses, and should be of the form
*        explained in the "NDF Sections" section of SUN/33;
*        typically it will be of the form "(xmin:xmax,ymin:ymax)".
*        Note that if supplying this parameter on the command line
*        it will be necessary to include each element in quotes and
*        the whole list in square brackets, e.g.:
*           sections=["(17:500,1:1024)","(525:1000,1:1024)"]
*
*        When using a Unix shell the whole thing will have to be
*        placed in single quotes as well.
*
*        If a null value (!) is given for this parameter the
*        XSTART and YSTART parameters are used instead; if the
*        sections into which the input images are to be split
*        tile the whole of the input image, this is usually
*        more convenient.  This parameter is ignored unless
*        MODE=SPLIT.
*        [!]
*     SETSIZE = _INTEGER (Read)
*        The number of NDFs in each Set.  This will default initially
*        to the number of NDFs in the IN list, but if set to a
*        number less than that, then more than one set will be
*        generated (the first SETSIZE from IN will become the first
*        set, and so on).  If INDICES is specified it must have SETSIZE
*        elements, and Set INDEX assignment will wrap round when
*        SETSIZE elements have been processed.  SETSIZE must be
*        positive, and must be a divisor of the number of NDFs in
*        the IN list, so that each distinct Set created by one
*        invocation of MAKESET is forced to be the same size.
*        Only used if MODE=LIST.
*        [dynamic]
*     XSTART( * ) = _INTEGER (Read)
*        If MODE=SPLIT and SECTIONS is null, this gives a list of
*        the first pixel index in the X direction (first coordinate)
*        of rectangular regions which will become members of a new Set.
*        If there are NX elements given for XSTART and NY for YSTART
*        then each created Set will contain NX*NY members.  The
*        region at position (IX,IY) will be composed of pixels
*        XSTART(IX)..XSTART(IX+1)-1 in the X direction and
*        YSTART(IY)..YSTART(IY+1)-1 in the Y direction, where the
*        last pixel in the input image is implied for the upper
*        bound of the NX'th element of XSTART.  The
*        XSTART and YSTART parameters are given for convenience; the
*        same information can be given by specifying an appropriate
*        value for the more flexible SECTIONS parameter.
*     YSTART( * ) = _INTEGER (Read)
*        If MODE=SPLIT and SECTIONS is null, this gives a list of
*        the first pixel index in the Y direction (second coordinate)
*        of rectangular sections which will become members of a new Set.
*        If there are NX elements given for XSTART and NY for YSTART
*        then each created Set will contain NX*NY members.  The
*        region at position (IX,IY) will be composed of pixels
*        XSTART(IX)..XSTART(IX+1)-1 in the X direction and
*        YSTART(IY)..YSTART(IY+1)-1 in the Y direction, where the
*        last pixel in the input image is implied for the upper
*        bound of the NY'th element of YSTART.  The
*        XSTART and YSTART parameters are given for convenience; the
*        same information can be given by specifying an appropriate
*        value for the more flexible SECTIONS parameter.

*  Examples:
*     makeset "data1,data2,data3,data4" addwcs mode=list
*        This will write Set information into the named NDFs; they will
*        all be given the same Set Name attribute ("data1") and will
*        be given the Set Index attributes 1, 2, 3 and 4 respectively.
*        Additionally, a new attached coordinate system with the Domain
*        "CCD_SET" will be added to the World Coordinate System (WCS)
*        component of each; this will be a copy of each one's Current
*        attached coordinate system.  If not all of them have the
*        same Current coordinate system when the program is run
*        (i.e. they do not all have the same Domain), then a warning
*        will be issued.
*
*     makeset * mode=container
*        In this case, all the NDFs in the current directory are
*        assigned Set header information based on how they are
*        contained within HDS container files.
*
*     makeset * mode=list setsize=4
*        This will add Set information to all the NDFs in the current
*        directory, grouping them into Sets of 4 NDFs each.  If MAKESET
*        is to be used in this way however it must be done with care,
*        since it will group the files in the order in which they
*        are presented.  This depends on what order the "*" character
*        is expanded in, which depends on the details of the shell
*        that you are using.  Typically shells expand alphabetically,
*        so that if the directory contains files with the names
*        d08.sdf, d09.sdf, d10.sdf, d11.sdf they will be presented
*        in that order, but files with the names d8.sdf, d9.sdf,
*        d10.sdf, d11.sdf would be presented in the order d10.sdf,
*        d11.sdf, d8.sdf, d9.sdf.  Unless you are confident of how
*        your shell behaves in this respect, then when using wildcards
*        you should pay careful attention to the log output of
*        MAKESET to check that the order is correct.  It is safest
*        to list Set members explicitly as in the previous example.
*
*     makeset "d1,d2,d3,e1,e2,e3" name=night1-* setsize=3 addwcs=no
*        This will construct two Sets, which will be given Set Name
*        attributes of "night1-d1" and "night1-e1" respectively.
*        You might want to do this if you are going to use these
*        files along with other Sets generated from files with the
*        names the same as these.  No additions are made to the
*        WCS componnent of the images.
*
*     makeset "d1,d3" indices=[1,3]
*        This will construct a Set of the two named NDFs, giving them
*        the Set Index attributes of 1 and 3 respectively.  This
*        might be necessary for comparison with 3-member sets if the
*        Index=2 one is absent in this case due to a loss of the data
*        file for some reason.
*
*     makeset multi split out=multi-s
*             sections=["(1:32,1:48)","(1:32,49:96)",
*                       "(33:64,1:48)","(33:64,49:96)"]
*        A new HDS container file called multi-s is created which
*        contains the data from the single image multi, split up
*        into four new NDFs.  A new coordinate system with the
*        domain CCD_SET will be added which is a copy of the
*        Pixel coordinates, and the Pixel coordinate of each of
*        the new images will be the same as it was in the original.
*
*     makeset multi split out=multi-s
*             sections=["(:32,:48)","(:32,49:)","(33:,:48)","(33:,49:)"]
*        If the input NDF multi has X pixels in the range 1:64 and
*        Y pixels in the range 1:96, this does exactly the same as
*        the previous example, cutting multi into quarters.  The
*        abbreviated NDF section specifier syntax allows omission
*        of a pixel bound when it is at the edge of the NDF.
*
*     makeset in=* mode=split out=*-s sections=!
*             xstart="1,33" ystart="1,49"
*        This does the same as the previous example again, using the
*        somewhat simpler XSTART and YSTART parameters.  This time
*        a new Set is created for each of the NDFs in the current
*        directory, and written into a container file with the
*        same name but '-s' appended.

*  Notes:
*     - When MODE=CONTAINER, membership of a Set is not strictly
*     determined by the identity of the HDS container file in which
*     it resides, but by the pathname supplied to the IN parameter
*     which identifies that HDS container file.  Thus it is possible
*     to create members of two Sets within a single container file
*     in one invocation of MAKESET, but it's most unlikely that this
*     will result unless you are deliberately invoking it in a
*     bizarre way.
*
*     - When a non-null ASTFILE parameter is supplied, this program
*     duplicates much of the functionality of ASTIMP.

*  Behaviour of Parameters:
*     All parameters retain their current value as default. The
*     "current" value is the value assigned on the last run of the
*     application. If the application has not been run then the
*     "intrinsic" defaults, as shown in the parameter help, apply.
*
*     Retaining parameter values has the advantage of allowing you to
*     define the default behaviour of the application. The intrinsic
*     default behaviour of the application may be restored by using the
*     RESET keyword on the command line.
*
*     Certain parameters (LOGTO and LOGFILE) have global
*     values. These global values will always take precedence, except
*     when an assignment is made on the command line. Global values may
*     be set and reset using the CCDSETUP and CCDCLEAR commands.

*  Copyright:
*     Copyright (C) 2001 Central Laboratory of the Research Councils

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 2 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful, but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 51 Franklin Street,Fifth Floor, Boston, MA
*     02110-1301, USA

*  Authors:
*     MBT: Mark Taylor (STARLINK)
*     {enter_new_authors_here}

*  History:
*     5-FEB-2001 (MBT):
*        Original version.
*     {enter_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-

*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'AST_PAR'          ! Standard AST constants
      INCLUDE 'GRP_PAR'          ! Standard GRP constants
      INCLUDE 'PRM_PAR'          ! PRIMDAT system constants
      INCLUDE 'DAT_PAR'          ! Standard HDS constants
      INCLUDE 'PAR_ERR'          ! PAR system error values
      INCLUDE 'CCD1_PAR'         ! Private CCDPACK constants

*  External References:
      INTEGER CHR_LEN
      EXTERNAL CHR_LEN           ! Used length of string

*  Status:
      INTEGER STATUS             ! Global status

*  Local Constants:
      INTEGER MXFSET             ! Maximum framesets in one file
      PARAMETER ( MXFSET = 100 )
      INTEGER MXSECT             ! Maximum number of sections to split into
      PARAMETER ( MXSECT = 32 )

*  Local Variables:
      INTEGER FIRST              ! Position of first character in string
      INTEGER FSET( MXFSET )     ! AST pointers to import framesets
      INTEGER FSMAT              ! AST pointer to matching frameset
      INTEGER I                  ! Loop variable
      INTEGER IAT                ! Position in string
      INTEGER ICARD              ! Index of FITS header card
      INTEGER IF                 ! Loop index for framesets
      INTEGER IGOT               ! Found index in GRP group
      INTEGER IGRP               ! Temporary GRP identifier
      INTEGER INDEX              ! Set INDEX attribute
      INTEGER INDDFL( CCD1__MXNDF ) ! Default values for INDXS
      INTEGER INDXS( CCD1__MXNDF ) ! Index values for successive NDFs in Set
      INTEGER INDF               ! NDF identifier
      INTEGER INGRP              ! GRP identifier for input NDFs
      INTEGER INNDF              ! Input only NDF identifier
      INTEGER IPFITS             ! Pointer to mapped FITS headers
      INTEGER ISET( CCD1__MXNDF ) ! Which Set NDF belongs to
      INTEGER IVGRP              ! GRP identifier for index values
      INTEGER IVSGRP             ! GRP identifier for sorted index values
      INTEGER IWCS               ! AST identifier for WCS frameset
      INTEGER J                  ! Loop variable
      INTEGER JSET               ! Symbolic frame index for new WCS frame
      INTEGER K                  ! Offset into input NDF list
      INTEGER LAST               ! Position of last character in string
      INTEGER LDRGRP             ! GRP identifier for NDF base names
      INTEGER NAMGRP             ! GRP identifier for Set NAME attributes
      INTEGER NC( CCD1__MXNDF )  ! Number of NDFs so far in each Set
      INTEGER NCARD              ! Number of mapped FITS header cards
      INTEGER NCHAR              ! Number of characters in conversion
      INTEGER NFSET              ! Number of framesets in group
      INTEGER NIV                ! Number of index values
      INTEGER NNDF               ! Number of input NDFs
      INTEGER NOUT               ! Number of output NDFs
      INTEGER NRET               ! Number of names returned (dummy)
      INTEGER NSECT              ! Number of sections to split into
      INTEGER NSET               ! Number of Sets to be generated
      INTEGER NSX                ! Number of split panels in X direction
      INTEGER NSY                ! Number of split panels in Y direction
      INTEGER NTRY               ! Number of tries for parameter entry
      INTEGER OUTGRP             ! GRP identifier for output file names
      INTEGER PLACE( CCD1__MXNDF ) ! Placeholders for output NDFs
      INTEGER SETSIZ             ! Number of NDFs in each Set
      INTEGER SINDEX( CCD1__MXNDF ) ! What Set Index the NDF has
      INTEGER SX( MXSECT )       ! X direction split panel start pixel indices
      INTEGER SY( MXSECT )       ! Y direction split panel start pixel indices
      LOGICAL ADDWCS             ! Add a CCD_SET frame?
      LOGICAL ASTFL              ! Use an AST file?
      LOGICAL DIFER              ! Do some NDFs have different Current domain?
      LOGICAL DIFSIZ             ! Are some groups different sizes?
      LOGICAL FITSEX             ! Does FITS extension exist?
      LOGICAL MATCH              ! Does frameset match?
      CHARACTER * ( 16 ) MODE    ! Mode for Set information construction
      CHARACTER * ( 80 ) FITIND  ! FITS header keyword for Set Index info
      CHARACTER * ( 80 ) FITNAM  ! FITS header keyword for Set Name info
      CHARACTER * ( 80 ) FITRTS( MXFSET ) ! FITS rot keyword frameset modifiers
      CHARACTER * ( 80 ) FNAME( CCD1__MXNDF ) ! FITNAM header card values
      CHARACTER * ( 80 ) FINDEX( CCD1__MXNDF ) ! FITIND header card values
      CHARACTER * ( 80 ) IVS( CCD1__MXNDF ) ! Index value strings
      CHARACTER * ( AST__SZCHR ) DMN1 ! Domain of Set leader Current frame
      CHARACTER * ( AST__SZCHR ) DOMAIN ! Domain to use for CCD_SET frame
      CHARACTER * ( AST__SZCHR ) FSID( MXFSET ) ! Id values for each frameset
      CHARACTER * ( DAT__SZLOC ) LOC ! HDS locator
      CHARACTER * ( GRP__SZNAM ) FIELDS( 6 ) ! NDG supplementary information
      CHARACTER * ( GRP__SZNAM ) NAME ! Set NAME attribute
      CHARACTER * ( GRP__SZNAM ) NDFNAM ! Name of NDF
      CHARACTER * ( GRP__SZNAM ) SECTS( MXSECT ) ! Section specifiers
      CHARACTER * ( CCD1__BLEN ) LINE ! Buffer for character output

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Start up log file system, write introduction.
      CALL CCD1_START( 'MAKESET', STATUS )

*  Begin a new NDF context.
      CALL NDF_BEGIN

*  Initialise GRP identifiers, so that a later call of CCD1_GRDEL on
*  an uninitialised group cannot cause trouble.
      INGRP = GRP__NOID
      LDRGRP = GRP__NOID
      NAMGRP = GRP__NOID
      OUTGRP = GRP__NOID

*  ====================================================================
*  Preparation section.  Work out what Set header information will be
*  written to each NDF.
*  ====================================================================
*  Access an NDG group containing a list of NDF names.
      CALL CCD1_NDFGL( 'IN', 1, CCD1__MXNDF, INGRP, NNDF, STATUS )

*  What shall we do with all these NDFs?
      CALL PAR_CHOIC( 'MODE', 'LIST', 'LIST,CONTAINER,FITS,SPLIT',
     :                .TRUE., MODE, STATUS )

*  Initialise number of Sets and Set base name group.
      NSET = 0
      CALL GRP_NEW( 'CCD:BASENAMES', LDRGRP, STATUS )
      IF ( STATUS .NE. SAI__OK ) GO TO 99

*  Getting Set information by position in container files.
      IF ( MODE .EQ. 'CONTAINER' ) THEN

*  Go through all the input NDFs recording which container file each
*  is in.
         DO I = 1, NNDF

*  Get the name of the container file.
            CALL NDG_GTSUP( INGRP, I, FIELDS, STATUS )
            NCHAR = 0
            IF ( FIELDS( 5 ) .NE. ' ' ) THEN
               CALL CHR_APPND( FIELDS( 5 ), NAME, NCHAR )
               CALL CHR_APPND( '/', NAME, NCHAR )
            END IF
            CALL CHR_APPND( FIELDS( 4 ), NAME, NCHAR )

*  Work out which Set of the ones we are creating this will belong to.
*  If it's the first one of a new Set, initialise the records for
*  that Set and add the name of the container file to the base names
*  group.
            CALL GRP_INDEX( NAME, LDRGRP, 1, IGOT, STATUS )
            IF ( IGOT .EQ. 0 ) THEN
               NSET = NSET + 1
               NC( NSET ) = 0
               CALL GRP_PUT( LDRGRP, 1, NAME, NSET, STATUS )
               IGOT = NSET
            END IF

*  Store the Set Name information and which Set it belongs to.
            NC( IGOT ) = NC( IGOT ) + 1
            SINDEX( I ) = NC( IGOT )
            ISET( I ) = IGOT
         END DO

*  Check that all the Sets we are about to create are the same size.
*  If not, warn the user.
         DIFSIZ = .FALSE.
         IF ( NSET .GT. 1 ) THEN
            DO I = 2, NSET
               DIFSIZ = DIFSIZ .OR. ( NC( I ) .NE. NC( I - 1 ) )
            END DO
         END IF
         IF ( DIFSIZ ) THEN
            CALL CCD1_MSG( ' ', ' ', STATUS )
            CALL CCD1_MSG( ' ',
     :      '  ** Warning: not all Sets are the same size.', STATUS )
         END IF

*  Getting Set information by position in input list.
      ELSE IF ( MODE .EQ. 'LIST' ) THEN

*  Get the number of NDFs per Set.  It dynamically defaults to the
*  number of NDFs in the IN group.  It must divide into the number of
*  NDFs in the input group.
         NTRY = 0
 1       CONTINUE
         CALL PAR_DEF0I( 'SETSIZE', NNDF, STATUS )
         CALL PAR_GET0I( 'SETSIZE', SETSIZ, STATUS )
         IF ( MOD( NNDF, SETSIZ ) .NE. 0 .OR. SETSIZ .LT. 0 ) THEN
            IF ( NTRY .LT. 5 ) THEN
               CALL MSG_SETI( 'NNDF', NNDF )
               CALL MSG_SETI( 'SETSIZ', SETSIZ )
               CALL MSG_OUT( ' ', '  Number of input NDFs ^NNDF not '
     :         // 'divisible by SETSIZE ^SETSIZ - try again.',
     :         STATUS )
               CALL PAR_CANCL( 'SETSIZE', STATUS )
               NTRY = NTRY + 1
               GO TO 1
            ELSE
               STATUS = SAI__ERROR
               CALL ERR_REP( 'MAKESET_BADSIZE',
     :                       'MAKESET: Bad SETSIZE parameter.', STATUS )
               GO TO 99
            END IF
         END IF

*  Calculate the number of Sets we will be generating.
         NSET = NNDF / SETSIZ

*  Get a list of integers to use for the Set INDEX attributes.  If null,
*  use an array 1,2,3..SETSIZ.
         IF ( STATUS .NE. SAI__OK ) GO TO 99
         CALL CCD1_GISEQ( 1, 1, SETSIZ, INDDFL, STATUS )
         CALL PAR_GDR1I( 'INDICES', SETSIZ, INDDFL, 1, VAL__MAXI,
     :                   .TRUE., INDXS, STATUS )

*  Store the Set Index and number of the Set for each input NDF.
         K = 1
         DO I = 1, NSET
            CALL GRP_GET( INGRP, K, 1, NAME, STATUS )
            CALL GRP_PUT( LDRGRP, 1, NAME, I, STATUS )
            DO J = 1, SETSIZ
               ISET( K ) = I
               SINDEX( K ) = INDXS( J )
               K = K + 1
            END DO
         END DO

*  Creating a new Set by splitting the input NDF.
      ELSE IF ( MODE .EQ. 'SPLIT' ) THEN

*  Get NDF Section specifiers for the members of each Set.
         CALL PAR_GET1C( 'SECTIONS', MXSECT, SECTS, NSECT, STATUS )
         IF ( STATUS .EQ. SAI__OK ) THEN

*  Ensure that the NDF section specifiers contain surrounding parentheses
*  (optional in supplying the parameter value).
            DO I = 1, NSECT
               CALL CHR_FANDL( SECTS( I ), FIRST, LAST )
               IF ( SECTS( I )( FIRST:FIRST ) .EQ. '(' .AND.
     :              SECTS( I )( LAST:LAST ) .EQ. ')' ) THEN
                  SECTS( I )( FIRST:FIRST ) = ' '
                  SECTS( I )( LAST:LAST ) = ' '
                  CALL CHR_RMBLK( SECTS( I ) )
               END IF
               SECTS( I ) = '(' // SECTS( I )( 1:CHR_LEN( SECTS( I ) ) )
     :                   // ')'
            END DO

*  If the SECTIONS parameter has not been supplied, construct NDF
*  section specifiers from the convenience XSTART and YSTART
*  parameters instead.
         ELSE IF ( STATUS .EQ. PAR__NULL ) THEN

*  Annul the error.
            CALL ERR_ANNUL( STATUS )

*  Get the parameter values.
            CALL PAR_GET1I( 'XSTART', MXSECT, SX, NSX, STATUS )
            CALL PAR_GET1I( 'YSTART', MXSECT / NSX, SY, NSY, STATUS )
            IF ( STATUS .NE. SAI__OK ) GO TO 99

*  Construct an NDF section specifier for each of the NSX * NSY
*  rectangles.
            NSECT = 0
            DO I = 1, NSX
               DO J = 1, NSY
                  NSECT = NSECT + 1
                  CALL MSG_SETI( 'X1', SX( I ) )
                  IF ( I .LT. NSX ) THEN
                     CALL MSG_SETI( 'X2', SX( I + 1 ) )
                  ELSE
                     CALL MSG_SETC( 'X2', ' ' )
                  END IF
                  CALL MSG_SETI( 'Y1', SY( J ) )
                  IF ( J .LT. NSY ) THEN
                     CALL MSG_SETI( 'Y2', SY( J + 1 ) )
                  ELSE
                     CALL MSG_SETC( 'Y2', ' ' )
                  END IF
                  CALL MSG_LOAD( ' ', '(^X1:^X2,^Y1:^Y2)',
     :                           SECTS( NSECT ), IAT, STATUS )
                  CALL CHR_RMBLK( SECTS( NSECT ) )
               END DO
            END DO
         END IF
         IF ( STATUS .NE. SAI__OK ) GO TO 99

*  Get the names of the output files by modification of the input NDF
*  name group.
         CALL CCD1_NDFPG( 'OUT', INGRP, NNDF, OUTGRP, STATUS )

*  Create a new group of input NDF names (now one for each NDF section,
*  rather than just one for each input NDF), and corresponding output
*  NDF placeholders.
         IGRP = INGRP
         NSET = NNDF
         NOUT = 0
         CALL GRP_NEW( 'CCD:NAMES', INGRP, STATUS )
         DO I = 1, NNDF

*  Use the names of the input NDFs to construct the Set Name attributes.
            CALL GRP_GET( IGRP, I, 1, NAME, STATUS )
            CALL GRP_PUT( LDRGRP, 1, NAME, I, STATUS )

*  Create a new HDS container file for each new Set.
            CALL GRP_GET( OUTGRP, I, 1, NAME, STATUS )
            CALL HDS_NEW( NAME, 'NDFS', 'NDF_CONTAINER', 0, 0, LOC,
     :                    STATUS )

*  Prepare to write one NDF for each Set into the container file.
            DO J = 1, NSECT
               NOUT = NOUT + 1

*  Record which Set this one is in.
               ISET( NOUT ) = I
               SINDEX( NOUT ) = J

*  Get a placeholder.
               CALL MSG_SETI( 'INDEX', J )
               CALL MSG_LOAD( ' ', 'i^INDEX', NAME, IAT, STATUS )
               CALL NDF_PLACE( LOC, NAME, PLACE( NOUT ), STATUS )

*  Record its name.
               CALL GRP_GET( IGRP, I, 1, NAME, STATUS )
               NAME( CHR_LEN( NAME ) + 1: ) = SECTS( J )
               CALL GRP_PUT( INGRP, 1, NAME, 0, STATUS )
            END DO
            CALL DAT_ANNUL( LOC, STATUS )
         END DO
         NNDF = NOUT

*  Release resources.
         CALL CCD1_GRDEL( IGRP, STATUS )

*  Getting Set information from FITS headers.
      ELSE IF ( MODE .EQ. 'FITS' ) THEN

*  Find out what FITS headers we have to use.
         CALL PAR_GET0C( 'FITSNAME', FITNAM, STATUS )
         CALL PAR_GET0C( 'FITSINDEX', FITIND, STATUS )

*  Convert them to upper case.
         CALL CHR_UCASE( FITNAM )
         CALL CHR_UCASE( FITIND )

*  Get the values of these headers for each of the input files.
         DO I = 1, NNDF

*  Locate and map the FITS extension.
            CALL GRP_GET( INGRP, I, 1, NDFNAM, STATUS )
            CALL NDG_NDFAS( INGRP, I, 'READ', INDF, STATUS )
            CALL NDF_XSTAT( INDF, 'FITS', FITSEX, STATUS )
            IF ( .NOT. FITSEX .AND. STATUS .EQ. SAI__OK ) THEN
               STATUS = SAI__ERROR
               CALL MSG_SETC( 'NDF', NDFNAM )
               CALL ERR_REP( 'MAKESET_NOFTS',
     :         'MAKESET: No FITS extension in NDF ^NDF.', STATUS )
            END IF
            CALL NDF_XLOC( INDF, 'FITS', 'READ', LOC, STATUS )
            CALL DAT_MAPV( LOC, '_CHAR*80', 'READ', IPFITS, NCARD,
     :                     STATUS )

*  Get the requested header card values.
            CALL CCD1_FTGET( NCARD, IPFITS, 1, FITNAM, FNAME( I ),
     :                       ICARD, STATUS )
            CALL CCD1_FTGET( NCARD, IPFITS, 1, FITIND, FINDEX( I ),
     :                       ICARD, STATUS )

*  Remove quote characters; these are unlikely to remove any
*  ambiguity and quoting them in the parameter values is a pain.
            CALL CHR_RMCHR( '''', FNAME( I ) )
            CALL CHR_RMCHR( '''', FINDEX( I ) )

*  Unmap and release the FITS header.
            CALL DAT_UNMAP( LOC, STATUS )
            CALL DAT_ANNUL( LOC, STATUS )

*  Make sure that the header card values are not blank.
            IF ( FNAME( I ) .EQ. ' ' .AND. STATUS .EQ. SAI__OK ) THEN
               STATUS = SAI__ERROR
               CALL MSG_SETC( 'FITNAM', FITNAM )
               CALL ERR_REP( 'MAKESET_BADFTS', 'MAKESET: Blank value '//
     :' of FITSNAME header ^FITNAM not allowed.', STATUS )
            END IF
            IF ( FINDEX( I ) .EQ. ' ' .AND. STATUS .EQ. SAI__OK ) THEN
               STATUS = SAI__ERROR
               CALL MSG_SETC( 'FITIND', FITIND )
               CALL ERR_REP( 'MAKESET_BADFTS', 'MAKESET: Blank value '//
     :' of FITSINDEX header %FITIND not allowed.', STATUS )
            END IF
            IF ( STATUS .NE. SAI__OK ) GO TO 99
         END DO

*  Create groups containing each of the FINDEX values once and each
*  of the FNAME values once.
         CALL GRP_NEW( 'CCD:INDEXVALS', IVGRP, STATUS )
         CALL GRP_NEW( 'CCD:NAMES', NAMGRP, STATUS )
         NIV = 0
         NSET = 0
         DO I = 1, NNDF
            CALL GRP_INDEX( FINDEX( I ), IVGRP, 1, IGOT, STATUS )
            IF ( IGOT .EQ. 0 ) THEN
               NIV = NIV + 1
               CALL GRP_PUT( IVGRP, 1, FINDEX( I ), NIV, STATUS )
            END IF
            CALL GRP_INDEX( FNAME( I ), NAMGRP, 1, ISET( I ), STATUS )
            IF ( ISET( I ) .EQ. 0 ) THEN
               NSET = NSET + 1
               CALL GRP_PUT( NAMGRP, 1, FNAME( I ), NSET, STATUS )
               ISET( I ) = NSET
            END IF
         END DO

*  Sort the group of FINDEX values alphabetically.
         CALL CCD1_GSRT( IVGRP, IVSGRP, STATUS )

*  Write them into an array, and use this as the dynamic default for
*  the parameter.  We use a vector of strings here rather than the
*  more easy-to-use group because each element might have delimiters
*  (commas) in it, and the dynamic default might just be too long
*  for the ADAM parameter length.  Hopefully most of the time it
*  will be possible just to use the default in any case.
         CALL GRP_GET( IVSGRP, 1, NIV, IVS, STATUS )
         CALL PAR_DEF1C( 'INDEXVALS', NIV, IVS, STATUS )

*  Release sets.
         CALL CCD1_GRDEL( IVGRP, STATUS )
         CALL CCD1_GRDEL( IVSGRP, STATUS )

*  Get the actual list from the user and write it into a group.
         CALL PAR_GET1C( 'INDEXVALS', VAL__MAXI, IVS, NIV, STATUS )
         CALL GRP_NEW( 'CCD:NAMES', IVSGRP, STATUS )
         CALL GRP_PUT( IVSGRP, NIV, IVS, 1, STATUS )

*  Work out the Set Index value of each presented NDF on the basis
*  of this.
         DO I = 1, NNDF
            CALL GRP_INDEX( FINDEX( I ), IVSGRP, 1, SINDEX( I ),
     :                      STATUS )
            IF ( SINDEX( I ) .LE. 0 ) THEN
               STATUS = SAI__ERROR
               CALL MSG_SETC( 'KEY', FITIND )
               CALL MSG_SETC( 'VAL', FINDEX( I ) )
               CALL ERR_REP( 'MAKESET_NOTGOT', 'MAKESET: FITS ^KEY'//
     :' value ^VAL not in INDEXVALS', STATUS )
               GO TO 99
            END IF
         END DO

*  Unrecognised Set creation mode.
      ELSE
         STATUS = SAI__ERROR
         CALL ERR_REP( 'MAKESET_BADMODE',
     :                 'MAKESET: Bad Set creation mode', STATUS )
         GO TO 99
      END IF
      IF ( STATUS .NE. SAI__OK ) GO TO 99

*  Construct a group of names using the NAME parameter as a basis,
*  possibly modifying the leader group.
      IF ( MODE .NE. 'FITS' ) THEN
         CALL CCD1_STRGR( 'NAME', LDRGRP, NSET, NSET, NAMGRP, NRET,
     :                    STATUS )
      END IF

*  ======================================================================
*  WCS section: Decide what new coordinate frame to add if any.
*  ======================================================================

*  Read framesets from an AST file if required; if this is done, they
*  will be used as the CCD_SET alignment frames.
      IF ( STATUS .NE. SAI__OK ) GO TO 99
      ASTFL = .FALSE.
      ADDWCS = .FALSE.
      JSET = AST__NOFRAME
      IF ( MODE .NE. 'SPLIT' ) THEN
         CALL CCD1_AFRD( 'ASTFILE', MXFSET, FSET, FSID, FITRTS, NFSET,
     :                   STATUS )
         IF ( STATUS .EQ. PAR__NULL ) THEN
            ASTFL = .FALSE.
            CALL ERR_ANNUL( STATUS )
         ELSE
            ASTFL = .TRUE.
         END IF

*  Determine whether we are to mark the Current frame as the CCD_SET
*  alignment frame.
         IF ( .NOT. ASTFL ) THEN
            CALL PAR_GET0L( 'ADDWCS', ADDWCS, STATUS )
            IF ( ADDWCS ) THEN
               JSET = AST__CURRENT
            END IF
         END IF
      END IF

*  ======================================================================
*  Set construction section: go through input NDFs and write Set headers.
*  ======================================================================

*  Write output message header to user.
      CALL CCD1_MSG( ' ', ' ', STATUS )
      LINE = ' '
      LINE( 2: ) = 'Set name'
      LINE( 12: ) = 'Set index'
      LINE( 24: ) = 'NDF name'
      IF ( ADDWCS .OR. ASTFL .OR. MODE .EQ. 'SPLIT' ) THEN
         LINE( 60: ) = 'CCD_SET domain'
      END IF
      CALL CCD1_MSG( ' ', LINE, STATUS )
      LINE( 2: ) = '--------'
      LINE( 12: ) = '---------'
      LINE( 24: ) = '--------'
      IF ( ADDWCS .OR. ASTFL .OR. MODE .EQ. 'SPLIT' ) THEN
         LINE( 60: ) = '--------------'
      END IF
      CALL CCD1_MSG( ' ', LINE, STATUS )

*  Loop over Sets to be generated.
      K = 0
      DO I = 1, NSET
         CALL CCD1_MSG( ' ', ' ', STATUS )

*  If we are writing output files, log the name to the user.
         IF ( MODE .EQ. 'SPLIT' ) THEN
            CALL GRP_GET( OUTGRP, I, 1, NAME, STATUS )
            CALL MSG_SETC( 'NAME', NAME )
            CALL CCD1_MSG( ' ', ' Writing to container file ^NAME',
     :                     STATUS )
         END IF

*  Get the NAME attribute for this Set, and write it to the user.
         CALL GRP_GET( NAMGRP, I, 1, NAME, STATUS )
         LINE = ' '
         LINE( 2: ) = NAME
         LINE( CHR_LEN( LINE ) + 1: ) = ':'
         CALL CCD1_MSG( ' ', LINE, STATUS )

*  Search out NDFs to be placed in this Set.
         DIFER = .FALSE.
         K = 0
         DO J = 1, NNDF
            IF ( STATUS .NE. SAI__OK ) GO TO 99
            IF ( ISET( J ) .EQ. I ) THEN
               K = K + 1
               INDEX = SINDEX( J )

*  Get the NDF identifier.
               IF ( MODE .EQ. 'SPLIT' ) THEN

*  In the case of MODE=SPLIT, create a new NDF here from the input one.
                  CALL NDG_NDFAS( INGRP, J, 'READ', INNDF, STATUS )
                  CALL NDF_SCOPY( INNDF, 'Axis,WCS,Data,Quality,'
     :                            //'Variance,Units', PLACE( J ),
     :                            INDF, STATUS )
                  CALL NDF_ANNUL( INNDF, STATUS )
               ELSE
                  CALL NDG_NDFAS( INGRP, J, 'UPDATE', INDF, STATUS )
               END IF

*  Get the NDF name.
               CALL GRP_GET( INGRP, J, 1, NDFNAM, STATUS )

*  Initialise WCS data.
               JSET = AST__NOFRAME
               DOMAIN = ' '

*  Get WCS data from an AST file.
               IF ( ASTFL ) THEN

*  Get the WCS frameset.
                  CALL CCD1_GTWCS( INDF, IWCS, STATUS )

*  Map the FITS extension if it can be found.
                  NCARD = 0
                  CALL NDF_XSTAT( INDF, 'FITS', FITSEX, STATUS )
                  IF ( FITSEX ) THEN
                     CALL NDF_XLOC( INDF, 'FITS', 'READ', LOC, STATUS )
                     CALL DAT_MAPV( LOC, '_CHAR*80', 'READ', IPFITS,
     :                              NCARD, STATUS )
                  END IF

*  Go through the list of IDs to see if any match this NDF.
                  DO IF = 1, NFSET
                     CALL CCD1_NMID( FSID( IF ), INDEX, NCARD, IPFITS,
     :                               INDEX, MATCH, STATUS )
                     IF ( MATCH ) THEN
                        FSMAT = FSET( IF )
                        GO TO 2
                     END IF
                  END DO
 2                CONTINUE

*  No matching frameset was found from the AST file - inform user.
                  IF ( .NOT. MATCH ) THEN
                     CALL CCD1_MSG( ' ', '  No matching frameset in '//
     :               'AST file - Set coordinates not added', STATUS )
                  ELSE

*  Now we need to add the new frame to the WCS frameset.
*  Set the Current frame of the WCS frameset to the one which has the
*  same Domain as the Base frame of the read-in frameset.
                     DOMAIN = AST_GETC( FSMAT, 'Domain', STATUS )
                     CALL CCD1_ADFRM( IWCS, FSMAT, 'CCD_SET', 0D0,
     :                                FITRTS( I ), NCARD, IPFITS,
     :                                STATUS )

*  Set the new frame to be the Current one.
                     JSET = AST_GETI( IWCS, 'Nframe', STATUS )
                     CALL AST_SETI( IWCS, 'Current', JSET, STATUS )

*  Ensure that we don't try to add the frame again.
                     JSET = AST__NOFRAME

*  Write the modified WCS component back to the NDF.
                     CALL NDF_PTWCS( IWCS, INDF, STATUS )
                  END IF

*  Release resources.
                  CALL AST_ANNUL( IWCS, STATUS )
                  CALL DAT_UNMAP( LOC, STATUS )
                  CALL DAT_ANNUL( LOC, STATUS )

*  Arrange to write a new CCD_SET frame as a copy of the Current
*  frame of the WCS frameset.
               ELSE IF ( ADDWCS ) THEN
                  CALL CCD1_GTWCS( INDF, IWCS, STATUS )
                  DOMAIN = AST_GETC( IWCS, 'Domain', STATUS )
                  JSET = AST_GETI( IWCS, 'Current', STATUS )
                  CALL AST_ANNUL( IWCS, STATUS )

*  Arrange to write a new CCD_SET frame as a copy of the PIXEL frame.
               ELSE IF ( MODE .EQ. 'SPLIT' ) THEN
                  DOMAIN = 'PIXEL'
                  CALL CCD1_GTWCS( INDF, IWCS, STATUS )
                  CALL CCD1_FRDM( IWCS, 'PIXEL', JSET, STATUS )
                  CALL AST_ANNUL( IWCS, STATUS )
               END IF

*  Check that the domains are consistent for all NDFs.
               IF ( ADDWCS .OR. ASTFL ) THEN
                  IF ( K .EQ. 1 ) THEN
                     DMN1 = DOMAIN
                  ELSE
                     IF ( DOMAIN .NE. DMN1 ) DIFER = .TRUE.
                  END IF
               END IF

*  Output a message to the user.
               LINE = ' '
               CALL CHR_ITOC( INDEX, LINE( 16: ), NCHAR )
               LINE( 24:58 ) = NDFNAM
               LINE( 60: ) = DOMAIN
               CALL CCD1_MSG( ' ', LINE, STATUS )

*  Write the Set information.
               CALL CCD1_SETWR( INDF, NAME, INDEX, JSET, STATUS )

*  Annul the NDF.
               CALL NDF_ANNUL( INDF, STATUS )
            END IF
         END DO

*  Warn if not all Current frame domains were the same.
         IF ( DIFER ) THEN
            CALL CCD1_MSG( ' ', ' ', STATUS )
            CALL CCD1_MSG( ' ', '  Warning: Not all CCD_SET'
     :      // ' frames have the same Domain', STATUS )
         END IF
      END DO

*  Error exit label.
 99   CONTINUE

*  Exit NDF context
      CALL NDF_END( STATUS )

*  Release groups.
      CALL CCD1_GRDEL( INGRP, STATUS )
      CALL CCD1_GRDEL( LDRGRP, STATUS )
      CALL CCD1_GRDEL( NAMGRP, STATUS )
      CALL CCD1_GRDEL( OUTGRP, STATUS )

*  If an error occurred, then report a contextual message.
      IF ( STATUS .NE. SAI__OK ) THEN
          CALL ERR_REP( 'MAKESET_ERR',
     ;                  'MAKESET: Failed to write Set header.', STATUS )
      END IF

*  Close the logging system.
      CALL CCD1_END( STATUS )

      END
* $Id$
