      SUBROUTINE TRANNDF( STATUS )
*+
*  Name:
*     TRANNDF

*  Purpose:
*     Transforms a list of NDFs by resampling.

*  Language:
*     Starlink Fortran 77

*  Type of Module:
*     ADAM A-task

*  Invocation:
*     CALL TRANNDF( STATUS )

*  Arguments:
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description:
*     This application performs the arbitrary transformation of a list
*     of NDFs.  The output NDFs are calculated by resampling
*     the data of the input NDFs. Output array elements are set to the
*     bad value if their inverse-transformed coordinates lie outside the
*     corresponding input NDF's coordinate limits.  Many NDFs can
*     be resampled with a single invocation of TRANNDF, but it is
*     the user's responsibility to ensure that they are resampled
*     into the same coordinate system if they are subsequently to be
*     combined or compared on a pixel-by-pixel basis.
*
*     Images processed by CCDPACK are resampled in one of two ways,
*     depending on the value of the USEWCS parameter.
*
*     If USEWCS is TRUE then they are resampled from their Pixel
*     coordinates into their Current attached coordinate system
*     (this is the default).  Since the resampling means that a 1 x 1
*     square in the Current coordinates will represent one pixel
*     in the output image, the Current coordinate system must be of
*     an appropriate size (so for instance resampling into SKY
*     coordinates is not suitable because they have units of radians).
*     The Current coordinate system will typically have been added
*     by the CCDPACK REGISTER or WCSREG applications, and be labelled
*     'CCD_REG' or 'CCD_WCSREG' accordingly - if it has another label
*     (domain) a warning will be issued but resampling will proceed.
*     A copy of the original PIXEL coordinate system will be retained
*     in the WCS component of the new image under the name CCD_OLDPIXEL;
*     this can be useful for transforming positions back into the
*     pre-transformation coordinate system.
*
*     If USEWCS is set to FALSE, then the resampling will take place
*     according to the TRANSFORM structure stored in the .MORE.CCDPACK
*     extension of the file.  This option exists chiefly for
*     compatibility with older versions of CCDPACK.

*  Usage:
*     tranndf in out [method]

*  ADAM Parameters:
*     CONSERVE = _LOGICAL (Read)
*        If CONSERVE is TRUE, the output values are normalised by the
*        ratio of the output-to-input pixel areas.  In other words
*        this conserves flux.  If CONSERVE is FALSE, there is no
*        normalisation.  Flux can only be conserved if the
*        transformation is linear, so that even if CONSERVE is TRUE,
*        flux will be incorrectly conserved if the transformation is
*        of a non-linear nature.
*        [TRUE]
*     IN = NDF (Read)
*        A list of NDF names whose data are to be transformed. The NDF
*        names should be separated by commas and may include wildcards.
*     INEXT = _LOGICAL (Read)
*        If TRUE then the transformation which is to be applied to the
*        NDF is stored in the NDF's CCDPACK extension
*        (.MORE.CCDPACK.TRANSFORM). If FALSE then a transformation
*        structure must be supplied via the parameter TRANSFORM. This
*        transformation is then applied to the list of NDFs.  [TRUE]
*     LBOUND() = _INTEGER (Read)
*        If SHAPE is "SPECIFY" then this parameter specifies the lower
*        pixel-index bounds of all the output NDFs. The number of
*        values should equal the maximum number of dimensions of the
*        input NDFs. The suggested defaults are the lower bounds
*        generated by the SHAPE="AUTO" option for the first NDF. These
*        bounds are probably small enough to ensure that all the
*        transformed data (of the first NDF) will appear in the output
*        NDF.
*        [Dynamic default]
*     LOGFILE = FILENAME (Read)
*        Name of the CCDPACK logfile.  If a null (!) value is given for
*        this parameter then no logfile will be written, regardless of
*        the value of the LOGTO parameter.
*
*        If the logging system has been initialised using CCDSETUP
*        then the value specified there will be used. Otherwise, the
*        default is "CCDPACK.LOG".
*        [CCDPACK.LOG]
*     LOGTO = LITERAL (Read)
*        Every CCDPACK application has the ability to log its output
*        for future reference as well as for display on the terminal.
*        This parameter controls this process, and may be set to any
*        unique abbreviation of the following:
*           -  TERMINAL  -- Send output to the terminal only
*           -  LOGFILE   -- Send output to the logfile only (see the
*                           LOGFILE parameter)
*           -  BOTH      -- Send output to both the terminal and the
*                           logfile
*           -  NEITHER   -- Produce no output at all
*
*        If the logging system has been initialised using CCDSETUP
*        then the value specified there will be used. Otherwise, the
*        default is "BOTH".
*        [BOTH]
*     METHOD = LITERAL (Read)
*        The interpolation method used to resample the input NDF data
*        arrays. Permitted values are "NEAREST" for nearest-neighbour,
*        and "LININT" for linear interpolation.
*        [NEAREST]
*     OUT = LITERAL (Write)
*        Names of the output -- transformed -- NDFs. These may be
*        specified as list of comma separated names, using indirection
*        if required, or, as a single modification element (of the
*        input names). The simplest modification element is the
*        asterisk "*" which means call each of the output NDFs the same
*        name as the corresponding input NDFs. So,
*           IN > *
*           OUT > *
*        signifies that all the NDFs in the current directory should be
*        used and the output NDFs should have the same names. Other
*        types of modification can also be used, such as,
*           OUT > *-TRN
*        which means call the output NDFs the same as the input NDFs
*        but add -TRN to the end of the names. Replacement of a
*        specified string with another in the output file names can
*        also be used,
*           OUT > *|RAW|RES|
*        this replaces the string RAW with RES in any of the output
*        names.
*     SHAPE = LITERAL (Read)
*        The method to be used to determine the SHAPE of the output
*        NDFs. Can take one of the values "AUTO", "SAME", "SPECIFY".
*        With the meanings.
*
*           - AUTO    -- automatically determine the bounds of the
*                        output NDFs such that all of the input data
*                        appears. This is achieved by transforming test
*                        points along the current bounds so assumes
*                        that the transformation will behave reasonably.
*           - SAME    -- set the output NDF bounds to those of the
*                        corresponding input NDFs.
*           - SPECIFY -- you will specify a single set of bounds for
*                        all the output NDFs. (See the LBOUND and UBOUND
*                        parameters.)
*        [AUTO]
*     TITLE = LITERAL (Read)
*        Title for the output images.
*        [Output from TRANNDF]
*     TRANSFORM = TRN (Read)
*        If INEXT is FALSE then this parameter specifies the
*        transformation structure.  This includes the file name and the
*        HDS object.  For example, DISTORT.MAPPING would use the
*        TRANSFORM structure called MAPPING in the HDS file DISTORT.
*        Normally the object name is TRANSFORM.  The structure must
*        contain both the forward and inverse mappings. This transform
*        if supplied acts on all the input NDFs.
*     UBOUND() = _INTEGER (Read)
*        If SHAPE is "SPECIFY" then this parameter specifies the upper
*        pixel-index bounds of all the output NDFs. The number of
*        values should equal the maximum number of dimensions of the
*        input NDFs. The suggested defaults are the upper bounds
*        generated by the SHAPE="AUTO" option for the first NDF. These
*        bounds are probably large enough to ensure that all the
*        transformed data (of the first NDF) will appear in the output
*        NDF.
*        [Dynamic default]
*     USEWCS = _LOGICAL (Read)
*        If TRUE then the transformation which is to be applied to the
*        NDF is stored in the NDF's WCS extension as an attached
*        coordinate system. If FALSE then the transformation is either
*        stored as a TRN structure in the NDF's CCDPACK extension
*        (.MORE.CCDPACK.TRANSFORM), or is supplied by the user (see
*        the INEXT parameter). [TRUE]

*  Examples:
*     tranndf '*' '*-resamp' reset
*        This transforms all the NDFs in the current directory from
*        pixel coordinates to their Current coordinate system.
*        It uses nearest-neighbour resampling and conserves the flux
*        levels (assuming that the transformation is linear).
*        The output NDFs are of a size such that all the input
*        pixels have contributed.
*     tranndf curved straight linint shape=same
*        As above, except linear interpolation is used, and the straight
*        array uses the bounds of curved.
*     tranndf 'a119*' '*s' inext=false transform=proj.merc shape=bounds
*             lbound='[1,-20]' ubound='[256,172]'
*        This transforms the images called a119*, using the transformation
*        structure merc in the HDS file called proj, into images called
*        a119*s.  It uses nearest-neighbour resampling.  All the output
*        images have size 256 x 192 pixels and origin (1,-20).

*  Implementation Status:
*     - Flux conservation can only be applied to constant-determinant
*       or linear transformations.  It is currently impossible to tell
*       whether an AST Mapping is linear, but in the expectation that
*       it is (most of them are, and most of the rest very nearly are),
*       it is turned on, without a warning, by default.
*     - The NDF components are processed by this application as
*       follows:
*        -  AXES, LABEL, UNITS, HISTORY, and extensions are merely
*           propagated.
*        -  QUALITY is not derived from the input NDF for a linearly
*           interpolated NDF. The DATA and VARIANCE arrays are
*           resampled.
*        -  If USEWCS is .TRUE. then the NDF WCS extension is updated
*           and propagated.
*     -  Bad pixels, including automatic quality masking, are supported.
*     -  All non-complex numeric data types are supported.
*     -  There can be an arbitrary number of NDF dimensions.

*  Behaviour of Parameters:
*     Most parameters retain their current value as default. The
*     "current" value is the value assigned on the last run of the
*     application. If the application has not been run then the
*     "intrinsic" defaults, as shown in the parameter help, apply.
*     The exceptions to this rule are:
*        - LBOUND  -- always uses a dynamic default
*        - UBOUND  -- always uses a dynamic default
*        - TITLE   -- always "Output from TRANNDF"
*
*     Retaining parameter values has the advantage of allowing you to
*     define the default behaviour of the application but does mean
*     that additional care needs to be taken when using the application
*     after a break of sometime. The intrinsic default behaviour of
*     the application may be restored by using the RESET keyword on
*     the command line.
*
*     Certain parameters (LOGTO and LOGFILE) have global values. These
*     global values will always take precedence, except when an
*     assignment is made on the command line.  Global values may be set
*     and reset using the CCDSETUP and CCDCLEAR commands.

*  Copyright:
*     Copyright (C) 1993 Science & Engineering Research Council.
*     Copyright (C) 1995, 1998-2003 Central Laboratory of the Research
*     Councils. All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 2 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful, but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 51 Franklin Street,Fifth Floor, Boston, MA
*     02110-1301, USA

*  Authors:
*     MJC: Malcolm J. Currie (STARLINK)
*     PDRAPER: Peter Draper (STARLINK)
*     AALLAN: Alasdair Allan (STARLINK)
*     MBT: Mark Taylor (STARLINK)
*     {enter_new_authors_here}

*  History:
*     1993 March 16 (MJC):
*        Original version.
*     18-JUN-1993 (PDRAPER):
*        Changed for use in CCDPACK pipe-line - Lists of NDFs,
*        information logging etc. Restricted functionality to that which
*        is used by CCDPACK (no axes information).
*     19-JUL-1995 (PDRAPER):
*        Removed AIF_ calls.
*     6-SEP-1995 (PDRAPER):
*        Updated for CCDPACK version 2.0.
*     25-JUN-1998 (PDRAPER):
*        Stopped quality bad flag from being set (isn't possible).
*     11-MAR-1999 (AALLAN):
*        Added USEWCS parameter (.TRUE. for AST, .FALSE. for TRN).
*        Converted TRANNDF to use AST FrameSets rather than TRN structures.
*     14-APR-1999 (AALLAN):
*        Ongoing tweaks to conversion.
*     03-MAY-1999 (AALLAN):
*        Turned off flux conservation (NORM = .FALSE.) for AST FrameSets.
*        Now deals only in the current frame, warns in AST__CURRENT != CCD_REG.
*        Other minor changes.
*     17-MAY-1999 (AALLAN):
*        Final tweaks for shipping.
*     20-MAY-1999 (MBT):
*        Mucked about a bit.
*     07-SEP-1999 (AALLAN):
*        Renamed some KPG1_* routines and propogated changes
*     4-NOV-1999 (MBT):
*        Modified some of the warnings.
*     29-JUN-2000 (MBT):
*        Replaced use of IRH/IRG with GRP/NDG.
*     21-MAR-2001 (MBT):
*        Now refuses to resample into a SkyFrame, which is bound to be
*        a user error or misconception.
*     9-SEP-2002 (MBT):
*        Now retains a copy of the old PIXEL frame as CCD_OLDPIXEL.
*     11-FEB-2003 (MBT):
*        Fixed a flux-conservation bug which occurred with flipped frames.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-

*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'DAT_PAR'          ! HDS constants
      INCLUDE 'MSG_PAR'          ! MSG constants
      INCLUDE 'NDF_PAR'          ! NDF constants
      INCLUDE 'PRM_PAR'          ! PRIMDAT public constants
      INCLUDE 'TRN_PAR'          ! TRANSFORM constants
      INCLUDE 'CCD1_PAR'         ! CCDPACK parameters
      INCLUDE 'AST_PAR'          ! AST parameters
      INCLUDE 'CNF_PAR'          ! For CNF_PVAL function

*  Status:
      INTEGER STATUS             ! Global status

*  Local Constants:
      INTEGER NACOMP             ! Number NDF array components
      PARAMETER ( NACOMP = 3 )

*  External references:
      EXTERNAL VAL_DTOI
      INTEGER VAL_DTOI           ! DBLE to nearest INTEGER with
                                 ! exception checking

*  Local Variables:
      BYTE VARB                  ! Dummy input variance
      BYTE VARBO                 ! Dummy output variance
      CHARACTER * ( 8 ) COMP( NACOMP ) ! NDF array component names
      CHARACTER * ( AST__SZCHR ) DMN ! AST Current domain
      CHARACTER * ( 7 ) METHOD   ! Resampling method
      CHARACTER * ( 20 ) OPIXDM  ! Domain name for copy of old PIXEL frame
      CHARACTER * ( 7 ) SHAPE    ! How output NDF shape is determined
      CHARACTER * ( DAT__SZLOC ) LOCEXT ! Locator to NDF extension
      CHARACTER * ( DAT__SZLOC ) LOCTR ! Locator to the transformation
      CHARACTER * ( DAT__SZTYP ) DTYPE ! NDF output array type
      CHARACTER * ( DAT__SZTYP ) ITYPE ! NDF array implementation type
      CHARACTER * ( 50 ) TEXT       ! Temporary string for message output
      DOUBLE PRECISION AEND( NDF__MXDIM ) ! End co-ord of each axis
      DOUBLE PRECISION ASTART( NDF__MXDIM ) ! Start co-ord of each axis
      DOUBLE PRECISION COIN( 0:NDF__MXDIM, NDF__MXDIM ) ! Input coord for determinant finding
      DOUBLE PRECISION COOUT( 0:NDF__MXDIM, NDF__MXDIM ) ! Output coord for determinant finding
      DOUBLE PRECISION DDLBND( NDF__MXDIM ) ! Data coord lower bnds of out NDF
      DOUBLE PRECISION DDUBND( NDF__MXDIM ) ! Data coord upper bnds of out NDF
      DOUBLE PRECISION DDXL( NDF__MXDIM ) ! Co-ord of input pnt gives lower bnd
      DOUBLE PRECISION DDXU( NDF__MXDIM ) ! Co-ord of input pnt gives upper bnd
      DOUBLE PRECISION FLUX      ! Flux conservation factor
      DOUBLE PRECISION JACOB( NDF__MXDIM, NDF__MXDIM ) ! Jacobian matrix
      DOUBLE PRECISION VARD      ! Dummy input variance
      DOUBLE PRECISION WORK2( NDF__MXDIM ) ! Workspace for determinant
      INTEGER * 2 VARW           ! Dummy input variance
      INTEGER ADIMS( NDF__MXDIM ) ! Number of elements in axis to be pasted
      INTEGER AEL( NDF__MXDIM )  ! Axis-array dimensions
      INTEGER AXOFFS( NDF__MXDIM ) ! Offset in concatenated axis vector
      INTEGER AXPNTR( NDF__MXDIM ) ! Pointers to the axis centre arrays
      INTEGER BMAX( NDF__MXDIM ) ! Maximum upper bounds of output NDF
      INTEGER CADIMS( NDF__MXDIM ) ! Number of elements in concatenated- axis vector
      INTEGER CAXPTR             ! Pointer to the concatenated axes
      INTEGER CFRAME            ! Index value of the current AST Frame
      INTEGER DLBND( NDF__MXDIM ) ! Default bounds of the output NDF
      INTEGER DUBND( NDF__MXDIM ) ! Default bounds of the output NDF
      INTEGER EL                 ! Number of elements in higher dims
      INTEGER ELIN               ! Number of elements in input array
      INTEGER ELOUT              ! Number of elements in output array
      INTEGER FRCUR              ! Pointer to the Current AST Frame
      INTEGER FRNEW             ! Pointer to the New AST Frame
      INTEGER GIDIN              ! Input NDF group identifier
      INTEGER GIDOUT             ! Output NDF group identifier
      INTEGER I, J, K            ! Loop counters
      INTEGER IAXIS              ! Loop counter through the axes
      INTEGER ICOMP              ! Loop counter through array components
      INTEGER IDIMS( NDF__MXDIM ) ! Dimensions of the input NDF
      INTEGER IDIN               ! NDF identifier of input NDF
      INTEGER IDOUT              ! NDF identifier of output NDF
      INTEGER ILBND( NDF__MXDIM ) ! Lower bounds of the input NDF
      INTEGER INDEX              ! Main loop counter
      INTEGER INDID              ! Workspace identifier
      INTEGER INPNTR             ! Pointer to nearest-neighbour list
      INTEGER IPNTR( 2 )         ! Pointers to the input arrays
      INTEGER IUBND( NDF__MXDIM ) ! Upper bounds of the input NDF
      INTEGER IWCS               ! Pointer to the WCS extension of the input NDF
      INTEGER JPIX               ! Index of the PIXEL frame
      INTEGER MAP                ! Mapping to use
      INTEGER NBAD               ! Number of bad elements in output array
      INTEGER NDIMI              ! Number of dimensions in input NDF
      INTEGER NFRM               ! Number of frames in frameset
      INTEGER NNDF               ! Number of NDFs to process
      INTEGER NVIN               ! Number of input variables in the transformation
      INTEGER NVOUT              ! Number of output variables in the transformation
      INTEGER OWCS              ! Pointer to the WCS extension of the output NDF
      INTEGER ODIMS( NDF__MXDIM ) ! Dimensions of the output NDF
      INTEGER OLBND( NDF__MXDIM ) ! Lower bounds of the output NDF
      INTEGER OPNTR( 2 )         ! Pointers to the output arrays
      INTEGER OPNTRW             ! Pointer to the output array or workspace for flux conservation
      INTEGER OUBND( NDF__MXDIM ) ! Upper bounds of the output NDF
      INTEGER PFRM               ! AST pointer to the PIXEL frame
      INTEGER SHADEF( NDF__MXDIM ) ! Suggested default output NDF shape upper bound
      INTEGER TRIDF              ! Identifier to the forward input transformation
      INTEGER TRIDI              ! Identifier to the inverse input transformation
      INTEGER UMAP               ! Identifier for AST unit map
      INTEGER VARI               ! Dummy input variance
      INTEGER WDIMS( 2 )         ! Workspace dimensions
      INTEGER WKID4              ! Workspace identifier
      INTEGER WORK1( NDF__MXDIM ) ! Workspace for determinant finding
      INTEGER WPNTR1             ! Pointer to coordinate workspace
      INTEGER WPNTR2             ! Pointer to indices workspace
      INTEGER WPNTR3             ! Pointer to coordinate workspace
      LOGICAL BAD                ! If true, test for bad values
      LOGICAL CLASS( TRN__MXCLS ) ! Transformation classifications
      LOGICAL CONSRV             ! If true, the flux will be altered
      LOGICAL INEXT              ! Locate transform structure in NDF extensions
      LOGICAL NORM               ! Conserve flux if true
      LOGICAL SWCS               ! If true, then a WCS component is present in the NDF
      LOGICAL THERE              ! If true, the array component is present in the NDF
      LOGICAL USEWCS               ! If true then we use AST FrameSet rather than TRN structure
      LOGICAL VAR                ! Variance array is present in NDF
      REAL VARR                  ! Dummy input variance

      CHARACTER * ( 20 ) TEMP

*  Declare Functions:

*  Local Data:
      DATA COMP / 'Data', 'Variance', 'Quality' /
      DATA OPIXDM / 'CCD_OLDPIXEL' /

*  Check the inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Startup up the CCDPACK logging system.
      CALL CCD1_START( 'TRANNDF', STATUS )

*  Get the qualifications to the transformation.
*  =============================================

*  Get the method for calculating the output array value from the
*  input values.
      CALL PAR_CHOIC( 'METHOD', 'NEAREST', 'NEAREST,LININT', .FALSE.,
     :                METHOD, STATUS )

*  Are the output values to be normalised by the output-to-input pixel
*  areas, i.e. flux conservation; or just take the values from the
*  input NDF?
      CALL PAR_GET0L( 'CONSERVE', NORM, STATUS )

*  Obtain NDFs.
*  ============
*
*  Start a new NDF context.
      CALL NDF_BEGIN

*  Start a new AST context
      CALL AST_BEGIN( STATUS )

*  Get the group identifier for the NDFs.
      CALL CCD1_NDFGR( 'IN', GIDIN, NNDF, STATUS )

*  And get the names of the corresponding output NDFs.
      CALL CCD1_NDFPG( 'OUT', GIDIN, NNDF, GIDOUT, STATUS )
      IF ( STATUS .NE. SAI__OK ) GO TO 960

*  Get control parameters.
*  =======================

*  Are we using AST FrameSets or TRN structures?
      CALL PAR_GET0L( 'USEWCS', USEWCS, STATUS )

      IF( .NOT. USEWCS ) THEN

*  The user wants to read data with the old TRN structures.

*  Does the user want transformation structures to be located in the NDF
*  extensions or do they want to supply a single structure to transform
*  all the NDFs.
         CALL PAR_GET0L( 'INEXT', INEXT, STATUS )

*  If we're not using the extension we need a transformation structure.
         IF ( .NOT. INEXT ) THEN

*  User supplies a single locator to a transformation structure.
            CALL DAT_ASSOC( 'TRANSFORM', 'READ', LOCTR, STATUS )

         END IF

      ELSE

*  These are checked regardless, so initialise.
         CLASS( TRN__LIN ) = .FALSE.
         CLASS( TRN__CONDT ) = .FALSE.
      END IF

*  See if the user is happy with auto-sizing of the output bounds or
*  whether they want to specify some (just one chance at this --
*  delayed until more knowledge of the NDFs is available), or are the
*  NDF bounds to remain the same?
      CALL PAR_CHOIC( 'SHAPE', 'AUTO', 'AUTO,SAME,SPECIFY', .FALSE.,
     :                SHAPE, STATUS )

*  Report progress so far.
      CALL CCD1_MSG( ' ', '    Input parameters:', STATUS )
      CALL CCD1_MSG( ' ', '    -----------------', STATUS )

*  Resampling method.
      IF ( METHOD .EQ. 'LININT' ) THEN
         CALL CCD1_MSG( ' ',
     : '  Data resampling method: Linear interpolation', STATUS )
      ELSE
         CALL CCD1_MSG( ' ',
     : '  Data resampling method: Nearest neighbour', STATUS )
      END IF

*  If flux levels are conserved.
      IF ( NORM ) THEN
         IF ( USEWCS ) THEN
            CALL CCD1_MSG( ' ', '  Attempting to conserve flux levels',
     :                     STATUS )
         ELSE
            CALL CCD1_MSG( ' ', '  Total flux levels conserved',
     :                     STATUS )
         ENDIF
      ELSE
         CALL CCD1_MSG( ' ', '  Total flux levels not conserved',
     :                  STATUS )
      END IF

*  Are we using AST FrameSets or TRN structures?
      IF( USEWCS ) THEN
         CALL CCD1_MSG( ' ',
     :'  Using AST FrameSet in NDF extensions', STATUS )

      ELSE

*  Are we using a TRN structure from the NDFs or user?
         IF ( INEXT ) THEN
            CALL CCD1_MSG( ' ',
     :'  Using transform structures in NDF CCDPACK extensions', STATUS )
         ELSE
            CALL CCD1_MSG( ' ',
     :'  Using transform structure $STRUCT', STATUS )
         END IF

      ENDIF

*  Are we using auto-sizing or will the user get to specify a single
*  extent for all NDFs?
      IF ( SHAPE .EQ. 'AUTO' ) THEN
         CALL CCD1_MSG( ' ', '  Auto-sizing output NDF bounds', STATUS )
      ELSE IF ( SHAPE .EQ. 'SAME' ) THEN
         CALL CCD1_MSG( ' ',
     :'  Output NDFs will have same bounds as related input NDFs',
     :                  STATUS )
      ELSE
         CALL CCD1_MSG( ' ',
     :'  Output NDFs will have user specified bounds ', STATUS )
      END IF
      IF ( STATUS .NE. SAI__OK ) GO TO 960

*=======================================================================
*  Main loop. Access each NDF in turn and process.
*=======================================================================
      DO 99999 INDEX = 1, NNDF

*  Get the identifier of the input NDF.
         CALL NDG_NDFAS( GIDIN, INDEX, 'READ', IDIN, STATUS )

*  Write out name of this NDF. And which loop this is.
         CALL CCD1_MSG( ' ',  ' ', STATUS )
         CALL NDF_MSG( 'CURRENT_NDF', IDIN )
         CALL CCD1_MSG( ' ', '  +++ Processing NDF: ^CURRENT_NDF',
     :                  STATUS )
         CALL MSG_SETI( 'CURRENT_NUM', INDEX )
         CALL MSG_SETI( 'MAX_NUM', NNDF )
         CALL CCD1_MSG( ' ', '  (Number ^CURRENT_NUM of ^MAX_NUM)',
     :                  STATUS )
         CALL CCD1_MSG( ' ',  ' ', STATUS )

*  Decide whether we're using AST or TRN structres
         IF ( USEWCS ) THEN

*  Get the transformation associated with this NDF. This should be
*  stored in the WCS extention of the NDF.

*  First check that there is an existing WCS FrameSet
            CALL NDF_STATE( IDIN, 'WCS', SWCS, STATUS )
            IF( .NOT. SWCS ) THEN
               STATUS = SAI__ERROR
               CALL NDF_MSG( 'NDFNAME', IDIN )
               CALL ERR_REP( 'TRANNDF_NOAST', '  NDF ^NDFNAME '//
     :'does not have a WCS component (try setting USEWCS to .FALSE.).',
     :                       STATUS )
               GO TO 940
            ENDIF

*  It appears we have a WCS component, get a pointer to the current
*  Frame.
            CALL CCD1_GTWCS( IDIN, IWCS, STATUS )
            MAP = AST_GETMAPPING( IWCS, 2, AST__CURRENT, STATUS )
            MAP = AST_SIMPLIFY( MAP, STATUS )
            FRCUR = AST_GETFRAME( IWCS, AST__CURRENT, STATUS )

*  Get the index of the current frame for future use
            CFRAME = AST_GETI( IWCS, 'Current', STATUS )

         ELSE

*  The user wishes to use TRANSFORM structures.
            IF ( INEXT ) THEN

*  Get the transformation associated with this NDF. This should be
*  stored in the CCDPACK extension item TRANSFORM.

*  First get a CCDPACK extension.
               CALL CCD1_CEXT( IDIN, .FALSE., 'READ', LOCEXT, STATUS )

*  Now Look for a transformation structure.
               IF ( STATUS .EQ. SAI__OK ) THEN
                 CALL DAT_THERE( LOCEXT, 'TRANSFORM', THERE, STATUS )

*  If have one get a locator to it.
                 IF ( THERE ) THEN
                    CALL DAT_FIND( LOCEXT, 'TRANSFORM', LOCTR, STATUS )

                 ELSE

*  Failed to find component TRANSFORM.
                    STATUS = SAI__ERROR
                    CALL NDF_MSG( 'NDFNAME', IDIN )
                    CALL ERR_REP( 'TRANNDF_NOEXT', '  NDF ^NDFNAME '//
     :'does not have a TRANSFORM component in its CCDPACK extension',
     :                          STATUS )
                    GO TO 940
                 END IF
               ELSE

*  No extension structure. Set status and abort.
                 STATUS = SAI__ERROR
                 CALL NDF_MSG( 'NDFNAME', IDIN )
                 CALL ERR_REP( 'TRANNDF_NOEXT',
     : '  NDF ^NDFNAME does not have a CCDPACK extension', STATUS )
                 GO TO 940
               END IF
            END IF

         END IF


*  We need to validate the transformations
         IF( USEWCS ) THEN

*  We are using AST FrameSets
*  ==========================

*  Note there is a danger here that for nonlinear AST mappings the
*  flux tranformation will be incorrect.  AST mappings are (in this
*  respect) opaque however so there's no way of telling whether it's
*  linear or not.  We hope that it is, or that the user will have
*  specified that flux is not to be conserved (in any case it is
*  unlikely that deviations from linearity will be very great).

*  Validate the transformation
            IF ( IWCS .EQ. AST__NULL ) THEN
               STATUS = SAI__ERROR
               CALL NDF_MSG( 'NDFNAME', IDIN )
               CALL ERR_REP( 'TRANNDF_NOAST', '  NDF ^NDFNAME '//
     :'does not have a valid WCS component.', STATUS )
               GO TO 940

            ELSE IF ( AST_GETC( IWCS,'Class', STATUS ) .NE. 'FrameSet' )
     :      THEN
               STATUS = SAI__ERROR
               CALL NDF_MSG( 'NDFNAME', IDIN )
               CALL ERR_REP( 'TRANNDF_FRAME', '  NDF ^NDFNAME '//
     :'does not have a WCS component with class FrameSet.',STATUS )
               GO TO 940

*  Check that we are not trying to resample into a SkyFrame.  This
*  pretty much has to be a silly thing to do, and probably indicates
*  that the user has failed to stick a sensible frame onto the NDF.
            ELSE IF ( AST_ISASKYFRAME( FRCUR, STATUS ) ) THEN
               STATUS = SAI__ERROR
               CALL ERR_REP( 'TRANNDF_SKYFRM', 'TRANNDF: It makes no'//
     :' sense to resample into a SkyFrame (units are all wrong).',
     :STATUS )
               CALL ERR_REP( ' ', '         Try adding a pixel-like'//
     :' frame using WCSREG with DOMAINS=!.', STATUS )
               GO TO 940

            ELSE

*  Tell the user which co-ordinate frame we'll be resampling into.
               DMN = AST_GETC( FRCUR, 'Domain', STATUS )
               CALL MSG_SETC( 'DMN', DMN )
               CALL CCD1_MSG( ' ', '  Resampling into the ^DMN '
     :                           //'coordinate system', STATUS )

*  If it's neither CCD_REG nor CCD_WCSREG then issue a mild warning.
               IF ( DMN .NE. 'CCD_REG ' .AND. DMN .NE. 'CCD_WCSREG ' )
     :         THEN
                  CALL CCD1_MSG( ' ', '    (Warning: this is not a '//
     :'default CCDPACK registration coordinate system)', STATUS )
               END IF
            END IF

*  Obtain the number of input and output co-ordinates for a Mapping
            NVIN = AST_GETI( MAP, 'Nin', STATUS )
            NVOUT = AST_GETI( MAP, 'Nout', STATUS )

         ELSE

*  We are using TRN structres
*  ==========================

*  Now validate the transformation.  Need forward and backward
*  transformations.
            IF ( INEXT .OR. INDEX .EQ. 1 ) THEN
               CALL TRN_COMP( LOCTR, .TRUE., TRIDF, STATUS )
               CALL TRN_COMP( LOCTR, .FALSE., TRIDI, STATUS )

*  Obtain the number of variables in the transformation.
               CALL TRN_GTNV( LOCTR, NVIN, NVOUT, STATUS )
               IF ( STATUS .NE. SAI__OK ) GO TO 940

*  Inquire the classification of the transformation.
*  =================================================
*
*  Certain efficiencies gains can be made for certain types of
*  transformation, mostly notably a linear transformation, where the
*  flux conservation factor is a constant.
               CALL TRN_GTCL( LOCTR, .TRUE., CLASS, STATUS )

*  Test if the transformation can be processed.
               IF ( .NOT. CLASS( TRN__LIN   ) .AND.
     :            .NOT. CLASS( TRN__CONDT ) .AND. NORM ) THEN
                  STATUS = SAI__ERROR
                  CALL ERR_REP( 'TRANNDF_ERR',
     :     'TRANNDF: The transformation is non-linear, '/
     :     /'or does not have a constant determinant, and cannot be '/
     :     /'handled with flux conservation by this routine', STATUS )
                  GO TO 940
               END IF
            END IF

         ENDIF

*  Get the properties of the NDF.
*  ==============================
*  Dimensions.
         CALL NDF_DIM( IDIN, NDF__MXDIM, IDIMS, NDIMI, STATUS )

*  Bounds.
         CALL NDF_BOUND( IDIN, NDF__MXDIM, ILBND, IUBND, NDIMI, STATUS )

         IF ( STATUS .NE. SAI__OK ) GO TO 940

*  Validate dimensions and number of input coordinates.
*  =====================================================
*
*  Check that processing is possible.  The number of dimensions in the
*  NDF must be at least the number of input variables for the
*  transformation to be applied.
         IF ( NVIN .GT. NDIMI .AND. STATUS .EQ. SAI__OK ) THEN
            STATUS = SAI__ERROR
            CALL NDF_MSG( 'NDF', IDIN )
            CALL MSG_SETI( 'NVIN', NVIN )
            CALL MSG_SETI( 'NDIMI', NDIMI )
            CALL ERR_REP( 'TRANNDF_MISMATCH',
     :     'TRANNDF: There is a mismatch between the transformation '/
     :     /'which expects ^NVIN variables, and the '/
     :     /'NDF ^NDF, which has only ^NDIMI dimensions.', STATUS )
            GO TO 940
         END IF

*  Define the input coordinate system.
*  ====================================

*  Generate a pseudo axis array to satisfy later calls (which will keep
*  this application as simiar as possible to the KAPPA version).
         DO IAXIS = 1, NVIN

*  Get workspace for the axes.
            AEL( IAXIS ) = IUBND( IAXIS ) - ILBND( IAXIS ) + 1
            CALL CCD1_MALL( AEL( IAXIS ), '_DOUBLE', AXPNTR( IAXIS ),
     :                      STATUS )
            CALL CCG1_AXIND( ILBND( IAXIS ), IUBND( IAXIS ),
     :                       %VAL( CNF_PVAL( AXPNTR( IAXIS ) ) ),
     :                       STATUS )
         END DO

*  Find the coordinate bounds of the output NDF.
*  ==============================================

*  The transformed coordinates will not, in general, be in pixel
*  coordinates, so we shall need to derive and then join a
*  transformation that converts between the output coordinates and
*  pixel coordinates.  The first stage is to estimate the bounds.
*  Axis end-points are pixel coordinates.
         DO IAXIS = 1, NVIN
            ASTART( IAXIS ) = DBLE( ILBND( IAXIS ) )
            AEND( IAXIS ) = DBLE( IUBND( IAXIS ) )
         END DO
         IF ( USEWCS ) THEN

*  We're using AST framesets.
            DO IAXIS = 1, NVIN
               CALL AST_MAPBOX( MAP, ASTART, AEND, .TRUE., IAXIS,
     :                          DDLBND(IAXIS), DDUBND(IAXIS), DDXL,
     :                          DDXU, STATUS )
            END DO
         ELSE

*  We're using old fashioned TRN structures
            CALL KPG1_TRBOD( NVIN, ASTART, AEND, TRIDF, NVOUT, DDLBND,
     :                       DDUBND, STATUS )
            IF ( STATUS .NE. SAI__OK ) GO TO 940
         ENDIF

*  Set the bounds of the output NDF.
*  =================================

*  Find the dimensions and bounds of the output array. There are three
*  options for these values. If autosize has been chosen then dynamic
*  bounds will be created which ensure that all the output data is
*  present. If same is specified then the output NDFs will have the
*  same bounds as the input NDFs, otherwise the user will be prompted
*  once for bounds which will apply to all output NDFs.
         IF ( SHAPE .EQ. 'SPECIFY' ) THEN
           IF ( INDEX .EQ. 1 ) THEN

*  User specified bounds - just this once. Report the current extents
*  of the pixel coordinates as an aid to the user.
               DO IAXIS = 1, NVOUT
                  CALL MSG_SETI( 'AXIS', IAXIS )
                  CALL MSG_SETD( 'LOW', DDLBND( IAXIS ) )
                  CALL MSG_SETD( 'HIGH', DDUBND( IAXIS ) )
                  IF ( IAXIS .EQ. 1 ) THEN
                        CALL CCD1_MSG( 'OUTBOUNDS',
     :           '  coordinates limits for axis ^AXIS: ^LOW to ^HIGH',
     :                                 STATUS )
                  ELSE
                     CALL CCD1_MSG( 'OUTBOUNDS',
     :           '                               ^AXIS: ^LOW to ^HIGH',
     :                                          STATUS )
                  END IF

*  Set the defaults for the output NDF extent.
                  DLBND( IAXIS ) = VAL_DTOI( .FALSE.,
     :                             DDLBND( IAXIS ) - 0.5D0, STATUS )
                  DUBND( IAXIS ) = VAL_DTOI( .FALSE., DDUBND( IAXIS ),
     :                             STATUS )
               END DO

*  Now get the values.
               CALL PAR_DEF1I( 'LBOUND', NVOUT, DLBND, STATUS )
               CALL PAR_GDR1I( 'LBOUND', NVOUT, DLBND, -VAL__MAXI,
     :                         VAL__MAXI, .FALSE., OLBND, STATUS )
               DO I = 1, NVOUT
                  SHADEF( I ) = MAX( OLBND( I ), DUBND( I ) )
                  BMAX( I ) = VAL__MAXI
               END DO
               CALL PAR_DEF1I( 'UBOUND', NVOUT, DUBND, STATUS )
               CALL PAR_GRM1I( 'UBOUND', NVOUT, SHADEF, OLBND, BMAX,
     :                         .FALSE., OUBND, STATUS )
            END IF
         ELSE IF ( SHAPE .EQ. 'SAME') THEN

*  Output NDF bounds those of the input NDFs.
            DO IAXIS = 1, NVOUT
               OLBND( IAXIS ) = ILBND( IAXIS )
               OUBND( IAXIS ) = IUBND( IAXIS )
            END DO
         ELSE

*  Autosize the output NDF.
            DO IAXIS = 1, NVOUT
               OLBND( IAXIS ) = VAL_DTOI( .FALSE.,
     :                          DDLBND( IAXIS ) - 0.5D0, STATUS )
               OUBND( IAXIS ) = VAL_DTOI( .FALSE., DDUBND( IAXIS ),
     :                          STATUS )
            END DO
         END IF

*  Derive the output NDF's dimensions.
         DO IAXIS = 1, NVOUT
            ODIMS( IAXIS ) = OUBND( IAXIS ) - OLBND( IAXIS ) + 1
         END DO
         IF ( STATUS .NE. SAI__OK ) GO TO 940

*  Create a concatenated input axis array.
*  =======================================
*
*  The subroutines that perform the resampling need the axis arrays
*  to convert coordinates into pixel indices in the input array.
*  For convenience the axis centres are passed in a single vector
*  and required values are found using offsets equal to the sum of
*  the lower axis dimensions.
*
*  Find the length of the concatenated axes.
         CADIMS( 1 ) = 0
         DO IAXIS = 1, NVIN
           CADIMS( 1 ) = CADIMS( 1 ) + AEL( IAXIS )
         END DO

*  Create some workspace for the concatenated array.
         CALL CCD1_MALL( CADIMS( 1 ), '_DOUBLE', CAXPTR, STATUS )

*  Pasting routine needs filled dimension arrays of NDF__MXDIM values.
         DO IAXIS = 2, NDF__MXDIM
            ADIMS( IAXIS ) = 1
            CADIMS( IAXIS ) = 1
            AXOFFS( IAXIS ) = 0
         END DO

         AXOFFS( 1 ) = 0
         DO IAXIS = 1, NVIN

*  Assign the axis dimension.
            ADIMS( 1 ) = AEL( IAXIS )

*  Paste each axis into the work array.
            CALL KPG1_PASTD( .FALSE., .TRUE., AXOFFS, ADIMS, ADIMS( 1 ),
     :                       %VAL( CNF_PVAL( AXPNTR( IAXIS ) ) ),
     :                       CADIMS,
     :                       CADIMS( 1 ), %VAL( CNF_PVAL( CAXPTR ) ),
     :                       STATUS )

*  Increment the offsets for the next axis.
            AXOFFS( 1 ) = AXOFFS( 1 ) + AEL( IAXIS )
         END DO

         IF ( STATUS .NE. SAI__OK ) GO TO 940

*  Tidy the axis centres.
*  ======================
         DO IAXIS = 1, NVIN
            CALL CCD1_MFREE( AXPNTR( IAXIS ), STATUS )
         END DO

*  Create the output NDF.
*  ======================
         CALL NDG_NDFPR( IDIN, 'Axis,Units', GIDOUT, INDEX, IDOUT,
     :                   STATUS )

*  Tell user the name of the output NDF.
         CALL NDF_MSG( 'OUTNDF', IDOUT )
         CALL CCD1_MSG( ' ', '  Output NDF: ^OUTNDF', STATUS )

*  Report the extent of the input NDF, useful if using shape=auto to compare
*  with the ouptut NDF shape and see if something stupid is happening.
         DO IAXIS = 1, NVIN
            CALL MSG_SETI( 'LOW', ILBND( IAXIS ) )
            CALL MSG_SETI( 'HIGH', IUBND( IAXIS ) )
            IF ( IAXIS .EQ. 1 ) THEN
               CALL CCD1_MSG( 'INBOUNDS',
     :'  Input NDF bounds : ^LOW to ^HIGH', STATUS )
            ELSE
               CALL CCD1_MSG( 'INBOUNDS',
     :'                   : ^LOW to ^HIGH', STATUS )
            END IF
         END DO

*  And report the actual extent of the output NDF (before creating
*  an NDF of this actual extent - useful if shape=auto and funny
*  transformation is being used).
         DO IAXIS = 1, NVOUT
            CALL MSG_SETI( 'AXIS', IAXIS )
            CALL MSG_SETI( 'LOW', OLBND( IAXIS ) )
            CALL MSG_SETI( 'HIGH', OUBND( IAXIS ) )
            IF ( IAXIS .EQ. 1 ) THEN
                  CALL CCD1_MSG( 'OUTBOUNDS',
     :'  Output NDF bounds : ^LOW to ^HIGH', STATUS )
            ELSE
               CALL CCD1_MSG( 'OUTBOUNDS',
     :'                    : ^LOW to ^HIGH', STATUS )
            END IF
         END DO

*  Change its shape to the required output shape.
         CALL NDF_SBND( NDIMI, OLBND, OUBND, IDOUT, STATUS )
         IF ( STATUS .NE. SAI__OK ) GO TO 940


*  Find the flux-conservation factor.
*  ==================================

*  Find a constant determinant by transforming unit vectors along each
*  dimension.
         IF ( NORM .AND. NVIN .EQ. NVOUT .AND.
     :      ( CLASS(TRN__LIN) .OR. CLASS(TRN__CONDT) .OR. USEWCS)) THEN

*  First set the input coordinates to all zero.
            DO IAXIS = 1, NVIN
               DO I = 0, NVIN
                  COIN( I, IAXIS ) = 0.0D0
               END DO
            END DO

*  Revise the diagonal terms to one.
            DO I = 1, NVIN
               COIN( I, I ) = 1.0D0
            END DO
            EL = NVIN * NVIN + 1

*  Apply the transformation.
            IF( USEWCS ) THEN
              CALL AST_TRANN( MAP, EL, NVIN, NDF__MXDIM + 1, COIN,
     :                        .TRUE., NVOUT, NDF__MXDIM + 1, COOUT,
     :                        STATUS )
            ELSE
              CALL TRN_TRND( .FALSE., NDF__MXDIM + 1, NVIN, EL, COIN,
     :                  TRIDF, NDF__MXDIM + 1, NVOUT, COOUT, STATUS )
            ENDIF

*  Assign the Jacobian matrix.
            DO IAXIS = 1, NVIN
               DO I = 1, NVIN
                  JACOB( I, IAXIS ) = COOUT( I, IAXIS ) -
     :                                COOUT( 0, IAXIS )
               END DO
            END DO

*  The flux term is the inverse of the absolute determinant of the
*  Jacobian.
            CALL KPG1_MDETD( NVIN, NDF__MXDIM, JACOB, WORK1, WORK2,
     :                       FLUX, STATUS )
            IF ( ABS( FLUX ) .GT. VAL__SMLD ) THEN
               FLUX = ABS( 1.0D0 / FLUX )
            ELSE
               FLUX = 1.0D0
            END IF
         ELSE

*  No flux conservation.
            FLUX = 1.0D0
            CALL CCD1_MSG( ' ', '  Flux is not conserved', STATUS )
         END IF

*  See if there is any conservation of flux required.
         CONSRV = ABS( FLUX - 1.0D0 ) .GT. VAL__EPSD
         IF ( STATUS .NE. SAI__OK ) GO TO 940


*  Resample using the nearest-neighbour technique.
*  ===============================================
         IF ( METHOD .EQ. 'NEAREST' ) THEN

*  This method is applicable to the data, variance and quality arrays.
*  First determine the vector indices of the nearest neighbours applying
*  the transformation.  To do this we need some work space for the
*  input and output coordinates, and input fractional indices.
            WDIMS( 1 ) = ODIMS( 1 )
            WDIMS( 2 ) = NDIMI
            CALL CCD1_MALL( WDIMS( 1 ) * WDIMS( 2 ), '_DOUBLE', WPNTR1,
     :                      STATUS )
            CALL CCD1_MALL( WDIMS( 1 ) * WDIMS( 2 ), '_DOUBLE', WPNTR2,
     :                      STATUS )
            WDIMS( 2 ) = NDIMI
            CALL CCD1_MALL( WDIMS( 1 ) * WDIMS( 2 ), '_DOUBLE', WPNTR3,
     :                      STATUS )

*  Get workspace to hold the indices of the nearest neighbours. There
*  is one for each output array element.
            EL = 1
            DO I = 1, NVOUT
               EL = EL * ODIMS( I )
            END DO
            CALL CCD1_MKTMP( EL, '_INTEGER', INDID, STATUS )
            CALL CCD1_MPTMP( INDID, 'WRITE', INPNTR, STATUS )

*  Generate the list of vector indices for the resampling.
            IF( USEWCS ) THEN
                CALL CCG1_ASPID( NDIMI, IDIMS, MAP,
     :                           %VAL( CNF_PVAL( CAXPTR ) ),
     :                           WDIMS( 1 ), NVOUT, OLBND, ODIMS,
     :                           %VAL( CNF_PVAL( WPNTR1 ) ),
     :                           %VAL( CNF_PVAL( WPNTR3 ) ),
     :                           %VAL( CNF_PVAL( WPNTR2 ) ),
     :                           %VAL( CNF_PVAL( INPNTR ) ),
     :                           STATUS )
            ELSE
                CALL KPG1_TRPID( NDIMI, IDIMS, TRIDI,
     :                           %VAL( CNF_PVAL( CAXPTR ) ),
     :                        WDIMS( 1 ), NVOUT, OLBND, ODIMS,
     :                        %VAL( CNF_PVAL( WPNTR1 ) ),
     :                        %VAL( CNF_PVAL( WPNTR3 ) ),
     :                        %VAL( CNF_PVAL( WPNTR2 ) ),
     :                        %VAL( CNF_PVAL( INPNTR ) ), STATUS )
            ENDIF
*  Free the workspace that is no longer needed.
            CALL CCD1_MFREE( WPNTR1, STATUS )
            CALL CCD1_MFREE( WPNTR2, STATUS )
            CALL CCD1_MFREE( WPNTR3, STATUS )

*  Apply the transformation with n-n resampling.
*  =============================================
*  Loop through all the components.
            DO ICOMP = 1, NACOMP

*  See if the component is present.
               IF ( COMP( ICOMP ) .NE. 'Data' ) THEN
                  CALL NDF_STATE( IDIN, COMP( ICOMP ), THERE, STATUS )
               ELSE
                  THERE = .TRUE.
               END IF

*  Can only process when the array component is present.
               IF ( THERE ) THEN

*  Get the type of the array.
                  CALL NDF_TYPE( IDIN, COMP( ICOMP ), ITYPE, STATUS )

*  Map the input and output arrays.
                  CALL NDF_MAP( IDIN, COMP( ICOMP ), ITYPE, 'READ',
     :                          IPNTR, ELIN, STATUS )
                  CALL NDF_MAP( IDOUT, COMP( ICOMP ), ITYPE,
     :                          'WRITE/BAD', OPNTR, ELOUT, STATUS )

*  When there is flux conservation there is a two-stage process, so
*  workspace is needed to hold the uncorrected values.  Use the same
*  pointer for both cases to save code.  Flux conservation is not
*  required for the QUALITY array.
                  IF ( CONSRV .AND. COMP( ICOMP ) .NE. 'Quality' ) THEN
                     CALL CCD1_MKTMP( ELOUT, ITYPE, WKID4, STATUS )
                     CALL CCD1_MPTMP( WKID4, 'WRITE', OPNTRW, STATUS )
                  ELSE
                     OPNTRW = OPNTR( 1 )
                  END IF

*  Perform the transformation on the data array for the numeric data
*  type.  First for a byte array
                  IF ( ITYPE .EQ. '_BYTE' ) THEN
                     CALL KPG1_VASVB( ELOUT, %VAL( CNF_PVAL( INPNTR ) ),
     :                                ELIN,
     :                                %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                                %VAL( CNF_PVAL( OPNTRW ) ),
     :                                NBAD, STATUS )

*  Transform a double-precision array.
                  ELSE IF ( ITYPE .EQ. '_DOUBLE' ) THEN
                     CALL KPG1_VASVD( ELOUT, %VAL( CNF_PVAL( INPNTR ) ),
     :                                ELIN,
     :                                %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                                %VAL( CNF_PVAL( OPNTRW ) ),
     :                                NBAD, STATUS )

*  Transform an integer array.
                  ELSE IF ( ITYPE .EQ. '_INTEGER' ) THEN
                     CALL KPG1_VASVI( ELOUT, %VAL( CNF_PVAL( INPNTR ) ),
     :                                ELIN,
     :                                %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                                %VAL( CNF_PVAL( OPNTRW ) ),
     :                                NBAD, STATUS )

*  Transform an integer*8 array.
                  ELSE IF ( ITYPE .EQ. '_INT64' ) THEN
                     CALL KPG1_VASVK( ELOUT, %VAL( CNF_PVAL( INPNTR ) ),
     :                                ELIN,
     :                                %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                                %VAL( CNF_PVAL( OPNTRW ) ),
     :                                NBAD, STATUS )

*  Transform a single-precision array.
                  ELSE IF ( ITYPE .EQ. '_REAL' ) THEN
                     CALL KPG1_VASVR( ELOUT, %VAL( CNF_PVAL( INPNTR ) ),
     :                                ELIN,
     :                                %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                                %VAL( CNF_PVAL( OPNTRW ) ),
     :                                NBAD, STATUS )

*  Transform an unsigned-byte array.
                  ELSE IF ( ITYPE .EQ. '_UBYTE' ) THEN
                     CALL KPG1_VASVUB( ELOUT,
     :                                 %VAL( CNF_PVAL( INPNTR ) ), ELIN,
     :                                 %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                                 %VAL( CNF_PVAL( OPNTRW ) ),
     :                                 NBAD, STATUS )

*  Transform an unsigned-word array.
                  ELSE IF ( ITYPE .EQ. '_UWORD' ) THEN
                     CALL KPG1_VASVUW( ELOUT,
     :                                 %VAL( CNF_PVAL( INPNTR ) ), ELIN,
     :                                 %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                                 %VAL( CNF_PVAL( OPNTRW ) ),
     :                                 NBAD, STATUS )

*  Transform a word array.
                  ELSE IF ( ITYPE .EQ. '_WORD' ) THEN
                     CALL KPG1_VASVW( ELOUT, %VAL( CNF_PVAL( INPNTR ) ),
     :                                ELIN,
     :                                %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                                %VAL( CNF_PVAL( OPNTRW ) ),
     :                                NBAD, STATUS )
                  END IF

*  If there is no flux conservation we only need to unmap the output
*  array.
                  IF ( CONSRV .AND. COMP( ICOMP ) .NE. 'Quality' ) THEN

*  Decide whether or not we need to test for bad pixels.
                     BAD = NBAD .NE. 0

*  Select the appropriate routine for the data type being processed and
*  multiply the data array by the constant.
                     CALL CCD1_CMUL( BAD, ITYPE, OPNTRW, EL, FLUX,
     :                               OPNTR( 1 ), STATUS )

*  Tidy the workspace.
                     CALL CCD1_FRTMP( WKID4, STATUS )
                  END IF

*  Set the bad pixel flag when bad pixels have been found.
                  IF ( BAD .AND. COMP( ICOMP ) .NE. 'Quality' ) THEN
                     CALL NDF_SBAD( .TRUE., IDOUT, COMP( ICOMP ),
     :                              STATUS )
                  END IF

*  Unmap the output array.
                  CALL NDF_UNMAP( IDOUT, COMP( ICOMP ), STATUS )

*  Unmap the input NDF array.
                  CALL NDF_UNMAP( IDIN, COMP( ICOMP ), STATUS )
               END IF
            END DO

*  Free the workspace holding the resampled vector indices.
            CALL CCD1_FRTMP( INDID, STATUS )

*  Apply linear-interpolation resampling.
*  ======================================
         ELSE IF ( METHOD .EQ. 'LININT' ) THEN

*  Get work arrays for the transformation. Needed is space for the input
*  and output coordinates, and input fractional indices.
            WDIMS( 1 ) = ODIMS( 1 )
            WDIMS( 2 ) = NDIMI
            CALL CCD1_MALL( WDIMS( 1 ) * WDIMS( 2 ), '_DOUBLE', WPNTR1,
     :                      STATUS )
            CALL CCD1_MALL( WDIMS( 1 ) * WDIMS( 2 ), '_DOUBLE', WPNTR2,
     :                      STATUS )
            WDIMS( 2 ) = NDIMI
            CALL CCD1_MALL( WDIMS( 1 ) * WDIMS( 2 ), '_DOUBLE', WPNTR3,
     :                      STATUS )

*  See if the variance component is present.  Note that a quality array
*  cannot be linearly interpolated.
            CALL NDF_STATE( IDIN, 'Variance', VAR, STATUS )
            IF ( VAR ) THEN

*  Get the implementation type of the arrays.
               CALL NDF_MTYPE( '_BYTE,_UBYTE,_WORD,_UWORD,_INTEGER,'/
     :                         /'_INT64,_REAL,_DOUBLE', IDIN, IDIN,
     :                         'Data,Variance', ITYPE, DTYPE, STATUS )

*  Map the input and output arrays.
               CALL NDF_MAP( IDIN, 'Data,Variance', ITYPE, 'READ',
     :                       IPNTR, ELIN, STATUS )
               CALL NDF_MAP( IDOUT, 'Data,Variance', ITYPE, 'WRITE/BAD',
     :                       OPNTR, ELOUT, STATUS )

*  Perform the transformation on the data array for the numeric data
*  type.  First apply to a byte array.
               IF ( ITYPE .EQ. '_BYTE' ) THEN
                  IF( USEWCS ) THEN
                    CALL CCG1_ASLIB( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, %VAL( CNF_PVAL( IPNTR( 2 ) ) ),
     :                             MAP,
     :                             FLUX, %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             %VAL( CNF_PVAL( OPNTR( 2 ) ) ),
     :                             %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                  ELSE
                    CALL KPG1_TDLIB( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, %VAL( CNF_PVAL( IPNTR( 2 ) ) ),
     :                             TRIDI,
     :                             FLUX, %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             %VAL( CNF_PVAL( OPNTR( 2 ) ) ),
     :                             %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                  ENDIF
*  Transform a double-precision array.
               ELSE IF ( ITYPE .EQ. '_DOUBLE' ) THEN
                  IF( USEWCS ) THEN
                    CALL CCG1_ASLID( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, %VAL( CNF_PVAL( IPNTR( 2 ) ) ),
     :                             MAP,
     :                             FLUX, %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             %VAL( CNF_PVAL( OPNTR( 2 ) ) ),
     :                             %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                  ELSE
                    CALL KPG1_TDLID( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, %VAL( CNF_PVAL( IPNTR( 2 ) ) ),
     :                             TRIDI,
     :                             FLUX, %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             %VAL( CNF_PVAL( OPNTR( 2 ) ) ),
     :                             %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                  ENDIF
*  Transform an integer array.
               ELSE IF ( ITYPE .EQ. '_INTEGER' ) THEN
                  IF ( USEWCS ) THEN
                    CALL CCG1_ASLII( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, %VAL( CNF_PVAL( IPNTR( 2 ) ) ),
     :                             MAP,
     :                             FLUX, %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             %VAL( CNF_PVAL( OPNTR( 2 ) ) ),
     :                             %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                 ELSE
                    CALL KPG1_TDLII( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, %VAL( CNF_PVAL( IPNTR( 2 ) ) ),
     :                             TRIDI,
     :                             FLUX, %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             %VAL( CNF_PVAL( OPNTR( 2 ) ) ),
     :                             %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                 ENDIF
*  Transform an integer array.
               ELSE IF ( ITYPE .EQ. '_INT64' ) THEN
                  IF ( USEWCS ) THEN
                    CALL CCG1_ASLIK( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, %VAL( CNF_PVAL( IPNTR( 2 ) ) ),
     :                             MAP,
     :                             FLUX, %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             %VAL( CNF_PVAL( OPNTR( 2 ) ) ),
     :                             %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                 ELSE
                    CALL KPG1_TDLIK( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, %VAL( CNF_PVAL( IPNTR( 2 ) ) ),
     :                             TRIDI,
     :                             FLUX, %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             %VAL( CNF_PVAL( OPNTR( 2 ) ) ),
     :                             %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                 ENDIF
*  Transform a single-precision array.
               ELSE IF ( ITYPE .EQ. '_REAL' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLIR( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, %VAL( CNF_PVAL( IPNTR( 2 ) ) ),
     :                             MAP,
     :                             FLUX, %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             %VAL( CNF_PVAL( OPNTR( 2 ) ) ),
     :                             %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                  ELSE
                    CALL KPG1_TDLIR( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, %VAL( CNF_PVAL( IPNTR( 2 ) ) ),
     :                             TRIDI,
     :                             FLUX, %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             %VAL( CNF_PVAL( OPNTR( 2 ) ) ),
     :                             %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                  ENDIF
*  Transform an unsigned-byte array.
               ELSE IF ( ITYPE .EQ. '_UBYTE' ) THEN
                  IF (USEWCS ) THEN
                    CALL CCG1_ASLIUB( NDIMI, IDIMS,
     :                                %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                              VAR, %VAL( CNF_PVAL( IPNTR( 2 ) ) ),
     :                              MAP,
     :                              FLUX, %VAL( CNF_PVAL( CAXPTR ) ),
     :                              ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                              %VAL( CNF_PVAL( OPNTR( 2 ) ) ),
     :                              %VAL( CNF_PVAL( WPNTR1 ) ),
     :                              %VAL( CNF_PVAL( WPNTR3 ) ),
     :                              %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                  ELSE
                    CALL KPG1_TDLIUB( NDIMI, IDIMS,
     :                                %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                              VAR, %VAL( CNF_PVAL( IPNTR( 2 ) ) ),
     :                              TRIDI,
     :                              FLUX, %VAL( CNF_PVAL( CAXPTR ) ),
     :                              ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                              %VAL( CNF_PVAL( OPNTR( 2 ) ) ),
     :                              %VAL( CNF_PVAL( WPNTR1 ) ),
     :                              %VAL( CNF_PVAL( WPNTR3 ) ),
     :                              %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                  ENDIF
*  Transform an unsigned-word array.
               ELSE IF ( ITYPE .EQ. '_UWORD' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLIUW( NDIMI, IDIMS,
     :                                %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                              VAR, %VAL( CNF_PVAL( IPNTR( 2 ) ) ),
     :                              MAP,
     :                              FLUX, %VAL( CNF_PVAL( CAXPTR ) ),
     :                              ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                              %VAL( CNF_PVAL( OPNTR( 2 ) ) ),
     :                              %VAL( CNF_PVAL( WPNTR1 ) ),
     :                              %VAL( CNF_PVAL( WPNTR3 ) ),
     :                              %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                  ELSE
                    CALL KPG1_TDLIUW( NDIMI, IDIMS,
     :                                %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                              VAR, %VAL( CNF_PVAL( IPNTR( 2 ) ) ),
     :                              TRIDI,
     :                              FLUX, %VAL( CNF_PVAL( CAXPTR ) ),
     :                              ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                              %VAL( CNF_PVAL( OPNTR( 2 ) ) ),
     :                              %VAL( CNF_PVAL( WPNTR1 ) ),
     :                              %VAL( CNF_PVAL( WPNTR3 ) ),
     :                              %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                  ENDIF
*  Transform a word array.
               ELSE IF ( ITYPE .EQ. '_WORD' ) THEN
                  IF(USEWCS) THEN
                    CALL CCG1_ASLIW( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, %VAL( CNF_PVAL( IPNTR( 2 ) ) ),
     :                             MAP,
     :                             FLUX, %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             %VAL( CNF_PVAL( OPNTR( 2 ) ) ),
     :                             %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                  ELSE
                    CALL KPG1_TDLIW( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, %VAL( CNF_PVAL( IPNTR( 2 ) ) ),
     :                             TRIDI,
     :                             FLUX, %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             %VAL( CNF_PVAL( OPNTR( 2 ) ) ),
     :                             %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                  ENDIF
               END IF
            ELSE

*  Get the type of the data array.
               CALL NDF_TYPE( IDIN, 'Data', ITYPE, STATUS )

*  Map the input and output arrays.  Use a dummy variance value.  It is
*  not assigned as it will not be used.
               CALL NDF_MAP( IDIN, 'Data', ITYPE, 'READ', IPNTR, ELIN,
     :                       STATUS )
               CALL NDF_MAP( IDOUT, 'Data', ITYPE, 'WRITE/BAD', OPNTR,
     :                       ELOUT, STATUS )

*  Perform the transformation on the data array for the numeric data
*  type.  First apply to a byte array.
               IF ( ITYPE .EQ. '_BYTE' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLIB( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, VARB, MAP, FLUX,
     :                             %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             VARBO, %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ),
     :                             STATUS )
                  ELSE
                    CALL KPG1_TDLIB( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, VARB, TRIDI, FLUX,
     :                             %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             VARBO, %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ),
     :                             STATUS )
                  ENDIF

*  Transform a double-precision array.
               ELSE IF ( ITYPE .EQ. '_DOUBLE' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLID( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, VARD, MAP, FLUX,
     :                             %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             VARBO, %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ),
     :                             STATUS )
                  ELSE
                    CALL KPG1_TDLID( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, VARD, TRIDI, FLUX,
     :                             %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             VARBO, %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ),
     :                             STATUS )
                  ENDIF

*  Transform an integer array.
               ELSE IF ( ITYPE .EQ. '_INTEGER' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLII( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, VARI, MAP, FLUX,
     :                             %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             VARBO, %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ),
     :                             STATUS )
                  ELSE
                    CALL KPG1_TDLII( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, VARI, TRIDI, FLUX,
     :                             %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             VARBO, %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ),
     :                             STATUS )
                  ENDIF

               ELSE IF ( ITYPE .EQ. '_INT64' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLIK( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, VARI, MAP, FLUX,
     :                             %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             VARBO, %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ),
     :                             STATUS )
                  ELSE
                    CALL KPG1_TDLIK( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, VARI, TRIDI, FLUX,
     :                             %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             VARBO, %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ),
     :                             STATUS )
                  ENDIF

*  Transform a single-precision array.
               ELSE IF ( ITYPE .EQ. '_REAL' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLIR( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, VARR, MAP, FLUX,
     :                             %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             VARBO, %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ),
     :                             STATUS )
                  ELSE
                    CALL KPG1_TDLIR( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, VARR, TRIDI, FLUX,
     :                             %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             VARBO, %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ),
     :                             STATUS )
                  ENDIF

*  Transform an unsigned-byte array.
               ELSE IF ( ITYPE .EQ. '_UBYTE' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLIUB( NDIMI, IDIMS,
     :                                %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                              VAR, VARB, MAP, FLUX,
     :                              %VAL( CNF_PVAL( CAXPTR ) ),
     :                              ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                              VARBO,
     :                              %VAL( CNF_PVAL( WPNTR1 ) ),
     :                              %VAL( CNF_PVAL( WPNTR3 ) ),
     :                              %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                  ELSE
                    CALL KPG1_TDLIUB( NDIMI, IDIMS,
     :                                %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                              VAR, VARB, TRIDI, FLUX,
     :                              %VAL( CNF_PVAL( CAXPTR ) ),
     :                              ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                              VARBO,
     :                              %VAL( CNF_PVAL( WPNTR1 ) ),
     :                              %VAL( CNF_PVAL( WPNTR3 ) ),
     :                              %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                  ENDIF

*  Transform an unsigned-word array.
               ELSE IF ( ITYPE .EQ. '_UWORD' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLIUW( NDIMI, IDIMS,
     :                                %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                              VAR, VARW, MAP, FLUX,
     :                              %VAL( CNF_PVAL( CAXPTR ) ),
     :                              ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                              VARBO,
     :                              %VAL( CNF_PVAL( WPNTR1 ) ),
     :                              %VAL( CNF_PVAL( WPNTR3 ) ),
     :                              %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                  ELSE
                    CALL KPG1_TDLIUW( NDIMI, IDIMS,
     :                                %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                              VAR, VARW, TRIDI, FLUX,
     :                              %VAL( CNF_PVAL( CAXPTR ) ),
     :                              ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                              VARBO,
     :                              %VAL( CNF_PVAL( WPNTR1 ) ),
     :                              %VAL( CNF_PVAL( WPNTR3 ) ),
     :                              %VAL( CNF_PVAL( WPNTR2 ) ), STATUS )
                  ENDIF

*  Transform a word array.
               ELSE IF ( ITYPE .EQ. '_WORD' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLIW( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, VARW, MAP, FLUX,
     :                             %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             VARBO, %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ),
     :                             STATUS )
                  ELSE
                    CALL KPG1_TDLIW( NDIMI, IDIMS,
     :                               %VAL( CNF_PVAL( IPNTR( 1 ) ) ),
     :                             VAR, VARW, TRIDI, FLUX,
     :                             %VAL( CNF_PVAL( CAXPTR ) ),
     :                             ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS,
     :                             %VAL( CNF_PVAL( OPNTR( 1 ) ) ),
     :                             VARBO, %VAL( CNF_PVAL( WPNTR1 ) ),
     :                             %VAL( CNF_PVAL( WPNTR3 ) ),
     :                             %VAL( CNF_PVAL( WPNTR2 ) ),
     :                             STATUS )
                  ENDIF
               END IF

*  Free the workspace that is no longer needed.
               CALL CCD1_MFREE( WPNTR1, STATUS )
               CALL CCD1_MFREE( WPNTR2, STATUS )
               CALL CCD1_MFREE( WPNTR3, STATUS )
            END IF
         END IF

*  Add a title to the new NDF.
         CALL NDF_CINP( 'TITLE', IDOUT, 'TITLE', STATUS )

*  Propogate the WCS component
         IF (USEWCS) THEN

*  A reminder of the various pointers and indices we have to play with
*       CFRAME  Index of the alignment frame
*       FRCUR   Pointer to alignment frame
*       IWCS    Pointer to input AST FrameSet
*       OWCS    Pointer to output AST FrameSet

*  Get default WCS component (just GRID, PIXEL, AXIS) for the output NDF.
            CALL CCD1_GTWCS( IDOUT, OWCS, STATUS )
            CALL AST_SETI( IWCS, 'Current', CFRAME, STATUS )

*  Rename the PIXEL frame to CCD_OLDPIXEL to retain information about
*  the pre-transformation coordinates in case the user wants this at
*  a later date.
            CALL CCD1_DMPRG( IWCS, OPIXDM, .TRUE., 0, STATUS )
            CALL CCD1_FRDM( IWCS, 'PIXEL', JPIX, STATUS )
            PFRM = AST_GETFRAME( IWCS, JPIX, STATUS )
            CALL AST_SETC( PFRM, 'DOMAIN', OPIXDM, STATUS )

*  Remove any remaining GRID, PIXEL, AXIS frames from original frameset
*  since they're out of date now.  This just leaves the non-automatic
*  frames of the input WCS component.
            CALL CCD1_DMPRG( IWCS, 'PIXEL', .FALSE., 0, STATUS )
            CALL CCD1_DMPRG( IWCS, 'AXIS', .FALSE., 0, STATUS )
            CALL CCD1_DMPRG( IWCS, 'GRID', .FALSE., 0, STATUS )

*  Find out which frame contains the PIXEL domain in the output frameset.
            CALL CCD1_FRDM( OWCS, 'PIXEL', JPIX, STATUS )

*  And add the remaining bits of IWCS to OWCS
            CALL AST_ADDFRAME( OWCS, JPIX,
     :                         AST_UNITMAP( NDIMI, ' ', STATUS ),
     :                         IWCS, STATUS )

*  Write it out.
            CALL NDF_PTWCS( OWCS, IDOUT, STATUS )

         END IF

*  Release NDFs and close container files. Retain locator to transform
*  structure if INEXT is false.
         IF( USEWCS ) THEN
            CALL AST_ANNUL( IWCS, STATUS )
            CALL AST_ANNUL( FRCUR, STATUS )
            CALL AST_ANNUL( OWCS, STATUS )
         ELSE IF( INEXT ) THEN
            CALL DAT_ANNUL( LOCEXT, STATUS )
            CALL DAT_ANNUL( LOCTR, STATUS )
            CALL TRN_ANNUL( TRIDF, STATUS )
            CALL TRN_ANNUL( TRIDI, STATUS )
         END IF
         CALL NDF_ANNUL( IDIN, STATUS )
         CALL NDF_ANNUL( IDOUT, STATUS )

*  Free concatenated axes workspace.
         CALL CCD1_MFREE( CAXPTR, STATUS )

*  Write terminator for Processing NDF: message.
         CALL CCD1_MSG( ' ', '  ---',STATUS )

*  End of main processing loop.

99999 CONTINUE

*  Tidy resources.
*  ===============

*  Free any workspace.
  940 CONTINUE
      CALL CCD1_MFREE( -1, STATUS )
      CALL CCD1_FRTMP( -1, STATUS )

  960 CONTINUE
      IF( USEWCS ) THEN
*  Tidy up any remaining AST FrameSets
        CALL AST_END( STATUS )
      ELSE
*  Free any remaining transformation resources.
        CALL TRN_CLOSE( STATUS )
      ENDIF

*  Tidy the NDF context.
      CALL NDF_END( STATUS )

*  Release group resources.
      CALL CCD1_GRDEL( GIDIN, STATUS )
      CALL CCD1_GRDEL( GIDOUT, STATUS )

  999 CONTINUE
*  If an error occurred, then report a contextual message.
      IF ( STATUS .NE. SAI__OK ) THEN
         IF( USEWCS ) THEN
            CALL ERR_REP( 'TRANNDF_ERR',
     :        'TRANNDF: Unable to transform the NDF '/
     :       /'using WCS extensions.', STATUS )
         ELSE
            CALL ERR_REP( 'TRANNDF_ERR',
     :        'TRANNDF: Unable to transform the NDF '/
     :       /'using TRN structures.', STATUS )
         ENDIF
      END IF

*  Close the log file.
      CALL CCD1_END( STATUS )

      END
