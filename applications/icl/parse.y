/******************************************************************************
 *
 * P A R S E . Y
 *
 * yacc parse file for ICL
 *
 * 	Created : Cripen Goswell (Summer 1991)
 *		: S.K. Robinson  (1992)
 *		: B.K. McIlwrath All subsequent changes.
 *
 * This file contains the yacc(1) definition of the syntax of ICL as well as 
 * the actions needed to create the abstract syntax for ICL input. If the 
 * actions are ignored, this file may be treated as a grammar for the ICL 
 * language.
 * This file is passed through yacc(1) and generates a C program which will 
 * parse ICL input LINE by LINE and generate an 'internal' representation
 * for that line.
 * 
 * The format of the yacc(1) input file is
 *
 * declarations and definitions
 * %%
 * sequence of patterns and actions
 * %%
 * user code
 *
 * The declarations and definitions section consists of user C code segments 
 * enclosed in %{ and %} which are copied directly to the generated C parser,
 * token identifier declarations (see below) and pattern element type 
 * declarations (see below).
 *
 * The next section of the input file consists of a series of lines, each line
 * consisting of a pattern of a sequence of tokens (for example an integer
 * constant, an identifer etc) to be recognised and an action if that pattern
 * is parsed.  The actions' main function is to create the internal form 
 * (abstract syntax) for the statement just parsed.
 *
 * The final section is user C code which is simply copied to the generated C 
 * parser.
 *
 * The abstract syntax created is based on the ICL System Abstract Data Type 
 * "node", defined in node.h and interfaced through the file node.c.  The 
 * documentation of this data structure also lists the abstract syntax for 
 * each ICL statement and this documentation should be read before this file
 * is modified or maintained.
 * 
 * As the parse proceeds, each grammar rule will call a routine in node.c to
 * create a node in the abstract syntax tree. yacc() passes these nodes around
 * in such a way that when the generated parser (the function yyparse()) exits,
 * it leaves the node abstract syntax tree root pointed to by an external 
 * variable 'todo'.
 * If 'todo' is NULL, then there is nothing further to do with the line
 * (normally the line then has to be 'interpreted' (for a direct command) or 
 * stored as part of a user PROC/EXCEPTION).
 *
 * TOKENS
 * ======
 * 
 * Each input line is seen as a sequence of tokens, as documented in lex.l.  
 * Each token is a sequence of input characters that has meaning as a whole 
 * (for example an integer, or an identifer etc) and each time the generated 
 * parser wants the 'next' input token the routine yylex() is automatically 
 * called.
 *
 * yylex() is generated by the lex(1) processing of the file lex.l. This 
 * results in the file lex.c which, when compiled and linked into the ICL 
 * binary, provides the yylex() function.
 *
 * The call of yylex() results in an integer 'token class code' being returned.
 * This indicates the 'class' of the token just processed by yylex().  Typical
 * classes are integer, string, comma, name (identifer) etc.  The full list of
 * token classes is deined below in %term directives to yacc(1).  This causes
 * yacc(1) to GENERATE a file (y.tab.h) which is made up of lines of the form
 *
 *	#define tokenclassidentifer nn
 *
 * where nn is the integer code for that class.
 *
 * This file is included into the source file generated by the lex(1) 
 * processing of the lex.l file and the actions in the generated lex.c program
 * usually terminate with a return(tokenclassidentity); statement so that the 
 * class codes returned by the call to yylex() are those expected by the
 * parser generated by yacc(1)'s processing of this file.
 *
 * The lexical analyser and the parser can communicate through the variables
 * 'yytext' (the characters representing the token just parsed), the union
 * 'yylval' and the lex.c defined string pointer 'errormessage'.  This
 * last location is where the lexical analyser will place a message when it
 * detects an error in the source input. This can be used by the parser to 
 * qualify an error message generated by the system.
 *
 * Comments
 * ========
 *
 * ICL executes expressions and procedures by interpreting the abstract syntax
 * tree. ICL procedures are kept only in the form of a parse tree, so they are
 * listed and saved by regenerating the source from this internal form.
 *
 * A consequence of this is that comments need to be held in the abstract 
 * syntax tree. Rather than require every statement type to contain a comment 
 * field, a comment node is generated which contains the statement which the 
 * encountered comment comments. Control structures such as FOR, IF, LOOP, 
 * WHILE, PROC and similar are parsed as single statements, so they have to 
 * contain further commenting opportunities.
 *
 * Prompts to the User
 * ==================
 *
 * The prompt used to for the user to enter the next line varies depending on 
 * the  current input context.  For example, during the body of a FOR, the 
 * prompt is "FOR>", during an IF body it is "IF>".  As statements can nest 
 * (IFs within LOOPs within FOR loops etc.) we need the facility of a stack of
 * such prompts.
 * This is provided by the functions stack_prompt( char *prompt) which pushes 
 * the prompt 'prompt' onto the top of the prompt stack, which causes the next
 * line to be prompted with the prompt 'prompt', and unstack_prompt() which 
 * pops the stack and therefore  subsequently causes the top of the now popped
 * stack to be used as the prompt.
 *
 * Because the instant at which we wish to change the prompt does not always 
 * occur at the end of a token pattern we use a facilty offered by yacc(1) of 
 * including actions WITHIN a pattern (which are executed as soon as the 
 * pattern to the left has been recognised).  These internal pattern actions 
 * are delimited by C's '{' and '}' in the pattern specification.
 *
 * Patterns
 * ========
 *
 * A token pattern consists of a sequence of what are known as terminals 
 * (token class identifers - denoted by CAPITAL identifiers in this 
 * specification) and non-terminals (the identifer of another pattern to be 
 * found in the file that label's its pattern in the form xxxxxx : pattern 
 * (and denoted by lower case identifers in this file).  The parser proceeds 
 * from left to right through the pattern.  If the next pattern element is a 
 * token class identifer then it checks that the current token is that class 
 * and gets the next token.  If the next pattern element is a non-terminal it
 * starts at the beginning of that non-terminal's pattern.   If the next
 * pattern element is an embedded action then that action is executed. The 
 * non-terminal whose pattern that yyparse() starts with when called is 
 * specified by the %start directive to yacc(1).
 *
 * In many cases a non terminal's definition is of the form either this pattern 
 * or this pattern or this pattern.....  This is expressed as
 *
 * xxxxx :  pattern1	{action1}
 *       |  pattern2	{action2}
 *       |  pattern3	{action3}
 *       ...
 *       ;
 *
 * where the | reads 'or' and the ';' reads end of non terminal defintion. The
 * parser will (in effect) try to match all the patterns at once and succeed 
 * if it gets to the end of one of the patterns (yacc(1) will have analysed 
 * the patterns and report ambiguity if more than one pattern could be matched
 * at the same time).  Upon success the action associated with the end of that
 * pattern will be executed (as will have any embedded actions within that 
 * pattern as the parse proceeded).
 *
 * Errors During a Parse
 * =====================
 *
 * If an error occurs during the parse of a pattern (the input was not as 
 * expected) then yacc(1) permits the specifier to detail a further pattern 
 * (headed with the special non terminal 'error' as the first element in the 
 * pattern).  This usually takes the form of
 *
 *  error  {error action (report an error?)} terminal_identifer {action}
 * 
 * What the code generated by yacc(1) will do is to set an internal error flag,
 * then perform the error action and then proceed to consume input (in effect)
 * until the named terminal_identifer is found (and then the final action is 
 * executed).
 * 
 * Two macros are provided by the yacc(1) library to assist in this error
 * recovery procedure.
 *  
 * yyerrok clears the internal error flag (so that the error treatment does not
 * continue to apply on any subsequent input).
 * 
 * yyclearin clears the generated parser's lookahead buffer (consideration of 
 * the above description will lead to the conclusion that occasionally the 
 * parser must "look ahead" in the input stream. As the error process has 
 * positioned the input where the specifier wishes it to be (at 
 * terminal_identifer) we need to discard this lookahead).
 *
 *
 * ****************************************************************************
 * Pattern Element Values
 * ======================
 *
 * Each pattern element is understood by the generated parser to deliver a 
 * value (the result of its recognition).  So each terminal, non terminal and 
 * embedded action in a pattern is to deliver a result.  For terminals it is 
 * the value of the token delivered by the lex(1) lexical analyser.  As you
 * recall this value is placed in the relevent element of the yylval union.  
 * Similary non terminals can deliver a result of one of the types in this 
 * union (by the action at the end of the pattern producing one) and so can 
 * embedded actions (by calculating a value). Each pattern element's result 
 * value is kept by the generated parser on a stack as it is parsed.  To refer
 * to this value from within an action (one can only refer to pattern values 
 * that occur to the left of the action as these are only those that have been
 * parsed and delivered their result. This means that the action at the end of
 * a pattern has access to all the values in the pattern, whilst an embedded 
 * action only has access to those to its left in the pattern) one uses the
 * special identifiers $1, $2,  $3 etc.  where $1 refers to the first element 
 * in the pattern, $2 to the second etc.  The action's result value is denoted
 * by $$.  For example the pattern and action:
 *
 * xxxxx : YY yyy { $$ = ff($1,$2); } GG  { $$ = gg($3,$4); }
 *
 * would cause ff to be called with the values from the terminal YY and the 
 * non-terminal yyy  and gg() to be called with the values from the embedded 
 * action and the terminal GG.  In the latter case we could refer to the 
 * specific element of the yylval union (say, $$ = gg($3, yylval.double); ) as
 * only one token has been parsed since the last action and yylval will still 
 * contain the generated value.  In general this is not true (for example in
 * the pattern  XX YY { action} then yylval will contain the value from YY, 
 * that from XX is now in the value stack).
 * To allow the specifier to implicitly select the correct member of the union
 * when using the $i notation yacc(1) requires the specifier to list the value
 * types of ALL the terminal and non-terminal pattern elements.  This is done 
 * using a series of %type directives to yacc(1) each of which has the form:
 * 
 * %type <member name in union>  space separated list of terminals
 *			         and non terminals
 * 
 * This allows yacc(1) to generate stack_element.member_name ( the specific 
 * stack element is clearly some function of i when $i is used) at each 
 * occurence of $i and $$ in the action source.
 * 
 * The only remaining pattern element values that need typing are the embedded
 * actions. To specify which union member the embedded action delivers we use 
 * $<member_identifer>$
 *
 * Actions
 * =======
 *
 * Actions can be any C code enclosed in C's '{' and '}'. To refer to the 
 * pattern element values we use $$ and $i as explained earlier.  In ICL's 
 * case most of the actions are to the interface provided by node.c to 
 * generate the internal abstract syntax form of the parsed pattern.
 *
 * Example:
 *
 * xxx : xxx + yyy { $$ = mk_bintreenode(PLUS, $1, $2); }
 *     ;
 * yyy : ID  {$$ = $1;}
 *     | CON ($$ = $1;}
 *     ;
 *
 * would, given the input 3 + 4 + 10 (and assuming CON is an integer token and
 * mk_bintreenode() generates a binary tree node), generate
 *
 *                   +
 *                 /  \\
 *              +       10
 *           /   \\
 *         3       4
 * 
 *
 ******************************************************************************
 */
/*
 ******************************************************************************
 *
 *			T H E  I C L  P A R S E R
 *
 * When called the parser can expect a command~line which takes the form of 
 * either
 *
 *	an immediate statement NEWLINE  	( = .....
 *	an assignment statement NEWLINE 	( yy = ....
 *	a direct command NEWLINE		(for example LIST xx
 *	a PROC definition NEWLINE 		(PROC .... ENDPROC
 * 	a built_in command NEWLINE		(# xxx ......
 *	an immediate command			(% xxx ......
 *	a comment NEWLINE 			( ; ..... or { .......
 *
 * Failing these an error should be reported and the line skipped until a 
 * newline token is found.
 *
 * An immediate statement has the form
 *
 *	EQUAL expression comment NEWLINE
 *
 *	where a comment is either a token COMMENT or is not present
 *
 * An assignment has the form
 *
 *	name EQUAL expression comment NEWLINE
 *
 *	where a name is the token NAME (an identifer)
 *
 * A direct command has the form
 *
 *	name actual~parameter~list comment NEWLINE
 *	name comment NEWLINE
 *
 * 	where an actual~parameter~list is
 *
 *	a list of STRINGS, OPENSTRINGS or 
 *	OPEN_PAREN expression CLOSE_PAREN 
 *	where each is separated from the others with a COMMA or a space.
 *
 * A PROC definition has the form
 *
 *	PROC name args comment NEWLINE
 *	statement list
 *	exception list
 *	ENDPROC comment NEWLINE
 *
 * or that with HIDDEN before the PROC
 *
 *	where args is either absent or a list of names separated by a COMMA or
 *	a space (a list of the formal parameters to the PROC)
 *
 *	where exception list takes the form of a series of exceptions
 *	each exception takes the form
 *
 *		EXCEPTION name comment NEWLINE
 *		statement_list
 *		ENDEXCEPTION comment
 *              comment_list
 *
 *	where a statement_list is a series of proc_lines separated by NEWLINE 
 *	(or is empty)
 *	proc_line is either
 *		an assignment statement		( yy = ....
 *		an immediate statement 		( = .....
 *		an if statement,
 *		a loop statement,
 *		a break statement, which is BREAK comment
 *		a direct command 		(for example LIST xx
 *	 	a built_in command		(# xxx ......
 *		an immediate proc_line		(% proc_line
 *		a comment ( ; ..... or { .......
 *
 *	and where comment_list is a series of comments separated by NEWLINE 
 *
 ******************************************************************************
 *
 * A built_in command has the form 
 *
 *	# name actual~parameter~list comment NEWLINE
 *      # name comment NEWLINE
 *
 * An immediate command has the form
 *
 *	%  command~line NEWLINE command~line
 *
 *	 Note that the paser's actions in this case will immediately execute
 *	 the abstract syntax form of the first command line by calling the
 *	 function execute() (from main.c) and deliver, as its result the second
 *	 command line (which recursively will handle sequences of immediate 
 *	 commands delivering the first non-immediate command in that sequence).
 *
 * An IF statement has the form:
 *
 *	IF if_part ENDIF
 *	
 *	where if_part is
 *	
 *	expression comment NEWLINE statement_list else_part
 *
 *	and else_part is either absent or one of 
 *
 *		ELSE IF if_part
 *		ELSEIF if_part
 *		ELSE comment NEWLINE statement_list
 *
 * A LOOP statement has the form
 *
 *	LOOP comment NEWLINE statement_list ENDLOOP
 * or
 *	LOOP FOR name EQUAL expression TO expression STEP expression comment 
 *	statement_list 
 *	ENDLOOP
 *	where the STEP expression is optional
 * or
 *	LOOP while expression comment
 *	statement_list
 *	ENDLOOP
 *
 ******************************************************************************
 *
 * We have now discussed the whole syntax of ICL except expressions.  ICL has 
 * many operators each with their own precedence level and associativity
 * To specify expressions in yacc(1) input (and BNF in general) one starts by
 * defining the lowest precedence first (ie define + defore *) in terms of 
 * expressions involving the higher precedence. We define all operators of 
 * equal lowest precedence at one go so we might begin
 *
 *	expression : expression + expressions2
 * 		   | expression - expressions2
 * 		   | expressions2
 *		   ;
 *
 * By defining + and - in this way (rather than expressions2 + expression) we 
 * will make + left associative (the left expression will contain all left 
 * occuring + before parsing the rightmost +).  If we require the operator to 
 * be right associative we would use, in this case, expressions2 + expression.
 * If we require an operator to have no precedence we define it totally in 
 * terms of the next higher level of percedence (for example 
 * expressions2 % expressions2). The last alternate for expression allows 
 * expressions with no + or - present.
 *
 * Having done this level of precedence we proceed to the next lowest level. In
 * this case
 *
 *	expressions2 : expression * expressions3
 *		     | expression / expressions3
 *		     | expressions3
 *		     ;
 *
 * Note again we have made * and / as left associative.  This continues until 
 * all precedence levels are defined when we finally define the basic operands
 * of expressions (usually variable identifiers, function calls and constants).
 * Further, in most expression languages there is use made of parentheses to 
 * cause the contained expression's operators to be parsed using the normal 
 * rules of precedence and associativity but independent of any surrounding 
 * expression.  So, typically we would finish with
 *
 *	expressions3 : name
 *	             | constant
 *		     | name ( expression list )
 *	             | ( expression )
 *	             ;
 *
 ******************************************************************************
 *
 * The operators, their precedence levels and associativity is given below
 *
 *	Operator	Precedence	Associativity
 *	   AND		   0		  left   expression
 *	   OR		   0		  left
 *	   NOT		   0		  right
 *	   CONCAT	   0		  left
 *	   EQUAL	   1		  none   exp0
 *	   LESS_THAN	   1              none
 *	   GREATER_THAN	   1              none
 *	   LESS_EQUAL	   1              none
 *	   GREATER_EQUAL   1              none
 *	   NOT_EQUAL	   1              none
 *	   FORMAT          1		  none
 *	   ADD		   2		  left   exp1
 *	   SUBTRACT	   2		  left
 *	   negate	   2		  right
 *	   positate	   2		  left
 *	   MULTIPLY	   3		  left   exp2
 *	   DIVIDE	   3		  left
 *	   POWER	   4	          left   exp3
 *
 * The operands in ICL are the following (exp4)
 *
 *	   INTEGER (constant)
 *	   REAL (constant)
 *	   TRUE
 *	   FALSE
 *	   STRING
 *	   name
 *	   OPEN_PAREN expression CLOSE PAREN
 *	   name OPEN_PAREN expression list CLOSE_PAREN (function call)
 *	   name OPEN_PAREN CLOSE_PAREN
 ******************************************************************************
 */

/*
 ******************************************************************************
 *									      *
 * 		T H E  D E C L A R A T I O N S  S E C T I O N 		      *
 *									      *
 ******************************************************************************
 */

%{
#include <stdio.h>
#include "icl.h"
#include "expr.h"
#include "control.h"
#include "interp.h"
#include "node.h"
extern value value_emptysymtab(void);				/* symtab.c */
extern value store_symbol (char *name, int type, node *n);	/* symtab.c */
extern node *compose_syntaxerr(char *message);			/* input.c */
extern int stack_prompt(char *newprompt);			/* input.c */
extern int unstack_prompt(void);				/* input.c */
extern int stack_string_input(char *s, int length);		/* input.c */
extern void unstack_input(void);				/* input.c */
extern int execute(void);					/* main.c */
extern node *todo;						/* interp.c */

/* 
 * Some systems seem to run out of ICL parse stack when parsing complicated
 * ICL procedures. Increase YYMAXDEPTH from its default (150 on most systems)
 * to cope
 */
#define YYMAXDEPTH 600

int yylex();
void yyerror(const char*);

char *errormessage = NULL; 		/* used by lex.c */
static int optparam;              /* Flag used to indicate that a PROCedure
				 * argument is optional. BKM 04/05/95
				 */
%}

/******************************************************************************
 *
 * This union becomes the type of the values that the parse can pass
 * around most of the time these are parse tree nodes.
 *
 ******************************************************************************
 */
%union
{
	double real;
	int integer;
	char *ptr;
	node *nod;
};

/******************************************************************************
 *
 * The syntax  'terminals'. These are things which are recognised by the 
 * lexical analyser.  YACC generates a header file called y.tab.h which 
 * contains each of these names as a #define with a unique number.
 * lex.l uses these to identify input tokens to YACC.
 *
 * Some of these terminals have a precedence and associativity, though this is
 * not used as these are captured in the grammar.
 *
 ******************************************************************************
 */

%left  EQUAL GREATER_THAN LESS_THAN GREATER_EQUAL LESS_EQUAL NOT_EQUAL 
%left  MULTIPLY DIVIDE ADD SUBTRACT
%left  FORMAT AND OR CONCAT
%left  COMMA SPACE QUOTE BADCHAR
%left  POWER
%right NEGATE
%right NOT

%term END HIDDEN PROC ENDPROC ENDLOOP ENDIF ELSEIF
%term REAL INTEGER IMMEDIATE BUILTIN ERROR
%term NAME WORD
%term STRING OPENSTRING QUALSTRING COMMENT
%term ICL_TRUE ICL_FALSE NEWLINE
%term OPEN_PAREN CLOSE_PAREN IF ELSE
%term FOR TO STEP WHILE LOOP BREAK
%term EXCEPTION ENDEXCEPTION
%term OPEN_SQBKT CLOSE_SQBKT

/******************************************************************************
 *
 * %type declartions to yacc(1) inform it of the type of the parse results for
 * all nonterminals and terminals
 *
 ******************************************************************************
 */
%type <ptr> NAME ERROR
%type <ptr> STRING OPENSTRING QUALSTRING comment COMMENT name
%type <nod> command_line imm_stmt assign_stmt command
%type <nod> exp_list expression exp0 exp1 exp2 exp3 exp4
%type <nod> commpara_list compara qualstring squal_list squal name_list args
%type <nod> REAL INTEGER
%type <nod> proccommand bproccommand procbody proc_line
%type <nod> statement_list  else_part elseif_prompt if_stmt if_part
%type <nod> loop_stmt loop_part step_part
%type <nod> exceptions exception comment_list

/******************************************************************************
 *
 * The %start directive specifies which grammar rule is used tostart parsing.
 *
 ******************************************************************************
 */
%start icl

%%
/*
 ******************************************************************************
 *									      *
 * 		T H E  P A T T E R N S / A C T I O N S  S E C T I O N 	      *
 *									      *
 ******************************************************************************
 */

icl
  :   { errormessage = ""; }
    command_line
      { return 2; }
  | /*  EMPTY */
  ;

command_line
  : imm_stmt NEWLINE
      { todo = $1; $$ = $1; }
  | assign_stmt NEWLINE
      { todo = $1; $$ = $1; }
  | command NEWLINE
      { todo = $1; $$ = $1; }
  | proccommand NEWLINE
      { $$ = $1; }
  | bproccommand NEWLINE
      { todo = $1; $$ = $1; }
  | IMMEDIATE
    command_line
      { todo = $2; execute (); }
    command_line
      { $$ = $4; }
  | comment NEWLINE
      { $$ = node_comment ((node *)0, $1); }
  | error
      { todo = compose_syntaxerr(strconcat(errormessage," in command")); }
    NEWLINE
      { yyerrok; $$ = NODENIL; yyclearin; return 2; }
  ;

command
  : name commpara_list comment
     { $$ = node_comment ( node1 (proc_call_interpret, 
	 		   value_string ($1), $2), $3); }
  | name comment
     { $$ = node_comment ( node1 (proc_call_interpret, 
				  value_string ($1), NODENIL), $2); }
  ;

bproccommand
  : BUILTIN name commpara_list comment
     { $$ = node_comment (node1 (builtin_call_interpret, 
				value_string ($2), $3), $4); }
  | BUILTIN name comment
     { $$ = node_comment (node1 (builtin_call_interpret, value_string ($2), 
				NODENIL), $3); } 
  ;

/*
 ******************************************************************************
 *									      *
 * 			P R O C  D E F I N I T I O N                          *
 *									      *
 ******************************************************************************
 */

proccommand
  : PROC name
      { stack_prompt (strconcat ($2, "> ")); optparam = 0;}
    procbody
      { store_symbol ($2, SYM_PROC, $4); /* MIGHT FAIL */ unstack_prompt ();
	$$= NODENIL; }
  | HIDDEN PROC name
      { stack_prompt (strconcat ($3, "> ")); }
    procbody
      { store_symbol ($3, SYM_HIDDEN_PROC, $5); /* MIGHT FAIL */ 
	unstack_prompt (); $$= NODENIL; }
  ;

procbody
  : args comment NEWLINE
    statement_list
    exceptions
    end_proc comment
      {
      $$ = node4 (procedure_interpret,
                  value_emptysymtab (),
                  node_comment ($1, $2),
                  $4,
                  node_comment ((node *)0, $7),
                  $5);
      }
  ;

end_proc
  : ENDPROC
  | END PROC
  ;
/*
 ******************************************************************************
 *									      *
 * 			S T A T E M E N T  L I S T S 			      *
 *									      *
 ******************************************************************************
 */

statement_list
  : /* empty */
      { $$ = NODENIL; }
  | proc_line NEWLINE statement_list 
      { $$ = ($3 ? ($1 ? node2 (line_list_interpret, noval, $1, $3) : $3)
			: $1); }
  | error
      { todo = compose_syntaxerr (strconcat(errormessage," in statement")); 
	execute (); }
    NEWLINE
      { yyerrok; yyclearin; }
    statement_list
      { $$ = $5; }
  ;

proc_line
  : assign_stmt
  | imm_stmt
  | if_stmt comment
      { $$ = node_comment ($1, $2); }
  | loop_stmt comment
      { $$ = node_comment ($1, $2); }
  | BREAK comment
      { $$ = node_comment (node0 (break_interpret, noval), $2); }
  | command
  | bproccommand
  | IMMEDIATE proc_line
      { todo = $2; execute (); $$ = NODENIL; }
  | comment
      { $$ = node_comment ((node *)0, $1); }
  ;

/*
 ******************************************************************************
 *									      *
 * 		T H E  I M M E D I A T E  S T A T E M E N T           	      *
 *									      *
 ******************************************************************************
 */

imm_stmt
  : EQUAL expression comment
      { $$ = node_comment (node1 (display_interpret, noval, $2), $3); }
  ;

/*
 ******************************************************************************
 *									      *
 * 		T H E  A S S I G N M E N T  S T A T E M E N T  		      *
 *									      *
 ******************************************************************************
 */

assign_stmt
  : name EQUAL expression comment 
      { $$ = node_comment ( node2 (assign_interpret, noval,
				   node0 (name_interpret, 
				   value_string (uppercase($1))), $3), $4);
      }
  ;

/*
 ******************************************************************************
 *									      *
 * 		T H E   I F   S T A T E M E N T  		      	      *
 *									      *
 ******************************************************************************
 */

if_stmt
  : IF
      { stack_prompt ("IF> "); }
    if_part end_if
       { unstack_prompt (); $$ = $3; } 
  ;

if_part
  : expression comment NEWLINE
    statement_list
    else_part
      { $$ = node3 (if_interpret, falseval, node_comment ($1, $2), $4, $5); }
  ;

else_part
  : ELSE IF elseif_prompt
      { $$ = $3; reset_integer_part(&($3->val),1); }
  | ELSEIF elseif_prompt
      { $$ = $2; reset_integer_part(&($2->val),1); }
  | ELSE comment NEWLINE
      { stack_prompt("ELSE> "); }
    statement_list
      { unstack_prompt(); $$ = node1 (else_interpret, 
				      value_string (strcopy ($2)), $5); }
  | /* empty */
      { $$ = NODENIL; }
  ;

elseif_prompt
  :   { stack_prompt("ELSE IF> "); }
    if_part
      { unstack_prompt(); $$ = $2; }
  ;

end_if
  : END IF
  | ENDIF
  ;

/*
 ******************************************************************************
 *									      *
 * 		T H E   L O O P  S T A T E M E N T  		      	      *
 *									      *
 ******************************************************************************
 */

loop_stmt
  : LOOP comment NEWLINE
      { stack_prompt ("LOOP> "); }
    statement_list
    end_loop
      { unstack_prompt ();
        $$ = node2 (loop_interpret, noval,
                    node1 (while_interpret, value_string ($2), (node *)0),
                           $5);
      }
  | LOOP loop_part end_loop
      { $$ = $2; }
  | loop_part end_loop
  ;

loop_part
  :  FOR name EQUAL expression TO expression step_part comment NEWLINE
       { stack_prompt ("FOR> "); }
     statement_list
       {
       unstack_prompt ();
       $$ = node2 (loop_interpret, noval, 
                   node4 (for_interpret, value_string (strcopy ($8)),
			  node0 (name_interpret, value_string ($2)),
			  $4,
			  $6,
			  $7),
                   $11);
       }
  | WHILE expression comment NEWLINE
      { stack_prompt ("WHILE> "); }
    statement_list
      {
      unstack_prompt ();
      $$ = node2 (loop_interpret, noval,
                  node1 (while_interpret, value_string (strcopy ($3)), $2),
                  $6);
      }
  ;

step_part
  : STEP expression
      { $$ = node1 (step_interpret, noval, $2); }
  | /* EMPTY */
      { $$ = node1 (step_interpret, noval, node_value(value_integer (1))); }
  ;

end_loop
  : END LOOP
  | ENDLOOP
  ;

comment
  : COMMENT
      { $$ = strcopy (yylval.ptr); }
  | /* EMPTY */
      { $$ = CHARNIL; }
  ;

/*
 ******************************************************************************
 *									      *
 * 		E X C E P T I O N S					      *
 *									      *
 ******************************************************************************
 */

exceptions
  : exceptions exception
      { $$ = ($1 == NODENIL) ? $2 : 
			node2 (exception_list_interpret, noval, $1, $2); }
  | /* empty */
      { $$ = NODENIL; }
  ;

exception
  : EXCEPTION name comment NEWLINE
      { stack_prompt ("EXCEPTION> "); }
    statement_list
    end_exception {unstack_prompt ();} comment NEWLINE comment_list
      {
      $$ = node4 (exception_interpret, value_string ($2),
		  node_comment ((node *)0, $3), $6,
		  node_comment ((node *)0, $9), $11);
      }
  ;

comment_list
  : /* empty */
      { $$ = NODENIL; }
  | comment NEWLINE comment_list 
      { $$ = ($3 ? ($1 ? node2 (line_list_interpret, noval, 
				node_comment((node *)0, $1), $3)
		       : $3)
		: node_comment((node *)0, $1)); }
  | error
      { todo = compose_syntaxerr (strconcat(errormessage," in statement")); 
	execute (); }
    NEWLINE
      { yyerrok; yyclearin; }
    comment_list
      { $$ = $5; }
  ;

end_exception
  : END EXCEPTION
  | ENDEXCEPTION
  ;

/*
 ******************************************************************************
 *									      *
 * 		E X P R E S S I O N S 					      *
 *									      *
 ******************************************************************************
 */

exp_list
  : exp_list COMMA expression
      { $$ = node2 (explist_interpret, noval, $1, $3); }
  | expression
  ;

expression
  : expression AND exp0
      { $$ = node2 (and_interpret,    value_integer (AND), $1, $3); }
  | expression OR exp0
      { $$ = node2 (or_interpret,     value_integer (OR), $1, $3); }
  | NOT expression
      { $$ = node1 (not_interpret,    value_integer (NOT), $2); }
  | expression CONCAT exp0
      { $$ = node2 (concat_interpret, value_integer (CONCAT), $1, $3); }
  | exp0
  ;

exp0
  : exp1 EQUAL exp1
      { $$ = node2 (reloperator_interpret, value_integer (EQUAL), $1, $3); }
  | exp1 LESS_THAN exp1
      { $$ = node2 (reloperator_interpret, value_integer (LESS_THAN), $1, $3); }
  | exp1 LESS_EQUAL exp1
      { $$ = node2 (reloperator_interpret, 
		    value_integer (LESS_EQUAL), $1, $3); }
  | exp1 GREATER_THAN exp1
      { $$ = node2 (reloperator_interpret, 
		    value_integer (GREATER_THAN), $1, $3); }
  | exp1 GREATER_EQUAL exp1 
      { $$ = node2 (reloperator_interpret, 
		    value_integer (GREATER_EQUAL), $1, $3); }
  | exp1 NOT_EQUAL exp1
      { $$ = node2 (reloperator_interpret,
		    value_integer (NOT_EQUAL), $1, $3); }
  | exp1 FORMAT exp1 FORMAT exp1
      { $$ = node3 (format_interpret, noval, $1, $3, $5); }
  | exp1 FORMAT exp1
      { $$ = node3 (format_interpret, noval, $1, $3, (node *)0); }
  | exp1 
  ;

exp1
  : exp1 ADD exp2
      { $$ = node2 (binaryoperator_interpret, value_integer (ADD), $1, $3); }
  | exp1 SUBTRACT exp2
      { $$ = node2 (binaryoperator_interpret,
		    value_integer (SUBTRACT), $1, $3); }
  | SUBTRACT exp2
      { $$ = node1 (unaryarith_interpret, value_integer (SUBTRACT),$2); }
  | ADD exp2
      { $$ = node1 (unaryarith_interpret, value_integer (ADD), $2); }
  | exp2
  ;

exp2
  : exp2 MULTIPLY exp3
      { $$ = node2 (binaryoperator_interpret,
		    value_integer (MULTIPLY), $1, $3); }
  | exp2 DIVIDE exp3
      { $$ = node2 (binaryoperator_interpret,
		    value_integer (DIVIDE), $1, $3); }
  | exp3
  ;

exp3
  : exp4 POWER exp3
      { $$ = node2 (binaryoperator_interpret,
		    value_integer (POWER), $1, $3); }
  | exp4
  ;

/*
 ******************************************************************************
 *									      *
 * 		E X P R E S S I O N   O P E R A N D S			      *
 *									      *
 ******************************************************************************
 */

exp4
  : INTEGER
      { $$ = node_value (value_integer (yylval.integer)); }

  | REAL
      { $$ = node_value (value_real (yylval.real)); }

  | ICL_TRUE
      { $$ = node0 (logical_interpret, trueval); }

  | ICL_FALSE
      { $$ = node0 (logical_interpret, falseval);}

  | STRING
      { $$ = node_value (value_string (yylval.ptr)); }

  | name
      { $$ = node0 (name_interpret, value_string (uppercase($1))); }

  | OPEN_PAREN expression CLOSE_PAREN
      { $$ = node1 (paren_interpret, noval, $2); }

  | name OPEN_PAREN exp_list CLOSE_PAREN
     { $$ = node2 (function_call_interpret, noval,
		   node0 (name_interpret, value_string ($1)),
		   $3);
     }

  | name OPEN_PAREN CLOSE_PAREN
     { $$ = node2 (function_call_interpret, noval,
		   node0 (name_interpret, value_string ($1)),
		   NODENIL);
     }
  ;

/*
 ******************************************************************************
 *									      *
 * 	F O R M A L  P A R A M E T E R ( N A M E )   L I S T 		      *
 *									      *
 ******************************************************************************
 */

args
  : name_list
  | /* empty */
      { $$ = NODENIL; }
  ;

name
  : NAME
      { $$ = strcopy ($1); if (optparam) optparam = 0;}
  | OPEN_SQBKT NAME
      { $$ = strcopy ($2); optparam = 1;}
  ;

name_list
  : name_list COMMA name
      { $$ = node2 (explist_interpret, noval,
                    $1,
                    node0 (optparam == 0 ? name_interpret
				: optarg_name_interpret,
			   value_string ($3)));
      }
  | name_list name
      { $$ = node2 (explist_interpret, noval,
                     $1,
                     node0 (optparam == 0 ? name_interpret
				: optarg_name_interpret,
			    value_string ($2)));
      }
  | name 
      { $$ = node0 (optparam == 0 ? name_interpret
				: optarg_name_interpret,
		    value_string ($1)); }
  | name_list COMMA name CLOSE_SQBKT
      { $$ = node2 (explist_interpret, noval,
                    $1,
                    node0 (optarg_name_interpret_end, value_string($3)));
      }
  | name_list name CLOSE_SQBKT
      { $$ = node2 (explist_interpret, noval,
                    $1,
                    node0 (optarg_name_interpret_end, value_string($2)));
      }
  | name CLOSE_SQBKT
      { $$ = node0 (optarg_name_interpret_end,
		    value_string ($1)); }

  ;

/*
 ******************************************************************************
 *									      *
 * 	 C O M M A N D  L I N E  A C T U A L  P A R A M E T E R  L I S T      *
 *									      *
 ******************************************************************************
 */

commpara_list
  : compara COMMA commpara_list
      { $$ = node2 (abbut_interpret, value_logical(TRUE), $1, $3); }
  | compara SPACE commpara_list
      { $$ = node2 (abbut_interpret, value_logical(TRUE), $1, $3); }
  | compara commpara_list
      { $$ = node2 (abbut_interpret, value_logical(FALSE), $1, $2); }
  | compara
  ;

compara
  : STRING
      { $$ = node_value (value_string (yylval.ptr)); }
  | OPENSTRING 
      { $$ = node0 (openstring_interpret, value_string (yylval.ptr)); }
  | OPEN_PAREN expression CLOSE_PAREN
      { $$ = node1 (paren_interpret, noval, $2); }
  | qualstring squal_list CLOSE_PAREN
      { $$ = node2(abbut_interpret, value_logical(FALSE),
		  node2 (abbut_interpret, value_logical(FALSE), $1, $2),
		  node0(openstring_interpret, value_string(yylval.ptr)) ); }
  ;

qualstring
  : QUALSTRING
      { $$ = node0(openstring_interpret, value_string(yylval.ptr)); }

squal_list
  :  squal squal_list
      { $$ = node2 (abbut_interpret, value_logical(FALSE), $1, $2) ; }
  |  squal
  ;

squal
  :  OPEN_PAREN expression CLOSE_PAREN
      { if( $2->interpret == name_interpret)
	    $2->interpret = name_interpret_nohds;
	 $$ = node1 (paren_interpret, noval, $2); }
  | OPENSTRING
      { $$ = node0 (openstring_interpret, value_string (yylval.ptr)); }

%%
/*
 ******************************************************************************
 * 
 *			T H E  C O D E  S E C T I O N
 *
 * A single function used to cause the parser to parse a string rather than an
 * input line.  It does this by calling the routine stack_string_input() (in 
 * input.c) that will stack the current input source and reset it to be the 
 * string provided.  Once the parse has completed, unstack_input() is used to 
 * reset the input source to what it was before the call to 
 * stack_string_input().
 *
 ******************************************************************************
 */
node 
*parse_expression (char *s, int length)
{
    char buf [ICL_BUFSIZE];
    sprintf (buf, "= %s\n", s);
    (void) stack_string_input (buf, (int) strlen (buf));
    (void) yyparse ();
    unstack_input ();
    return todo && todo->n_nodes == 1 ? todo->sub[0] : todo;
}
