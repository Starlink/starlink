\documentclass[twoside,11pt]{article}

% ? Specify used packages
% \usepackage{graphicx}        %  Use this one for final production.
% \usepackage[draft]{graphicx} %  Use this one for drafting.
% ? End of specify used packages

\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\newcommand{\stardoccategory}  {Starlink System Note}
\newcommand{\stardocinitials}  {SSN}
\newcommand{\stardocsource}    {ssn\stardocnumber}

% Variable part - replace [xxx] as appropriate.
\newcommand{\stardocnumber}    {73.2 (draft)}
\newcommand{\stardocauthors}   {Mark Taylor}
\newcommand{\stardocdate}      {13 August 2001}
\newcommand{\stardoctitle}     {EXTREME --- Handling extreme data sets}
\newcommand{\stardocabstract}  {
This package provides some utilities, background documentation,
and associated files
for adapting the Starlink Software Collection, and software which uses it, 
to handle very large data sets.
The principal focus of this is to move to use of 64 bits of address
space on 64-bit operating systems.

This document (SSN/73) is squarely aimed at the problem of adapting the 
Starlink Software Collection, and consequently focuses on 
the three operating systems (Solaris, Linux and Tru64) supported by Starlink,
the compiled languages Fortran 77 and ANSI C, 
and Starlink's somewhat idiosyncratic build mechanisms. 
However, some of the discussion here may be of interest or use to 
people who are considering the change from 32 to 64 bits for
software in other contexts.
}
% ? End of document identification
% -----------------------------------------------------------------------------

% +
%  Name:
%     ssn.tex
%
%  Purpose:
%     Template for Starlink System Note (SSN) documents.
%     Refer to SUN/199
%
%  Authors:
%     AJC: A.J.Chipperfield (Starlink, RAL)
%     BLY: M.J.Bly (Starlink, RAL)
%     PWD: Peter W. Draper (Starlink, Durham University)
%     MBT: Mark B. Taylor (Starlink)
%
%  History:
%     17-JAN-1996 (AJC):
%        Original with hypertext macros, based on MDL plain originals.
%     16-JUN-1997 (BLY):
%        Adapted for LaTeX2e.
%     13-AUG-1998 (PWD):
%        Converted for use with LaTeX2HTML version 98.2 and
%        Star2HTML version 1.3.
%     17-JAN-1999 (MBT):
%        Instantiated as SSN/73.
%     {Add further history here}
%
% -

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markboth{\stardocname}{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %begin{latexonly} and %end{latexonly} lines (used by 
%  LaTeX2HTML to signify text it shouldn't process).
%begin{latexonly}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

\newenvironment{latexonly}{}{}
\newcommand{\latex}[1]{#1}
\newcommand{\html}[1]{}
\newcommand{\latexhtml}[2]{#1}
\newcommand{\HTMLcode}[2][]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{\LaTeX2\texttt{HTML}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\renewcommand{\_}{\texttt{\symbol{95}}}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
%end{latexonly}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.


% Private macro definitions.

\newcommand{\xroutine}[1]{\htmlref{{\tt #1}}{#1}}
\newcommand{\xdofilter}[1]{\htmlref{{\tt do-#1}}{do-xxx}}
\newcommand{\file}[1]{{\tt #1}}
\newcommand{\routine}[1]{{\tt #1}}
\newcommand{\dofilter}[1]{{\tt do-#1}}
\newcommand{\cc}[1]{{\tt #1}}
\newcommand{\ditem}[1]{\item[#1]\mbox{}\\}
\newenvironment{squote}{\begin{quote}\begin{small}}{\end{small}\end{quote}}
\newcommand{\igap}{\html{\begin{quote}\end{quote}}}

%+
%  Name:
%     SST.TEX

%  Purpose:
%     Define LaTeX commands for laying out Starlink routine descriptions.

%  Language:
%     LaTeX

%  Type of Module:
%     LaTeX data file.

%  Description:
%     This file defines LaTeX commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by LaTeX and
%     by LaTeX2html. The contents of this file should be included in the
%     source prior to any statements that make of the sst commnds.

%  Notes:
%     The style file html.sty provided with LaTeX2html needs to be used.
%     This must be before this file.

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)
%     PDRAPER: P.W. Draper (Starlink - Durham University)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     8-DEC-1994 (PDRAPER):
%        Added support for simplified formatting using LaTeX2html.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

%-

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}
\newlength{\sstexampleslength}
\newlength{\sstexampleswidth}

%  Define a \tt font of the required size.
\latex{\newfont{\ssttt}{cmtt10 scaled 1095}}
\html{\newcommand{\ssttt}{\tt}}

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \newpage
   \label{#1}
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \setlength{\sstexampleslength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-5.0pt}
   \settowidth{\sstexampleswidth}{{\bf Examples:}}
   \addtolength{\sstexampleslength}{-\sstexampleswidth}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{}
   \begin{description}
      {\ssttt \item #1}
   \end{description}
}
% \newcommand{\sstusage}[1]{\item[Usage:] \mbox{}
% \\[1.3ex]{\raggedright \ssttt #1}}

%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\sloppy \item[Invocation:]\hspace{0.4em}{\tt #1}}
%\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{ \item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[2]{\sloppy \item{\ssttt #1} \mbox{} \\ #2 }
%\newcommand{\sstexamplesubsection}[2]{\sloppy
%\item[\parbox{\sstexampleslength}{\ssttt #1}] \mbox{} \vspace{1.0ex}
%\\ #2 }

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[#1:] \mbox{} \\[1.3ex] #2}
%\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}]
%\mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%% Now define html equivalents of those already set. These are used by
%  latex2html and are defined in the html.sty files.
\begin{htmlonly}

%  sstroutine.
   \newcommand{\sstroutine}[3]{
      \subsection{#1\xlabel{#1}-\label{#1}#2}
      \begin{description}
         #3
      \end{description}
   }

%  sstdescription
   \newcommand{\sstdescription}[1]{\item[Description:]
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstusage
   \newcommand{\sstusage}[1]{\item[Usage:]
      \begin{description}
         {\ssttt #1}
      \end{description}
      \\
   }

%  sstinvocation
   \newcommand{\sstinvocation}[1]{\item[Invocation:]
      \begin{description}
         {\ssttt #1}
      \end{description}
      \\
   }

%  sstarguments
   \newcommand{\sstarguments}[1]{
      \item[Arguments:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstreturnedvalue
   \newcommand{\sstreturnedvalue}[1]{
      \item[Returned Value:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstparameters
   \newcommand{\sstparameters}[1]{
      \item[Parameters:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstexamples
   \newcommand{\sstexamples}[1]{
      \item[Examples:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstsubsection
   \newcommand{\sstsubsection}[1]{\item[{#1}]}

%  sstexamplesubsection
   \newcommand{\sstexamplesubsection}[2]{\item[{\ssttt #1}] #2}

%  sstnotes
   \newcommand{\sstnotes}[1]{\item[Notes:] #1 }

%  sstdiytopic
   \newcommand{\sstdiytopic}[2]{\item[{#1}] #2 }

%  sstimplementationstatus
   \newcommand{\sstimplementationstatus}[1]{
      \item[Implementation Status:] #1
   }

%  sstitemlist
   \newcommand{\sstitemlist}[1]{
      \begin{itemize}
         #1
      \end{itemize}
      \\
   }
%  sstitem
   \newcommand{\sstitem}{\item}

\end{htmlonly}

%  End of "sst.tex" layout definitions.


% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / \textsc{Rutherford Appleton Laboratory} \hfill \textbf{\stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Large\textbf{\stardoctitle}}
   \end{center}
   \vspace{5mm}

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\textbf{Abstract}}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1> \end{rawhtml}
      \stardoctitle
   \begin{rawhtml} </H1> <HR> \end{rawhtml}

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory\ \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC / Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://www.starlink.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://www.starlink.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents. 
%  ================================
%  Add table of contents header and a navigation button to return to this 
%  point in the document (this should always go before the abstract \section). 
  \label{stardoccontents}
  \begin{rawhtml} 
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}
% ? End of new section for abstract

\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%  ==================
\stardocabstract
% ? End of document abstract
% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
  \newpage
  \begin{latexonly}
    \setlength{\parskip}{0mm}
    \tableofcontents
    \setlength{\parskip}{\medskipamount}
    \markboth{\stardocname}{\stardocname}
  \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------
\cleardoublepage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}



% ? Main text

\section{Introduction}

The Extreme Data Set project is intended to allow processing of ``unusually''
large data sets by Starlink software, 
although the sizes for which special measures
are required will become less and less unusual as time goes on.
The principal underlying problem is that as images get larger,
32 bits are no longer enough to index into an image.
The largest integer that can be stored in 32 bits 
is approximately $4 \times 10^9$ (unsigned) or $2 \times 10^9$ (signed).
If the operating system itself uses unsigned 32 bit pointers to 
address bytes
in memory, this means that it is impossible to map into memory 
an image of more
than 4Gbyte or, say, two images of half that size. 
This could correspond to, for instance, an input and an output image
simultaneously mapped each with an HDS type of \_REAL and 
size of 23k pixels square.

For this sort of work therefore an operating system with 64-bit 
pointers is required.

For the systems supported by
Starlink this currently means that Compaq Tru64 Unix can be used,
as can Solaris running in 64-bit mode.  
On appropriate hardware the Solaris kernel 
may be compiled for 32 bit or 64 bit mode;
but almost\footnote{
   There can be trouble with applications which use 
   \file{libkvm} or access \file{/proc}.}
all binaries which run on the 32-bit version
will run equally well on the 64-bit version, 
so that reconfiguring a system from 32-bit to 64-bit should be
fairly painless from a software point of view.
You can tell if your Solaris kernel is 64-bit 
by using the \file{isainfo -v} command; on a 64-bit system the
following response will be given
\begin{squote}
\begin{verbatim}
% isainfo -v
64-bit sparcv9 applications
32-bit sparc applications
\end{verbatim}
\end{squote}

User code will run up against similar problems to those faced by
the operating system when coping with large images.
It is often necessary to count the pixels, or the bytes,
in an image, and this is typically done using a Fortran INTEGER
or a C \cc{int}.  These are normally signed 32-bit values, with
a maximum value of about $2 \times 10^9$; the pixel count of a 
47k $\times$ 47k image, or the byte count of a 16k $\times$ 16k 
\_DOUBLE image, will overflow this limit.

Another common requirement is holding a pointer 
to allocated memory, which has ultimately been 
acquired from a C routine such as \cc{malloc}, 
in a variable.
In C this will be taken care of automatically because the compiler
ensures that pointer types are long enough to hold memory addresses.
In Fortran 77 however there is no pointer type so that INTEGERs, which are
normally 32 bits, have to be used.
The solution to this, explained in \xref{SUN/209}{sun209}{pointers},
is to use the \xref{CNF\_PVAL}{sun209}{CNF\_PVAL} function.

The issues addressed in this document apply to user programs which link
against Starlink libraries as well as to the code which forms the USSC;
if the USSC has been built for a 64-bit system, then user code 
which uses its libraries will need to be modified at the 
source level in order to work.
Depending on the complexity of the code, it may be easier to do this
with a few manual adjustments than by using the automatic 
tools supplied with the EXTREME package.  
The discussion here should be of use in any case.

This package provides some tools and instructions for 
software maintainers to use 
in modifying their source code to take advantage of a 64-bit environment.
The rest of this document is organised as follows:
\begin{description}
%
\item[Section \ref{sec:changeover}]
discusses the general strategy for moving to provide 64-bit support.
%
\item[Section \ref{sec:modificienda}]
describes the changes which have to be made to each package at 
source level to achieve this.
%
\item[Section \ref{sec:tools}]
gives an overview of the tools provided by this package to help automate 
the source code modification.
%
\item[Section \ref{sec:cribsheet}]
gives a detailed step-by-step set of instructions which can be followed 
to carry out the changes.
%
\item[Appendix \ref{sec:commands}]
gives a detailed listing of the behaviour of each of the tools provided.
%
\end{description}
It is suggested that you read the first four sections
for an understanding of why and how the various changes need to be 
made, and then follow the steps in section \ref{sec:cribsheet}
if you have a package which you need to modify.
Appendix \ref{sec:commands} will be useful for reference or details
of the exact behaviour of the tools.


\section{Changeover to 64-bit systems\label{sec:changeover}}

In general, it is not possible to modify packages to deal with large
images independently of each other;
before changing a package to use 64 bits, it is necessary 
that all the packages on which it depends are 64-bit compatible.
Certain packages, which are used only at a command-line level, 
may not need changes to the code, but in general 
a package which provides a library 
against which other code is to link must be modified,
since the public interfaces of the routines,
specifically the types of integer arguments, will change. 
Additionally, in the case of Solaris,
32-bit and 64-bit object types cannot be mixed by the link loader.

At some point in the future, it may be that support for 32-bit systems
is dropped, but at the moment this is undesirable, since 
Solaris systems running 32-bit kernels would be incapable of running
code compiled for 64 bits.  
Older Suns (before SPARC v9) cannot be made to run the 64-bit kernels.

For these reasons, the transfer to 64 bits will be approached
effectively as ports to new systems, which will be supported
alongside the existing ones.  All Starlink packages should
therefore come to 
include support for two new values of the \file{makefile}/\file{mk}
SYSTEM variable: ``alpha\_OSF1\_64'' and ``sun4\_Solaris\_64''.



\section{Modifications to code\label{sec:modificienda}}

Making Starlink packages able to run in a 64-bit environment and 
handle appropriately large data sets requires changes to the source
code of each package.
For packages like \xref{HDS}{sun92}{}, 
which get their hands dirty with data structures on disk,
extensive changes will be required.
Most packages however can hopefully be fixed by making some more-or-less
automatic changes to the source code.
These changes boil down to making sure that Fortran pointers 
can address any allocated memory,
and making sure that non-pointer integers in Fortran and C 
have enough bits to hold sufficiently large numbers.

Because of the difficulty of distinguishing, in any automatic fashion,
variables which may 
need to hold big numbers from those which will not,
the recommended approach is to change the type of {\em all\/} 
integer variables to a 64-bit type in 64-bit environments.
There are undesirable consequences of this,
the main one being that 
the HDS type \_INTEGER becomes, as far as the user of HDS is concerned,
a 64-bit type;
it will still be stored on disk in 32 bits, but it is in any case a
function of HDS to shield the user from the disk representation
of defined types.
Where images are mapped with \_INTEGER type in the new system therefore, 
they will take up twice as much space as they need to in memory,
and the process of mapping and unmapping them can be expected to be slower.
There is nothing much to be done about this;
fortunately, \_INTEGER should not be a very common type for
storing large data arrays in an NDF.

Once the increase in integer size has been made 
globally to the source code in a package,
it would be a possibility 
to identify variables which do not need the extra size
and change their declarations (and other parts of the code which depend
on these) back to the normal integer types.
In most cases such retrochanges will not be worthwhile, 
but they could be appropriate in either of the following situations:
\begin{itemize}
\item
The change has broken something which is easier to fix by returning to 
a normal integer size than by other means
\item
The change results in significant overuse of resources, 
and returning to a normal
integer size will not cause too many problems.
\end{itemize}

The rest of this section describes the four main sets of changes
which need to be made to each package.

\subsection{Pointer references in Fortran 77}

As explained in \xref{SUN/209}{sun209}{pointers},
whenever the \%VAL Fortran compiler directive 
is used to pass the value of registered allocated
memory to a subroutine, its argument should be wrapped in a call
to \xref{CNF\_PVAL}{sun209}{CNF\_PVAL}.  This effectively allows
a 32-bit integer to address memory in a 64-bit address space.
This call could in principle be avoided 
when long integers are being used in Fortran
but it is still 
necessary where Fortran is written using normal integers in a
64-bit environment,
so these calls must be incorporated.
Since this change is less problematic than the move to large integers
and is mostly independent of it,
it is possible and advisable to make this
change to all code and test it before converting the normal integer types
as described in section \ref{sec:fint}.  

As well as the calls to CNF\_PVAL themselves, 
the header file \file{CNF\_PAR} needs to be included
in affected source files to provide the declaration of the CNF\_PVAL function.

The main pitfall of making these modifications is
wrapping the argument of a \%VAL in a CNF\_PVAL call when it ought
not to be so wrapped.
CNF\_PVAL should {\em only\/} be applied to registered pointers.
If your Fortran code uses pointers which are got from C without 
being registered with CNF, you'll need to address this in the C code 
as described in \xref{SUN/209}{sun209}{pointers}.
More commonly, you may have \%VAL invocations which are not
applied to pointers at all --- for instance when passing 
the lengths of character variables as trailing arguments 
which sometimes needs to be done when the compiler doesn't know that
it's passing a character variable.  In this case the \%VAL 
invocation should be left alone and no call to CNF\_PVAL inserted.
In general, it is impossible to spot all such non-pointer uses
of \%VAL automatically.  However, if \%VAL is applied to a constant,
or a small integer, then it should be left alone.

The program \xroutine{inscnf}, and the corresponding driver script 
\xdofilter{inscnf}, is supplied for inserting CNF\_PVALs
in the right places.  It wraps {\em all\/} arguments of \%VAL 
in calls to CNF\_PVAL, but emits warnings for those which look like
they may not be pointers.
It is described further in
\latexhtml{appendix \ref{sec:commands}}{\htmlref{the appendix}{inscnf}}.

\subsection{Enlarging integer type in Fortran 77\label{sec:fint}}


In Fortran 77 there is no (even slightly) portable way of declaring
an integer to be of a configurable length. 
Therefore all variables currently declared as `INTEGER' 
should be changed instead to type `INTEGER*8'. 
This is not standard Fortran 77, but it is widely understood by compilers.
This should not be interpreted (by a human) as an indication that exactly
eight bytes are required, but as an indication that 
the variable in question needs to be
long enough to hold a large number.
At compile time, typically on 64-bit systems the code will be compiled
as it stands, while on 32-bit systems a simple \file{sed} command or similar
can preprocess the source code before it is fed to the compiler,
under makefile control (see section \ref{sec:makefile}).

Having done this, the following issues may need to be addressed.
\begin{description}
%
\ditem{External libraries}
In Fortran, the actual arguments used in a subroutine/function
call must be of the same type as the formal arguments declared
in the routine itself, since arguments are passed by address.
Thus if you change the type of integers passed to a subroutine,
you have to change the type of the integers declared in the subroutine too.
It is therefore necessary either to convert any called subroutines
to using the new integer type (at least as far as their arguments go), 
or to ensure that any calls to these routines use variables of 
the old integer type.
Thus a package can only be successfully converted to large integers
and built once all the libraries against which it links have been 
similarly converted.  The Starlink libraries will therefore have to
be done before applications packages.
If a program uses an external library which is not part of the USSC,
then either the library will have to be converted in the same way,
or the affected calls will have to be written using 
variables specially declared as the normal INTEGER type.
\html{\begin{squote}\end{squote}}
%
\ditem{Literal integer constants as arguments}
If there are any calls to functions or subroutines in the converted 
code which have literal integer constants as actual arguments,
these will need to be replaced with expressions of the right type.
There is no way of specifying the length of a literal integer constant
in Fortran, so you must ensure that the expression has the correct type
in some other way.
The recommended method for doing this is to use a variable for the
purpose, which may be assigned using a PARAMETER statement.
Thus
\begin{squote}
\begin{verbatim}
      CALL SUB( 5, STATUS )
\end{verbatim}
\end{squote}
must be changed to something like
\begin{squote}
\begin{verbatim}
      INTEGER * 8 INT__5
      PARAMETER ( INT__5 = 5 )
        ...
      CALL SUB( INT__5, STATUS )
\end{verbatim}
\end{squote}
Other methods of getting around this are possible,
for instance using statement functions.
The include files \file{EXT\_PAR}, which contains a set of predefined
integer constants, and \file{EXT\_DEC} and \file{EXT\_DEF},
which define statement functions in the same way as the
\xref{PRIMDAT}{sun39}{} package, are provided with the EXTREME 
package by way of example of alternative strategies.
\html{\begin{squote}\end{squote}}
%
\ditem{Intrinsic functions}
Calls to standard Fortran intrinsic functions should take care of themselves,
as long as the generic name is used rather than the specific one
(e.g. you should use ABS instead of IABS),
since they adapt themselves automatically to the type of their argument.  
Use of generic names is generally good practice anyway;
the only time it is necessary to supply the specific name is 
when passing an intrinsic function itself as an actual argument
to a procedure, which is pretty rare.
The only intrinsic functions in standard Fortran 77 which have 
INTEGER-specific names are IABS, ISIGN, IDIM, MAX0, AMAX0, MIN0 and AMIN0.

There are some non-standard intrinsic functions which require INTEGER
arguments, and will cause trouble if they have INTEGER*8 arguments.
These are mostly system-specific ones, such as GETARG,
and are likely only to be used in fairly low level code.

A related problem is using a call to an intrinsic function with 
an integer return type as an actual argument to a function.
Since for most functions the return type is the same as the argument,
this will, again, take care of itself.  However, for the few
intrinsic functions which return integer regardless of the type of
the argument (LEN, INDEX), the return value will have to be converted to
the correct type as if it were an integer literal, 
by assigning to an intermediate variable or using a statement function.
\html{\begin{squote}\end{squote}}
%
\ditem{Storage association}
The Fortran 77 standard does not state how much storage is used by
an INTEGER, but does state that it should be the same amount as that
used by REALs and LOGICALs.
Converting all INTEGERs to INTEGER*8s will
normally have the effect that this is no longer the case.
Thus code which relies on this, for instance by using COMMON blocks or
EQUIVALENCE statements to address the same memory as both INTEGER and REAL,
will break.  
Such practices are, as you might expect, deprecated by the 
\xref{Starlink Application Programming Standard}{sgp16}{},
but there may be instances of them lurking about.

Similarly, code which makes the assumption that four elements of
a CHARACTER array correspond to each INTEGER will need changing.
%
\ditem{Storage alignment}
The compiler documentation indicates that
64-bit data types on Sun and Alpha systems should be aligned on 
64-bit boundaries for performance reasons.
Normally this is taken care of automatically by the compiler, 
but in COMMON blocks (or EQUIVALENCE?) the address of a 
variable is determined by the source code, so that the compiler
is not free to move it around (the start of a COMMON block is
always aligned to the largest boundary, 64 bits).
Thus the following code:
\begin{squote}
\begin{verbatim}
      REAL        XX, YY
      INTEGER * 8 IX, IY
      COMMON /BLOCK/ XX, IX, YY, IY
\end{verbatim}
\end{squote}
which would align everything (happily) on 32-bit boundaries if IX, IY
were INTEGER*4s, will be forced to align the 64-bit IX on a 32-bit
boundary.
The compilers will warn about this behaviour.
I believe that the result will be slower, rather than incorrect,
executables,
but such occurrences should ideally be fixed.
\html{\begin{squote}\end{squote}}
%
\ditem{IMPLICIT variable declarations}
It is highly desirable in Fortran, and usual in Starlink code, to use
the ``IMPLICIT NONE'' declaration, so that all variables have to be
explicitly declared before use.
If this is not done, and integer variables are used without explicit
declaration, they will not be converted to INTEGER*8.
It would be possible to fix this by redeclaring IMPLICIT INTEGER
statements as IMPLICIT INTEGER*8 and/or adding an IMPLICIT INTEGER*8 (I-N), 
but to make the job easier for
the makefile in editing the source code, it is better to place
an ``IMPLICIT NONE'' statement in every source code module, and
make explicit INTEGER*8 declarations for all integers.
\html{\begin{squote}\end{squote}}
%
\ditem{I/O return values}
A few Fortran I/O statements have specifiers which require the name
of an INTEGER variable.  In standard Fortran 77 these are 
IOSTAT in all I/O statements, and 
NUMBER, RECL and NEXTREC in the INQUIRE statement.
Particular compilers often provide a whole lot more, but these
should hopefully not be much used in Starlink code.
So there may be a problem with a statement like
\begin{squote}
\begin{verbatim}
      CLOSE( UNIT = 99, IOSTAT = STVAL )
\end{verbatim}
\end{squote}
if the variable STVAL is now declared INTEGER*8 rather than INTEGER.
Of the supported systems, Tru64 and Solaris seem to handle 
INTEGER*8 variables used for this purpose without complaint.
Linux with g77 0.5.24 may fail to compile although (a) it seems to
be OK if you compile with {\tt -O}, and (b) this is reportedly
fixed at g77 0.5.25.  So it's probably all right to leave these cases.
%
\end{description}

The program \xroutine{frepint}, and the corresponding driver script
\xdofilter{frepint}, is provided for changing 
INTEGER declarations to INTEGER*8.
Details of which of the above constructs it fixes, and which it
warns about, are given in 
\latexhtml{appendix \ref{sec:commands}}{\htmlref{the appendix}{frepint}}.


\subsection{Enlarging integer type in C\label{sec:cint}}

All references to the type \cc{int} in C code should be changed to 
\cc{INT\_BIG}.  This is a reference to a macro which can be defined
in a system-dependent header file or on the compiler command line 
(and hence typically in the \file{mk} environment variable CFLAGS).  
For a 32-bit build it would normally be defined at build time as 
\cc{int} and for a 64-bit build as \cc{long}.
As well as declarations of variables and functions, this applies
to almost any other syntactically significant occurrence of the
identifier \cc{int}, for instance casts and arguments of \cc{sizeof}.
References to the types \cc{short~int} and \cc{long~int},
which are just synonyms for \cc{short} and \cc{long} respectively,
should not be changed.  Type \cc{unsigned~INT\_BIG} 
(or, redundantly, \cc{signed~INT\_BIG}) may be used.
There are some places where an \cc{int} declaration is implicit,
and here an \cc{INT\_BIG} must be inserted.

As regards calling functions from external libraries,
the approach described in section \ref{sec:fint} of 
recoding all the functions in the library will of course work in C
as well as in Fortran.
However, this is not always necessary.
If the function's ANSI C-style declaration (prototype) is in scope when 
the function is called,
the compiler will normally arrange for conversion
of each actual argument to the declared type of
the corresponding formal argument in the declaration 
before passing it by value.
Hence the following code
\begin{squote}
\begin{verbatim}
int add( int a, int b );
INT_BIG i, j;
add( i, j );
\end{verbatim}
\end{squote}
is correct whatever integral type \cc{INT\_BIG} is defined as, 
since \cc{i} and \cc{j} are converted to type \cc{int}
before \cc{add()} sees them.
If the prototype of \cc{add()} were not in scope however,
the conversion would not take place and the code would be
in error.\footnote{
   In fact, the standard says simply that the effect of the call is
   undefined in this case.  Furthermore, it seems that the three
   currently supported systems handle these cases without
   any undesirable behaviour; presumably the compilers are written
   such that all arguments are passed in 64 bits or in registers.
   But such code is still not correct.
}
The lesson is to make sure that header files are
included.
Of course this relies on having ANSI C-style function prototypes;
if old-style function declarations are used then no argument type
conversions are made.  For code which uses old-style function 
declarations the best thing is to convert it, 
or at least a corresponding header file, 
to ANSI C style.

However this does not solve all problems.
Where a function has a variable argument list
(as declared in the prototype using ellipsis `\cc{...}'
and handled in the function using the \file{stdarg.h} macros), 
the function prototype
is not able to specify the types of all arguments,
and so the type of the actual argument must match the type of
the formal argument for correctness.  If it is impractical
to recode the function (as in the case of \cc{printf}),
the best solution is to cast the variable arguments to the type
which is expected where the function is called.

A more difficult problem is when the address of an argument is
passed so that the contents of that address can be changed by
the function.  In this case if the called function has a
different idea of the length of the object being pointed to
it will write to the wrong amount of memory, possibly overwriting
other data.  Consider this function:
\begin{squote}
\begin{verbatim}
   void zero( int *a ) { 
      *a = 0; 
   }
\end{verbatim}
\end{squote}
and this code:
\begin{squote}
\begin{verbatim}
   INT_BIG x;
   zero( &x );
\end{verbatim}
\end{squote}
If \cc{INT\_BIG} is a 64 bit type and \cc{int} is 32 bits
then only half the bits in the variable \cc{x} will be zeroed by this call.
If the function declaration is in scope when the call is made,
the compiler will issue a pointer mismatch warning about this sort of thing; 
again, make sure that the appropriate header files are included.
Again, in the case of variable argument lists, the compiler can't spot it.

To summarise, external functions should be declared before use by
including the appropriate header files.  If this is done, then the only
problems associated with calling functions which have not been
converted to use \cc{INT\_BIG} instead of \cc{int} should be:
\begin{description}
%
\item[INT\_BIG in variable part of argument list:]
A modified caller of an unmodified function should explicitly cast
an \cc{INT\_BIG} argument in the variable (\cc{...}) part of the argument
list.  
Normally the cast should be to \cc{int}, but it may be possible,
as with \cc{printf}, to cast to \cc{long} and indicate to the called
function that this has been done.
See the \cc{printf} example below.
A modified function which may get called by unmodified code
should expect arguments of type \cc{int}
(i.e.\ should call the \cc{va\_arg} macro with a second argument
of \cc{int} instead of \cc{INT\_BIG}).
%
\item[Pointer to INT\_BIG variable passed:]
A modified caller of an unmodified function will have to declare
a local variable of type \cc{int} and exchange values between it
and the \cc{INT\_BIG} before, and possibly after, the call.
See the \cc{scanf} example below.
A modified function which may get called by unmodified code 
will have to declare pointer arguments as pointers to a given fixed
type (presumably \cc{int}), not to \cc{INT\_BIG}.
\item[Overflow:]
If an \cc{INT\_BIG} value which is too large to be an \cc{int}
is passed to a variable which is an \cc{int}, arithmetic overflow will
occur when C tries to do the type conversion according to the function
declaration.
No warning is issued by the Solaris or Tru64 C runtime systems about
such overflows.
\end{description}


External libraries which code may have to link against
can be split into a few categories:
\begin{description}
%
\ditem{Starlink libraries}
As with Fortran, the plan is for Starlink libraries to get converted
to use \cc{INT\_BIG}
before code which uses them (although for C code calling C libraries
this is not so necessary as with Fortran when functions are pre-declared
using header files).
\html{\begin{squote}\end{squote}}
%
\ditem{Blocks of source code not to be converted}
It may not be a good idea to do \cc{INT\_BIG} conversion to
large bodies of non-Starlink code used by the USSC; Perl and Tcl
spring to mind.  
If there is function-level access to these packages,
some recoding may be required as above.
\html{\begin{squote}\end{squote}}
%
\ditem{The C standard library}
The functions of the C standard library are no different from any
other unconverted external library, but since their use is
common, it is discussed in detail here.
Most of the functions in the standard library will be handled
adequately as described above by including the appropriate header files,
since they do not have \cc{int~*} arguments or variable argument lists.
The only exceptions in the standard library are as follows:
\begin{description}
%
\ditem{\cc{frexp}}
The second argument of the mathematical function \cc{frexp} is declared
\cc{int *}, so a pointer to \cc{int} and not to \cc{INT\_BIG} must be passed.
\html{\begin{squote}\end{squote}}
%
\ditem{\cc{bsearch}, \cc{qsort}}
Both these functions take as arguments a comparison function 
declared \cc{int (*)(void *, void *)},
i.e.\ a function rerturning \cc{int}.
Although the calls to \cc{bsearch} and \cc{qsort} do not need to be
modified therefore, the function passed to them must be of the right
type, and not modified to be of type \cc{INT\_BIG (*)(void *, void *)}.
\html{\begin{squote}\end{squote}}
%
\ditem{\cc{signal}}
The second argument of \cc{signal} is declared as \cc{void (*)(int)}.
Calls to \cc{signal} do not need to be modified, but functions 
passed to it ought to be declared 
functions of \cc{int} and not of \cc{INT\_BIG}.
\html{\begin{squote}\end{squote}}
%
\ditem{\cc{printf}, \cc{scanf}}
The functions which use format strings and variable argument lists,
\cc{printf}, \cc{fprintf}, \cc{sprintf} and 
\cc{scanf}, \cc{fscanf}, \cc{sscanf},
require careful scrutiny.
For \cc{printf} and friends 
any of the format specifiers \cc{cdiouxX*}\footnote{
   Note the inclusion of the \cc{c} format specifier in this list.
   Although the corresponding argument will typically be of type \cc{char},
   it is promoted to \cc{int} by the usual mechanism before being 
   passed to \cc{printf}.  If the type of the actual argument is
   of type \cc{char} and not type \cc{INT\_BIG} of course, no change 
   will be required here.
}
indicate that the corresponding argument should be an \cc{int},
and the \cc{n} specifier indicates a pointer to \cc{int}.
For \cc{scanf} and friends, any of the specifiers \cc{diouxXn} indicate
pointer to \cc{int}.
If any of the actual arguments in the call is of type \cc{INT\_BIG} 
(or \cc{INT\_BIG~*}) when it should be of type \cc{int} (or \cc{int~*}),
then the calling code needs to be changed.

In the case of \cc{int} arguments, if the actual argument
might be too large to be
represented in an \cc{int}, then an \cc{l} should be inserted 
after the `{\tt\%}' sign to 
indicate that a \cc{long} argument is being supplied and the 
corresponding argument should be cast to \cc{long}.  If it will definitely
be possible to store the value in an \cc{int} then the format specifier
may be left alone and the argument cast to \cc{int}.
Arguments passed using the \cc{c} or \cc{*} specifiers should be cast 
to \cc{int}, and not modified with an \cc{l} character.
In the case of \cc{int~*} arguments, intermediate variables have to be used.

Here is an example.  If after simple substitution of \cc{INT\_BIG} for
\cc{int} a piece of code reads:
\begin{squote}
\begin{verbatim}
   extern INT_BIG triple( INT_BIG x );
   INT_BIG i, j;
   char c;
   scanf( "%i %c", &i, &c );
   j = triple( i );
   printf( "Integer tripled is %i; Character is '%c'\n", j, c );
\end{verbatim}
\end{squote}
then the \cc{scanf} call must be replaced by something like this: 
\begin{squote}
\begin{verbatim}
   {  
      long tmp; 
      scanf( "%li %c", &tmp, &c ); 
      i = tmp; 
   }
\end{verbatim}
\end{squote}
and the \cc{printf} call by something like this:
\begin{squote}
\begin{verbatim}
   printf( "Integer tripled is %li; Character is '%c'\n", (long) j, c );
\end{verbatim}
\end{squote}
\html{\begin{squote}\end{squote}}
%
\ditem{Other external libraries}
If your code links to any other external libraries
which cannot, or will not, be converted to use \cc{INT\_BIG}s,
some recoding of the calls may be required as above.
The most common case of this is use of the various system libraries
whose functions are declared in header files in or under \file{/usr/include}.
\cc{waitpid()}, \cc{signal()} and \cc{pipe()} are a few of the culprits.
\end{description}
%
\end{description}


There are a few other issues which arise from replacing \cc{int} type
with \cc{INT\_BIG}:
\begin{description}
%
\ditem{Integer constants from limits.h}
Where an \cc{int} is compared against one of the values 
\cc{INT\_MAX}, \cc{INT\_MIN} and \cc{UINT\_MAX} 
defined in the system header file \file{limits.h},
an \cc{INT\_BIG} should be compared against one of the corresponding
macros \cc{INT\_BIG\_MAX} etc.
These macros are defined in the header file \file{extreme.h}. 
\html{\begin{squote}\end{squote}}
%
\ditem{Implicit int declarations}
There are several places in C (macros and typedefs apart) 
in which an identifier can be declared
as an \cc{int} without the \cc{int} reserved word appearing.
For example, in the code:
\begin{squote}
\begin{verbatim}
sub( x ) {
   static y;
   signed z;
}
\end{verbatim}
\end{squote}
the symbols \cc{sub}, \cc{x}, \cc{y} and \cc{z} all have type \cc{int}
so that the converted code should read
\begin{squote}
\begin{verbatim}
INT_BIG sub( INT_BIG x ) {
   static INT_BIG y;
   signed INT_BIG z;
}
\end{verbatim}
\end{squote}
%
\ditem{int used for Fortran LOGICAL}
Where a C \cc{int} is used to represent a LOGICAL variable in Fortran,
it should not be replaced by \cc{INT\_BIG}.
This is only likely to arise in certain low-level code 
(e.g.\ \xref{HDS}{sun92}{} and \xref{CNF}{sun209}{}) 
which does direct interfacing with Fortran.
Under normal circumstances code should use the macros
F77\_LOGICAL\_TYPE and F77\_INTEGER\_TYPE defined in the 
CNF header file \file{cnf.h}.
%
\end{description}

The program \xroutine{crepint}, and the corresponding driver script
\xdofilter{crepint}, is provided for making some of these changes.  
It replaces all references to \cc{int} type, with a few exceptions,
by \cc{INT\_BIG} type, modifies explicit declarations which are 
implicitly of type \cc{int}, 
and warns about constructs which might need further attention.
Full details of which of the above constructs it fixes, and which it
warns about, are given in
\latexhtml{appendix \ref{sec:commands}}{\htmlref{the appendix}{crepint}}.

A construction which \routine{crepint} misses altogether is finding
implicit declarations in function prototypes, which are implicitly
of type \cc{int}.
These can be spotted by suitable use of the C compilers.
Given a file \file{sub.c} which reads:
\begin{squote}
\begin{verbatim}
sub( x ) {
   return x;
}
\end{verbatim}
\end{squote}
then running gcc with the {\tt -Wimplicit} flag generates warnings for
such declarations:
\begin{squote}
\begin{verbatim}
% gcc -fsyntax-only -Wimplicit-function-declaration -Wstrict-prototypes sub.c
sub.c:1: warning: return-type defaults to `int'
sub.c:1: warning: function declaration isn't a prototype
\end{verbatim}
\end{squote}
The {\tt -proto} flag of Tru64 Unix's C compiler is a little more
effort to use, but produces more concise output.  Running
\begin{squote}
\begin{verbatim}
% cc -protois -noobject sub.c
\end{verbatim}
\end{squote}
will produce a file called \file{sub.H} which reads:
\begin{squote}
\begin{verbatim}
extern int sub(int x);
\end{verbatim}
\end{squote}
Occurrences of \cc{int} in the output file \file{sub.H} should be 
changed to read \cc{INT\_BIG} wherever the function is declared or
defined in the source code (typically in a source file and maybe a 
header file), so that \file{sub.c} should
end up reading:
\begin{squote}
\begin{verbatim}
INT_BIG sub( INT_BIG x ) {
   return x;
}
\end{verbatim}
\end{squote}
By running
\begin{squote}
\begin{verbatim}
% cc -protois -noobject -DINT_BIG=long *.c
\end{verbatim}
\end{squote}
and attending to any \cc{int} declarations in the resulting \file{.H} files,
it should be possible to find any offending implicit declarations.
Note however that this only writes function prototypes 
from function definitions, it does not normalise existing prototypes,
so it cannot usefully be applied to header files.


\subsection{Changes to makefile/mk\label{sec:makefile}}

Since not all build environments require the enlarged integers,
the build process must be modified so that 64-bit integers are
used for some build environments and 32-bit integers for others.
Identifying build environments is done by using different values
of the SYSTEM macro.  As well as the existing supported values
\begin{itemize}
\item ix86\_Linux
\item sun4\_Solaris
\item alpha\_OSF1
\end{itemize}
which indicate that 32-bit integers should be used as before, 
the following new ones are added
\begin{itemize}
\item sun4\_Solaris\_64
\item alpha\_OSF1\_64
\end{itemize}
which indicate that 64-bit integers should be used.
Thus two new stanzas are required in the \file{mk} file for each package
setting the values of the other \file{makefile} macros for the newly
supported systems.  

Additionally, if the package contains Fortran source,
a new macro INTEGER8 should be 
defined by the \file{mk} file.  This should contain text which is to
replace `INTEGER~*~8' declarations in fortran source code.  
If blank (defined as spaces or the empty string) it means 
that INTEGER~*~8 declarations should be left unchanged.
Therefore for 64-bit systems this should be defined as the empty
string, and for 32-bit systems it should be defined as `INTEGER~~~~'
(defining it with four trailing spaces
is not required, but improves the aesthetics of
the modified source files).
The makefile should then apply the 
INTEGER*8 \latexhtml{$\rightarrow$}{->} \$(INTEGER8)
substitution to the fortran source files as it extracts them from the
tar archive where they are stored.
The recommended code for this is:
\begin{squote}
\begin{verbatim}
sed "s/^[ \t]*[Ii][Nn][Tt][Ee][Gg][Ee][Rr] *\* *8/      $(INTEGER8)/"
\end{verbatim}
\end{squote}
which should be applied only when {\tt test \$(INTEGER8)} is true.
Note that this changes nothing except variable declarations; 
in particular it will not modify references to INTEGER*8 type in IMPLICIT
statements.
It also makes no allowance for the more bizarre spacing possibilities
permissible in Fortran 77.
It would be possible to use a more comprehensive editing script,
but in the interests of clarity, and of simplicity at build time,
it is recommended that the above is used, 
and source code required to match the given pattern where edits
are needed.

The intention is that Fortran source code is stored in the source 
archive with INTEGER*8 declarations,
and is edited if necessary 
as it is extracted from the tar file, prior to being
written in the build directory.
In this way, the set of Fortran files in the build directory 
will be consistent and compilable, 
though it 
may not have the same content as the set of files in the source archive.

For C files, the source code itself does not need to be modified at
build time, but the \cc{INT\_BIG} preprocessor macro must be defined.
This is most easily done by adding a \cc{-DINT\_BIG=int} or 
\cc{-DINT\_BIG=long} flag as appropriate to the
CFLAGS macro in each \file{mk} stanza.
Alternatively, a SOURCE\_VARIANT-controlled header file could be
written and included into all C source files;
the header file \file{extreme.h} could be used
for this purpose.

The following gives the relevant parts of a basic \file{mk}
file by way of example:
\begin{squote}
\begin{verbatim}
   ...
#  Supported Systems:
#     The following systems are currently supported and may be
#     identified by defining the SYSTEM environment variable
#     appropriately before invoking this script:
#
#        alpha_OSF1
#           DEC Alpha machines running OSF1
#
#        alpha_OSF1_64
#           DEC Alpha machines running OSF1, long integers
#
#        ix86_Linux
#           Intel PC running Linux
#
#        sun4_Solaris
#           SUN Sparcstations running SunOS 5.x (Solaris)
#
#        sun4_Solaris_64
#           SUN Sparcstations running 64-bit SunOS 5.x (Solaris), long integers
   ...
#        CFLAGS (-O -DINT_BIG=int)
#           The C compiler options to use.
#
#        INTEGER8 (INTEGER    )
#           Replacement text for 'INTEGER * 8' declarations in the original
#           original Fortran source code.  If set to the empty string,
#           INTEGER * 8 declarations will not be modified.  For 64-bit
#           systems which must be able to deal with very large images
#           this should be set to the empty string (or 'INTEGER*8').
#           Otherwise, more efficient code may be generated by setting
#           it to 'INTEGER' or 'INTEGER*4'.  The trailing whitespace is
#           optional but may make source code more readable.
   ...

      export INTEGER8
   ...

      case "$SYSTEM" in

#  DEC Alpha machines running OSF1.
#  -------------------------------
         alpha_OSF1)
            CFLAGS='-DINT_BIG=int'
            INTEGER8='INTEGER    '
               ...

#  DEC Alpha machines running OSF1, long integers.
#  ----------------------------------------------
         alpha_OSF1_64)
            CFLAGS='-DINT_BIG=long'
            INTEGER8=''
               ...

#  SUN Sparcstations running SunOS 5.x (Solaris).
#  ---------------------------------------------
         sun4_Solaris)
            CFLAGS='-DINT_BIG=int'
            INTEGER8='INTEGER    '
               ...

#  SUN Sparcstations running 64-bit SunOS 5.x (Solaris), long integers.
#  -------------------------------------------------------------------
         sun4_Solaris_64)
            CFLAGS='-DINT_BIG=long -xarch=v9'
            FFLAGS='-xarch=v9'
            INTEGER8=''
               ...

#  Intel PC running Linux.
#  ----------------------
         ix86_Linux)
            CFLAGS='-DINT_BIG=int'
            INTEGER8='INTEGER    '
               ...
\end{verbatim}
\end{squote}
Note the `{\tt -xarch=v9}' addition to the sun4\_Solaris\_64 CFLAGS
and FFLAGS variables,
which instructs the compiler to compile for a 64-bit system.
Tru64 Unix C compiles for 64 bit executables by default, so needs no
extra flags.

It may also be desirable to add the lines:
\begin{squote}
\begin{verbatim}
            SOURCE_VARIANT='alpha_OSF1'
\end{verbatim}
\end{squote}
and 
\begin{squote}
\begin{verbatim}
            SOURCE_VARIANT='sun4_Solaris'
\end{verbatim}
\end{squote}
to the alpha\_OSF1\_64 and sun4\_Solaris\_64 stanzas respectively,
if the same
machine-specific source files can be used for 32-bit and 64-bit 
builds on the same platforms; if this is not the case then SOURCE\_VARIANT
should be left to default to the value of SYSTEM as usual,
and additional copies of the system-dependent files must be supplied.

The relevant parts of a suitable matching \file{makefile} would look 
something like this:
\begin{squote}
\begin{verbatim}
#  Default values for macros for compiling C and Fortran source code.

CFLAGS = -O -DINT_BIG=int
   ...

#  Default replacement text for Fortran INTEGER * 8 type.

INTEGER8 = INTEGER
   ...

#  Macro for filter to replace INTEGER * 8 declarations with INTEGER8.

REPLACE_INTEGER8 = sed \
   "s/^[ \t]*[Ii][Nn][Tt][Ee][Gg][Ee][Rr] *\* *8/      $(INTEGER8)/"

#  Rules for extracting non-Fortran source files from the source archive.

$(C_ROUTINES) $(PUBLIC_C_INCLUDES) $(PRIVATE_C_INCLUDES):
        $(TAR_OUT) $(PKG_NAME)_source.tar $@
        @ if test -f $@; then :;\
           else echo $@ is not in the tar file; exit 1; fi

#  Rules for extracting Fortran source files from the source archive.

$(F_ROUTINES) $(PUBLIC_F_INCLUDES) $(PRIVATE_F_INCLUDES):
        $(TAR_OUT) $(PKG_NAME)_source.tar $@
        @ if test -f $@; then :;\
           else echo $@ is not in the tar file; exit 1; fi
        if test $(INTEGER8); then \
           $(REPLACE_INTEGER8) < $@ > $@_tmp; \
           mv $@_tmp $@; \
        else :; fi

#  Rules for extracting platform specific Fortran files from the archive.

$(PLATFORM_F) dummy_target2:
        $(TAR_OUT) $(PKG_NAME)_source.tar $@_$(SOURCE_VARIANT)
        @ if test -f $@_$(SOURCE_VARIANT); then :;\
           else echo $@_$(SOURCE_VARIANT) is not in the tar file; exit 1; fi
        if test $(INTEGER8); then \
           $(REPLACE_INTEGER8) < $@_$(SOURCE_VARIANT) > $@; \
           rm -f $@_$(SOURCE_VARIANT); \
           else mv $@_$(SOURCE_VARIANT) $@; fi
   ...

#  Enter information about the current machine and build environment
#  into the date stamp file.
   ...
        @ echo '   INTEGER8: $(INTEGER8)'     >>$(DATE_STAMP)
\end{verbatim}
\end{squote}
Lists of files for extraction from the source archive may have to
be split into Fortran and non-Fortran sublists since the code for
extracting them will now differ.
For instance it might be convenient to replace assignments like this:
\begin{squote}
\begin{verbatim}
PUBLIC_INCLUDES = $(PKG_NAME)_par $(PKG_NAME)_err $(PKG_NAME).h
\end{verbatim}
\end{squote}
with something like the following:
\begin{squote}
\begin{verbatim}
PUBLIC_F_INCLUDES = $(PKG_NAME)_par $(PKG_NAME)_err
PUBLIC_C_INCLUDES = $(PKG_NAME).h
PUBLIC_INCLUDES = $(PUBLIC_F_INCLUDES) $(PUBLIC_C_INCLUDES)
\end{verbatim}
\end{squote}
so that the lists of Fortran and C files can appear as targets of
separate extraction rules, as in the example above.

It may also be necessary to add dependencies for INCLUDE files inserted
by the conversion tools; \xroutine{inscnf} may include \file{CNF\_PAR}
and \xroutine{crepint} may include \file{extreme.h} 
in some modified source files.  
Rules will need to be made for building links to the referenced
include files, and dependencies added for the object files corresponding
to the source files so modified.

Files may be extracted from the source archive(s) in more places than
one in the makefile - in particular, for some reason lost in the
mists of time the {\tt do\_test} target 
usually extracts required files from the source archives explicitly
rather than relying on a dependency.
It will be necessary to identify all such places 
(try grepping for TAR\_OUT), and ensure that
the INTEGER8 macro is substituted in to the source code before it
gets compiled.

Note that because of the way this approach edits Fortran source files on
their way out of the source archive,
the copies of the files in the build directory may not be the same
as the files in the source archive, and so files cannot in general
be transferred between the build directory and source archive
simply using {\tt tar}.
This means that in general the source archive cannot be rebuilt 
from the files in the build directory.
This may well break private, non-standard targets inserted into the
makefile by the package developer (commonly called {\tt archive}),
and effectively means that it is not possible to tweak package source
code in the build directory prior to re-exporting it.

The scripts \xroutine{extmk} and \xroutine{extmakefile} 
are provided to make the necessary 
modifications to \file{mk} and \file{makefile} files respectively, 
and are described fully in Appendix \ref{sec:commands}.
\xroutine{extmk} can normally make all the required changes to \file{mk},
but \xroutine{extmakefile} can only add some of the required parts;
other edits such as deciding which files need to be extracted as Fortran
and which as non-Fortran files must be made by hand.


\section{Overview of tools for making the modifications\label{sec:tools}}

This section explains how to use the utilities distributed with this package
to modify source code for use in 64-bit environments.
The details of their operation are given in \ref{sec:commands}.

To start up the EXTREME package, type
\begin{squote}
\begin{verbatim}
% extreme
 
   EXTREME commands are now available -- Version 0.1-0
\end{verbatim}
\end{squote}
(if the {\tt extreme} alias is not set up, 
try {\tt source /star/bin/extreme/extreme.csh}).
This makes the tools provided by this package available.

One tool is provided for each of the source code conversion
tasks described in the previous section:
\begin{description}
\item[\xroutine{inscnf}:] Inserts CNF\_PVAL calls where required in Fortran source code
\item[\xroutine{frepint}:] 
     Converts INTEGER to INTEGER*8 in Fortran source code
\item[\xroutine{crepint}:] 
     Converts \cc{int} to \cc{INT\_BIG} in C source code
\item[\xroutine{extmk}:] 
     Makes the necessary edits to a package \file{mk} file
\item[\xroutine{extmakefile}:]
     Makes some of the necessary edits to a package \file{makefile}
\end{description}
Each of these is a normal Unix filter command with usage like \file{cat}, 
so may be given zero, one or two arguments to specify its input and output.
Where no change needs to be made, the input is written with no changes 
to the output.  This means that the \file{diff} command can be used 
to see what changes the filters make, by doing something like:
\begin{squote}
\begin{verbatim}
% frepint file.f | diff file.f -
\end{verbatim}
\end{squote}
which might give a result like:
\begin{squote}
\begin{verbatim}
94c94
<       INTEGER STATUS             ! Global status
---
>       INTEGER * 8 STATUS         ! Global status
97,98c97,98
<       INTEGER I                  ! Loop variable
<       INTEGER INDF               ! NDF identifier
---
>       INTEGER * 8 I              ! Loop variable
>       INTEGER * 8 INDF           ! NDF identifier
\end{verbatim}
\end{squote}

Each of the filters, as well as making changes, 
draws attention to constructs which might need 
further attention by writing a message to standard error. 
In some cases, it will also insert a comment in the modified file where
the questionable construct occurs.
Such comment lines contain the name of the filter followed by a colon
and explanatory text, so given the file \file{watcher.c}:
\begin{squote}
\begin{verbatim}
   int watcher( int mins ) {
      printf( "Only %i minutes till coffee break\n", mins );
   }
\end{verbatim}
\end{squote}
\xroutine{crepint} will do the following:
\begin{squote}
\begin{verbatim}
% crepint watcher.c >fixed/watcher.c
crepint: Format string has %[cdiouxX*] (comment inserted)
\end{verbatim}
\end{squote}
and the resulting file \file{fixed/watcher.c} will look like this:
\begin{squote}
\begin{verbatim}
INT_BIG watcher( INT_BIG mins ) {
/* crepint: Format string has %[cdiouxX*]                                */
   printf( "Only %i minutes till coffee break\n", mins );
}
\end{verbatim}
\end{squote}
which can then be fixed by hand as described in
section \ref{sec:cint}.

If the filter thinks it has lost track of the source code in a dangerous
way, i.e.\ that it might be making changes which are likely to invalidate
the code, it may exit with an error status, and print a message to standard
error to that effect.

Each of the filters has a go at retaining the aesthetic 
qualities of the code; an attempt is made to respect 
case usage and spacing conventions in Fortran, 
padding whitespace is shuffled to keep things at the same column as
before if possible, and so on.
If replacement text is longer than the original
then Fortran lines are broken in hopefully reasonable places,
but no line breaks in existing lines are introduced in C.

In general, these filters try to be as helpful as possible, 
and to make any changes which can reasonably be done automatically.
On the whole, they work quite well, but they are not infallible
and ought to be used with human supervision.
Details of the exact capabilities and behaviour of each of them is
given in the command descriptions in Appendix \ref{sec:commands}.

In addition, for each of the source code modifying filters
\xroutine{inscnf}, \xroutine{frepint} and \xroutine{crepint}, 
a driver script is provided. 
For converting large numbers of files, this is likely to be the 
most convenient way to proceed.  Each driver script 
runs the filter on a given set of files, summarises any warnings, and
writes any files have been changed in a new directory.
Any files which did not need alteration are not rewritten.
It also performs some crude safety checks that the modified source
files seem to have been changed in the right way (for instance, that
no changes have been made except for the ones which should have been
made, and that changes to Fortran code do not result in lines longer
than 72 characters).  
These checks do not do such careful parsing
of the source code as the conversion filters themselves, 
so they can throw up false positives or false negatives, but they give 
an extra level of confidence.

The driver script for \xroutine{inscnf} is called \xdofilter{inscnf}
and is invoked with the files to be converted as command line arguments.
For each of its command line arguments it runs \xroutine{inscnf} and
\begin{itemize}
\item It writes a line to a log file \file{./inscnf.log} 
      saying how many lines were changed.  This file does not contain
      anything requiring attention which is not printed to standard output.
\item If and only if some changes were made, it writes the modified copy
      of the file, under the same name, 
      into a directory called \file{./inscnf.changed}.
\item If the filter or the driver script thinks there might be something 
      which needs human attention, it writes a suitable message to standard
      output.  These warning messages can be understood in conjunction 
      with the documentation of the filter, or of the corresponding 
      discussion in section \ref{sec:modificienda}.
\item It reports a brief summary to standard output of its activities,
      indicating how many files have changed, and whether any files have
      gained new dependencies on include files.
\end{itemize}
Finally it writes a short summary of the run.
An excerpt of its output might look like this:
\begin{squote}
\begin{verbatim}
% do-inscnf *.f *.gen
astimp.f:              2 x Last arg %VAL in FTS1_GKEYD
import.f:                  Integer %VAL arg in CCD1_IMFIT?
import.f:                  Last arg %VAL in CCD1_IMFIT
  ...
71 new dependencies on include file 'CNF_PAR'.
71/483 modified files written in ./inscnf.changed.
Logfile is ./inscnf.log.
\end{verbatim}
\end{squote}

The other driver scripts, \dofilter{crepint} and \dofilter{frepint},
differ in the exact warnings they give, but otherwise work the
same way as \dofilter{inscnf}.

The driver script may occasionally throw out a comment like this:
\begin{squote}
\begin{verbatim}
ndf1_pshdt.f:              Possible error in modifications?          
\end{verbatim}
\end{squote}
which indicates that there seems to be a difference between
the output of the filter and the input plus the expected changes.
The checking is done by a quick-and-dirty Perl script called
\file{cmp-inscnf} (and similarly for the other filters),
and if you see this warning you can run this script yourself
to get an idea what the problem may have been. 
The above warning was emitted by \xdofilter{frepint}; investigate 
as follows:
\begin{squote}
\begin{verbatim}
% cmp-frepint ndf1_pshdt.f
 *** Edit error near line 69?:
 CALL NDF1_SPLDT( STR, 1, LEN( STR ), ' ', -10, F, L, NFIELD, STATUS )
 CALL NDF1_SPLDT( STR, 1, LEN( STR ), ' ', - 10, F, L, NFIELD, STATUS )
\end{verbatim}
\end{squote}
from which it is clear that the culprit is some harmlessly inserted
whitespace.
Note that in order to make these comparisons, the \file{cmp-*} scripts
deal in a cavalier fashion with formatting, so the source
lines may not look very much like the original copies and the line number
reporting may not be accurate, but the message
should be sufficient to locate the problem.
Such ``{\tt Possible error in modifications?}'' 
warnings ought to be infrequent, and may often not be indicative
of a real problem, but it is as well to investigate them.

Detailed descriptions of the behaviour of the filter programs is
given in appendix \ref{sec:commands}


\section{EXTREME cribsheet: Converting for extreme data sets in 99 easy 
                            steps\label{sec:cribsheet}}

This section gives a list of what you should to to
a Starlink package to enable it to cope with large images.
Many of the steps can be applied equally 
to modifying non-USSC code which makes use of the USSC.
The steps here give an indication of how to proceed, 
but for more discussion of what's going on, refer to other sections
in this document.
Some examples of the commands you could use are given, 
but obviously you can change these to personal taste.

\begin{enumerate}
%
\item
Identify all C source files and all Fortran source files
(the listing of package files given by the
\htmladdnormallink{Source Code 
 Browser}{http://capc23.ast.cam.ac.uk/cgi-bin/scb}
can be useful for this).
\begin{squote}
\begin{verbatim}
% tar xf package_source.tar
% echo >ffiles *.f *.gen pkg1_par pkg1_err
% echo >cfiles *.c *.h
\end{verbatim}
\end{squote}
%
\item
Start up the EXTREME package
\begin{squote}
\begin{verbatim}
% extreme
 
   EXTREME commands are now available -- Version 0.1-0
\end{verbatim}
\end{squote}
%
\item
Run \xdofilter{inscnf} on Fortran files 
to wrap \%VAL arguments in CNF\_PVAL calls,
if this has not already been done.
\begin{squote}
\begin{verbatim}
% do-inscnf `cat ffiles`
pkg1_sub.f:                Constant %VAL arg in PKG1_ADD?
5 new dependencies on include file 'CNF_PAR'.
5/25 modified files written in ./inscnf.changed.
Logfile is ./inscnf.log.
\end{verbatim}
\end{squote}
%
\item
Check CNF\_PVAL insertions which generated warnings,
and remove them if they wrap arguments which are not registered pointers.
\begin{squote}
\begin{verbatim}
% vi inscnf.changed/pkg1_sub.f
\end{verbatim}
\end{squote}
%
\item
Rebuild source archive, rebuild package, and test.
\begin{squote}
\begin{verbatim}
% mkdir retar
% cd retar
% tar xf ../package_source.tar
% cp ../inscnf.changed/* .
% tar cf ../package_source.tar *
% cd ..
% rm -r retar inscnf.changed
   ...
\end{verbatim}
\end{squote}
%
\item
Ensure that you have 64-bit copies of all the Starlink libraries on which the
package depends (these are not required for making the changes, but 
will be needed for building and testing the modified package).
\html{\begin{squote}\end{squote}}
\item
Run \xdofilter{frepint} on Fortran files to replace INTEGER declarations
by INTEGER~*~8.
\begin{squote}
\begin{verbatim}
% tar xf package_source.tar `cat ffiles`
% do-frepint `cat ffiles`
pgk1_mult.f:               INTEGER*2 declaration not changed                 
pkg1_divid.f:              No IMPLICIT NONE in module PKG1_DIVID
pkg1_misc.f:               Nowhere to declare INT__'s in module PKG1_MISC

22/25 modified files written in ./frepint.changed.
Logfile is ./frepint.log
\end{verbatim}
\end{squote}
%
\item
Check constructs which led to warnings and make any necessary edits,
following the discussion in section \ref{sec:fint}:
\begin{description}
%
\item[Missing IMPLICIT NONE:]
An IMPLICIT NONE statement should really 
be inserted into the module in question and 
explicit declarations made for all the variables used.
If this is impractical, the only essential change is to make sure that
all the implicit INTEGER variables are explicitly declared as INTEGER~*~8.
Note it is {\it not\/} sufficient to make an 
IMPLICIT~INTEGER*8~(I\latexhtml{$-$}{-}N)
declaration, since the resulting declarations would not be edited 
at build time by
the makefile machinery described in section \ref{sec:makefile}.
%
\item[EQUIVALENCE statements:]
Ensure that none of the memory associations are between INTEGER and some
other type.  If they are, careful recoding will probably be required.
%
\item[Use of INTEGER specific intrinsic functions:]
If possible these should be changed to the corresponding generic 
names of the intrinsic functions.
If this is not possible some other workaround may be required.
%
\item[INTEGER*n declarations left unchanged:]
These probably require no further modification.
%
\item[Nowhere to declare INT\_\_'s:]
This indicates that literal integer constants were found as (apparently)
actual arguments to subroutine calls and replaced by constants,
but \xroutine{frepint} couldn't find a suitable place in
the module to put the PARAMETER statements (it looks for an INCLUDE 
statement).  In this case you will have to insert the lines yourself,
but running \routine{frepint} will tell you what it would have inserted,
so that you can paste it in by hand.
\begin{squote}
\begin{verbatim}
% frepint pkg1_misc.f >/dev/null
frepint: Nowhere to declare INT__'s in module PGK1_MISC

*  Local constants for use as actual arguments:
      INTEGER * 8 INT__0
      INTEGER * 8 INT__12
      PARAMETER ( INT__0 = 0 )
      PARAMETER ( INT__12 = 12 )
\end{verbatim}
\end{squote}
%
\end{description}
%
\item
If there is any tricky storage association involving integers,
such as use of COMMON or EQUIVALENCE, or a formal argument of
different type to an actual argument, you may need to recode this.
Hopefully such things should be few and far between.
\html{\begin{squote}\end{squote}}
%
\item
If the package calls any unconverted libraries 
(e.g. non-standard intrinsic functions), change the types of
actual arguments in affected calls back to INTEGER.
\html{\begin{squote}\end{squote}}
%
\item
It is now possible, though not normally worth the effort, 
to change any private INTEGER*8 variables back to INTEGERs 
for efficiency or other reasons.
\html{\begin{squote}\end{squote}}
%
\item
Prepare for C source conversion: ensure that all functions are
properly declared using ANSI C-style formal argument type declarations.
If you think this may not be the case, compiler warnings may be of help.
\begin{squote}
\begin{verbatim}
% gcc -fsyntax-only -Wimplicit-function-declaration -Wstrict-prototypes *.c
tmp.c:160: warning: implicit declaration of function `pipe'
% man pipe
    ...
\end{verbatim}
\end{squote}
%
\item
Make sure that communication with Fortran routines is done properly
using CNF as described in \xref{SUN/209}{sun209}{}.
In particular it is important to use the \xref{TRAIL}{sun209}{TRAIL} 
macro for passing character string lengths.
\html{\begin{squote}\end{squote}}
%
\item
Run \xdofilter{crepint} on C files to replace references to \cc{int} type
by \cc{INT\_BIG}.
\begin{squote}
\begin{verbatim}
% tar xf package_source.tar `cat cfiles`
% do-crepint `cat cfiles`
input.c:               2 x Format string implies int * (comment inserted)
output.c:              5 x Format string has %[cdiouxX*] (comment inserted)  
output.c:                  Format string non-literal (comment inserted)
toplevel.c:                Non-stdlib system header file <unistd.h>    
toplevel.c:                Type of main not changed from int
toplevel.c:                Type of argc not changed from int

8/8 modified files written in ./crepint.changed.
Logfile is ./crepint.log.
\end{verbatim}
\end{squote}
%
\item
Check constructs which led to warnings and make any necessary
edits, following the discussion in section \ref{sec:cint}:
\begin{description}
%
\item[main or argc declaration unchanged:]
Check that the items in question are supposed to be \cc{int} and not
just called \cc{main} or \cc{argc} by coincidence.
\item[Format strings:]
These will mostly require edits as shown in the examples
and discussion in section \ref{sec:cint}.
Positions of the warned-about calls are marked in the source code
by `\cc{crepint:}' comments.
%
\item[signal, bsearch and qsort calls:]
These calls do not need modification, but make sure that the functions 
which they pass are declared and defined 
using \cc{int} type not \cc{INT\_BIG}.
%
\item[Inclusion of non standard-library system header files:]
These presumably indicate use of non standard-library system libraries;
the calls to such functions should be identified, and any which take
\cc{int *} arguments or variable argument lists should be treated in
a similar way to \cc{scanf} and \cc{printf}.
You can see which calls are made to the functions declared in a header file
by removing the include directive and checking compiler warnings,
something like:
\begin{squote}
\begin{verbatim}
% grep -v '<unistd.h>' toplevel.c >tmp.c
% gcc -fsyntax-only -Wimplicit-function-declaration tmp.c
\end{verbatim}
\end{squote}
\end{description}
%
\item
Check that you've attended to all the Format string warnings and removed
the flagging comments.
\begin{squote}
\begin{verbatim}
% grep 'crepint:' crepint.changed/*
\end{verbatim}
\end{squote}
%
\item
Have a look for implicit function or argument declarations
and replace them by explicit \cc{INT\_BIG} declarations.
Certain flags of \file{gcc} can be used to pick this up:
\begin{squote}
\begin{verbatim}
% gcc -fsyntax-only -Wimplicit-int -Wstrict-prototypes *.c
\end{verbatim}
\end{squote}
or the {\tt -proto} flag of the Tru64 Unix C compiler:
\begin{squote}
\begin{verbatim}
% cc -noobject -protois -DINT_BIG=long crepint.changed/*.c
% grep '[^a-z]int[^a-z]' *.H
\end{verbatim}
\end{squote}
%
\item
It is now possible, though not normally worth the effort, 
to change any private \cc{INT\_BIG} variables back to \cc{int}s
for efficiency or other reasons.
\html{\begin{squote}\end{squote}}
%
\item
Rebuild the source archive.
\begin{squote}
\begin{verbatim}
% mkdir retar
% cd retar
% tar xf ../package_source.tar
% cp ../frepint.changed/* .
% cp ../crepint.changed/* .
% tar cf ../package_source.tar *
% cd ..
% rm -r retar frepint.changed crepint.changed
\end{verbatim}
\end{squote}
%
\item
Use \xroutine{extmk} to make the necessary modifications to the \file{mk} file.
\begin{squote}
\begin{verbatim}
% mv mk mk.orig
% extmk < mk.orig > mk
% chmod 755 mk
\end{verbatim}
\end{squote}
%
\item
If \routine{extmk} generated any warnings, edit the \file{mk} file by
hand accordingly.
\html{\begin{squote}\end{squote}}
%
\item
If there are platform-dependent files in the package you must either add
\begin{squote}
\begin{verbatim}
      SOURCE_VARIANT='alpha_OSF1'
\end{verbatim}
\end{squote}
and
\begin{squote}
\begin{verbatim}
      SOURCE_VARIANT='sun4_Solaris'
\end{verbatim}
\end{squote}
to the new alpha\_OSF1\_64 and sun4\_Solaris\_64 stanzas of the \file{mk} file
respectively, or generate new platform-dependent files for the 
two new platforms.
\html{\begin{squote}\end{squote}}
%
\item
Use \xroutine{extmakefile} to make some of the necessary modifications 
to the \file{makefile}, and check the changes made.
\begin{squote}
\begin{verbatim}
% mv makefile makefile.orig
% extmakefile < makefile.orig >makefile
% diff makefile.orig makefile
\end{verbatim}
\end{squote}
%
\item
If \routine{extmakefile} indicated that it failed to make any of the
changes that it wanted to, insert the relevant bits of code by hand
with reference to section \ref{sec:makefile}.
\html{\begin{squote}\end{squote}}
%
\item
Edit the \file{makefile} by hand to make the rest of the necessary changes
as discussed in \ref{sec:makefile}:
\begin{itemize}
\item
Ensure that all, and only, 
extractions of Fortran source files from source archives
are processed using the REPLACE\_INTEGER8 macro 
(replace the new dummy target \$(FORTRAN\_FILES) with macros representing
the Fortran files to be extracted, and check for any other 
use of TAR\_OUT to extract fortran files, e.g.\ in the `do\_test' target).
(search for uses of TAR\_OUT).
\item
Add rules for building any new include files required by the changes
(\file{CNF\_PAR}, \file{EXT\_PAR} or \file{extreme.h}).
\item
Add any new dependencies of object files on these include files.
\item
Fix, or remove, any private archive-type targets which have been broken
by the fact that source files in the build directory are no longer
original copies.
\end{itemize}
\html{\begin{squote}\end{squote}}
%
\item
Export the source, and build the package. 
Look out especially for the following warnings:
\begin{itemize}
\item Fortran variable misaligned in COMMON block.
\item C pointer type mismatch.
\item Incompatible arguments.
\end{itemize}
If there are compilation errors or new warnings fix them.
In general, sun4\_Solaris\_64 is more sensitive to problems than
alpha\_OSF1\_64, since the sizes of \cc{long} and pointers are 
actually different between the 32-bit and 64-bit compilations.
\html{\begin{squote}\end{squote}}
%
\item Test!  
Bear in mind that 
the changes may have broken the package on the old platforms
as well as the new ones.
\html{\begin{squote}\end{squote}}
%
\end{enumerate}

\appendix

\section{Description of tools\label{sec:commands}}

%%%% Begin filter descriptions
\newpage
\sstroutine{
   crepint
}{
   Replace int by INT\_BIG in C
}{
   \sstdescription{
      This program is a filter which takes C source code and replaces
      occurrences of the type specifier `int{\tt '} by the identifier
      `INT\_BIG{\tt '}.  This identifier can then be assigned a preprocessor
      value of a suitable integral type (int or long) either using an
      include file or with a -DINT\_BIG=(type) flag on the C compiler
      command line.

      It{\tt '}s not quite as simple as replacing every semantically significant
      occurrence of the `int{\tt '} identifier; `short int{\tt '} and `long int{\tt '} type
      specifiers will be left alone.

      If a use of int appears to be declaring a symbol called `main{\tt '} or
      `argc{\tt '}, then this will be left alone too, and a warning written
      to standard error to the effect that it is not being changed.

      Additionally, references to the $<$limits.h$>$ macros INT\_MAX, INT\_MIN
      and UINT\_MAX are replaced by INT\_BIG\_MAX, INT\_BIG\_MIN and
      UINT\_BIG\_MAX respectively.  If any of these substitutions are
      made, then a line `\#include {\tt "}extreme.h{\tt "}{\tt '} is added after the
      `\#include $<$limits.h$>${\tt '} line which is presumably in the file.
      If $<$limits.h$>$ is not included in the input file, a warning is
      written to standard error.

      Explicit declarations which are implicitly of type int will have
      an INT\_BIG token inserted - for instance `static x, y;{\tt '} will be
      changed to `static INT\_BIG x, y;{\tt '}.

      The program will write a warning on standard error for certain
      constructions in the code which are likely to cause trouble after
      the mass redeclaration of int as INT\_BIG has occurred, since in
      some places the type int, and not INT\_BIG, is still required.
      These constructions are:
      \sstitemlist{

         \sstitem
            Inclusion of system header files other than those of the C
              standard library, since these may indicate use of functions
              other than those warned about above with arguments of type
              pointer to int.

         \sstitem
            Use of functions from the C standard library which may require
              changes.

      }
      The functions from the C standard library which may require changes
      are the following:
      \sstitemlist{

         \sstitem
            Format strings in formatted I/O which may need changes
              because they use variable argument lists or require
              arguments of type pointer to int.

         \sstitem
            The frexp() math function whose second argument must be
              a pointer to int

         \sstitem
            The signal() function whose second argument is a function
              which must take an int argument

         \sstitem
            The bsearch() and qsort() functions which take a comparison
              function as argument, and this function must be of type int

      }
      In the case of potentially dangerous format strings, for
      convenience a comment is inserted in the output code on the line
      before the function call is made.  The comment will contain the
      character string `crepint: {\tt '}.  The warning to standard error
      notes that the comment line has been inserted.

      The following constructions are also likely to cause trouble, but
      will not be warned about by the program:
      \sstitemlist{

         \sstitem
            Use of functions without prototypes.  If header files are
              omitted or old style function declarations are used then the
              ANSI C machinery for doing type conversion at function call
              time will not work.  Gcc{\tt '}s `-Wstrict-prototypes{\tt '} and
              `-Wimplicit-function-declaration{\tt '} flags are useful for this.

         \sstitem
            Implicit declarations, which are implicitly of type int.
              If a name is declared simply by mentioning it without any type
              or type qualifiers, it is implicitly of type int, and so
              should become delcared as INT\_BIG.  This program does not
              find these.  Such implicit declarations (only?) occur in
              function declarations.  The Tru64 Unix C compiler{\tt '}s `-protois{\tt '}
              flag or gcc{\tt '}s `-Wimplicit-int{\tt '} flag are useful for identifying
              these.

      }
      The program tries to adjust padding whitespace outside comments
      so that the spacing of the output looks OK.

      No changes are made to comment lines so that, for instance, the
      Synopsis stanza of function prologues will not have formal argument
      types changed from `int{\tt '} to `INT\_BIG{\tt '}.

      Source code which makes sufficiently inventive use of the C
      will stand a good chance of confusing this program.
   }
   \sstusage{
      crepint [ in [ out ] ]
   }
   \sstnotes{
      Although this program behaves as a filter, it is written on
      the assumption that it will be run on a file of a finite length:
      it may buffer large amounts of input before writing output, and
      it may not free up memory.
   }
}
\newpage
\sstroutine{
   frepint
}{
   Replace INTEGER by INTEGER$*$8 in Fortran 77
}{
   \sstdescription{
      This program is a filter which takes FORTRAN 77 source code
      and modifies it so that INTEGER declarations are rewritten as
      `INTEGER $*$ 8{\tt '}.  It also attempts to warn if there are usages which
      might cause trouble given this change.

      Additionally, if there appear to be actual arguments to subroutines
      or functions which are literal integers, the program will attempt
      to replace them with symbolic constants, and to define these
      constants in the declaration section of the module.  Thus the line

         CALL SUB( X, 5, STATUS )

      will be replaced by

         CALL SUB( X, INT\_\_5, STATUS )

      and the corresponding declaration statements

         INTEGER $*$ 8 INT\_\_5

      and

         PARAMETER ( INT\_\_5 = 5 )

      will be inserted in the declaration section of the module.
      The program will attempt to insert these declarations near an
      INCLUDE statement, and if it cannot find one, it will write a
      warning to standard error, including the text of the declarations
      that it would have made.

      Attention is paid to fortran 77 source format, so that lines
      more than 72 characters long are avoided (unless they were there
      in the first place).

      Some attention is paid to the aesthetic qualities of the output:
      line breaks are made, where possible, following the usage in, e.g.,
      KAPPA.  An attempt is made to copy the style of case usage from the
      input.

      No changes are made to comment lines so that, for instance, the
      Arguments stanza of subroutine prologues will not have argument
      types modified from `INTEGER{\tt '} to `INTEGER $*$ 8{\tt '}.

      No change is made to references to INTEGER type in IMPLICIT
      statements.

      The program will write a warning on standard error for certain
      constructions in the code which are likely to cause trouble after
      the mass redeclaration of INTEGER as INTEGER$*$8 has occurred.
      These constructions are:
      \sstitemlist{

         \sstitem
            INTEGER $*$ n declarations which already exist in the code
              (these are not modified)

         \sstitem
            EQUIVALENCE statements

         \sstitem
            Use of INTEGER Specific names for standard intrinsic functions
              (IABS, ISIGN, MAX0, AMAX0, MIN0, IMIN0).  IDIM could also go in
              this list, but since it is a common variable name, and an
              uncommon intrinsic, no warning is given for IDIM.

         \sstitem
            Any module (SUBROUTINE, FUNCTION or BLOCK DATA) which does not
              include an IMPLICIT NONE statement.
      }
   }
   \sstusage{
      frepint [ in [ out ] ]
   }
   \sstnotes{
      The program is not infallible at identifying function calls, which
      it needs to do in order to replace integer literals, since they
      look like array references.  It uses the rule of thumb that it if
      the would-be function name contains an underscore it is a function,
      otherwise it is an array.

      It will also not identify an INTEGER-type expression as such unless
      it is a single integer literal; for instance the expression `3 $*$ 5{\tt '}
      as actual argument of a subroutine/function ought to be retyped,
      but will not be spotted.

      In a few cases, the line breaks are not made in very beautiful places.
      They should, however, always be correct.

      Although this program behaves as a filter, it is written on
      the assumption that it will be run on a file of a finite length:
      it may buffer large amounts of input before writing output, and
      it may not free up memory.
   }
}
\newpage
\sstroutine{
   inscnf
}{
   Wrap \%VAL arguments with CNF\_PVAL in Fortran 77
}{
   \sstdescription{
      This is a filter which takes FORTRAN 77 source code
      and modifies it so that text which is the argument of a \%VAL
      directive is wrapped in a call to CNF\_PVAL; i.e. input text

         \%VAL( IPTR )

      is changed to

         \%VAL( CNF\_PVAL( IPTR ) )

      If the call to CNF\_PVAL is already present no change is made,
      and a warning is emitted.  Lines with no references to the \%VAL
      directive are left alone.

      Additionally, for each program unit in which a call to CNF\_PVAL
      has been made, an attempt is made to insert a line like

         INCLUDE {\tt '}CNF\_PAR{\tt '}        ! For CNF\_PVAL function

      This is inserted after the last INCLUDE line which already exists
      in the program unit.  If there are no INCLUDE lines there, this
      line is not inserted, and a warning message is printed to standard
      error.

      Attention is paid to Fortran 77 source format, so that lines
      more than 72 characters long are avoided (unless they were there
      in the first place).

      Characters {\tt '}$\backslash$r{\tt '} (carriage return) and {\tt '}$\backslash$t{\tt '} (tab) might possibly
      cause erroneous line breaking - if any are encountered a warning
      is given (these should not be in the source really).
      Code using columns 73-80 of the source cards for comments is
      likely to be mangled (nobody does this any more do they?).

      Under certain improbable circumstances it is possible for the
      program to get stuck trying to break a line; in this case it will
      exit with error status and an error message.

      Some attention is paid to the aesthetic qualities of the output:
      line breaks are made, where possible, following the usage in, e.g.,
      KAPPA.  An attempt is made to copy the style of case usage and bracket
      spacing from the input.

      This program wraps ALL occurrences of \%VAL in a call to CNF\_PVAL,
      unless they are already so wrapped.  If it suspects that \%VAL
      may not be a legitimate candidate for this treatment, it will
      output a warning message to standard error.  It will do this in
      the following cases:
      \sstitemlist{

         \sstitem
           \%VAL is on the last argument in the argument list (this
             suggests that it might be a trailing string length)

         \sstitem
           The argument of \%VAL looks like an integer constant

         \sstitem
           The argument of \%VAL looks like a Starlink-style symbolic
             constant (has two adjacent underscore characters).
      }
   }
   \sstusage{
      inscnf [ in [ out ] ]
   }
   \sstnotes{
      Although this program behaves as a filter, it is written on
      the assumption that it will be run on a file of a finite length:
      it may buffer large amounts of input before writing output, and
      it may not free up memory.
   }
}
\newpage
\sstroutine{
   extmk
}{
   Modify mk file for use with EXTREME data sets
}{
   \sstdescription{
      This is a simple filter which takes a Starlink mk file as input and
      writes as output a file which should provide the additional
      functionality required for EXTREME use, i.e. it adds new
      SYSTEM types of alpha\_OSF1\_64 and sun4\_Solaris\_64, provides
      for use of the INTEGER8 macro to preprocess Fortran source code
      before compilation, and modifies the C compilation flags for
      use with the INT\_BIG macro.

      The changes it attempts to make are as follows:
      \sstitemlist{

         \sstitem
            Add comment blocks describing the two new values of SYSTEM

         \sstitem
            Modify the comment describing the default value of CFLAGS

         \sstitem
            Add a comment describing the INTEGER8 environment variable

         \sstitem
            Export the INTEGER8 environment variable

         \sstitem
            Modify SYSTEM-specific settings for existing SYSTEMs

         \sstitem
            Add support for the two new SYSTEMs

      }
      If it is unable to make any of the modifications it would like to,
      it will print an explanatory message saying what it could not do.

      The only change which might be required which this script does not
      make is to set values for the SOURCE\_VARIANT variable.  Depending
      on how the system-specific compilation is going to be done, it
      may be desirable to add SOURCE\_VARIANT={\tt '}alpha\_OSF1{\tt '} in the new
      alpha\_OSF1\_64 stanza, and SOURCE\_VARIANT={\tt '}sun4\_Solaris{\tt '} in the
      new sun4\_Solaris\_64 stanza.  If required, this must be done by hand.

      This script is not extremely intelligent - unless the mk file
      follows the usual pattern quite closely, the output may be in
      error, or complete rubbish.  It is intended as a convenience,
      and if it does not work, then it will be necessary to make the
      modifications by hand; this is not too arduous.
   }
   \sstusage{
      extmk $<$ mk $>$ mk.new
   }
}
\newpage
\sstroutine{
   extmakefile
}{
   Modify makefile for use with EXTREME data sets
}{
   \sstdescription{
      This is a simple filter which takes a Starlink makefile as input
      and writes as output a file which provides some of the changes
      required for EXTREME use.  Not all the requisite changes can be
      made however, and the resulting file will need some edits to be
      made by hand.

      The changes it attempts to make are as follows:
      \sstitemlist{

         \sstitem
            Add {\tt '} -DINT\_BIG=int{\tt '} to the default CFLAGS macro

         \sstitem
            Add {\tt '}INTEGER8 = INTEGER{\tt '} default macro setting

         \sstitem
            Add definition of the REPLACE\_INTEGER8 macro

         \sstitem
            Add a rule for extracting Fortran source files from source archive

         \sstitem
            Add code for recording the INTEGER8 macro in the datestamp file

      }
      If it is unable to make any of the modifications it would like to,
      it will print an explanatory message saying what it could not do.

      Various changes will still need to be made by hand after generating
      a new makefile by running this script.  The principal one is
      splitting files between Fortran and non-Fortran ones, so that the
      non-Fortran files can be extracted using the old rule, but the
      Fortran files can be extracted using the new rule inserted by this
      script (the dummy target {\tt '}\$(FORTRAN\_FILES){\tt '} is written as a
      placeholder for such files).  This may require splitting up
      existing macros, for instance splitting PRIVATE\_INCLUDES into
      PRIVATE\_C\_INCLUDES and PRIVATE\_F\_INCLUDES.

      This script is not extremely intelligent - unless the makefile
      follows the usual pattern quite closely, the output may be in
      error.  It is strongly advised that the input and output are
      compared using diff.  If there are problems, it may be necessary
      to make the modifications by hand; this is not too arduous.
   }
   \sstusage{
      extmakefile $<$ makefile $>$ makefile.new
   }
}
\newpage
\sstroutine{
   cmp-xxx
}{
   Compare filtered source with original for unwanted changes
}{
   \sstdescription{
      This script checks an original source code file against a version
      of it run through the one of the source code filter programs in
      the EXTREME package.  It should be invoked under the name `cmp-xxx{\tt '}
      to check the effects of the filter `xxx{\tt '}.

      The available filters xxx are:
      \sstitemlist{

         \sstitem
            \xroutine{inscnf} -- Wrap \%VAL invocations in CNF\_PVAL calls

         \sstitem
            \xroutine{crepint} -- Change int type to INT\_BIG in C

         \sstitem
            \xroutine{frepint} -- Change INTEGER to INTEGER $*$ 8 in Fortran

      }
      If a file containing the filtered source code already exists, it
      can be given as the second command-line argument, otherwise the
      file given as the first command-line argument will be run through
      the appropriate filter before the comparison is made.

      The script uses its knowledge of the changes made by each of the
      filters to identify changes which are unexpected.  The idea is to
      serve as a check that the the source code filter program itself
      has not made a mistake.  The parsing done by this script is much
      less careful than that done by the filters, so it may make
      mistakes - apparent discrepancies reported by this script should
      be investigated, but may well not indicate genuine problems.

      If an apparent discrepancy is found, the script prints the
      first line from each file in which a discrepancy exists.
      The text printed is not the text as it appears in the files, but
      a version mangled by this program for comparison - whitespace,
      formatting, and other things may have been changed.  The printed
      text should however make it easy enough to find the relevant point
      in the input file.

      If there is an apparent discrepancy the exit status of the program
      will be non-zero; if the files match then there is no output and
      exit status is zero.
   }
   \sstusage{
      cmp-xxx file [ newfile ]
   }
}
\newpage
\sstroutine{
   do-xxx
}{
   Apply source code filter xxx to a set of files
}{
   \sstdescription{
      This is a driver script to run one of the filter programs in
      the EXTREME package which modifies source code.  It should be
      invoked under the name `do-xxx{\tt '} to run the filter `xxx{\tt '}.

      The available filters xxx are:
      \sstitemlist{

         \sstitem
            \xroutine{inscnf} -- Wrap \%VAL invocations in CNF\_PVAL calls

         \sstitem
            \xroutine{crepint} -- Change int type to INT\_BIG in C

         \sstitem
            \xroutine{frepint} -- Change INTEGER to INTEGER $*$ 8 in Fortran

      }
      For each of its command line arguments (files) it:
      \sstitemlist{

         \sstitem
            Runs the filter xxx.

         \sstitem
            Writes a line to the file ./xxx.log saying how many lines were
              changed.

         \sstitem
            If and only if changes were made, it writes the modified file
              under the same name into the directory ./xxx.changed.

         \sstitem
            If the filter wrote any warnings to standard error, these are
              summarised to standard output.

         \sstitem
            Checks that the input file and output file don{\tt '}t look different
              in any unexpected ways, and writes a warning if they do.

         \sstitem
            For Fortran files, checks that no lines have been extended
              beyond 72 characters (this should not be possible, it{\tt '}s just
              an extra precaution).

      }
      It then writes a short summary of the run, including a report of
      whether any files gained new dependencies on include files.
      Thus anything which the filter or this script thinks may require
      human attention is written to standard output while modified
      files are written to a new directory.

      As part of its checking, it invokes a script called \xroutine{cmp-xxx} on
      each pair of (original, changed) files; these scripts are
      crude checks that the changes made have not done anything to the
      source code to change its intention other than what should have
      been done.  They have been written in a fairly quick and dirty
      way however, and may well turn up false positives or false negatives.
   }
   \sstusage{
      do-xxx files
   }
}
%%%% End filter descriptions

% ? End of main text
\end{document}

% $Id$
