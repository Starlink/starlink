#include "sae_par.h"
#include "cupid.h"
#include "ast.h"
#include "mers.h"
#include <string.h>
#include <math.h>

void CGEN_FUNCTION(cupidFWJoin)( CGEN_TYPE *array, int nel, int ndim,
                                 int dims[ 3 ], int skip[ 3 ], double rms,
                                 AstKeyMap *config, int *ipa, double *peakvals,
                                 int *npeak, int perspectrum,
                                 int *status ){
/*
*+
*  Name:
*     cupidFWJoin<X>

*  Purpose:
*     Assign a clump index to every data pixel.

*  Language:
*     Starlink C

*  Synopsis:
*     void cupidFWJoin<X>( CGEN_TYPE *array, int nel, int ndim,
*                          int dims[ 3 ], int skip[ 3 ], double rms,
*                          AstKeyMap *config, int *ipa, double *peakvals,
*                          int *npeak, int perspectrum,
*                          int *status )

*  Description:
*     This function identifies groups of adjoining clumps which have no
*     significant dips between them, and merges them into a single clump.
*     For instance, if a single clump has a flat plateau, on which are
*     two small noise spikes separated by more than MaxJump, the basic
*     FellWalker algorithm would have created two clumps, one centred on
*     each of the two noise spikes. In reality, these two clumps are not
*     significantly different and should be considered part of the same
*     clump. This tendency for noise spikes to be interpreted as clumps is
*     made worse if pixel-to-pixel noise is correlated over a distance
*     comporable to or larger than MaxJump.
*
*     This function scans the pixel assigment array twice; the first scan
*     is row-by-row and the second is column-by-column. On each scan, the
*     boundary between adjoining clumps is found by looking for a change in
*     the pixel assignment index. The data value at each boundary pixel
*     is noted, and the hightest data value on the boundary between any two
*     adjoining clumps is thus found. This highest data value corresponds
*     to the bottom of the "dip" between the two adjoining peaks. If the
*     bottom of the dip is not significantly lower than the peak values in
*     both of the two adjoining peaks, then the two clumps are merged
*     into one. Here, "significantly lower" means that the data value at
*     the dip is more than "MinDip" lower than the lowest of the two clump
*     peak values ("MinDip" is a configuration parameter).

*  Parameters:
*     array
*        The array containing the data to be scanned. The elements should
*        be ordered according to Fortran order (first axis varying most
*        rapidly).
*     nel
*        The number of elements in "array".
*     ndim
*        The number of significant pixel axes.
*     dims
*        The number of pixels on each pixel axis of the array.
*     skip
*        The increment in 1D vector index required to move a distance of 1
*        pixel along each axis. This allows conversion between indexing
*        the array using a single 1D vector index and using nD coords. This
*        array should have 3 elements even if "ndim" is less than 3, and
*        the extra elements should be filled with zero's.
*     rms
*        The RMS noise in the data
*     config
*        An AstKeyMap contining the configuration parameters for this
*        algorithm.
*     ipa
*        Pointer to the array to receive the index of the clump to which
*        each data pixel is assigned. The lowest clump index is 0. Pixels
*        not in a clump are assigned -1.
*     peakvals
*        Pointer to an array in which element "i" holds the peak data
*        value in the clump with index "i". The values will be modified
*        on exit if any of the clumps were merged.
*     npeak
*        The address of an integer holding the highest clump index value
*        in "ipa". On exit, the supplied value will be reduced if any of
*        the clumps were merged.
*     perspectrum
*        If non-zero, then each spectrum is processed independently of its
*        neighbours. A clump that extends across several spectra will be
*        split into multiple clumps, each restricted to a single spectrum.
*        The non-zero value supplied should be the 1-based axis index of
*        the spectral pixel axis. Should be supplied as zero if "ndim" is
*        not 3.
*     status
*        Pointer to the inherited status value.

*  Notes:
*     - This function can be invoked using the generic cupidFWJoin macro
*     defined in cupid.h. This macro has the same parameter list as
*     cupidFWJoin<X> except that an extra parameter is added to the start
*     of the parameter list indicating the data type of the specific
*     cupidFWJoin... function to be invoked. This extra parameter should
*     be an integer and should be one of CUPID__DOUBLE, CUPID__FLOAT, etc.

*  Copyright:
*     Copyright (C) 2006 Particle Physics & Astronomy Research Council.
*     Copyright (C) 2007, 2009 Science & Technology Facilities Council.
*     All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 2 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful, but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 59 Temple Place,Suite 330, Boston, MA
*     02111-1307, USA

*  Authors:
*     DSB: David S. Berry
*     TIMJ: Tim Jenness (JAC, Hawaii)
*     {enter_new_authors_here}

*  History:
*     27-MAR-2006 (DSB):
*        Original version.
*     21-MAR-2007 (DSB):
*        Fix bug that prevented merger occuring if only one merger is needed.
*     23-MAR-2007 (DSB):
*        Fix bug that caused incorrect clumps to be merged.
*     17-SEP-2007 (DSB):
*        Added "perspectrum" parameter.
*     14-JAN-2009 (TIMJ):
*        Use MERS for message filtering.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-
*/

/* Local Variables: */
   double mindip;  /* Minimum dip between distinct peaks */
   double newv;    /* Data value at current scan line sample */
   double oldv;    /* Data value at previous scan line sample */
   double v;       /* Mean data value at clump boundary */
   int *pairs;     /* Array holding indices of clumps to be merged */
   int *p;         /* Pointer to the lower of a pair of clumps to be merged */
   int *pa;        /* Pointer to next "ipa" value */
   int *table1;    /* Translates orginal clump index into intermediate clump index */
   int *table2;    /* Translates orginal clump index into final clump index */
   int ii;         /* Index of current scan line sample */
   int iidim;      /* Length of current scan line */
   int iiskip;     /* Skip between samples on current scan line */
   int ipair;      /* Index for a pair of clumps to be merged */
   int ipeak;      /* Original clump index */
   int iv0;        /* Vector index at start of scan line */
   int iv;         /* Vector index at current scan line sample */
   int ix;         /* GRID index on 1st axis at starting pixel */
   int iy;         /* GRID index on 2nd axis at starting pixel */
   int iz;         /* GRID index on 3rd axis at starting pixel */
   int jpeak;      /* Intermediate clump index */
   int kpeak;      /* Final clump index */
   int lowclump;   /* Index of the clump with lower peak value */
   int new_npeak;   /* Highest final clump index used so far */
   int newclump;   /* Clump index of current sample in scan line */
   int npair;      /* No. of pairs of adjoining clumps to be merged */
   int oldclump;   /* Clump index of previous sample in scan line */
   int peak0;      /* Index of first peak to be merged */
   int peak1;      /* Index of second peak to be merged */
   int scanax;     /* Index of pixel axis being scanned */
   int trans;      /* Do any clump indices need to be translated? */
   int x[ 3 ];     /* GRID indices at starting pixel */

/* Abort if an error has already occurred. */
   if( *status != SAI__OK ) return;

/* Get the minimum dip between two adjoining peaks necessary for the two
   peaks to be considered distinct. */
   mindip = cupidConfigRMS( config, "MINDIP", rms, 3.0*rms, status );

/* Return without action if merging of clumps is not required. */
   if( mindip <= 0.0 ) return;

/* This first section identifies pairs of adjoining clumps between which
   there is no significant intervening dip. */
/* ---------------------------------------------------------------------- */

/* Initialise things to avoid compiler warnings. */
   oldv = 0.0;

/* Indicate that we have not as yet found any pair of adjoining clumps
   that have no significant intervening dip. */
   npair = 0;
   pairs = NULL;

/* We scan the "ipa" array "ndim" times, once along each pixel axis. */
   for( scanax = 0; scanax < ndim; scanax++ ) {

/* If we are processing spectra independently of the neioghbouring
   spectra, we only scan the array once, along the spectral axis. */
      if( perspectrum && perspectrum != scanax + 1 ) continue;

/* Store the skip in 1D vector index between adjacent samples along the scan
   line, and the number of samples along the scan line. */
      iiskip = skip[ scanax ];
      iidim = dims[ scanax ];

/* Consider every pixel in the data cube as a candidate for the start of
   a scan line. */
      iv0 = 0;
      for( iz = 1; iz <= dims[ 2 ]; iz++ ) {
         x[ 2 ] = iz;

         for( iy = 1; iy <= dims[ 1 ]; iy++ ) {
            x[ 1 ] = iy;

            for( ix = 1; ix <= dims[ 0 ]; ix++, iv0++ ) {
               x[ 0 ] = ix;

/* Scan lines start at pixels which have a value of one on the axis
   currently being scanned. */
               if( x[ scanax ] == 1 ) {

/* Initialise the index of the clump to which the current sample in the
   scan line is assigned. */
                  oldclump = -1;

/* Initialise the 1D vector index of the current sample. */
                  iv = iv0;

/* Loop round every sample in the scan line. */
                  for( ii = 0; ii < iidim; ii++ ) {

/* Note the index of the clump to which the current sample belongs, and
   its data value. */
                     newclump = ipa[ iv ];
                     newv = (double) array[ iv ];

/* If the scan line has passed from one clump to an adjoining clump, check the
   depth of the dip between the two peak values. */
                     if( oldclump != newclump &&
                         oldclump != -1 && newclump != -1 ) {

/* Find the mean of the two data values on either side of the boundary. */
                        v = 0.5*( oldv + newv );

/* Find the index of the clump with the lower peak. */
                        if( peakvals[ newclump ] < peakvals[ oldclump ] ) {
                           lowclump = newclump;
                        } else {
                           lowclump = oldclump;
                        }

/* If the dip between the lower of the two adjoining peaks and the current
   sample is less than "MinDip" note that the two clumps need to be
   merged together because there is no significant dip between them. */
                        if( peakvals[ lowclump ] - v < mindip ) {
                           ipair = npair++;
                           pairs = astGrow( pairs, npair, 2*sizeof( int ) );
                           if( astOK ) {
                              p = pairs + 2*ipair;
                              p[ 0 ] = oldclump;
                              p[ 1 ] = newclump;
                           }
                        }
                     }

/* Same the clump index and data value at the current sample. */
                     oldclump = newclump;
                     oldv = newv;

/* Move on to the next sample. */
                     iv += iiskip;
                  }
               }
            }
         }
      }
   }

/* This next section merges the pairs of clumps found above. */
/* --------------------------------------------------------- */
   if( npair ) {

/* Allocate memory to hold two translation tables from old clump indices to
   new clump indicies. */
      table1 = astMalloc( sizeof( int )*( *npeak + 1 ) );
      table2 = astMalloc( sizeof( int )*( *npeak + 1 ) );
      if( astOK ) {

/* Initialise the 1st table to indicate that all clumps retain their initial
   identifiers. */
         for( ipeak = 0; ipeak <= *npeak; ipeak++ ) table1[ ipeak ] = ipeak;

/* Now loop through each of the pairs of clumps which are to be merged. Find
   the clump index that is being used in place of the lower clump index in
   the pair, and use it also for the other clump in the pair. These give
   the intermediate clump assignments. */
         p = pairs;
         for( ipair = 0; ipair < npair; ipair++, p += 2 ) {
            peak0 = table1[ p[ 0 ] ];
            peak1 = table1[ p[ 1 ] ];

            if( peak1 > peak0 ){

               for( ipeak = 0; ipeak <= *npeak; ipeak++ ) {
                  if( table1[ ipeak ] == peak1 ) {
                     table1[ ipeak ] = peak0;
                  }
               }

            } else {

               for( ipeak = 0; ipeak <= *npeak; ipeak++ ) {
                  if( table1[ ipeak ] == peak0 ) {
                     table1[ ipeak ] = peak1;
                  }
               }

            }
         }

/* Initialise the 2nd table to indicate that no clumps indices are used. */
         for( ipeak = 0; ipeak <= *npeak; ipeak++ ) table2[ ipeak ] = 0;

/* Now map the intermediate clump identifiers onto a contiguous set of
   final clump identifiers starting at 1. Set a flag ("trans") that
   indicates if any clump index is to be changed. */
         trans = 0;
         new_npeak = 0;
         for( ipeak = 0; ipeak <= *npeak; ipeak++ ) {
            jpeak = table1[ ipeak ];
            kpeak = table2[ jpeak ];
            if( kpeak == 0 ){
               kpeak = ( table2[ jpeak ] = ++new_npeak );
            }
            table2[ ipeak ] = kpeak;
            if( ipeak != kpeak ) trans = 1;
         }

/* If necesaary, translate all the values in "ipa" using the above table. */
         if( trans ) {

            for( ipeak = 0; ipeak <= *npeak; ipeak++ ) {
              if( ipeak != table2[ ipeak ] ) {
                msgSeti( "P0", ipeak );
                msgSeti( "P1", table2[ ipeak ] );
                msgOutif( MSG__DEBUG, "",
                          "Moving clump ^P0 into clump ^P1", status );
              }
            }

            pa = ipa;
            for( iv = 0; iv < nel; iv++, pa++ ) {
               if( *pa != -1 ) *pa = table2[ *pa ];
            }

/* Save the new highest clump index in the returned "ip" array. */
            *npeak = new_npeak;
         }
      }

/* Free resources. */
      pairs = astFree( pairs );
      table1 = astFree( table1 );
      table2 = astFree( table2 );
   }
}
