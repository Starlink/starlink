                       <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>575(sed) manual page</TITLE>
</HEAD>
<BODY bgcolor=white>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">Name </A></H2>
busy - Make Tk widgets busy, temporarily blocking 
user interactions.  
<H2><A NAME="sect1" HREF="#toc1">Synopsis </A></H2>
<B>busy hold <I>window </I></B> ?<I>option value </I>?...  <P>
<B>busy release 
<I>window </I></B> ?<I>window </I>?...  <P>
<B>busy configure <I>window </I></B> ?<I>option value </I>?...  <P>
<B>busy forget 
<I>window </I></B> ?<I>window </I>?...  <P>
<B>busy isbusy  </B>?<I>pattern </I>?  <P>
<B>busy status <I>window </I></B>   <P>
<B>busy 
windows  </B>?<I>pattern </I>?  
<H2><A NAME="sect2" HREF="#toc2">Description </A></H2>
<P>
The <B>busy </B> command provides a simple means 
to block keyboard, button, and pointer events from Tk widgets, while overriding 
the widget's cursor with a configurable busy cursor.  
<H2><A NAME="sect3" HREF="#toc3">Introduction </A></H2>
<P>
There 
are many times in applications where you want to temporarily restrict 
what actions the user can take.  For example, an application could have 
a "run" button that when pressed causes some processing to occur.  But 
while the application is busy processing, you probably don't want the the 
user to be able to click the "run" button again.  You may also want restrict 
the user from other tasks such as clicking a "print" button. <P>
The <B>busy </B> 
command lets you make Tk widgets busy. This means that user interactions 
such as button clicks, moving the mouse, typing at the keyboard, etc. are 
ignored by the widget.  You can also set a special cursor (like a watch) 
which overrides the widget's normal cursor, providing feedback that the 
application (widget) is temporarily busy. <P>
When a widget is made busy, all 
of the widgets in its window hierarchy also become busy.  It's easy then 
to make an entire panel of widgets busy by simply making the uppermost 
widget (such as ".") busy. This is far easier and much more efficient than 
recursively traversing the widget hierarchy, disabling each widget and 
re-configuring its cursor. <P>
The busy command can also be used in many cases 
instead of Tk's <B>grab </B> command.  Unlike <B>grab </B> which directs all user interaction 
to one widget, the busy command allows more than one widget to be active 
(for example, a "cancel" dialog and a "help" button) while the other widgets 
are busy.  
<H2><A NAME="sect4" HREF="#toc4">Example </A></H2>
You can make a set of widgets busy by simply making 
the uppermost widget in the hierarchy busy using the <B>hold </B> operation.  
  <BR>
<P>
<CODE> frame .top <BR>
 button .top.button; canvas .top.canvas <BR>
 pack .top.button .top.canvas 
<BR>
 pack .top <BR>
   . . . <BR>
 busy hold .top <BR>
 update <BR>
 </CODE><P>All the widgets within <I>.top </I> (including 
<I>.top </I>) are now busy.   The <B>update </B> command insures that <B>busy </B> command has 
a  chance to effect. <P>
When the application is no longer busy, you can allow 
user interaction again  by the <B>release </B> operation.  
<!--
 
  
-->
<I><tt> </tt>&nbsp;<tt> </tt>&nbsp;busy release .top 
 </I> <BR>
  
<!--
 
  
-->
You can change the busy cursor using the <B>configure </B> operation.  

<!--
 
  
-->
<I><tt> </tt>&nbsp;<tt> </tt>&nbsp;busy configure .top -cursor "watch" </I> <BR>
  
<!--
 
  
-->
Finally, when you no longer 
need to make the widget busy anymore,  invoke the <B>forget </B> operation to 
free any resources allocated.  
<!--
 
  
-->
<I><tt> </tt>&nbsp;<tt> </tt>&nbsp;busy forget .top  </I> <BR>
  
<!--
 
  
-->
Destroying the 
widget also cleans up any resources allocated by the busy command. <P>
 
<H2><A NAME="sect5" HREF="#toc5">Operations 
</A></H2>
The following operations are available for the <B>busy </B> command: 
<DL>

<DT><B>busy hold 
<I>window </I></B> ?<I>option value </I>?...  </DT>
<DD>Makes the widget <I>window </I> (and its descendants 
in the Tk window hierarchy) busy.  <I>Window </I> must be a valid path name of 
a Tk widget.  After idle tasks are processed, the widget will be blocked 
from user interactions. All device events in the widget window and its 
descendants will be ignored.  Typically <B>update </B> should be called immediately 
afterward to insure that the <B>hold </B> operation is in effect <I>before </I> the 
application starts its processing. The following configuration options 
are valid:  <blockquote></DD>

<DT><B>-cursor <I>cursorName </I></B>  </DT>
<DD>Specifies the cursor to be displayed when 
the widget is made busy. <I>CursorName </I> can be in any form accepted by <B>Tk_GetCursor 
</B>. The default cursor is <I>watch </I>. </DD>
</DL>
 </blockquote>

<DL>

<DT><B>busy configure <I>window </I></B> ?<I>option value </I>?... 
 </DT>
<DD>Queries or modifies the <B>busy </B> command configuration options for  <I>window 
</I>. <I>Window </I> must be the path name of a widget previously made busy by the 
<B>hold </B> operation.  If no options are specified, a list describing all of 
the available options for <I>window </I> (see <B>Tk_ConfigureInfo </B> for information 
on the format of this list) is returned.  If <I>option </I> is specified with 
no <I>value </I>, then the command returns a list describing the one named option 
(this list will be identical to the corresponding sublist of the value 
returned if no <I>option </I> is specified).  If one or more <I>option-value </I> pairs 
are specified, then the command modifies the given widget option(s) to 
have the given value(s); in this case the command returns the empty string. 
 <I>Option </I> may have any of the values accepted by the <B>hold </B> operation.   
 <P>
Please note that the option database is referenced through <I>window </I>.  For 
example, if  the widget <I>.frame </I> is to be made busy, the busy  cursor can 
be specified for it by either <B>option </B> command:  
<!--
 
  
-->
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<I>option add *frame.busyCursor 
gumby </I> <BR>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;<I>option add *Frame.BusyCursor gumby </I> <BR>
  
<!--
 
  
-->
</DD>

<DT><B>busy forget <I>window </I></B> ?<I>window 
</I>?...  </DT>
<DD>Releases resources allocated by the busy command for <I>window </I>, including 
the InputOnly window.  User events will again be received again  by <I>window 
</I>.  Busy resources are also released when <I>window </I> is destroyed. <I>Window </I> must 
be the name of a widget specified  in the <B>hold </B> operation, otherwise an 
error is reported. </DD>

<DT><B>busy isbusy  </B>?<I>pattern </I>?  </DT>
<DD>Returns the pathnames of all 
widget windows which are currently busy. If a <I>pattern </I> is given, the path 
names of busy widgets  matching <I>pattern </I> are returned. </DD>

<DT><B>busy release <I>window 
</I></B> ?<I>window </I>?...  </DT>
<DD>Restores user interactions to the widget <I>window </I> again.  This 
differs from the <B>forget </B> operation in that the InputOnly window  is not 
destroyed, but simply unmapped.   <I>Window </I> must be the name of a widget 
specified  in a <B>hold </B> operation, otherwise an error is reported. </DD>

<DT><B>busy status 
<I>window </I></B>  </DT>
<DD>Returns the status of a widget <I>window </I> previously made busy. An 
error is reported if <I>window </I> was never made busy, or the <B>forget </B> operation 
was invoked (i.e. does not currently have a InputOnly window associated 
with it).  If <I>window </I> is presently can not receive user interaction, <I>1 
</I> is returned, otherwise <I>0 </I>. </DD>

<DT><B>busy windows  </B>?<I>pattern </I>?  </DT>
<DD>Returns the pathnames 
of all widget windows which have previously been made busy (i.e. an InputOnly 
is allocated and associated with the widget).  It makes no difference if 
the window is currently busy ot not.  If a <I>pattern </I> is given, the path 
names of busy widgets matching <I>pattern </I> are returned.  <P>
</DD>
</DL>
 
<H2><A NAME="sect6" HREF="#toc6">Bindings </A></H2>
The blocking 
feature is implemented by creating and mapping a transparent InputOnly 
class window which completely covers the widget.  When the InputOnly window 
is mapped, it intercepts all events which could be sent to the widget 
and its hierarchy.   Like Tk widgets, the InputOnly windows have names 
in the Tk window hierarchy.  This means that you can use the <B>bind </B>  command, 
to handle events in the InputOnly window.  <BR>
<P>
<CODE> busy hold .frame.canvas <BR>
 bind 
.frame.canvas_Busy &lt;Enter&gt; { ... }  <BR>
 <P>
</CODE><P>Typically, the InputOnly window is a sibling 
of the widget's window. The name of the InputOnly window will be "<I>widget<I>_Busy 
</I></I>" where  <I>widget </I> is the name of the widget made busy.  In the above example, 
the pathname of the InputOnly window is "<I>.frame.canvas_Busy </I>" The exception 
is when the widget is a toplevel window (such as "."). Then the InputOnly 
window is a child of the widget's window and the name of the widget will 
be "<I>widget<I>._Busy </I></I>" where <I>widget </I> is the name  of the widget made busy.  
In the following example, the pathname of the InputOnly window is "<I>._Busy 
</I>"   <BR>
<P>
<CODE> busy hold . <BR>
 bind ._Busy &lt;Enter&gt; { ... }  <BR>
 </CODE><P> 
<H2><A NAME="sect7" HREF="#toc7">Enter/Leave Events </A></H2>
Mapping and 
unmapping the InputOnly window generates Enter/Leave events for all widget 
(windows) that it covers.  Please note this when you are tracking Enter/Leave 
events in widgets.  
<H2><A NAME="sect8" HREF="#toc8">Keyboard Events </A></H2>
When a widget is made busy, the widget 
is prevented from gaining the keyboard focus by the InputOnly window. But 
Tk widgets can still get keyboard events if the keyboard focus is already 
set. Care must be taken to move focus to another window.  <BR>
<P>
<CODE> busy hold .frame 
<BR>
 label .dummy <BR>
 focus .dummy <BR>
 update <BR>
 </CODE><P>The above example moves the focus from 
.frame immediately after invoking the <B>hold </B> so that no keyboard events 
will be relayed to windows under the hierarchy of <I>.frame </I>.  
<H2><A NAME="sect9" HREF="#toc9">Keywords </A></H2>
busy, 
keyboard events, pointer events, window, cursor  
<!--
 
  
 <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Synopsis</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Description</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Introduction</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Example</A></LI>
<LI><A NAME="toc5" HREF="#sect5">Operations</A></LI>
<LI><A NAME="toc6" HREF="#sect6">Bindings</A></LI>
<LI><A NAME="toc7" HREF="#sect7">Enter/Leave Events</A></LI>
<LI><A NAME="toc8" HREF="#sect8">Keyboard Events</A></LI>
<LI><A NAME="toc9" HREF="#sect9">Keywords</A></LI>
</UL>
</BODY></HTML>
