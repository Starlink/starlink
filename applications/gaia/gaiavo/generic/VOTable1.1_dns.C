// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "VOTable1.1_dns.hxx"

namespace votable_11_dns
{
  // anyTEXT
  // 

  const anyTEXT::any_sequence& anyTEXT::
  any () const
  {
    return this->any_;
  }

  anyTEXT::any_sequence& anyTEXT::
  any ()
  {
    return this->any_;
  }

  void anyTEXT::
  any (const any_sequence& s)
  {
    this->any_ = s;
  }

  const ::xercesc::DOMDocument& anyTEXT::
  dom_document () const
  {
    return *dom_document_;
  }

  ::xercesc::DOMDocument& anyTEXT::
  dom_document ()
  {
    return *dom_document_;
  }


  // astroYear
  // 


  // ucdType
  // 


  // arrayDEF
  // 


  // encodingType
  // 

  encodingType::
  encodingType (value v)
  : ::xml_schema::nmtoken (_xsd_encodingType_literals_[v])
  {
  }

  encodingType::
  encodingType (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  encodingType::
  encodingType (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  encodingType::
  encodingType (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  encodingType::
  encodingType (const encodingType& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  encodingType& encodingType::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_encodingType_literals_[v]);

    return *this;
  }


  // dataType
  // 

  dataType::
  dataType (value v)
  : ::xml_schema::nmtoken (_xsd_dataType_literals_[v])
  {
  }

  dataType::
  dataType (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  dataType::
  dataType (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  dataType::
  dataType (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  dataType::
  dataType (const dataType& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  dataType& dataType::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_dataType_literals_[v]);

    return *this;
  }


  // precType
  // 


  // yesno
  // 

  yesno::
  yesno (value v)
  : ::xml_schema::nmtoken (_xsd_yesno_literals_[v])
  {
  }

  yesno::
  yesno (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  yesno::
  yesno (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  yesno::
  yesno (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  yesno::
  yesno (const yesno& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  yesno& yesno::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_yesno_literals_[v]);

    return *this;
  }


  // VOTABLE
  // 

  const VOTABLE::DESCRIPTION_optional& VOTABLE::
  DESCRIPTION () const
  {
    return this->DESCRIPTION_;
  }

  VOTABLE::DESCRIPTION_optional& VOTABLE::
  DESCRIPTION ()
  {
    return this->DESCRIPTION_;
  }

  void VOTABLE::
  DESCRIPTION (const DESCRIPTION_type& x)
  {
    this->DESCRIPTION_.set (x);
  }

  void VOTABLE::
  DESCRIPTION (const DESCRIPTION_optional& x)
  {
    this->DESCRIPTION_ = x;
  }

  void VOTABLE::
  DESCRIPTION (::std::auto_ptr< DESCRIPTION_type > x)
  {
    this->DESCRIPTION_.set (x);
  }

  const VOTABLE::DEFINITIONS_optional& VOTABLE::
  DEFINITIONS () const
  {
    return this->DEFINITIONS_;
  }

  VOTABLE::DEFINITIONS_optional& VOTABLE::
  DEFINITIONS ()
  {
    return this->DEFINITIONS_;
  }

  void VOTABLE::
  DEFINITIONS (const DEFINITIONS_type& x)
  {
    this->DEFINITIONS_.set (x);
  }

  void VOTABLE::
  DEFINITIONS (const DEFINITIONS_optional& x)
  {
    this->DEFINITIONS_ = x;
  }

  void VOTABLE::
  DEFINITIONS (::std::auto_ptr< DEFINITIONS_type > x)
  {
    this->DEFINITIONS_.set (x);
  }

  const VOTABLE::COOSYS_sequence& VOTABLE::
  COOSYS () const
  {
    return this->COOSYS_;
  }

  VOTABLE::COOSYS_sequence& VOTABLE::
  COOSYS ()
  {
    return this->COOSYS_;
  }

  void VOTABLE::
  COOSYS (const COOSYS_sequence& s)
  {
    this->COOSYS_ = s;
  }

  const VOTABLE::PARAM_sequence& VOTABLE::
  PARAM () const
  {
    return this->PARAM_;
  }

  VOTABLE::PARAM_sequence& VOTABLE::
  PARAM ()
  {
    return this->PARAM_;
  }

  void VOTABLE::
  PARAM (const PARAM_sequence& s)
  {
    this->PARAM_ = s;
  }

  const VOTABLE::INFO_sequence& VOTABLE::
  INFO () const
  {
    return this->INFO_;
  }

  VOTABLE::INFO_sequence& VOTABLE::
  INFO ()
  {
    return this->INFO_;
  }

  void VOTABLE::
  INFO (const INFO_sequence& s)
  {
    this->INFO_ = s;
  }

  const VOTABLE::RESOURCE_sequence& VOTABLE::
  RESOURCE () const
  {
    return this->RESOURCE_;
  }

  VOTABLE::RESOURCE_sequence& VOTABLE::
  RESOURCE ()
  {
    return this->RESOURCE_;
  }

  void VOTABLE::
  RESOURCE (const RESOURCE_sequence& s)
  {
    this->RESOURCE_ = s;
  }

  const VOTABLE::ID_optional& VOTABLE::
  ID () const
  {
    return this->ID_;
  }

  VOTABLE::ID_optional& VOTABLE::
  ID ()
  {
    return this->ID_;
  }

  void VOTABLE::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void VOTABLE::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void VOTABLE::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const VOTABLE::version_optional& VOTABLE::
  version () const
  {
    return this->version_;
  }

  VOTABLE::version_optional& VOTABLE::
  version ()
  {
    return this->version_;
  }

  void VOTABLE::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void VOTABLE::
  version (const version_optional& x)
  {
    this->version_ = x;
  }

  void VOTABLE::
  version (::std::auto_ptr< version_type > x)
  {
    this->version_.set (x);
  }


  // RESOURCE
  // 

  const RESOURCE::DESCRIPTION_optional& RESOURCE::
  DESCRIPTION () const
  {
    return this->DESCRIPTION_;
  }

  RESOURCE::DESCRIPTION_optional& RESOURCE::
  DESCRIPTION ()
  {
    return this->DESCRIPTION_;
  }

  void RESOURCE::
  DESCRIPTION (const DESCRIPTION_type& x)
  {
    this->DESCRIPTION_.set (x);
  }

  void RESOURCE::
  DESCRIPTION (const DESCRIPTION_optional& x)
  {
    this->DESCRIPTION_ = x;
  }

  void RESOURCE::
  DESCRIPTION (::std::auto_ptr< DESCRIPTION_type > x)
  {
    this->DESCRIPTION_.set (x);
  }

  const RESOURCE::INFO_sequence& RESOURCE::
  INFO () const
  {
    return this->INFO_;
  }

  RESOURCE::INFO_sequence& RESOURCE::
  INFO ()
  {
    return this->INFO_;
  }

  void RESOURCE::
  INFO (const INFO_sequence& s)
  {
    this->INFO_ = s;
  }

  const RESOURCE::COOSYS_sequence& RESOURCE::
  COOSYS () const
  {
    return this->COOSYS_;
  }

  RESOURCE::COOSYS_sequence& RESOURCE::
  COOSYS ()
  {
    return this->COOSYS_;
  }

  void RESOURCE::
  COOSYS (const COOSYS_sequence& s)
  {
    this->COOSYS_ = s;
  }

  const RESOURCE::PARAM_sequence& RESOURCE::
  PARAM () const
  {
    return this->PARAM_;
  }

  RESOURCE::PARAM_sequence& RESOURCE::
  PARAM ()
  {
    return this->PARAM_;
  }

  void RESOURCE::
  PARAM (const PARAM_sequence& s)
  {
    this->PARAM_ = s;
  }

  const RESOURCE::LINK_sequence& RESOURCE::
  LINK () const
  {
    return this->LINK_;
  }

  RESOURCE::LINK_sequence& RESOURCE::
  LINK ()
  {
    return this->LINK_;
  }

  void RESOURCE::
  LINK (const LINK_sequence& s)
  {
    this->LINK_ = s;
  }

  const RESOURCE::TABLE_sequence& RESOURCE::
  TABLE () const
  {
    return this->TABLE_;
  }

  RESOURCE::TABLE_sequence& RESOURCE::
  TABLE ()
  {
    return this->TABLE_;
  }

  void RESOURCE::
  TABLE (const TABLE_sequence& s)
  {
    this->TABLE_ = s;
  }

  const RESOURCE::RESOURCE1_sequence& RESOURCE::
  RESOURCE1 () const
  {
    return this->RESOURCE1_;
  }

  RESOURCE::RESOURCE1_sequence& RESOURCE::
  RESOURCE1 ()
  {
    return this->RESOURCE1_;
  }

  void RESOURCE::
  RESOURCE1 (const RESOURCE1_sequence& s)
  {
    this->RESOURCE1_ = s;
  }

  const RESOURCE::any_sequence& RESOURCE::
  any () const
  {
    return this->any_;
  }

  RESOURCE::any_sequence& RESOURCE::
  any ()
  {
    return this->any_;
  }

  void RESOURCE::
  any (const any_sequence& s)
  {
    this->any_ = s;
  }

  const RESOURCE::name_optional& RESOURCE::
  name () const
  {
    return this->name_;
  }

  RESOURCE::name_optional& RESOURCE::
  name ()
  {
    return this->name_;
  }

  void RESOURCE::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void RESOURCE::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void RESOURCE::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const RESOURCE::ID_optional& RESOURCE::
  ID () const
  {
    return this->ID_;
  }

  RESOURCE::ID_optional& RESOURCE::
  ID ()
  {
    return this->ID_;
  }

  void RESOURCE::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void RESOURCE::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void RESOURCE::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const RESOURCE::utype_optional& RESOURCE::
  utype () const
  {
    return this->utype_;
  }

  RESOURCE::utype_optional& RESOURCE::
  utype ()
  {
    return this->utype_;
  }

  void RESOURCE::
  utype (const utype_type& x)
  {
    this->utype_.set (x);
  }

  void RESOURCE::
  utype (const utype_optional& x)
  {
    this->utype_ = x;
  }

  void RESOURCE::
  utype (::std::auto_ptr< utype_type > x)
  {
    this->utype_.set (x);
  }

  const RESOURCE::type_type& RESOURCE::
  type () const
  {
    return this->type_.get ();
  }

  RESOURCE::type_type& RESOURCE::
  type ()
  {
    return this->type_.get ();
  }

  void RESOURCE::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void RESOURCE::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const RESOURCE::type_type& RESOURCE::
  type_default_value ()
  {
    return type_default_value_;
  }

  const RESOURCE::any_attribute_set& RESOURCE::
  any_attribute () const
  {
    return this->any_attribute_;
  }

  RESOURCE::any_attribute_set& RESOURCE::
  any_attribute ()
  {
    return this->any_attribute_;
  }

  void RESOURCE::
  any_attribute (const any_attribute_set& s)
  {
    this->any_attribute_ = s;
  }

  const ::xercesc::DOMDocument& RESOURCE::
  dom_document () const
  {
    return *dom_document_;
  }

  ::xercesc::DOMDocument& RESOURCE::
  dom_document ()
  {
    return *dom_document_;
  }


  // DEFINITIONS
  // 

  const DEFINITIONS::COOSYS_sequence& DEFINITIONS::
  COOSYS () const
  {
    return this->COOSYS_;
  }

  DEFINITIONS::COOSYS_sequence& DEFINITIONS::
  COOSYS ()
  {
    return this->COOSYS_;
  }

  void DEFINITIONS::
  COOSYS (const COOSYS_sequence& s)
  {
    this->COOSYS_ = s;
  }

  const DEFINITIONS::PARAM_sequence& DEFINITIONS::
  PARAM () const
  {
    return this->PARAM_;
  }

  DEFINITIONS::PARAM_sequence& DEFINITIONS::
  PARAM ()
  {
    return this->PARAM_;
  }

  void DEFINITIONS::
  PARAM (const PARAM_sequence& s)
  {
    this->PARAM_ = s;
  }


  // INFO
  // 

  const INFO::ID_optional& INFO::
  ID () const
  {
    return this->ID_;
  }

  INFO::ID_optional& INFO::
  ID ()
  {
    return this->ID_;
  }

  void INFO::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void INFO::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void INFO::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const INFO::name_optional& INFO::
  name () const
  {
    return this->name_;
  }

  INFO::name_optional& INFO::
  name ()
  {
    return this->name_;
  }

  void INFO::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void INFO::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void INFO::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const INFO::value_optional& INFO::
  value () const
  {
    return this->value_;
  }

  INFO::value_optional& INFO::
  value ()
  {
    return this->value_;
  }

  void INFO::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void INFO::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void INFO::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // PARAM
  // 

  const PARAM::DESCRIPTION_optional& PARAM::
  DESCRIPTION () const
  {
    return this->DESCRIPTION_;
  }

  PARAM::DESCRIPTION_optional& PARAM::
  DESCRIPTION ()
  {
    return this->DESCRIPTION_;
  }

  void PARAM::
  DESCRIPTION (const DESCRIPTION_type& x)
  {
    this->DESCRIPTION_.set (x);
  }

  void PARAM::
  DESCRIPTION (const DESCRIPTION_optional& x)
  {
    this->DESCRIPTION_ = x;
  }

  void PARAM::
  DESCRIPTION (::std::auto_ptr< DESCRIPTION_type > x)
  {
    this->DESCRIPTION_.set (x);
  }

  const PARAM::VALUES_optional& PARAM::
  VALUES () const
  {
    return this->VALUES_;
  }

  PARAM::VALUES_optional& PARAM::
  VALUES ()
  {
    return this->VALUES_;
  }

  void PARAM::
  VALUES (const VALUES_type& x)
  {
    this->VALUES_.set (x);
  }

  void PARAM::
  VALUES (const VALUES_optional& x)
  {
    this->VALUES_ = x;
  }

  void PARAM::
  VALUES (::std::auto_ptr< VALUES_type > x)
  {
    this->VALUES_.set (x);
  }

  const PARAM::LINK_sequence& PARAM::
  LINK () const
  {
    return this->LINK_;
  }

  PARAM::LINK_sequence& PARAM::
  LINK ()
  {
    return this->LINK_;
  }

  void PARAM::
  LINK (const LINK_sequence& s)
  {
    this->LINK_ = s;
  }

  const PARAM::ID_optional& PARAM::
  ID () const
  {
    return this->ID_;
  }

  PARAM::ID_optional& PARAM::
  ID ()
  {
    return this->ID_;
  }

  void PARAM::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void PARAM::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void PARAM::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const PARAM::unit_optional& PARAM::
  unit () const
  {
    return this->unit_;
  }

  PARAM::unit_optional& PARAM::
  unit ()
  {
    return this->unit_;
  }

  void PARAM::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void PARAM::
  unit (const unit_optional& x)
  {
    this->unit_ = x;
  }

  void PARAM::
  unit (::std::auto_ptr< unit_type > x)
  {
    this->unit_.set (x);
  }

  const PARAM::datatype_optional& PARAM::
  datatype () const
  {
    return this->datatype_;
  }

  PARAM::datatype_optional& PARAM::
  datatype ()
  {
    return this->datatype_;
  }

  void PARAM::
  datatype (const datatype_type& x)
  {
    this->datatype_.set (x);
  }

  void PARAM::
  datatype (const datatype_optional& x)
  {
    this->datatype_ = x;
  }

  void PARAM::
  datatype (::std::auto_ptr< datatype_type > x)
  {
    this->datatype_.set (x);
  }

  const PARAM::precision_optional& PARAM::
  precision () const
  {
    return this->precision_;
  }

  PARAM::precision_optional& PARAM::
  precision ()
  {
    return this->precision_;
  }

  void PARAM::
  precision (const precision_type& x)
  {
    this->precision_.set (x);
  }

  void PARAM::
  precision (const precision_optional& x)
  {
    this->precision_ = x;
  }

  void PARAM::
  precision (::std::auto_ptr< precision_type > x)
  {
    this->precision_.set (x);
  }

  const PARAM::width_optional& PARAM::
  width () const
  {
    return this->width_;
  }

  PARAM::width_optional& PARAM::
  width ()
  {
    return this->width_;
  }

  void PARAM::
  width (const width_type& x)
  {
    this->width_.set (x);
  }

  void PARAM::
  width (const width_optional& x)
  {
    this->width_ = x;
  }

  const PARAM::ref_optional& PARAM::
  ref () const
  {
    return this->ref_;
  }

  PARAM::ref_optional& PARAM::
  ref ()
  {
    return this->ref_;
  }

  void PARAM::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void PARAM::
  ref (const ref_optional& x)
  {
    this->ref_ = x;
  }

  void PARAM::
  ref (::std::auto_ptr< ref_type > x)
  {
    this->ref_.set (x);
  }

  const PARAM::name_optional& PARAM::
  name () const
  {
    return this->name_;
  }

  PARAM::name_optional& PARAM::
  name ()
  {
    return this->name_;
  }

  void PARAM::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void PARAM::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void PARAM::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const PARAM::ucd_optional& PARAM::
  ucd () const
  {
    return this->ucd_;
  }

  PARAM::ucd_optional& PARAM::
  ucd ()
  {
    return this->ucd_;
  }

  void PARAM::
  ucd (const ucd_type& x)
  {
    this->ucd_.set (x);
  }

  void PARAM::
  ucd (const ucd_optional& x)
  {
    this->ucd_ = x;
  }

  void PARAM::
  ucd (::std::auto_ptr< ucd_type > x)
  {
    this->ucd_.set (x);
  }

  const PARAM::utype_optional& PARAM::
  utype () const
  {
    return this->utype_;
  }

  PARAM::utype_optional& PARAM::
  utype ()
  {
    return this->utype_;
  }

  void PARAM::
  utype (const utype_type& x)
  {
    this->utype_.set (x);
  }

  void PARAM::
  utype (const utype_optional& x)
  {
    this->utype_ = x;
  }

  void PARAM::
  utype (::std::auto_ptr< utype_type > x)
  {
    this->utype_.set (x);
  }

  const PARAM::value_optional& PARAM::
  value () const
  {
    return this->value_;
  }

  PARAM::value_optional& PARAM::
  value ()
  {
    return this->value_;
  }

  void PARAM::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void PARAM::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void PARAM::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const PARAM::arraysize_optional& PARAM::
  arraysize () const
  {
    return this->arraysize_;
  }

  PARAM::arraysize_optional& PARAM::
  arraysize ()
  {
    return this->arraysize_;
  }

  void PARAM::
  arraysize (const arraysize_type& x)
  {
    this->arraysize_.set (x);
  }

  void PARAM::
  arraysize (const arraysize_optional& x)
  {
    this->arraysize_ = x;
  }

  void PARAM::
  arraysize (::std::auto_ptr< arraysize_type > x)
  {
    this->arraysize_.set (x);
  }


  // TABLE
  // 

  const TABLE::DESCRIPTION_optional& TABLE::
  DESCRIPTION () const
  {
    return this->DESCRIPTION_;
  }

  TABLE::DESCRIPTION_optional& TABLE::
  DESCRIPTION ()
  {
    return this->DESCRIPTION_;
  }

  void TABLE::
  DESCRIPTION (const DESCRIPTION_type& x)
  {
    this->DESCRIPTION_.set (x);
  }

  void TABLE::
  DESCRIPTION (const DESCRIPTION_optional& x)
  {
    this->DESCRIPTION_ = x;
  }

  void TABLE::
  DESCRIPTION (::std::auto_ptr< DESCRIPTION_type > x)
  {
    this->DESCRIPTION_.set (x);
  }

  const TABLE::FIELD_sequence& TABLE::
  FIELD () const
  {
    return this->FIELD_;
  }

  TABLE::FIELD_sequence& TABLE::
  FIELD ()
  {
    return this->FIELD_;
  }

  void TABLE::
  FIELD (const FIELD_sequence& s)
  {
    this->FIELD_ = s;
  }

  const TABLE::PARAM_sequence& TABLE::
  PARAM () const
  {
    return this->PARAM_;
  }

  TABLE::PARAM_sequence& TABLE::
  PARAM ()
  {
    return this->PARAM_;
  }

  void TABLE::
  PARAM (const PARAM_sequence& s)
  {
    this->PARAM_ = s;
  }

  const TABLE::GROUP_sequence& TABLE::
  GROUP () const
  {
    return this->GROUP_;
  }

  TABLE::GROUP_sequence& TABLE::
  GROUP ()
  {
    return this->GROUP_;
  }

  void TABLE::
  GROUP (const GROUP_sequence& s)
  {
    this->GROUP_ = s;
  }

  const TABLE::LINK_sequence& TABLE::
  LINK () const
  {
    return this->LINK_;
  }

  TABLE::LINK_sequence& TABLE::
  LINK ()
  {
    return this->LINK_;
  }

  void TABLE::
  LINK (const LINK_sequence& s)
  {
    this->LINK_ = s;
  }

  const TABLE::DATA_optional& TABLE::
  DATA () const
  {
    return this->DATA_;
  }

  TABLE::DATA_optional& TABLE::
  DATA ()
  {
    return this->DATA_;
  }

  void TABLE::
  DATA (const DATA_type& x)
  {
    this->DATA_.set (x);
  }

  void TABLE::
  DATA (const DATA_optional& x)
  {
    this->DATA_ = x;
  }

  void TABLE::
  DATA (::std::auto_ptr< DATA_type > x)
  {
    this->DATA_.set (x);
  }

  const TABLE::ID_optional& TABLE::
  ID () const
  {
    return this->ID_;
  }

  TABLE::ID_optional& TABLE::
  ID ()
  {
    return this->ID_;
  }

  void TABLE::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void TABLE::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void TABLE::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const TABLE::name_optional& TABLE::
  name () const
  {
    return this->name_;
  }

  TABLE::name_optional& TABLE::
  name ()
  {
    return this->name_;
  }

  void TABLE::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void TABLE::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void TABLE::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const TABLE::ref_optional& TABLE::
  ref () const
  {
    return this->ref_;
  }

  TABLE::ref_optional& TABLE::
  ref ()
  {
    return this->ref_;
  }

  void TABLE::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void TABLE::
  ref (const ref_optional& x)
  {
    this->ref_ = x;
  }

  void TABLE::
  ref (::std::auto_ptr< ref_type > x)
  {
    this->ref_.set (x);
  }

  const TABLE::ucd_optional& TABLE::
  ucd () const
  {
    return this->ucd_;
  }

  TABLE::ucd_optional& TABLE::
  ucd ()
  {
    return this->ucd_;
  }

  void TABLE::
  ucd (const ucd_type& x)
  {
    this->ucd_.set (x);
  }

  void TABLE::
  ucd (const ucd_optional& x)
  {
    this->ucd_ = x;
  }

  void TABLE::
  ucd (::std::auto_ptr< ucd_type > x)
  {
    this->ucd_.set (x);
  }

  const TABLE::utype_optional& TABLE::
  utype () const
  {
    return this->utype_;
  }

  TABLE::utype_optional& TABLE::
  utype ()
  {
    return this->utype_;
  }

  void TABLE::
  utype (const utype_type& x)
  {
    this->utype_.set (x);
  }

  void TABLE::
  utype (const utype_optional& x)
  {
    this->utype_ = x;
  }

  void TABLE::
  utype (::std::auto_ptr< utype_type > x)
  {
    this->utype_.set (x);
  }

  const TABLE::nrows_optional& TABLE::
  nrows () const
  {
    return this->nrows_;
  }

  TABLE::nrows_optional& TABLE::
  nrows ()
  {
    return this->nrows_;
  }

  void TABLE::
  nrows (const nrows_type& x)
  {
    this->nrows_.set (x);
  }

  void TABLE::
  nrows (const nrows_optional& x)
  {
    this->nrows_ = x;
  }


  // FIELD
  // 

  const FIELD::DESCRIPTION_optional& FIELD::
  DESCRIPTION () const
  {
    return this->DESCRIPTION_;
  }

  FIELD::DESCRIPTION_optional& FIELD::
  DESCRIPTION ()
  {
    return this->DESCRIPTION_;
  }

  void FIELD::
  DESCRIPTION (const DESCRIPTION_type& x)
  {
    this->DESCRIPTION_.set (x);
  }

  void FIELD::
  DESCRIPTION (const DESCRIPTION_optional& x)
  {
    this->DESCRIPTION_ = x;
  }

  void FIELD::
  DESCRIPTION (::std::auto_ptr< DESCRIPTION_type > x)
  {
    this->DESCRIPTION_.set (x);
  }

  const FIELD::VALUES_optional& FIELD::
  VALUES () const
  {
    return this->VALUES_;
  }

  FIELD::VALUES_optional& FIELD::
  VALUES ()
  {
    return this->VALUES_;
  }

  void FIELD::
  VALUES (const VALUES_type& x)
  {
    this->VALUES_.set (x);
  }

  void FIELD::
  VALUES (const VALUES_optional& x)
  {
    this->VALUES_ = x;
  }

  void FIELD::
  VALUES (::std::auto_ptr< VALUES_type > x)
  {
    this->VALUES_.set (x);
  }

  const FIELD::LINK_sequence& FIELD::
  LINK () const
  {
    return this->LINK_;
  }

  FIELD::LINK_sequence& FIELD::
  LINK ()
  {
    return this->LINK_;
  }

  void FIELD::
  LINK (const LINK_sequence& s)
  {
    this->LINK_ = s;
  }

  const FIELD::ID_optional& FIELD::
  ID () const
  {
    return this->ID_;
  }

  FIELD::ID_optional& FIELD::
  ID ()
  {
    return this->ID_;
  }

  void FIELD::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void FIELD::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void FIELD::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const FIELD::unit_optional& FIELD::
  unit () const
  {
    return this->unit_;
  }

  FIELD::unit_optional& FIELD::
  unit ()
  {
    return this->unit_;
  }

  void FIELD::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void FIELD::
  unit (const unit_optional& x)
  {
    this->unit_ = x;
  }

  void FIELD::
  unit (::std::auto_ptr< unit_type > x)
  {
    this->unit_.set (x);
  }

  const FIELD::datatype_optional& FIELD::
  datatype () const
  {
    return this->datatype_;
  }

  FIELD::datatype_optional& FIELD::
  datatype ()
  {
    return this->datatype_;
  }

  void FIELD::
  datatype (const datatype_type& x)
  {
    this->datatype_.set (x);
  }

  void FIELD::
  datatype (const datatype_optional& x)
  {
    this->datatype_ = x;
  }

  void FIELD::
  datatype (::std::auto_ptr< datatype_type > x)
  {
    this->datatype_.set (x);
  }

  const FIELD::precision_optional& FIELD::
  precision () const
  {
    return this->precision_;
  }

  FIELD::precision_optional& FIELD::
  precision ()
  {
    return this->precision_;
  }

  void FIELD::
  precision (const precision_type& x)
  {
    this->precision_.set (x);
  }

  void FIELD::
  precision (const precision_optional& x)
  {
    this->precision_ = x;
  }

  void FIELD::
  precision (::std::auto_ptr< precision_type > x)
  {
    this->precision_.set (x);
  }

  const FIELD::width_optional& FIELD::
  width () const
  {
    return this->width_;
  }

  FIELD::width_optional& FIELD::
  width ()
  {
    return this->width_;
  }

  void FIELD::
  width (const width_type& x)
  {
    this->width_.set (x);
  }

  void FIELD::
  width (const width_optional& x)
  {
    this->width_ = x;
  }

  const FIELD::ref_optional& FIELD::
  ref () const
  {
    return this->ref_;
  }

  FIELD::ref_optional& FIELD::
  ref ()
  {
    return this->ref_;
  }

  void FIELD::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void FIELD::
  ref (const ref_optional& x)
  {
    this->ref_ = x;
  }

  void FIELD::
  ref (::std::auto_ptr< ref_type > x)
  {
    this->ref_.set (x);
  }

  const FIELD::name_optional& FIELD::
  name () const
  {
    return this->name_;
  }

  FIELD::name_optional& FIELD::
  name ()
  {
    return this->name_;
  }

  void FIELD::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void FIELD::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void FIELD::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const FIELD::ucd_optional& FIELD::
  ucd () const
  {
    return this->ucd_;
  }

  FIELD::ucd_optional& FIELD::
  ucd ()
  {
    return this->ucd_;
  }

  void FIELD::
  ucd (const ucd_type& x)
  {
    this->ucd_.set (x);
  }

  void FIELD::
  ucd (const ucd_optional& x)
  {
    this->ucd_ = x;
  }

  void FIELD::
  ucd (::std::auto_ptr< ucd_type > x)
  {
    this->ucd_.set (x);
  }

  const FIELD::utype_optional& FIELD::
  utype () const
  {
    return this->utype_;
  }

  FIELD::utype_optional& FIELD::
  utype ()
  {
    return this->utype_;
  }

  void FIELD::
  utype (const utype_type& x)
  {
    this->utype_.set (x);
  }

  void FIELD::
  utype (const utype_optional& x)
  {
    this->utype_ = x;
  }

  void FIELD::
  utype (::std::auto_ptr< utype_type > x)
  {
    this->utype_.set (x);
  }

  const FIELD::arraysize_optional& FIELD::
  arraysize () const
  {
    return this->arraysize_;
  }

  FIELD::arraysize_optional& FIELD::
  arraysize ()
  {
    return this->arraysize_;
  }

  void FIELD::
  arraysize (const arraysize_type& x)
  {
    this->arraysize_.set (x);
  }

  void FIELD::
  arraysize (const arraysize_optional& x)
  {
    this->arraysize_ = x;
  }

  void FIELD::
  arraysize (::std::auto_ptr< arraysize_type > x)
  {
    this->arraysize_.set (x);
  }

  const FIELD::type_optional& FIELD::
  type () const
  {
    return this->type_;
  }

  FIELD::type_optional& FIELD::
  type ()
  {
    return this->type_;
  }

  void FIELD::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void FIELD::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void FIELD::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }


  // GROUP
  // 

  const GROUP::DESCRIPTION_optional& GROUP::
  DESCRIPTION () const
  {
    return this->DESCRIPTION_;
  }

  GROUP::DESCRIPTION_optional& GROUP::
  DESCRIPTION ()
  {
    return this->DESCRIPTION_;
  }

  void GROUP::
  DESCRIPTION (const DESCRIPTION_type& x)
  {
    this->DESCRIPTION_.set (x);
  }

  void GROUP::
  DESCRIPTION (const DESCRIPTION_optional& x)
  {
    this->DESCRIPTION_ = x;
  }

  void GROUP::
  DESCRIPTION (::std::auto_ptr< DESCRIPTION_type > x)
  {
    this->DESCRIPTION_.set (x);
  }

  const GROUP::FIELDref_sequence& GROUP::
  FIELDref () const
  {
    return this->FIELDref_;
  }

  GROUP::FIELDref_sequence& GROUP::
  FIELDref ()
  {
    return this->FIELDref_;
  }

  void GROUP::
  FIELDref (const FIELDref_sequence& s)
  {
    this->FIELDref_ = s;
  }

  const GROUP::PARAMref_sequence& GROUP::
  PARAMref () const
  {
    return this->PARAMref_;
  }

  GROUP::PARAMref_sequence& GROUP::
  PARAMref ()
  {
    return this->PARAMref_;
  }

  void GROUP::
  PARAMref (const PARAMref_sequence& s)
  {
    this->PARAMref_ = s;
  }

  const GROUP::PARAM_sequence& GROUP::
  PARAM () const
  {
    return this->PARAM_;
  }

  GROUP::PARAM_sequence& GROUP::
  PARAM ()
  {
    return this->PARAM_;
  }

  void GROUP::
  PARAM (const PARAM_sequence& s)
  {
    this->PARAM_ = s;
  }

  const GROUP::GROUP1_sequence& GROUP::
  GROUP1 () const
  {
    return this->GROUP1_;
  }

  GROUP::GROUP1_sequence& GROUP::
  GROUP1 ()
  {
    return this->GROUP1_;
  }

  void GROUP::
  GROUP1 (const GROUP1_sequence& s)
  {
    this->GROUP1_ = s;
  }

  const GROUP::ID_optional& GROUP::
  ID () const
  {
    return this->ID_;
  }

  GROUP::ID_optional& GROUP::
  ID ()
  {
    return this->ID_;
  }

  void GROUP::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void GROUP::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void GROUP::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const GROUP::name_optional& GROUP::
  name () const
  {
    return this->name_;
  }

  GROUP::name_optional& GROUP::
  name ()
  {
    return this->name_;
  }

  void GROUP::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void GROUP::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void GROUP::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const GROUP::ref_optional& GROUP::
  ref () const
  {
    return this->ref_;
  }

  GROUP::ref_optional& GROUP::
  ref ()
  {
    return this->ref_;
  }

  void GROUP::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void GROUP::
  ref (const ref_optional& x)
  {
    this->ref_ = x;
  }

  void GROUP::
  ref (::std::auto_ptr< ref_type > x)
  {
    this->ref_.set (x);
  }

  const GROUP::ucd_optional& GROUP::
  ucd () const
  {
    return this->ucd_;
  }

  GROUP::ucd_optional& GROUP::
  ucd ()
  {
    return this->ucd_;
  }

  void GROUP::
  ucd (const ucd_type& x)
  {
    this->ucd_.set (x);
  }

  void GROUP::
  ucd (const ucd_optional& x)
  {
    this->ucd_ = x;
  }

  void GROUP::
  ucd (::std::auto_ptr< ucd_type > x)
  {
    this->ucd_.set (x);
  }

  const GROUP::utype_optional& GROUP::
  utype () const
  {
    return this->utype_;
  }

  GROUP::utype_optional& GROUP::
  utype ()
  {
    return this->utype_;
  }

  void GROUP::
  utype (const utype_type& x)
  {
    this->utype_.set (x);
  }

  void GROUP::
  utype (const utype_optional& x)
  {
    this->utype_ = x;
  }

  void GROUP::
  utype (::std::auto_ptr< utype_type > x)
  {
    this->utype_.set (x);
  }


  // FIELDref
  // 

  const FIELDref::ref_type& FIELDref::
  ref () const
  {
    return this->ref_.get ();
  }

  FIELDref::ref_type& FIELDref::
  ref ()
  {
    return this->ref_.get ();
  }

  void FIELDref::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void FIELDref::
  ref (::std::auto_ptr< ref_type > x)
  {
    this->ref_.set (x);
  }


  // PARAMref
  // 

  const PARAMref::ref_type& PARAMref::
  ref () const
  {
    return this->ref_.get ();
  }

  PARAMref::ref_type& PARAMref::
  ref ()
  {
    return this->ref_.get ();
  }

  void PARAMref::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void PARAMref::
  ref (::std::auto_ptr< ref_type > x)
  {
    this->ref_.set (x);
  }


  // VALUES
  // 

  const VALUES::MIN_optional& VALUES::
  MIN () const
  {
    return this->MIN_;
  }

  VALUES::MIN_optional& VALUES::
  MIN ()
  {
    return this->MIN_;
  }

  void VALUES::
  MIN (const MIN_type& x)
  {
    this->MIN_.set (x);
  }

  void VALUES::
  MIN (const MIN_optional& x)
  {
    this->MIN_ = x;
  }

  void VALUES::
  MIN (::std::auto_ptr< MIN_type > x)
  {
    this->MIN_.set (x);
  }

  const VALUES::MAX_optional& VALUES::
  MAX () const
  {
    return this->MAX_;
  }

  VALUES::MAX_optional& VALUES::
  MAX ()
  {
    return this->MAX_;
  }

  void VALUES::
  MAX (const MAX_type& x)
  {
    this->MAX_.set (x);
  }

  void VALUES::
  MAX (const MAX_optional& x)
  {
    this->MAX_ = x;
  }

  void VALUES::
  MAX (::std::auto_ptr< MAX_type > x)
  {
    this->MAX_.set (x);
  }

  const VALUES::OPTION_sequence& VALUES::
  OPTION () const
  {
    return this->OPTION_;
  }

  VALUES::OPTION_sequence& VALUES::
  OPTION ()
  {
    return this->OPTION_;
  }

  void VALUES::
  OPTION (const OPTION_sequence& s)
  {
    this->OPTION_ = s;
  }

  const VALUES::ID_optional& VALUES::
  ID () const
  {
    return this->ID_;
  }

  VALUES::ID_optional& VALUES::
  ID ()
  {
    return this->ID_;
  }

  void VALUES::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void VALUES::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void VALUES::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const VALUES::type_type& VALUES::
  type () const
  {
    return this->type_.get ();
  }

  VALUES::type_type& VALUES::
  type ()
  {
    return this->type_.get ();
  }

  void VALUES::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void VALUES::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const VALUES::type_type& VALUES::
  type_default_value ()
  {
    return type_default_value_;
  }

  const VALUES::null_optional& VALUES::
  null () const
  {
    return this->null_;
  }

  VALUES::null_optional& VALUES::
  null ()
  {
    return this->null_;
  }

  void VALUES::
  null (const null_type& x)
  {
    this->null_.set (x);
  }

  void VALUES::
  null (const null_optional& x)
  {
    this->null_ = x;
  }

  void VALUES::
  null (::std::auto_ptr< null_type > x)
  {
    this->null_.set (x);
  }

  const VALUES::ref_optional& VALUES::
  ref () const
  {
    return this->ref_;
  }

  VALUES::ref_optional& VALUES::
  ref ()
  {
    return this->ref_;
  }

  void VALUES::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void VALUES::
  ref (const ref_optional& x)
  {
    this->ref_ = x;
  }

  void VALUES::
  ref (::std::auto_ptr< ref_type > x)
  {
    this->ref_.set (x);
  }


  // MIN
  // 

  const MIN::value_type& MIN::
  value () const
  {
    return this->value_.get ();
  }

  MIN::value_type& MIN::
  value ()
  {
    return this->value_.get ();
  }

  void MIN::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void MIN::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const MIN::inclusive_type& MIN::
  inclusive () const
  {
    return this->inclusive_.get ();
  }

  MIN::inclusive_type& MIN::
  inclusive ()
  {
    return this->inclusive_.get ();
  }

  void MIN::
  inclusive (const inclusive_type& x)
  {
    this->inclusive_.set (x);
  }

  void MIN::
  inclusive (::std::auto_ptr< inclusive_type > x)
  {
    this->inclusive_.set (x);
  }

  const MIN::inclusive_type& MIN::
  inclusive_default_value ()
  {
    return inclusive_default_value_;
  }


  // MAX
  // 

  const MAX::value_type& MAX::
  value () const
  {
    return this->value_.get ();
  }

  MAX::value_type& MAX::
  value ()
  {
    return this->value_.get ();
  }

  void MAX::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void MAX::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const MAX::inclusive_type& MAX::
  inclusive () const
  {
    return this->inclusive_.get ();
  }

  MAX::inclusive_type& MAX::
  inclusive ()
  {
    return this->inclusive_.get ();
  }

  void MAX::
  inclusive (const inclusive_type& x)
  {
    this->inclusive_.set (x);
  }

  void MAX::
  inclusive (::std::auto_ptr< inclusive_type > x)
  {
    this->inclusive_.set (x);
  }

  const MAX::inclusive_type& MAX::
  inclusive_default_value ()
  {
    return inclusive_default_value_;
  }


  // OPTION
  // 

  const OPTION::OPTION1_sequence& OPTION::
  OPTION1 () const
  {
    return this->OPTION1_;
  }

  OPTION::OPTION1_sequence& OPTION::
  OPTION1 ()
  {
    return this->OPTION1_;
  }

  void OPTION::
  OPTION1 (const OPTION1_sequence& s)
  {
    this->OPTION1_ = s;
  }

  const OPTION::name_optional& OPTION::
  name () const
  {
    return this->name_;
  }

  OPTION::name_optional& OPTION::
  name ()
  {
    return this->name_;
  }

  void OPTION::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void OPTION::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void OPTION::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const OPTION::value_optional& OPTION::
  value () const
  {
    return this->value_;
  }

  OPTION::value_optional& OPTION::
  value ()
  {
    return this->value_;
  }

  void OPTION::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void OPTION::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void OPTION::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // LINK
  // 

  const LINK::ID_optional& LINK::
  ID () const
  {
    return this->ID_;
  }

  LINK::ID_optional& LINK::
  ID ()
  {
    return this->ID_;
  }

  void LINK::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void LINK::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void LINK::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const LINK::content_role_optional& LINK::
  content_role () const
  {
    return this->content_role_;
  }

  LINK::content_role_optional& LINK::
  content_role ()
  {
    return this->content_role_;
  }

  void LINK::
  content_role (const content_role_type& x)
  {
    this->content_role_.set (x);
  }

  void LINK::
  content_role (const content_role_optional& x)
  {
    this->content_role_ = x;
  }

  void LINK::
  content_role (::std::auto_ptr< content_role_type > x)
  {
    this->content_role_.set (x);
  }

  const LINK::content_type_optional& LINK::
  content_type () const
  {
    return this->content_type_;
  }

  LINK::content_type_optional& LINK::
  content_type ()
  {
    return this->content_type_;
  }

  void LINK::
  content_type (const content_type_type& x)
  {
    this->content_type_.set (x);
  }

  void LINK::
  content_type (const content_type_optional& x)
  {
    this->content_type_ = x;
  }

  void LINK::
  content_type (::std::auto_ptr< content_type_type > x)
  {
    this->content_type_.set (x);
  }

  const LINK::title_optional& LINK::
  title () const
  {
    return this->title_;
  }

  LINK::title_optional& LINK::
  title ()
  {
    return this->title_;
  }

  void LINK::
  title (const title_type& x)
  {
    this->title_.set (x);
  }

  void LINK::
  title (const title_optional& x)
  {
    this->title_ = x;
  }

  void LINK::
  title (::std::auto_ptr< title_type > x)
  {
    this->title_.set (x);
  }

  const LINK::value_optional& LINK::
  value () const
  {
    return this->value_;
  }

  LINK::value_optional& LINK::
  value ()
  {
    return this->value_;
  }

  void LINK::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void LINK::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void LINK::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const LINK::href_optional& LINK::
  href () const
  {
    return this->href_;
  }

  LINK::href_optional& LINK::
  href ()
  {
    return this->href_;
  }

  void LINK::
  href (const href_type& x)
  {
    this->href_.set (x);
  }

  void LINK::
  href (const href_optional& x)
  {
    this->href_ = x;
  }

  void LINK::
  href (::std::auto_ptr< href_type > x)
  {
    this->href_.set (x);
  }

  const LINK::gref_optional& LINK::
  gref () const
  {
    return this->gref_;
  }

  LINK::gref_optional& LINK::
  gref ()
  {
    return this->gref_;
  }

  void LINK::
  gref (const gref_type& x)
  {
    this->gref_.set (x);
  }

  void LINK::
  gref (const gref_optional& x)
  {
    this->gref_ = x;
  }

  void LINK::
  gref (::std::auto_ptr< gref_type > x)
  {
    this->gref_.set (x);
  }

  const LINK::action_optional& LINK::
  action () const
  {
    return this->action_;
  }

  LINK::action_optional& LINK::
  action ()
  {
    return this->action_;
  }

  void LINK::
  action (const action_type& x)
  {
    this->action_.set (x);
  }

  void LINK::
  action (const action_optional& x)
  {
    this->action_ = x;
  }

  void LINK::
  action (::std::auto_ptr< action_type > x)
  {
    this->action_.set (x);
  }


  // DATA
  // 

  const DATA::TABLEDATA_optional& DATA::
  TABLEDATA () const
  {
    return this->TABLEDATA_;
  }

  DATA::TABLEDATA_optional& DATA::
  TABLEDATA ()
  {
    return this->TABLEDATA_;
  }

  void DATA::
  TABLEDATA (const TABLEDATA_type& x)
  {
    this->TABLEDATA_.set (x);
  }

  void DATA::
  TABLEDATA (const TABLEDATA_optional& x)
  {
    this->TABLEDATA_ = x;
  }

  void DATA::
  TABLEDATA (::std::auto_ptr< TABLEDATA_type > x)
  {
    this->TABLEDATA_.set (x);
  }

  const DATA::BINARY_optional& DATA::
  BINARY () const
  {
    return this->BINARY_;
  }

  DATA::BINARY_optional& DATA::
  BINARY ()
  {
    return this->BINARY_;
  }

  void DATA::
  BINARY (const BINARY_type& x)
  {
    this->BINARY_.set (x);
  }

  void DATA::
  BINARY (const BINARY_optional& x)
  {
    this->BINARY_ = x;
  }

  void DATA::
  BINARY (::std::auto_ptr< BINARY_type > x)
  {
    this->BINARY_.set (x);
  }

  const DATA::FITS_optional& DATA::
  FITS () const
  {
    return this->FITS_;
  }

  DATA::FITS_optional& DATA::
  FITS ()
  {
    return this->FITS_;
  }

  void DATA::
  FITS (const FITS_type& x)
  {
    this->FITS_.set (x);
  }

  void DATA::
  FITS (const FITS_optional& x)
  {
    this->FITS_ = x;
  }

  void DATA::
  FITS (::std::auto_ptr< FITS_type > x)
  {
    this->FITS_.set (x);
  }


  // TABLEDATA
  // 

  const TABLEDATA::TR_sequence& TABLEDATA::
  TR () const
  {
    return this->TR_;
  }

  TABLEDATA::TR_sequence& TABLEDATA::
  TR ()
  {
    return this->TR_;
  }

  void TABLEDATA::
  TR (const TR_sequence& s)
  {
    this->TR_ = s;
  }


  // TD
  // 

  const TD::encoding_optional& TD::
  encoding () const
  {
    return this->encoding_;
  }

  TD::encoding_optional& TD::
  encoding ()
  {
    return this->encoding_;
  }

  void TD::
  encoding (const encoding_type& x)
  {
    this->encoding_.set (x);
  }

  void TD::
  encoding (const encoding_optional& x)
  {
    this->encoding_ = x;
  }

  void TD::
  encoding (::std::auto_ptr< encoding_type > x)
  {
    this->encoding_.set (x);
  }


  // TR
  // 

  const TR::TD_sequence& TR::
  TD () const
  {
    return this->TD_;
  }

  TR::TD_sequence& TR::
  TD ()
  {
    return this->TD_;
  }

  void TR::
  TD (const TD_sequence& s)
  {
    this->TD_ = s;
  }


  // FITS
  // 

  const FITS::STREAM_type& FITS::
  STREAM () const
  {
    return this->STREAM_.get ();
  }

  FITS::STREAM_type& FITS::
  STREAM ()
  {
    return this->STREAM_.get ();
  }

  void FITS::
  STREAM (const STREAM_type& x)
  {
    this->STREAM_.set (x);
  }

  void FITS::
  STREAM (::std::auto_ptr< STREAM_type > x)
  {
    this->STREAM_.set (x);
  }

  const FITS::extnum_optional& FITS::
  extnum () const
  {
    return this->extnum_;
  }

  FITS::extnum_optional& FITS::
  extnum ()
  {
    return this->extnum_;
  }

  void FITS::
  extnum (const extnum_type& x)
  {
    this->extnum_.set (x);
  }

  void FITS::
  extnum (const extnum_optional& x)
  {
    this->extnum_ = x;
  }


  // BINARY
  // 

  const BINARY::STREAM_type& BINARY::
  STREAM () const
  {
    return this->STREAM_.get ();
  }

  BINARY::STREAM_type& BINARY::
  STREAM ()
  {
    return this->STREAM_.get ();
  }

  void BINARY::
  STREAM (const STREAM_type& x)
  {
    this->STREAM_.set (x);
  }

  void BINARY::
  STREAM (::std::auto_ptr< STREAM_type > x)
  {
    this->STREAM_.set (x);
  }


  // STREAM
  // 

  const STREAM::type_type& STREAM::
  type () const
  {
    return this->type_.get ();
  }

  STREAM::type_type& STREAM::
  type ()
  {
    return this->type_.get ();
  }

  void STREAM::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void STREAM::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const STREAM::type_type& STREAM::
  type_default_value ()
  {
    return type_default_value_;
  }

  const STREAM::href_optional& STREAM::
  href () const
  {
    return this->href_;
  }

  STREAM::href_optional& STREAM::
  href ()
  {
    return this->href_;
  }

  void STREAM::
  href (const href_type& x)
  {
    this->href_.set (x);
  }

  void STREAM::
  href (const href_optional& x)
  {
    this->href_ = x;
  }

  void STREAM::
  href (::std::auto_ptr< href_type > x)
  {
    this->href_.set (x);
  }

  const STREAM::actuate_type& STREAM::
  actuate () const
  {
    return this->actuate_.get ();
  }

  STREAM::actuate_type& STREAM::
  actuate ()
  {
    return this->actuate_.get ();
  }

  void STREAM::
  actuate (const actuate_type& x)
  {
    this->actuate_.set (x);
  }

  void STREAM::
  actuate (::std::auto_ptr< actuate_type > x)
  {
    this->actuate_.set (x);
  }

  const STREAM::actuate_type& STREAM::
  actuate_default_value ()
  {
    return actuate_default_value_;
  }

  const STREAM::encoding_type& STREAM::
  encoding () const
  {
    return this->encoding_.get ();
  }

  STREAM::encoding_type& STREAM::
  encoding ()
  {
    return this->encoding_.get ();
  }

  void STREAM::
  encoding (const encoding_type& x)
  {
    this->encoding_.set (x);
  }

  void STREAM::
  encoding (::std::auto_ptr< encoding_type > x)
  {
    this->encoding_.set (x);
  }

  const STREAM::encoding_type& STREAM::
  encoding_default_value ()
  {
    return encoding_default_value_;
  }

  const STREAM::expires_optional& STREAM::
  expires () const
  {
    return this->expires_;
  }

  STREAM::expires_optional& STREAM::
  expires ()
  {
    return this->expires_;
  }

  void STREAM::
  expires (const expires_type& x)
  {
    this->expires_.set (x);
  }

  void STREAM::
  expires (const expires_optional& x)
  {
    this->expires_ = x;
  }

  void STREAM::
  expires (::std::auto_ptr< expires_type > x)
  {
    this->expires_.set (x);
  }

  const STREAM::rights_optional& STREAM::
  rights () const
  {
    return this->rights_;
  }

  STREAM::rights_optional& STREAM::
  rights ()
  {
    return this->rights_;
  }

  void STREAM::
  rights (const rights_type& x)
  {
    this->rights_.set (x);
  }

  void STREAM::
  rights (const rights_optional& x)
  {
    this->rights_ = x;
  }

  void STREAM::
  rights (::std::auto_ptr< rights_type > x)
  {
    this->rights_.set (x);
  }


  // COOSYS
  // 

  const COOSYS::ID_optional& COOSYS::
  ID () const
  {
    return this->ID_;
  }

  COOSYS::ID_optional& COOSYS::
  ID ()
  {
    return this->ID_;
  }

  void COOSYS::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void COOSYS::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void COOSYS::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const COOSYS::equinox_optional& COOSYS::
  equinox () const
  {
    return this->equinox_;
  }

  COOSYS::equinox_optional& COOSYS::
  equinox ()
  {
    return this->equinox_;
  }

  void COOSYS::
  equinox (const equinox_type& x)
  {
    this->equinox_.set (x);
  }

  void COOSYS::
  equinox (const equinox_optional& x)
  {
    this->equinox_ = x;
  }

  void COOSYS::
  equinox (::std::auto_ptr< equinox_type > x)
  {
    this->equinox_.set (x);
  }

  const COOSYS::epoch_optional& COOSYS::
  epoch () const
  {
    return this->epoch_;
  }

  COOSYS::epoch_optional& COOSYS::
  epoch ()
  {
    return this->epoch_;
  }

  void COOSYS::
  epoch (const epoch_type& x)
  {
    this->epoch_.set (x);
  }

  void COOSYS::
  epoch (const epoch_optional& x)
  {
    this->epoch_ = x;
  }

  void COOSYS::
  epoch (::std::auto_ptr< epoch_type > x)
  {
    this->epoch_.set (x);
  }

  const COOSYS::system_type& COOSYS::
  system () const
  {
    return this->system_.get ();
  }

  COOSYS::system_type& COOSYS::
  system ()
  {
    return this->system_.get ();
  }

  void COOSYS::
  system (const system_type& x)
  {
    this->system_.set (x);
  }

  void COOSYS::
  system (::std::auto_ptr< system_type > x)
  {
    this->system_.set (x);
  }

  const COOSYS::system_type& COOSYS::
  system_default_value ()
  {
    return system_default_value_;
  }


  // version
  // 


  // type
  // 

  type::
  type (value v)
  : ::xml_schema::nmtoken (_xsd_type_literals_[v])
  {
  }

  type::
  type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type::
  type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type::
  type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type::
  type (const type& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  type& type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_type_literals_[v]);

    return *this;
  }


  // type1
  // 

  type1::
  type1 (value v)
  : ::xml_schema::nmtoken (_xsd_type1_literals_[v])
  {
  }

  type1::
  type1 (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type1::
  type1 (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type1::
  type1 (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type1::
  type1 (const type1& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  type1& type1::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_type1_literals_[v]);

    return *this;
  }


  // type2
  // 

  type2::
  type2 (value v)
  : ::xml_schema::nmtoken (_xsd_type2_literals_[v])
  {
  }

  type2::
  type2 (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type2::
  type2 (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type2::
  type2 (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type2::
  type2 (const type2& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  type2& type2::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_type2_literals_[v]);

    return *this;
  }


  // content_role
  // 

  content_role::
  content_role (value v)
  : ::xml_schema::nmtoken (_xsd_content_role_literals_[v])
  {
  }

  content_role::
  content_role (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  content_role::
  content_role (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  content_role::
  content_role (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  content_role::
  content_role (const content_role& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  content_role& content_role::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_content_role_literals_[v]);

    return *this;
  }


  // type3
  // 

  type3::
  type3 (value v)
  : ::xml_schema::nmtoken (_xsd_type3_literals_[v])
  {
  }

  type3::
  type3 (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type3::
  type3 (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type3::
  type3 (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type3::
  type3 (const type3& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  type3& type3::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_type3_literals_[v]);

    return *this;
  }


  // actuate
  // 

  actuate::
  actuate (value v)
  : ::xml_schema::nmtoken (_xsd_actuate_literals_[v])
  {
  }

  actuate::
  actuate (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  actuate::
  actuate (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  actuate::
  actuate (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  actuate::
  actuate (const actuate& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  actuate& actuate::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_actuate_literals_[v]);

    return *this;
  }


  // system
  // 

  system::
  system (value v)
  : ::xml_schema::nmtoken (_xsd_system_literals_[v])
  {
  }

  system::
  system (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  system::
  system (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  system::
  system (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  system::
  system (const system& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  system& system::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_system_literals_[v]);

    return *this;
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace votable_11_dns
{
  // anyTEXT
  //

  anyTEXT::
  anyTEXT ()
  : ::xml_schema::type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->dom_document ())
  {
  }

  anyTEXT::
  anyTEXT (const anyTEXT& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (x.any_, this->dom_document ())
  {
  }

  anyTEXT::
  anyTEXT (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->dom_document ())
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void anyTEXT::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // any
      //
      if (true)
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->dom_document ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_ .push_back (r);
        continue;
      }

      break;
    }
  }

  anyTEXT* anyTEXT::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class anyTEXT (*this, f, c);
  }

  anyTEXT::
  ~anyTEXT ()
  {
  }

  // astroYear
  //

  astroYear::
  astroYear ()
  : ::xml_schema::token ()
  {
  }

  astroYear::
  astroYear (const char* _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  astroYear::
  astroYear (const ::std::string& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  astroYear::
  astroYear (const ::xml_schema::token& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  astroYear::
  astroYear (const astroYear& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  astroYear::
  astroYear (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  astroYear::
  astroYear (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  astroYear::
  astroYear (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  astroYear* astroYear::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class astroYear (*this, f, c);
  }

  astroYear::
  ~astroYear ()
  {
  }

  // ucdType
  //

  ucdType::
  ucdType ()
  : ::xml_schema::token ()
  {
  }

  ucdType::
  ucdType (const char* _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  ucdType::
  ucdType (const ::std::string& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  ucdType::
  ucdType (const ::xml_schema::token& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  ucdType::
  ucdType (const ucdType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  ucdType::
  ucdType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  ucdType::
  ucdType (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  ucdType::
  ucdType (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  ucdType* ucdType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ucdType (*this, f, c);
  }

  ucdType::
  ~ucdType ()
  {
  }

  // arrayDEF
  //

  arrayDEF::
  arrayDEF ()
  : ::xml_schema::token ()
  {
  }

  arrayDEF::
  arrayDEF (const char* _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  arrayDEF::
  arrayDEF (const ::std::string& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  arrayDEF::
  arrayDEF (const ::xml_schema::token& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  arrayDEF::
  arrayDEF (const arrayDEF& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  arrayDEF::
  arrayDEF (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  arrayDEF::
  arrayDEF (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  arrayDEF::
  arrayDEF (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  arrayDEF* arrayDEF::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class arrayDEF (*this, f, c);
  }

  arrayDEF::
  ~arrayDEF ()
  {
  }

  // encodingType
  //

  encodingType::
  encodingType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_encodingType_convert ();
  }

  encodingType::
  encodingType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_encodingType_convert ();
  }

  encodingType::
  encodingType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_encodingType_convert ();
  }

  encodingType* encodingType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class encodingType (*this, f, c);
  }

  encodingType::value encodingType::
  _xsd_encodingType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_encodingType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_encodingType_indexes_,
                      _xsd_encodingType_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_encodingType_indexes_ + 4 || _xsd_encodingType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const encodingType::
  _xsd_encodingType_literals_[4] =
  {
    "gzip",
    "base64",
    "dynamic",
    "none"
  };

  const encodingType::value encodingType::
  _xsd_encodingType_indexes_[4] =
  {
    ::votable_11_dns::encodingType::base64,
    ::votable_11_dns::encodingType::dynamic,
    ::votable_11_dns::encodingType::gzip,
    ::votable_11_dns::encodingType::none
  };

  // dataType
  //

  dataType::
  dataType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_dataType_convert ();
  }

  dataType::
  dataType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_dataType_convert ();
  }

  dataType::
  dataType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_dataType_convert ();
  }

  dataType* dataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dataType (*this, f, c);
  }

  dataType::value dataType::
  _xsd_dataType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_dataType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_dataType_indexes_,
                      _xsd_dataType_indexes_ + 12,
                      *this,
                      c));

    if (i == _xsd_dataType_indexes_ + 12 || _xsd_dataType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const dataType::
  _xsd_dataType_literals_[12] =
  {
    "boolean",
    "bit",
    "unsignedByte",
    "short",
    "int",
    "long",
    "char",
    "unicodeChar",
    "float",
    "double",
    "floatComplex",
    "doubleComplex"
  };

  const dataType::value dataType::
  _xsd_dataType_indexes_[12] =
  {
    ::votable_11_dns::dataType::bit,
    ::votable_11_dns::dataType::boolean,
    ::votable_11_dns::dataType::char_,
    ::votable_11_dns::dataType::double_,
    ::votable_11_dns::dataType::doubleComplex,
    ::votable_11_dns::dataType::float_,
    ::votable_11_dns::dataType::floatComplex,
    ::votable_11_dns::dataType::int_,
    ::votable_11_dns::dataType::long_,
    ::votable_11_dns::dataType::short_,
    ::votable_11_dns::dataType::unicodeChar,
    ::votable_11_dns::dataType::unsignedByte
  };

  // precType
  //

  precType::
  precType ()
  : ::xml_schema::token ()
  {
  }

  precType::
  precType (const char* _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  precType::
  precType (const ::std::string& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  precType::
  precType (const ::xml_schema::token& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  precType::
  precType (const precType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  precType::
  precType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  precType::
  precType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  precType::
  precType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  precType* precType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class precType (*this, f, c);
  }

  precType::
  ~precType ()
  {
  }

  // yesno
  //

  yesno::
  yesno (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_yesno_convert ();
  }

  yesno::
  yesno (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_yesno_convert ();
  }

  yesno::
  yesno (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_yesno_convert ();
  }

  yesno* yesno::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class yesno (*this, f, c);
  }

  yesno::value yesno::
  _xsd_yesno_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_yesno_literals_);
    const value* i (::std::lower_bound (
                      _xsd_yesno_indexes_,
                      _xsd_yesno_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_yesno_indexes_ + 2 || _xsd_yesno_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const yesno::
  _xsd_yesno_literals_[2] =
  {
    "yes",
    "no"
  };

  const yesno::value yesno::
  _xsd_yesno_indexes_[2] =
  {
    ::votable_11_dns::yesno::no,
    ::votable_11_dns::yesno::yes
  };

  // VOTABLE
  //

  VOTABLE::
  VOTABLE ()
  : ::xml_schema::type (),
    DESCRIPTION_ (::xml_schema::flags (), this),
    DEFINITIONS_ (::xml_schema::flags (), this),
    COOSYS_ (::xml_schema::flags (), this),
    PARAM_ (::xml_schema::flags (), this),
    INFO_ (::xml_schema::flags (), this),
    RESOURCE_ (::xml_schema::flags (), this),
    ID_ (::xml_schema::flags (), this),
    version_ (::xml_schema::flags (), this)
  {
  }

  VOTABLE::
  VOTABLE (const VOTABLE& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DESCRIPTION_ (x.DESCRIPTION_, f, this),
    DEFINITIONS_ (x.DEFINITIONS_, f, this),
    COOSYS_ (x.COOSYS_, f, this),
    PARAM_ (x.PARAM_, f, this),
    INFO_ (x.INFO_, f, this),
    RESOURCE_ (x.RESOURCE_, f, this),
    ID_ (x.ID_, f, this),
    version_ (x.version_, f, this)
  {
  }

  VOTABLE::
  VOTABLE (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DESCRIPTION_ (f, this),
    DEFINITIONS_ (f, this),
    COOSYS_ (f, this),
    PARAM_ (f, this),
    INFO_ (f, this),
    RESOURCE_ (f, this),
    ID_ (f, this),
    version_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void VOTABLE::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DESCRIPTION
      //
      if (n.name () == "DESCRIPTION" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DESCRIPTION_type > r (
          DESCRIPTION_traits::create (i, f, this));

        if (!this->DESCRIPTION_)
        {
          this->DESCRIPTION_.set (r);
          continue;
        }
      }

      // DEFINITIONS
      //
      if (n.name () == "DEFINITIONS" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DEFINITIONS_type > r (
          DEFINITIONS_traits::create (i, f, this));

        if (!this->DEFINITIONS_)
        {
          this->DEFINITIONS_.set (r);
          continue;
        }
      }

      // COOSYS
      //
      if (n.name () == "COOSYS" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< COOSYS_type > r (
          COOSYS_traits::create (i, f, this));

        this->COOSYS_.push_back (r);
        continue;
      }

      // PARAM
      //
      if (n.name () == "PARAM" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< PARAM_type > r (
          PARAM_traits::create (i, f, this));

        this->PARAM_.push_back (r);
        continue;
      }

      // INFO
      //
      if (n.name () == "INFO" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< INFO_type > r (
          INFO_traits::create (i, f, this));

        this->INFO_.push_back (r);
        continue;
      }

      // RESOURCE
      //
      if (n.name () == "RESOURCE" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RESOURCE_type > r (
          RESOURCE_traits::create (i, f, this));

        this->RESOURCE_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< version_type > r (
          version_traits::create (i, f, this));

        this->version_.set (r);
        continue;
      }
    }
  }

  VOTABLE* VOTABLE::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VOTABLE (*this, f, c);
  }

  VOTABLE::
  ~VOTABLE ()
  {
  }

  // RESOURCE
  //

  const RESOURCE::type_type RESOURCE::type_default_value_ (
    "results");

  RESOURCE::
  RESOURCE ()
  : ::xml_schema::type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    DESCRIPTION_ (::xml_schema::flags (), this),
    INFO_ (::xml_schema::flags (), this),
    COOSYS_ (::xml_schema::flags (), this),
    PARAM_ (::xml_schema::flags (), this),
    LINK_ (::xml_schema::flags (), this),
    TABLE_ (::xml_schema::flags (), this),
    RESOURCE1_ (::xml_schema::flags (), this),
    any_ (this->dom_document ()),
    name_ (::xml_schema::flags (), this),
    ID_ (::xml_schema::flags (), this),
    utype_ (::xml_schema::flags (), this),
    type_ (type_default_value (), ::xml_schema::flags (), this),
    any_attribute_ (this->dom_document ())
  {
  }

  RESOURCE::
  RESOURCE (const RESOURCE& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    DESCRIPTION_ (x.DESCRIPTION_, f, this),
    INFO_ (x.INFO_, f, this),
    COOSYS_ (x.COOSYS_, f, this),
    PARAM_ (x.PARAM_, f, this),
    LINK_ (x.LINK_, f, this),
    TABLE_ (x.TABLE_, f, this),
    RESOURCE1_ (x.RESOURCE1_, f, this),
    any_ (x.any_, this->dom_document ()),
    name_ (x.name_, f, this),
    ID_ (x.ID_, f, this),
    utype_ (x.utype_, f, this),
    type_ (x.type_, f, this),
    any_attribute_ (x.any_attribute_, this->dom_document ())
  {
  }

  RESOURCE::
  RESOURCE (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    DESCRIPTION_ (f, this),
    INFO_ (f, this),
    COOSYS_ (f, this),
    PARAM_ (f, this),
    LINK_ (f, this),
    TABLE_ (f, this),
    RESOURCE1_ (f, this),
    any_ (this->dom_document ()),
    name_ (f, this),
    ID_ (f, this),
    utype_ (f, this),
    type_ (f, this),
    any_attribute_ (this->dom_document ())
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void RESOURCE::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DESCRIPTION
      //
      if (n.name () == "DESCRIPTION" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DESCRIPTION_type > r (
          DESCRIPTION_traits::create (i, f, this));

        if (!this->DESCRIPTION_)
        {
          this->DESCRIPTION_.set (r);
          continue;
        }
      }

      // INFO
      //
      if (n.name () == "INFO" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< INFO_type > r (
          INFO_traits::create (i, f, this));

        this->INFO_.push_back (r);
        continue;
      }

      // COOSYS
      //
      if (n.name () == "COOSYS" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< COOSYS_type > r (
          COOSYS_traits::create (i, f, this));

        this->COOSYS_.push_back (r);
        continue;
      }

      // PARAM
      //
      if (n.name () == "PARAM" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< PARAM_type > r (
          PARAM_traits::create (i, f, this));

        this->PARAM_.push_back (r);
        continue;
      }

      // LINK
      //
      if (n.name () == "LINK" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< LINK_type > r (
          LINK_traits::create (i, f, this));

        this->LINK_.push_back (r);
        continue;
      }

      // TABLE
      //
      if (n.name () == "TABLE" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< TABLE_type > r (
          TABLE_traits::create (i, f, this));

        this->TABLE_.push_back (r);
        continue;
      }

      // RESOURCE
      //
      if (n.name () == "RESOURCE" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RESOURCE1_type > r (
          RESOURCE1_traits::create (i, f, this));

        this->RESOURCE1_.push_back (r);
        continue;
      }

      // any
      //
      if (!n.namespace_ ().empty ())
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->dom_document ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_ .push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "utype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< utype_type > r (
          utype_traits::create (i, f, this));

        this->utype_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      // any_attribute
      //
      if ((!n.namespace_ ().empty () &&
           n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
           n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
      {
        ::xercesc::DOMAttr* r (
          static_cast< ::xercesc::DOMAttr* > (
            this->dom_document ().importNode (
              const_cast< ::xercesc::DOMAttr* > (&i), true)));
        this->any_attribute_ .insert (r);
        continue;
      }
    }

    if (!type_.present ())
    {
      this->type_.set (type_default_value ());
    }
  }

  RESOURCE* RESOURCE::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RESOURCE (*this, f, c);
  }

  RESOURCE::
  ~RESOURCE ()
  {
  }

  // DEFINITIONS
  //

  DEFINITIONS::
  DEFINITIONS ()
  : ::xml_schema::type (),
    COOSYS_ (::xml_schema::flags (), this),
    PARAM_ (::xml_schema::flags (), this)
  {
  }

  DEFINITIONS::
  DEFINITIONS (const DEFINITIONS& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    COOSYS_ (x.COOSYS_, f, this),
    PARAM_ (x.PARAM_, f, this)
  {
  }

  DEFINITIONS::
  DEFINITIONS (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    COOSYS_ (f, this),
    PARAM_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void DEFINITIONS::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // COOSYS
      //
      if (n.name () == "COOSYS" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< COOSYS_type > r (
          COOSYS_traits::create (i, f, this));

        this->COOSYS_.push_back (r);
        continue;
      }

      // PARAM
      //
      if (n.name () == "PARAM" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< PARAM_type > r (
          PARAM_traits::create (i, f, this));

        this->PARAM_.push_back (r);
        continue;
      }

      break;
    }
  }

  DEFINITIONS* DEFINITIONS::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DEFINITIONS (*this, f, c);
  }

  DEFINITIONS::
  ~DEFINITIONS ()
  {
  }

  // INFO
  //

  INFO::
  INFO ()
  : ::xml_schema::string (),
    ID_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this),
    value_ (::xml_schema::flags (), this)
  {
  }

  INFO::
  INFO (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    ID_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this),
    value_ (::xml_schema::flags (), this)
  {
  }

  INFO::
  INFO (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    ID_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this),
    value_ (::xml_schema::flags (), this)
  {
  }

  INFO::
  INFO (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    ID_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this),
    value_ (::xml_schema::flags (), this)
  {
  }

  INFO::
  INFO (const INFO& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    ID_ (x.ID_, f, this),
    name_ (x.name_, f, this),
    value_ (x.value_, f, this)
  {
  }

  INFO::
  INFO (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    ID_ (f, this),
    name_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void INFO::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        this->value_.set (r);
        continue;
      }
    }
  }

  INFO* INFO::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class INFO (*this, f, c);
  }

  INFO::
  ~INFO ()
  {
  }

  // PARAM
  //

  PARAM::
  PARAM ()
  : ::xml_schema::type (),
    DESCRIPTION_ (::xml_schema::flags (), this),
    VALUES_ (::xml_schema::flags (), this),
    LINK_ (::xml_schema::flags (), this),
    ID_ (::xml_schema::flags (), this),
    unit_ (::xml_schema::flags (), this),
    datatype_ (::xml_schema::flags (), this),
    precision_ (::xml_schema::flags (), this),
    width_ (::xml_schema::flags (), this),
    ref_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this),
    ucd_ (::xml_schema::flags (), this),
    utype_ (::xml_schema::flags (), this),
    value_ (::xml_schema::flags (), this),
    arraysize_ (::xml_schema::flags (), this)
  {
  }

  PARAM::
  PARAM (const PARAM& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DESCRIPTION_ (x.DESCRIPTION_, f, this),
    VALUES_ (x.VALUES_, f, this),
    LINK_ (x.LINK_, f, this),
    ID_ (x.ID_, f, this),
    unit_ (x.unit_, f, this),
    datatype_ (x.datatype_, f, this),
    precision_ (x.precision_, f, this),
    width_ (x.width_, f, this),
    ref_ (x.ref_, f, this),
    name_ (x.name_, f, this),
    ucd_ (x.ucd_, f, this),
    utype_ (x.utype_, f, this),
    value_ (x.value_, f, this),
    arraysize_ (x.arraysize_, f, this)
  {
  }

  PARAM::
  PARAM (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DESCRIPTION_ (f, this),
    VALUES_ (f, this),
    LINK_ (f, this),
    ID_ (f, this),
    unit_ (f, this),
    datatype_ (f, this),
    precision_ (f, this),
    width_ (f, this),
    ref_ (f, this),
    name_ (f, this),
    ucd_ (f, this),
    utype_ (f, this),
    value_ (f, this),
    arraysize_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void PARAM::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DESCRIPTION
      //
      if (n.name () == "DESCRIPTION" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DESCRIPTION_type > r (
          DESCRIPTION_traits::create (i, f, this));

        if (!this->DESCRIPTION_)
        {
          this->DESCRIPTION_.set (r);
          continue;
        }
      }

      // VALUES
      //
      if (n.name () == "VALUES" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< VALUES_type > r (
          VALUES_traits::create (i, f, this));

        if (!this->VALUES_)
        {
          this->VALUES_.set (r);
          continue;
        }
      }

      // LINK
      //
      if (n.name () == "LINK" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< LINK_type > r (
          LINK_traits::create (i, f, this));

        this->LINK_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_type > r (
          unit_traits::create (i, f, this));

        this->unit_.set (r);
        continue;
      }

      if (n.name () == "datatype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< datatype_type > r (
          datatype_traits::create (i, f, this));

        this->datatype_.set (r);
        continue;
      }

      if (n.name () == "precision" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< precision_type > r (
          precision_traits::create (i, f, this));

        this->precision_.set (r);
        continue;
      }

      if (n.name () == "width" && n.namespace_ ().empty ())
      {
        this->width_.set (width_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref_type > r (
          ref_traits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "ucd" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ucd_type > r (
          ucd_traits::create (i, f, this));

        this->ucd_.set (r);
        continue;
      }

      if (n.name () == "utype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< utype_type > r (
          utype_traits::create (i, f, this));

        this->utype_.set (r);
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        this->value_.set (r);
        continue;
      }

      if (n.name () == "arraysize" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< arraysize_type > r (
          arraysize_traits::create (i, f, this));

        this->arraysize_.set (r);
        continue;
      }
    }
  }

  PARAM* PARAM::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PARAM (*this, f, c);
  }

  PARAM::
  ~PARAM ()
  {
  }

  // TABLE
  //

  TABLE::
  TABLE ()
  : ::xml_schema::type (),
    DESCRIPTION_ (::xml_schema::flags (), this),
    FIELD_ (::xml_schema::flags (), this),
    PARAM_ (::xml_schema::flags (), this),
    GROUP_ (::xml_schema::flags (), this),
    LINK_ (::xml_schema::flags (), this),
    DATA_ (::xml_schema::flags (), this),
    ID_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this),
    ref_ (::xml_schema::flags (), this),
    ucd_ (::xml_schema::flags (), this),
    utype_ (::xml_schema::flags (), this),
    nrows_ (::xml_schema::flags (), this)
  {
  }

  TABLE::
  TABLE (const TABLE& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DESCRIPTION_ (x.DESCRIPTION_, f, this),
    FIELD_ (x.FIELD_, f, this),
    PARAM_ (x.PARAM_, f, this),
    GROUP_ (x.GROUP_, f, this),
    LINK_ (x.LINK_, f, this),
    DATA_ (x.DATA_, f, this),
    ID_ (x.ID_, f, this),
    name_ (x.name_, f, this),
    ref_ (x.ref_, f, this),
    ucd_ (x.ucd_, f, this),
    utype_ (x.utype_, f, this),
    nrows_ (x.nrows_, f, this)
  {
  }

  TABLE::
  TABLE (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DESCRIPTION_ (f, this),
    FIELD_ (f, this),
    PARAM_ (f, this),
    GROUP_ (f, this),
    LINK_ (f, this),
    DATA_ (f, this),
    ID_ (f, this),
    name_ (f, this),
    ref_ (f, this),
    ucd_ (f, this),
    utype_ (f, this),
    nrows_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TABLE::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DESCRIPTION
      //
      if (n.name () == "DESCRIPTION" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DESCRIPTION_type > r (
          DESCRIPTION_traits::create (i, f, this));

        if (!this->DESCRIPTION_)
        {
          this->DESCRIPTION_.set (r);
          continue;
        }
      }

      // FIELD
      //
      if (n.name () == "FIELD" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< FIELD_type > r (
          FIELD_traits::create (i, f, this));

        this->FIELD_.push_back (r);
        continue;
      }

      // PARAM
      //
      if (n.name () == "PARAM" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< PARAM_type > r (
          PARAM_traits::create (i, f, this));

        this->PARAM_.push_back (r);
        continue;
      }

      // GROUP
      //
      if (n.name () == "GROUP" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< GROUP_type > r (
          GROUP_traits::create (i, f, this));

        this->GROUP_.push_back (r);
        continue;
      }

      // LINK
      //
      if (n.name () == "LINK" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< LINK_type > r (
          LINK_traits::create (i, f, this));

        this->LINK_.push_back (r);
        continue;
      }

      // DATA
      //
      if (n.name () == "DATA" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DATA_type > r (
          DATA_traits::create (i, f, this));

        if (!this->DATA_)
        {
          this->DATA_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref_type > r (
          ref_traits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }

      if (n.name () == "ucd" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ucd_type > r (
          ucd_traits::create (i, f, this));

        this->ucd_.set (r);
        continue;
      }

      if (n.name () == "utype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< utype_type > r (
          utype_traits::create (i, f, this));

        this->utype_.set (r);
        continue;
      }

      if (n.name () == "nrows" && n.namespace_ ().empty ())
      {
        this->nrows_.set (nrows_traits::create (i, f, this));
        continue;
      }
    }
  }

  TABLE* TABLE::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TABLE (*this, f, c);
  }

  TABLE::
  ~TABLE ()
  {
  }

  // FIELD
  //

  FIELD::
  FIELD ()
  : ::xml_schema::type (),
    DESCRIPTION_ (::xml_schema::flags (), this),
    VALUES_ (::xml_schema::flags (), this),
    LINK_ (::xml_schema::flags (), this),
    ID_ (::xml_schema::flags (), this),
    unit_ (::xml_schema::flags (), this),
    datatype_ (::xml_schema::flags (), this),
    precision_ (::xml_schema::flags (), this),
    width_ (::xml_schema::flags (), this),
    ref_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this),
    ucd_ (::xml_schema::flags (), this),
    utype_ (::xml_schema::flags (), this),
    arraysize_ (::xml_schema::flags (), this),
    type_ (::xml_schema::flags (), this)
  {
  }

  FIELD::
  FIELD (const FIELD& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DESCRIPTION_ (x.DESCRIPTION_, f, this),
    VALUES_ (x.VALUES_, f, this),
    LINK_ (x.LINK_, f, this),
    ID_ (x.ID_, f, this),
    unit_ (x.unit_, f, this),
    datatype_ (x.datatype_, f, this),
    precision_ (x.precision_, f, this),
    width_ (x.width_, f, this),
    ref_ (x.ref_, f, this),
    name_ (x.name_, f, this),
    ucd_ (x.ucd_, f, this),
    utype_ (x.utype_, f, this),
    arraysize_ (x.arraysize_, f, this),
    type_ (x.type_, f, this)
  {
  }

  FIELD::
  FIELD (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DESCRIPTION_ (f, this),
    VALUES_ (f, this),
    LINK_ (f, this),
    ID_ (f, this),
    unit_ (f, this),
    datatype_ (f, this),
    precision_ (f, this),
    width_ (f, this),
    ref_ (f, this),
    name_ (f, this),
    ucd_ (f, this),
    utype_ (f, this),
    arraysize_ (f, this),
    type_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void FIELD::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DESCRIPTION
      //
      if (n.name () == "DESCRIPTION" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DESCRIPTION_type > r (
          DESCRIPTION_traits::create (i, f, this));

        if (!this->DESCRIPTION_)
        {
          this->DESCRIPTION_.set (r);
          continue;
        }
      }

      // VALUES
      //
      if (n.name () == "VALUES" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< VALUES_type > r (
          VALUES_traits::create (i, f, this));

        if (!this->VALUES_)
        {
          this->VALUES_.set (r);
          continue;
        }
      }

      // LINK
      //
      if (n.name () == "LINK" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< LINK_type > r (
          LINK_traits::create (i, f, this));

        this->LINK_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_type > r (
          unit_traits::create (i, f, this));

        this->unit_.set (r);
        continue;
      }

      if (n.name () == "datatype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< datatype_type > r (
          datatype_traits::create (i, f, this));

        this->datatype_.set (r);
        continue;
      }

      if (n.name () == "precision" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< precision_type > r (
          precision_traits::create (i, f, this));

        this->precision_.set (r);
        continue;
      }

      if (n.name () == "width" && n.namespace_ ().empty ())
      {
        this->width_.set (width_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref_type > r (
          ref_traits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "ucd" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ucd_type > r (
          ucd_traits::create (i, f, this));

        this->ucd_.set (r);
        continue;
      }

      if (n.name () == "utype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< utype_type > r (
          utype_traits::create (i, f, this));

        this->utype_.set (r);
        continue;
      }

      if (n.name () == "arraysize" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< arraysize_type > r (
          arraysize_traits::create (i, f, this));

        this->arraysize_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }
    }
  }

  FIELD* FIELD::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FIELD (*this, f, c);
  }

  FIELD::
  ~FIELD ()
  {
  }

  // GROUP
  //

  GROUP::
  GROUP ()
  : ::xml_schema::type (),
    DESCRIPTION_ (::xml_schema::flags (), this),
    FIELDref_ (::xml_schema::flags (), this),
    PARAMref_ (::xml_schema::flags (), this),
    PARAM_ (::xml_schema::flags (), this),
    GROUP1_ (::xml_schema::flags (), this),
    ID_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this),
    ref_ (::xml_schema::flags (), this),
    ucd_ (::xml_schema::flags (), this),
    utype_ (::xml_schema::flags (), this)
  {
  }

  GROUP::
  GROUP (const GROUP& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DESCRIPTION_ (x.DESCRIPTION_, f, this),
    FIELDref_ (x.FIELDref_, f, this),
    PARAMref_ (x.PARAMref_, f, this),
    PARAM_ (x.PARAM_, f, this),
    GROUP1_ (x.GROUP1_, f, this),
    ID_ (x.ID_, f, this),
    name_ (x.name_, f, this),
    ref_ (x.ref_, f, this),
    ucd_ (x.ucd_, f, this),
    utype_ (x.utype_, f, this)
  {
  }

  GROUP::
  GROUP (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DESCRIPTION_ (f, this),
    FIELDref_ (f, this),
    PARAMref_ (f, this),
    PARAM_ (f, this),
    GROUP1_ (f, this),
    ID_ (f, this),
    name_ (f, this),
    ref_ (f, this),
    ucd_ (f, this),
    utype_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void GROUP::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DESCRIPTION
      //
      if (n.name () == "DESCRIPTION" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DESCRIPTION_type > r (
          DESCRIPTION_traits::create (i, f, this));

        if (!this->DESCRIPTION_)
        {
          this->DESCRIPTION_.set (r);
          continue;
        }
      }

      // FIELDref
      //
      if (n.name () == "FIELDref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< FIELDref_type > r (
          FIELDref_traits::create (i, f, this));

        this->FIELDref_.push_back (r);
        continue;
      }

      // PARAMref
      //
      if (n.name () == "PARAMref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< PARAMref_type > r (
          PARAMref_traits::create (i, f, this));

        this->PARAMref_.push_back (r);
        continue;
      }

      // PARAM
      //
      if (n.name () == "PARAM" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< PARAM_type > r (
          PARAM_traits::create (i, f, this));

        this->PARAM_.push_back (r);
        continue;
      }

      // GROUP
      //
      if (n.name () == "GROUP" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< GROUP1_type > r (
          GROUP1_traits::create (i, f, this));

        this->GROUP1_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref_type > r (
          ref_traits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }

      if (n.name () == "ucd" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ucd_type > r (
          ucd_traits::create (i, f, this));

        this->ucd_.set (r);
        continue;
      }

      if (n.name () == "utype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< utype_type > r (
          utype_traits::create (i, f, this));

        this->utype_.set (r);
        continue;
      }
    }
  }

  GROUP* GROUP::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GROUP (*this, f, c);
  }

  GROUP::
  ~GROUP ()
  {
  }

  // FIELDref
  //

  FIELDref::
  FIELDref (const ref_type& ref)
  : ::xml_schema::type (),
    ref_ (ref, ::xml_schema::flags (), this)
  {
  }

  FIELDref::
  FIELDref (const FIELDref& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  FIELDref::
  FIELDref (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void FIELDref::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref_type > r (
          ref_traits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ref",
        "");
    }
  }

  FIELDref* FIELDref::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FIELDref (*this, f, c);
  }

  FIELDref::
  ~FIELDref ()
  {
  }

  // PARAMref
  //

  PARAMref::
  PARAMref (const ref_type& ref)
  : ::xml_schema::type (),
    ref_ (ref, ::xml_schema::flags (), this)
  {
  }

  PARAMref::
  PARAMref (const PARAMref& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  PARAMref::
  PARAMref (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void PARAMref::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref_type > r (
          ref_traits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ref",
        "");
    }
  }

  PARAMref* PARAMref::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PARAMref (*this, f, c);
  }

  PARAMref::
  ~PARAMref ()
  {
  }

  // VALUES
  //

  const VALUES::type_type VALUES::type_default_value_ (
    "legal");

  VALUES::
  VALUES ()
  : ::xml_schema::type (),
    MIN_ (::xml_schema::flags (), this),
    MAX_ (::xml_schema::flags (), this),
    OPTION_ (::xml_schema::flags (), this),
    ID_ (::xml_schema::flags (), this),
    type_ (type_default_value (), ::xml_schema::flags (), this),
    null_ (::xml_schema::flags (), this),
    ref_ (::xml_schema::flags (), this)
  {
  }

  VALUES::
  VALUES (const VALUES& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    MIN_ (x.MIN_, f, this),
    MAX_ (x.MAX_, f, this),
    OPTION_ (x.OPTION_, f, this),
    ID_ (x.ID_, f, this),
    type_ (x.type_, f, this),
    null_ (x.null_, f, this),
    ref_ (x.ref_, f, this)
  {
  }

  VALUES::
  VALUES (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    MIN_ (f, this),
    MAX_ (f, this),
    OPTION_ (f, this),
    ID_ (f, this),
    type_ (f, this),
    null_ (f, this),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void VALUES::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MIN
      //
      if (n.name () == "MIN" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< MIN_type > r (
          MIN_traits::create (i, f, this));

        if (!this->MIN_)
        {
          this->MIN_.set (r);
          continue;
        }
      }

      // MAX
      //
      if (n.name () == "MAX" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< MAX_type > r (
          MAX_traits::create (i, f, this));

        if (!this->MAX_)
        {
          this->MAX_.set (r);
          continue;
        }
      }

      // OPTION
      //
      if (n.name () == "OPTION" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< OPTION_type > r (
          OPTION_traits::create (i, f, this));

        this->OPTION_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "null" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< null_type > r (
          null_traits::create (i, f, this));

        this->null_.set (r);
        continue;
      }

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref_type > r (
          ref_traits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!type_.present ())
    {
      this->type_.set (type_default_value ());
    }
  }

  VALUES* VALUES::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VALUES (*this, f, c);
  }

  VALUES::
  ~VALUES ()
  {
  }

  // MIN
  //

  const MIN::inclusive_type MIN::inclusive_default_value_ (
    "yes");

  MIN::
  MIN (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, ::xml_schema::flags (), this),
    inclusive_ (inclusive_default_value (), ::xml_schema::flags (), this)
  {
  }

  MIN::
  MIN (const MIN& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this),
    inclusive_ (x.inclusive_, f, this)
  {
  }

  MIN::
  MIN (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (f, this),
    inclusive_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void MIN::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        this->value_.set (r);
        continue;
      }

      if (n.name () == "inclusive" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< inclusive_type > r (
          inclusive_traits::create (i, f, this));

        this->inclusive_.set (r);
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }

    if (!inclusive_.present ())
    {
      this->inclusive_.set (inclusive_default_value ());
    }
  }

  MIN* MIN::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MIN (*this, f, c);
  }

  MIN::
  ~MIN ()
  {
  }

  // MAX
  //

  const MAX::inclusive_type MAX::inclusive_default_value_ (
    "yes");

  MAX::
  MAX (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, ::xml_schema::flags (), this),
    inclusive_ (inclusive_default_value (), ::xml_schema::flags (), this)
  {
  }

  MAX::
  MAX (const MAX& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this),
    inclusive_ (x.inclusive_, f, this)
  {
  }

  MAX::
  MAX (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (f, this),
    inclusive_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void MAX::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        this->value_.set (r);
        continue;
      }

      if (n.name () == "inclusive" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< inclusive_type > r (
          inclusive_traits::create (i, f, this));

        this->inclusive_.set (r);
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }

    if (!inclusive_.present ())
    {
      this->inclusive_.set (inclusive_default_value ());
    }
  }

  MAX* MAX::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MAX (*this, f, c);
  }

  MAX::
  ~MAX ()
  {
  }

  // OPTION
  //

  OPTION::
  OPTION ()
  : ::xml_schema::type (),
    OPTION1_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this),
    value_ (::xml_schema::flags (), this)
  {
  }

  OPTION::
  OPTION (const OPTION& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    OPTION1_ (x.OPTION1_, f, this),
    name_ (x.name_, f, this),
    value_ (x.value_, f, this)
  {
  }

  OPTION::
  OPTION (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    OPTION1_ (f, this),
    name_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void OPTION::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OPTION
      //
      if (n.name () == "OPTION" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< OPTION1_type > r (
          OPTION1_traits::create (i, f, this));

        this->OPTION1_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        this->value_.set (r);
        continue;
      }
    }
  }

  OPTION* OPTION::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OPTION (*this, f, c);
  }

  OPTION::
  ~OPTION ()
  {
  }

  // LINK
  //

  LINK::
  LINK ()
  : ::xml_schema::type (),
    ID_ (::xml_schema::flags (), this),
    content_role_ (::xml_schema::flags (), this),
    content_type_ (::xml_schema::flags (), this),
    title_ (::xml_schema::flags (), this),
    value_ (::xml_schema::flags (), this),
    href_ (::xml_schema::flags (), this),
    gref_ (::xml_schema::flags (), this),
    action_ (::xml_schema::flags (), this)
  {
  }

  LINK::
  LINK (const LINK& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ID_ (x.ID_, f, this),
    content_role_ (x.content_role_, f, this),
    content_type_ (x.content_type_, f, this),
    title_ (x.title_, f, this),
    value_ (x.value_, f, this),
    href_ (x.href_, f, this),
    gref_ (x.gref_, f, this),
    action_ (x.action_, f, this)
  {
  }

  LINK::
  LINK (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ID_ (f, this),
    content_role_ (f, this),
    content_type_ (f, this),
    title_ (f, this),
    value_ (f, this),
    href_ (f, this),
    gref_ (f, this),
    action_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void LINK::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "content-role" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< content_role_type > r (
          content_role_traits::create (i, f, this));

        this->content_role_.set (r);
        continue;
      }

      if (n.name () == "content-type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< content_type_type > r (
          content_type_traits::create (i, f, this));

        this->content_type_.set (r);
        continue;
      }

      if (n.name () == "title" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< title_type > r (
          title_traits::create (i, f, this));

        this->title_.set (r);
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        this->value_.set (r);
        continue;
      }

      if (n.name () == "href" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< href_type > r (
          href_traits::create (i, f, this));

        this->href_.set (r);
        continue;
      }

      if (n.name () == "gref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< gref_type > r (
          gref_traits::create (i, f, this));

        this->gref_.set (r);
        continue;
      }

      if (n.name () == "action" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< action_type > r (
          action_traits::create (i, f, this));

        this->action_.set (r);
        continue;
      }
    }
  }

  LINK* LINK::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LINK (*this, f, c);
  }

  LINK::
  ~LINK ()
  {
  }

  // DATA
  //

  DATA::
  DATA ()
  : ::xml_schema::type (),
    TABLEDATA_ (::xml_schema::flags (), this),
    BINARY_ (::xml_schema::flags (), this),
    FITS_ (::xml_schema::flags (), this)
  {
  }

  DATA::
  DATA (const DATA& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    TABLEDATA_ (x.TABLEDATA_, f, this),
    BINARY_ (x.BINARY_, f, this),
    FITS_ (x.FITS_, f, this)
  {
  }

  DATA::
  DATA (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    TABLEDATA_ (f, this),
    BINARY_ (f, this),
    FITS_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void DATA::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TABLEDATA
      //
      if (n.name () == "TABLEDATA" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< TABLEDATA_type > r (
          TABLEDATA_traits::create (i, f, this));

        if (!this->TABLEDATA_)
        {
          this->TABLEDATA_.set (r);
          continue;
        }
      }

      // BINARY
      //
      if (n.name () == "BINARY" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< BINARY_type > r (
          BINARY_traits::create (i, f, this));

        if (!this->BINARY_)
        {
          this->BINARY_.set (r);
          continue;
        }
      }

      // FITS
      //
      if (n.name () == "FITS" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< FITS_type > r (
          FITS_traits::create (i, f, this));

        if (!this->FITS_)
        {
          this->FITS_.set (r);
          continue;
        }
      }

      break;
    }
  }

  DATA* DATA::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DATA (*this, f, c);
  }

  DATA::
  ~DATA ()
  {
  }

  // TABLEDATA
  //

  TABLEDATA::
  TABLEDATA ()
  : ::xml_schema::type (),
    TR_ (::xml_schema::flags (), this)
  {
  }

  TABLEDATA::
  TABLEDATA (const TABLEDATA& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    TR_ (x.TR_, f, this)
  {
  }

  TABLEDATA::
  TABLEDATA (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    TR_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TABLEDATA::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TR
      //
      if (n.name () == "TR" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< TR_type > r (
          TR_traits::create (i, f, this));

        this->TR_.push_back (r);
        continue;
      }

      break;
    }
  }

  TABLEDATA* TABLEDATA::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TABLEDATA (*this, f, c);
  }

  TABLEDATA::
  ~TABLEDATA ()
  {
  }

  // TD
  //

  TD::
  TD ()
  : ::xml_schema::string (),
    encoding_ (::xml_schema::flags (), this)
  {
  }

  TD::
  TD (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    encoding_ (::xml_schema::flags (), this)
  {
  }

  TD::
  TD (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    encoding_ (::xml_schema::flags (), this)
  {
  }

  TD::
  TD (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    encoding_ (::xml_schema::flags (), this)
  {
  }

  TD::
  TD (const TD& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    encoding_ (x.encoding_, f, this)
  {
  }

  TD::
  TD (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    encoding_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void TD::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "encoding" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< encoding_type > r (
          encoding_traits::create (i, f, this));

        this->encoding_.set (r);
        continue;
      }
    }
  }

  TD* TD::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TD (*this, f, c);
  }

  TD::
  ~TD ()
  {
  }

  // TR
  //

  TR::
  TR ()
  : ::xml_schema::type (),
    TD_ (::xml_schema::flags (), this)
  {
  }

  TR::
  TR (const TR& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    TD_ (x.TD_, f, this)
  {
  }

  TR::
  TR (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    TD_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TR::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TD
      //
      if (n.name () == "TD" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< TD_type > r (
          TD_traits::create (i, f, this));

        this->TD_.push_back (r);
        continue;
      }

      break;
    }
  }

  TR* TR::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TR (*this, f, c);
  }

  TR::
  ~TR ()
  {
  }

  // FITS
  //

  FITS::
  FITS (const STREAM_type& STREAM)
  : ::xml_schema::type (),
    STREAM_ (STREAM, ::xml_schema::flags (), this),
    extnum_ (::xml_schema::flags (), this)
  {
  }

  FITS::
  FITS (::std::auto_ptr< STREAM_type >& STREAM)
  : ::xml_schema::type (),
    STREAM_ (STREAM, ::xml_schema::flags (), this),
    extnum_ (::xml_schema::flags (), this)
  {
  }

  FITS::
  FITS (const FITS& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    STREAM_ (x.STREAM_, f, this),
    extnum_ (x.extnum_, f, this)
  {
  }

  FITS::
  FITS (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    STREAM_ (f, this),
    extnum_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void FITS::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // STREAM
      //
      if (n.name () == "STREAM" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< STREAM_type > r (
          STREAM_traits::create (i, f, this));

        if (!STREAM_.present ())
        {
          this->STREAM_.set (r);
          continue;
        }
      }

      break;
    }

    if (!STREAM_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "STREAM",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "extnum" && n.namespace_ ().empty ())
      {
        this->extnum_.set (extnum_traits::create (i, f, this));
        continue;
      }
    }
  }

  FITS* FITS::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FITS (*this, f, c);
  }

  FITS::
  ~FITS ()
  {
  }

  // BINARY
  //

  BINARY::
  BINARY (const STREAM_type& STREAM)
  : ::xml_schema::type (),
    STREAM_ (STREAM, ::xml_schema::flags (), this)
  {
  }

  BINARY::
  BINARY (::std::auto_ptr< STREAM_type >& STREAM)
  : ::xml_schema::type (),
    STREAM_ (STREAM, ::xml_schema::flags (), this)
  {
  }

  BINARY::
  BINARY (const BINARY& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    STREAM_ (x.STREAM_, f, this)
  {
  }

  BINARY::
  BINARY (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    STREAM_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void BINARY::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // STREAM
      //
      if (n.name () == "STREAM" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< STREAM_type > r (
          STREAM_traits::create (i, f, this));

        if (!STREAM_.present ())
        {
          this->STREAM_.set (r);
          continue;
        }
      }

      break;
    }

    if (!STREAM_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "STREAM",
        "");
    }
  }

  BINARY* BINARY::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BINARY (*this, f, c);
  }

  BINARY::
  ~BINARY ()
  {
  }

  // STREAM
  //

  const STREAM::type_type STREAM::type_default_value_ (
    "locator");

  const STREAM::actuate_type STREAM::actuate_default_value_ (
    "onRequest");

  const STREAM::encoding_type STREAM::encoding_default_value_ (
    "none");

  STREAM::
  STREAM ()
  : ::xml_schema::string (),
    type_ (type_default_value (), ::xml_schema::flags (), this),
    href_ (::xml_schema::flags (), this),
    actuate_ (actuate_default_value (), ::xml_schema::flags (), this),
    encoding_ (encoding_default_value (), ::xml_schema::flags (), this),
    expires_ (::xml_schema::flags (), this),
    rights_ (::xml_schema::flags (), this)
  {
  }

  STREAM::
  STREAM (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type_default_value (), ::xml_schema::flags (), this),
    href_ (::xml_schema::flags (), this),
    actuate_ (actuate_default_value (), ::xml_schema::flags (), this),
    encoding_ (encoding_default_value (), ::xml_schema::flags (), this),
    expires_ (::xml_schema::flags (), this),
    rights_ (::xml_schema::flags (), this)
  {
  }

  STREAM::
  STREAM (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type_default_value (), ::xml_schema::flags (), this),
    href_ (::xml_schema::flags (), this),
    actuate_ (actuate_default_value (), ::xml_schema::flags (), this),
    encoding_ (encoding_default_value (), ::xml_schema::flags (), this),
    expires_ (::xml_schema::flags (), this),
    rights_ (::xml_schema::flags (), this)
  {
  }

  STREAM::
  STREAM (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type_default_value (), ::xml_schema::flags (), this),
    href_ (::xml_schema::flags (), this),
    actuate_ (actuate_default_value (), ::xml_schema::flags (), this),
    encoding_ (encoding_default_value (), ::xml_schema::flags (), this),
    expires_ (::xml_schema::flags (), this),
    rights_ (::xml_schema::flags (), this)
  {
  }

  STREAM::
  STREAM (const STREAM& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    type_ (x.type_, f, this),
    href_ (x.href_, f, this),
    actuate_ (x.actuate_, f, this),
    encoding_ (x.encoding_, f, this),
    expires_ (x.expires_, f, this),
    rights_ (x.rights_, f, this)
  {
  }

  STREAM::
  STREAM (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    type_ (f, this),
    href_ (f, this),
    actuate_ (f, this),
    encoding_ (f, this),
    expires_ (f, this),
    rights_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void STREAM::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "href" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< href_type > r (
          href_traits::create (i, f, this));

        this->href_.set (r);
        continue;
      }

      if (n.name () == "actuate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< actuate_type > r (
          actuate_traits::create (i, f, this));

        this->actuate_.set (r);
        continue;
      }

      if (n.name () == "encoding" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< encoding_type > r (
          encoding_traits::create (i, f, this));

        this->encoding_.set (r);
        continue;
      }

      if (n.name () == "expires" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< expires_type > r (
          expires_traits::create (i, f, this));

        this->expires_.set (r);
        continue;
      }

      if (n.name () == "rights" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< rights_type > r (
          rights_traits::create (i, f, this));

        this->rights_.set (r);
        continue;
      }
    }

    if (!type_.present ())
    {
      this->type_.set (type_default_value ());
    }

    if (!actuate_.present ())
    {
      this->actuate_.set (actuate_default_value ());
    }

    if (!encoding_.present ())
    {
      this->encoding_.set (encoding_default_value ());
    }
  }

  STREAM* STREAM::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class STREAM (*this, f, c);
  }

  STREAM::
  ~STREAM ()
  {
  }

  // COOSYS
  //

  const COOSYS::system_type COOSYS::system_default_value_ (
    "eq_FK5");

  COOSYS::
  COOSYS ()
  : ::xml_schema::string (),
    ID_ (::xml_schema::flags (), this),
    equinox_ (::xml_schema::flags (), this),
    epoch_ (::xml_schema::flags (), this),
    system_ (system_default_value (), ::xml_schema::flags (), this)
  {
  }

  COOSYS::
  COOSYS (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    ID_ (::xml_schema::flags (), this),
    equinox_ (::xml_schema::flags (), this),
    epoch_ (::xml_schema::flags (), this),
    system_ (system_default_value (), ::xml_schema::flags (), this)
  {
  }

  COOSYS::
  COOSYS (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    ID_ (::xml_schema::flags (), this),
    equinox_ (::xml_schema::flags (), this),
    epoch_ (::xml_schema::flags (), this),
    system_ (system_default_value (), ::xml_schema::flags (), this)
  {
  }

  COOSYS::
  COOSYS (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    ID_ (::xml_schema::flags (), this),
    equinox_ (::xml_schema::flags (), this),
    epoch_ (::xml_schema::flags (), this),
    system_ (system_default_value (), ::xml_schema::flags (), this)
  {
  }

  COOSYS::
  COOSYS (const COOSYS& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    ID_ (x.ID_, f, this),
    equinox_ (x.equinox_, f, this),
    epoch_ (x.epoch_, f, this),
    system_ (x.system_, f, this)
  {
  }

  COOSYS::
  COOSYS (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    ID_ (f, this),
    equinox_ (f, this),
    epoch_ (f, this),
    system_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void COOSYS::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "equinox" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< equinox_type > r (
          equinox_traits::create (i, f, this));

        this->equinox_.set (r);
        continue;
      }

      if (n.name () == "epoch" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< epoch_type > r (
          epoch_traits::create (i, f, this));

        this->epoch_.set (r);
        continue;
      }

      if (n.name () == "system" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< system_type > r (
          system_traits::create (i, f, this));

        this->system_.set (r);
        continue;
      }
    }

    if (!system_.present ())
    {
      this->system_.set (system_default_value ());
    }
  }

  COOSYS* COOSYS::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class COOSYS (*this, f, c);
  }

  COOSYS::
  ~COOSYS ()
  {
  }

  // version
  //

  version::
  version (const char* _xsd_nmtoken_base)
  : ::xml_schema::nmtoken (_xsd_nmtoken_base)
  {
  }

  version::
  version (const ::std::string& _xsd_nmtoken_base)
  : ::xml_schema::nmtoken (_xsd_nmtoken_base)
  {
  }

  version::
  version (const ::xml_schema::nmtoken& _xsd_nmtoken_base)
  : ::xml_schema::nmtoken (_xsd_nmtoken_base)
  {
  }

  version::
  version (const version& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (x, f, c)
  {
  }

  version::
  version (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
  }

  version::
  version (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
  }

  version::
  version (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
  }

  version* version::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class version (*this, f, c);
  }

  version::
  ~version ()
  {
  }

  // type
  //

  type::
  type (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_type_convert ();
  }

  type::
  type (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_type_convert ();
  }

  type::
  type (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_type_convert ();
  }

  type* type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type (*this, f, c);
  }

  type::value type::
  _xsd_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_type_indexes_,
                      _xsd_type_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_type_indexes_ + 2 || _xsd_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type::
  _xsd_type_literals_[2] =
  {
    "results",
    "meta"
  };

  const type::value type::
  _xsd_type_indexes_[2] =
  {
    ::votable_11_dns::type::meta,
    ::votable_11_dns::type::results
  };

  // type1
  //

  type1::
  type1 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_type1_convert ();
  }

  type1::
  type1 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_type1_convert ();
  }

  type1::
  type1 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_type1_convert ();
  }

  type1* type1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type1 (*this, f, c);
  }

  type1::value type1::
  _xsd_type1_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type1_literals_);
    const value* i (::std::lower_bound (
                      _xsd_type1_indexes_,
                      _xsd_type1_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_type1_indexes_ + 4 || _xsd_type1_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type1::
  _xsd_type1_literals_[4] =
  {
    "hidden",
    "no_query",
    "trigger",
    "location"
  };

  const type1::value type1::
  _xsd_type1_indexes_[4] =
  {
    ::votable_11_dns::type1::hidden,
    ::votable_11_dns::type1::location,
    ::votable_11_dns::type1::no_query,
    ::votable_11_dns::type1::trigger
  };

  // type2
  //

  type2::
  type2 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_type2_convert ();
  }

  type2::
  type2 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_type2_convert ();
  }

  type2::
  type2 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_type2_convert ();
  }

  type2* type2::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type2 (*this, f, c);
  }

  type2::value type2::
  _xsd_type2_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type2_literals_);
    const value* i (::std::lower_bound (
                      _xsd_type2_indexes_,
                      _xsd_type2_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_type2_indexes_ + 2 || _xsd_type2_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type2::
  _xsd_type2_literals_[2] =
  {
    "legal",
    "actual"
  };

  const type2::value type2::
  _xsd_type2_indexes_[2] =
  {
    ::votable_11_dns::type2::actual,
    ::votable_11_dns::type2::legal
  };

  // content_role
  //

  content_role::
  content_role (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_content_role_convert ();
  }

  content_role::
  content_role (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_content_role_convert ();
  }

  content_role::
  content_role (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_content_role_convert ();
  }

  content_role* content_role::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class content_role (*this, f, c);
  }

  content_role::value content_role::
  _xsd_content_role_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_content_role_literals_);
    const value* i (::std::lower_bound (
                      _xsd_content_role_indexes_,
                      _xsd_content_role_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_content_role_indexes_ + 4 || _xsd_content_role_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const content_role::
  _xsd_content_role_literals_[4] =
  {
    "query",
    "hints",
    "doc",
    "location"
  };

  const content_role::value content_role::
  _xsd_content_role_indexes_[4] =
  {
    ::votable_11_dns::content_role::doc,
    ::votable_11_dns::content_role::hints,
    ::votable_11_dns::content_role::location,
    ::votable_11_dns::content_role::query
  };

  // type3
  //

  type3::
  type3 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_type3_convert ();
  }

  type3::
  type3 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_type3_convert ();
  }

  type3::
  type3 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_type3_convert ();
  }

  type3* type3::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type3 (*this, f, c);
  }

  type3::value type3::
  _xsd_type3_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type3_literals_);
    const value* i (::std::lower_bound (
                      _xsd_type3_indexes_,
                      _xsd_type3_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_type3_indexes_ + 2 || _xsd_type3_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type3::
  _xsd_type3_literals_[2] =
  {
    "locator",
    "other"
  };

  const type3::value type3::
  _xsd_type3_indexes_[2] =
  {
    ::votable_11_dns::type3::locator,
    ::votable_11_dns::type3::other
  };

  // actuate
  //

  actuate::
  actuate (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_actuate_convert ();
  }

  actuate::
  actuate (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_actuate_convert ();
  }

  actuate::
  actuate (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_actuate_convert ();
  }

  actuate* actuate::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class actuate (*this, f, c);
  }

  actuate::value actuate::
  _xsd_actuate_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_actuate_literals_);
    const value* i (::std::lower_bound (
                      _xsd_actuate_indexes_,
                      _xsd_actuate_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_actuate_indexes_ + 4 || _xsd_actuate_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const actuate::
  _xsd_actuate_literals_[4] =
  {
    "onLoad",
    "onRequest",
    "other",
    "none"
  };

  const actuate::value actuate::
  _xsd_actuate_indexes_[4] =
  {
    ::votable_11_dns::actuate::none,
    ::votable_11_dns::actuate::onLoad,
    ::votable_11_dns::actuate::onRequest,
    ::votable_11_dns::actuate::other
  };

  // system
  //

  system::
  system (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_system_convert ();
  }

  system::
  system (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_system_convert ();
  }

  system::
  system (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_system_convert ();
  }

  system* system::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class system (*this, f, c);
  }

  system::value system::
  _xsd_system_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_system_literals_);
    const value* i (::std::lower_bound (
                      _xsd_system_indexes_,
                      _xsd_system_indexes_ + 10,
                      *this,
                      c));

    if (i == _xsd_system_indexes_ + 10 || _xsd_system_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const system::
  _xsd_system_literals_[10] =
  {
    "eq_FK4",
    "eq_FK5",
    "ICRS",
    "ecl_FK4",
    "ecl_FK5",
    "galactic",
    "supergalactic",
    "xy",
    "barycentric",
    "geo_app"
  };

  const system::value system::
  _xsd_system_indexes_[10] =
  {
    ::votable_11_dns::system::ICRS,
    ::votable_11_dns::system::barycentric,
    ::votable_11_dns::system::ecl_FK4,
    ::votable_11_dns::system::ecl_FK5,
    ::votable_11_dns::system::eq_FK4,
    ::votable_11_dns::system::eq_FK5,
    ::votable_11_dns::system::galactic,
    ::votable_11_dns::system::geo_app,
    ::votable_11_dns::system::supergalactic,
    ::votable_11_dns::system::xy
  };
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace votable_11_dns
{
  ::std::auto_ptr< ::votable_11_dns::VOTABLE >
  VOTABLE_read (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::votable_11_dns::VOTABLE > r (
      ::votable_11_dns::VOTABLE_read (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::votable_11_dns::VOTABLE >
  VOTABLE_read (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::votable_11_dns::VOTABLE > r (
      ::votable_11_dns::VOTABLE_read (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::votable_11_dns::VOTABLE >
  VOTABLE_read (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::votable_11_dns::VOTABLE > r (
      ::votable_11_dns::VOTABLE_read (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::votable_11_dns::VOTABLE >
  VOTABLE_read (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::votable_11_dns::VOTABLE_read (isrc, f, p);
  }

  ::std::auto_ptr< ::votable_11_dns::VOTABLE >
  VOTABLE_read (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::votable_11_dns::VOTABLE_read (isrc, h, f, p);
  }

  ::std::auto_ptr< ::votable_11_dns::VOTABLE >
  VOTABLE_read (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::votable_11_dns::VOTABLE_read (isrc, h, f, p);
  }

  ::std::auto_ptr< ::votable_11_dns::VOTABLE >
  VOTABLE_read (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::votable_11_dns::VOTABLE_read (isrc, f, p);
  }

  ::std::auto_ptr< ::votable_11_dns::VOTABLE >
  VOTABLE_read (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::votable_11_dns::VOTABLE_read (isrc, h, f, p);
  }

  ::std::auto_ptr< ::votable_11_dns::VOTABLE >
  VOTABLE_read (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::votable_11_dns::VOTABLE_read (isrc, h, f, p);
  }

  ::std::auto_ptr< ::votable_11_dns::VOTABLE >
  VOTABLE_read (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::votable_11_dns::VOTABLE > r (
      ::votable_11_dns::VOTABLE_read (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::votable_11_dns::VOTABLE >
  VOTABLE_read (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::votable_11_dns::VOTABLE > r (
      ::votable_11_dns::VOTABLE_read (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::votable_11_dns::VOTABLE >
  VOTABLE_read (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::votable_11_dns::VOTABLE > r (
      ::votable_11_dns::VOTABLE_read (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::votable_11_dns::VOTABLE >
  VOTABLE_read (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::votable_11_dns::VOTABLE > r (
        ::votable_11_dns::VOTABLE_read (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "VOTABLE" &&
        n.namespace_ () == "")
    {
      ::std::auto_ptr< ::votable_11_dns::VOTABLE > r (
        ::xsd::cxx::tree::traits< ::votable_11_dns::VOTABLE, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "VOTABLE",
      "");
  }

  ::std::auto_ptr< ::votable_11_dns::VOTABLE >
  VOTABLE_read (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "VOTABLE" &&
        n.namespace_ () == "")
    {
      ::std::auto_ptr< ::votable_11_dns::VOTABLE > r (
        ::xsd::cxx::tree::traits< ::votable_11_dns::VOTABLE, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "VOTABLE",
      "");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

