/* -*- mode: c++ -*- */
/*+
 *  Name:
 *     VOTableWriteFunctions

 *  Purpose:
 *     Utility functions for accessing VOTables, part of the gaia::VOTable
 *     class.

 *  Description:
 *     These functions make use of the codesynthesis classes generated using
 *     the VOTable 1.1 schema. There are two fundamental versions of theses
 *     classes (sadly not derived from each other, so no common interface,
 *     which is why these functions are preprocessed using differing C++
 *     namespaces) one fully namespace qualified, the official schema, and one
 *     where all the elements are in the default namespace (this latter form
 *     should become less common, but is always likely to occur).
 *
 *     The macro "NS" should be defined before including this file. It
 *     currently assumes the same classes and methods are available in
 *     namespace "NS". Clearly if the structure of the VOTable changes this
 *     may need revisiting.
 *
 *     (Note: some of this could be done using templates, but that looks
 *     untidy as you cannot use a namespace, just types, so each type
 *     used would need to be declared, that NS::VOTABLE, NS::TABLE,
 *     NS::PARAM etc., see emptyTable for a starter if you prefer
 *     that approach).
 *
 *     See VOTableWriteFunctions.C where these are really instantiated.

 *  Language:
 *     C++ include file.

 *  Copyright:
 *     Copyright (C) 2008 Science and Technology Facilities Council.
 *     All Rights Reserved.

 *  Licence:
 *     This program is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU General Public License as
 *     published by the Free Software Foundation; either version 2 of the
 *     License, or (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be
 *     useful, but WITHOUT ANY WARRANTY; without even the implied warranty
 *     of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street,Fifth Floor, Boston, MA
 *     02110-1301, USA

 *  Authors:
 *     PWD: Peter W. Draper (JAC, Durham University)

 *  History:
 *     05-JUN-2008 (PWD):
 *        Original version.
 *     {enter_changes_here}
 *-
 */

/**
 *  Visit all TABLE elements and construct a informative listing of
 *  its contents. Constructed as a Tcl list using {} delimeters.
 */
void VOTable::votable_enum( NS::VOTABLE& votable, ostream& str )
{
    using namespace NS;

    int ntable = votable_count( votable );
    string description;

    for ( int i = 0; i < ntable; i++ ) {
        TABLE& table( votable_get( votable, i ) );
        if ( ! ( table.name() && table.name().get() == "empty" ) ) {
            str << "{ ";

            str << "{" << i << "} ";

            str << "{" << table.name() << "} ";

            table_description( table, description);
            if ( description == "" ) {
                str << "{?} ";
            }
            else {
                str << "{" << description << "} ";
            }

            if ( table.ID() ) {
                str << "{" << table.ID() << "} ";
            }
            else {
                str << "{?} ";
            }

            if ( table.nrows() ) {
                str << "{" << table.nrows() << "} ";
            }
            else {
                str << "{?} ";
            }

            //  Count the fields.
            str << "{" << table_nfields( table ) << "} ";
            str << "} ";
        }
    }
}

/**
 *  Return the number of TABLE elements in the VOTable. Uses the underlying
 *  DOM to navigate the document.
 */
int VOTable::votable_count( NS::VOTABLE& votable )
{
    using namespace NS;

    DOMNode *node = votable._node();
    DOMElement *element = static_cast<DOMElement*>( node );
    XMLCh tempstr[20];
    XMLString::transcode( "TABLE", tempstr, 20 );
    DOMNodeList *tables = element->getElementsByTagName( tempstr );
    return tables->getLength();
}

/**
 *  Return the number of FIELD elements in a TABLE. Uses the underlying
 *  DOM to navigate the document.
 */
int VOTable::table_nfields( NS::TABLE& table )
{
    using namespace NS;

    DOMNode *node = table._node();
    DOMElement *element = static_cast<DOMElement*>( node );
    XMLCh tempstr[20];
    XMLString::transcode( "FIELD", tempstr, 20 );
    DOMNodeList *fields = element->getElementsByTagName( tempstr );
    return fields->getLength();
}

/**
 *  Return the DESCRIPTION of a TABLE. Can be any textual content, but we just
 *  want a string, so just look for children with name DESCRIPTION.
 */
void VOTable::table_description( NS::TABLE& table, string& description )
{
    using namespace NS;

    description = "";

    DOMNode *node = table._node();
    DOMElement *element = static_cast<DOMElement*>( node );
    XMLCh tempstr[20];
    XMLString::transcode( "DESCRIPTION", tempstr, 20 );
    DOMNodeList *nodes = element->getChildNodes();
    if ( nodes->getLength() > 0 ) {
        int n = nodes->getLength();
        for ( int i = 0; i < n; i++ ) {
            DOMElement *element = static_cast<DOMElement*>( nodes->item( i ) );
            if ( XMLString::compareString( element->getNodeName(),
                                           tempstr ) == 0 ) {
                const XMLCh *content = element->getTextContent();
                description += XMLString::transcode( content );
            }
        }
    }
}

/**
 *  Return the value of the attribute value and the text content of a named
 *  INFO element in the VOTable. Uses the underlying DOM to navigate the
 *  document. Not having an element is not an error and the value return is
 *  the string "OK".
 */
int VOTable::votable_info_value( NS::VOTABLE& votable, const char *namevalue,
                                 string &value, string &content )
{
    using namespace NS;

    DOMNode *node = votable._node();
    DOMElement *element = static_cast<DOMElement*>( node );

    XMLCh infostr[20];
    XMLString::transcode( "INFO", infostr, 20 );
    DOMNodeList *nodes = element->getElementsByTagName( infostr );
    int ok = 0;
    if ( nodes->getLength() > 0 ) {

        //  name=value parts
        XMLCh namestr[20];
        XMLString::transcode( "name", namestr, 20 );
        XMLCh namevaluestr[20];
        XMLString::transcode( namevalue, namevaluestr, 20 );

        //  value=
        XMLCh valuestr[20];
        XMLString::transcode( "value", valuestr, 20 );

        int n = nodes->getLength();
        for ( int i = 0; i < n; i++ ) {
            DOMElement *element = static_cast<DOMElement*>( nodes->item( i ) );

            //  Check value of name attribute against the given value.
            if ( XMLString::compareString( element->getAttribute( namestr ),
                                           namevaluestr ) == 0 ) {

                //  Get value of the value attribute.
                const XMLCh *attribute = element->getAttribute( valuestr );
                value = XMLString::transcode( attribute );

                //  And the text content.
                const XMLCh *contentChars = element->getTextContent();
                content = XMLString::transcode( contentChars );

                //  Note it is an error to have an element with no value.
                ok = 1;
                break;
            }
        }
    }
    else {
        //  No element, sadly many tables are incomplete, so not an error.
        value = "OK";
        content = "";
        ok = 1;
    }
    return ok;
}

/**
 *  Locate and return an NS::TABLE. Returns emptyTable on error (need to
 *  return the reference to avoid a copy which would lose the connection to
 *  any IDREF hooks).
 */
NS::TABLE& VOTable::votable_get( NS::VOTABLE& votable, int index )
{
    using namespace NS;

    //  Use the underlying DOM to search for all TABLE elements. These are
    //  located in a breath-first search of the whole document.
    DOMNode *node = votable._node();
    DOMElement *element = static_cast<DOMElement*>( node );
    XMLCh tempstr[20];
    XMLString::transcode( "TABLE", tempstr, 20 );
    DOMNodeList *tables = element->getElementsByTagName( tempstr );
    if ( (int) tables->getLength() > index ) {

        //  Convert TABLE DOM node back to TABLE class.
        DOMElement *tableelement =
            static_cast<DOMElement*>( tables->item( index ) );
        xml_schema::type&
            schema_node( *reinterpret_cast<xml_schema::type*>
                         ( tableelement->getUserData
                           ( xml_schema::dom::tree_node_key ) ) );
        if ( &schema_node ) {
            return dynamic_cast<TABLE&>( schema_node );
        }
    }

    cerr << "No table with index " << index <<
        " (max " << tables->getLength() << ")" << endl;

    return *emptyTable<NS::TABLE>();
}

/**
 *  Convert a TABLE into a Skycat table and write it to the given output
 *  stream.
 */
int VOTable::votable_write( NS::VOTABLE& votable, int index, ofstream& out )
{
    using namespace NS;

    //  Locate the TABLE.
    TABLE& table( votable_get( votable, index ) );
    if ( ! ( table.name() && table.name().get() == "empty" ) ) {

        /*  Found table "index", so write it out. */
        return table_write( table, out );
    }
    cerr << "No table with index " << index << endl;

    return 0;
}

/**
 *  Extract a TABLE into a Skycat table and write it to the given output
 *  stream.
 */
int VOTable::table_write( const NS::TABLE& table, ofstream& out )
{
    using namespace NS;
    try{

        //  Table identification.
        out << table.name() << "\n\n";

        //  Add all parameters (name: value).
        table_params( table, out );

        //  Now the fields and data values.
        table_data( table, out );

        return 1;
    }
    catch ( const xml_schema::exception& e ) {
        cerr << "table_write: ";
        cerr << e << endl;
    }
    return 0;
}

/**
 *  Write the PARAMs of a TABLE to the given output stream in Skycat format.
 */
int VOTable::table_params( const NS::TABLE& table, ofstream& out )
{
    using namespace NS;

    try{
        out << "#  Table parameters: \n";

        out << "long_name: " << table.name() << '\n';

        TABLE::PARAM_const_iterator piter( table.PARAM().begin() );
        TABLE::PARAM_const_iterator pend( table.PARAM().end() );
        string name;
        for ( ; piter != pend; ++piter ) {
            if ( piter->name() ) {
                name = piter->name().get();
                //  Parameter names may not start with '-'.
                if ( name.find( '-' ) == 0 ) {
                    name.erase( 0, 1 );
                }
                out << name << ": " << piter->value() << '\n';
            }
            else {
                //  Unnamed parameter.
                out << ": " << piter->value() << '\n';
            }
        }
        out << '\n';

        return 1;
    }
    catch ( const xml_schema::exception& e ) {
        cerr << "table_params: ";
        cerr << e << endl;
    }
    return 0;
}

/**
 *  Write the data of a table, this includes the FIELD elements as Skycat
 *  column names and other column metadata such as the units, ucd, utypes and
 *  xtypes.  The derivation of the column indices for ID, RA, Dec, X and Y (if
 *  not found they will be set to -1). If the RA or Dec columns require
 *  transforming to degrees from radians then that will also be done. Finally
 *  the DATA elements will be expanded into the actual columns.
 */
int VOTable::table_data( const NS::TABLE& table, ofstream& out )
{
    using namespace NS;

    try{
        //  Lower case FIELD meta data.
        string name;
        string ucd;
        string utype;
#if NSVERS > 11
        string xtype;
#endif
        string unit;

        //  Local decs for parameters we want to locate.
        int dec_index = -1;
        int id_index = -1;
        int ra_index = -1;
        int x_index = -1;
        int y_index = -1;

        //  Whether RA and Dec need conversion from radians, raw units.
        bool dec_radians = false;
        bool ra_radians = false;
        string ra_unit;
        string dec_unit;

        //  The column names as a TST header and the separator.
        string header;
        string sep;

        //  FIELD meta-data items as TST parameter.
        string ucds;
        string utypes;
#if NSVERS > 11
        string xtypes;
#endif
        string units;
        string datatypes;

        //  Iterate over all FIELD elements in this TABLE.
        TABLE::FIELD_const_iterator fiter( table.FIELD().begin() );
        TABLE::FIELD_const_iterator fend( table.FIELD().end() );

        //  When an RA or Dec is discovered look for the related coordinate
        //  system.
        bool checkcoosys = false;
        bool havecoosys = false;

        int ncol = 0;
        for ( ; fiter != fend; ++fiter ) {

            //  FIELD meta data.
            //  Get these values as string instances and cast to lower case.
            if ( fiter->name() ) {
                to_lower( fiter->name().get(), name );
            }
            else {
                //  ID is sometimes used as name.
                if ( fiter->ID() ) {
                    to_lower( fiter->ID().get(), name );
                }
                else {
                    //  Unnamed field.
                    name = "unnamed";
                }
            }
            if ( fiter->ucd() ) {
                to_lower( fiter->ucd().get(), ucd );
            }
            if ( fiter->utype() ) {
                to_lower( fiter->utype().get(), utype );
            }
#if NSVERS > 11
            if ( fiter->xtype() ) {
                to_lower( fiter->xtype().get(), xtype );
            }
#endif
            if ( fiter->unit() ) {
                to_lower( fiter->unit().get(), unit );
            }

            //  Check this column against the possible matches for a Skycat
            //  special column (ID, RA, DEC, X and Y).
            if ( id_index == -1 && gaia::matches_id( name, ucd, utype ) ) {
                id_index = ncol;
            }
            else if ( ra_index == -1 &&
                      gaia::matches_ra( name, ucd, unit, utype ) ) {
                ra_index = ncol;
                ra_unit = unit;
                if ( unit.find( "rad" ) == 0 ) {
                    ra_radians = true;
                }
                checkcoosys = true;
            }
            else if ( dec_index == -1 &&
                      gaia::matches_dec( name, ucd, unit, utype ) ) {
                dec_index = ncol;
                dec_unit = unit;
                if ( unit.find( "rad" ) == 0 ) {
                    dec_radians = true;
                }
                checkcoosys = true;
            }
            else if ( x_index == -1 && gaia::matches_x( name, ucd, utype ) ) {
                x_index = ncol;
            }
            else if ( y_index == -1 && gaia::matches_y( name, ucd, utype ) ) {
                y_index = ncol;
            }

            //  Write out the COOSYS first time we hit an RA/Dec column.
            if ( checkcoosys && !havecoosys ) {
                //  Look up the ref to get at the IDREF object.
                if ( fiter->ref() ) {
                    if ( fiter->ref().get() ) {
                        try {
                            COOSYS const& coosys
                                ( dynamic_cast<COOSYS const&>
                                  ( *(fiter->ref().get()) ) );
                            table_coosys( coosys, out );

                            //  Only do this once. Assumes RA and Dec are in
                            //  same system.
                            havecoosys = true;
                        }
                        catch (bad_cast) {
                            //  Could be STC which starts with a GROUP.
                            try {
                                GROUP const& group
                                    ( dynamic_cast<GROUP const&>
                                      ( *(fiter->ref().get()) ) );
                                table_stc( group, out );
                                out << '\n';
                                havecoosys = true;
                            }
                            catch (bad_cast) {
                                cerr << "Bad coordinate system for reference: "
                                     << fiter->ref() << endl;
                            }
                        }
                    }
                    else {
                        cerr << "Missing target for reference: "
                             << fiter->ref() << endl;
                    }
                }
            }

            /*  Add column name and gather other meta-data. */
            if ( ncol == 0 ) {
                if ( fiter->name() ) {
                    header = fiter->name().get();
                }
                else {
                    if ( fiter->ID() ) {
                        header = fiter->ID().get();
                    }
                    else {
                        header = "unnamed";
                    }
                }
                sep = "---";
                if ( fiter->ucd() ) {
                    ucds = fiter->ucd().get();
                }
                else {
                    ucds = "---";
                }
                if ( fiter->utype() ) {
                    utypes = fiter->utype().get();
                }
                else {
                    utypes = "---";
                }
#if NSVERS > 11
                if ( fiter->xtype() ) {
                    xtypes = fiter->xtype().get();
                }
                else {
                    xtypes = "---";
                }
#endif
                if ( fiter->unit() ) {
                    units = fiter->unit().get();
                }
                else {
                    units = "---";
                }
                if ( fiter->datatype() ) {
                    datatypes = fiter->datatype().get();
                }
                else {
                    datatypes = "---";
                }
            }
            else {
                if ( fiter->name() ) {
                    header += '\t' + fiter->name().get();
                }
                else {
                    if ( fiter->ID() ) {
                        header += '\t' + fiter->ID().get();
                    }
                    else {
                        header += "\tunnamed";
                    }
                }

                sep += "---\t";
                ucds += '\t';
                if ( fiter->ucd() ) {
                    ucds += fiter->ucd().get();
                }
                else {
                    ucds += "---";
                }
                utypes += '\t';
                if ( fiter->utype() ) {
                    utypes += fiter->utype().get();
                }
                else {
                    utypes += "---";
                }
#if NSVERS > 11
                xtypes += '\t';
                if ( fiter->xtype() ) {
                    xtypes += fiter->xtype().get();
                }
                else {
                    xtypes += "---";
                }
#endif
                units += '\t';
                if ( fiter->unit() ) {
                    units += fiter->unit().get();
                }
                else {
                    units += "---";
                }
                datatypes += '\t';
                if ( fiter->datatype() ) {
                    datatypes += fiter->datatype().get();
                }
                else {
                    datatypes += "---";
                }
            }

            //  Iterates in sequence of columns. */
            ncol++;
        }

        //  If no ID column has been found add one to the end.
        int id_col = id_index;
        if ( id_col == -1 ) {
            id_col = ncol;
            header += "\tID";
        }

        //  Write special parameters out.
        out << "#  Table columns: \n";
        out << "id_col: " << id_col << '\n';
        out << "ra_col: " << ra_index << '\n';
        out << "dec_col: " << dec_index << '\n';
        out << "x_col: " << x_index << '\n';
        out << "y_col: " << y_index << '\n';
        out << '\n';

        //  FIELD meta-data.
        out << "ucd: " << ucds << '\n';
        out << "utype: " << utypes << '\n';
#if NSVERS > 11
        out << "xtype: " << xtypes << '\n';
#endif
        out << "unit: " << units << '\n';
        out << "datatype: " << datatypes << '\n';

        //  Column headings and separator to table data.
        out << header << '\n';
        out << sep << '\n';

        //  Write the table columns.
        table_columns( table, out, id_index, ra_index, ra_radians, ra_unit,
                       dec_index, dec_radians, dec_unit );

        return 1;
    }
    catch ( const xml_schema::exception& e ) {
        cerr << "table_fields: ";
        cerr << e << endl;
    }
    return 0;
}

/**
 *  Look at a GROUP that defines the STC coordinates of a FIELD and convert
 *  into a standard system, equinox and epoch if possible.
 */
void VOTable::table_stc( const NS::GROUP& group, ofstream& out )
{
    using namespace NS;

    //  Look for a ref to the a related coordinate system (CUPID style).
    //  Should be in another GROUP.
    try {
        const NS::GROUP *gp = &group;
        const xml_schema::idref& ref( *(gp->ref()) );
        if ( &ref != 0 ) {
            GROUP const& fgroup(dynamic_cast<GROUP const&>( *ref ) );
            table_stc( fgroup, out );
        }
    }
    catch (bad_cast) {
        cerr << "Failed to get ID for group: " << group.ref() << endl;
        //  Just ignore, this group is the end of the chain.
    }

    //  Could also contain a series of GROUPS.
    GROUP::GROUP1_const_iterator giter( group.GROUP1().begin() );
    GROUP::GROUP1_const_iterator gend( group.GROUP1().end() );
    for ( ; giter != gend; ++giter ) {
        table_stc( *giter, out );
    }

    //  Finally down to PARAMs of this GROUP.
    GROUP::PARAM_const_iterator piter( group.PARAM().begin() );
    GROUP::PARAM_const_iterator pend( group.PARAM().end() );
    string name;
    string value;
    for ( ; piter != pend; ++piter ) {
        if ( piter->name() ) {
            to_lower( piter->name().get(), name );
            const PARAM::value_optional ov( piter->value() );
            to_lower( ov.get(), value );
            if ( name == "spaceframe"  ) {
                out << "system: " << value << '\n';
                if ( value == "fk5" ) {
                    out << "equinox: 2000.0\n";
                }
                else if ( value == "fk4" ) {
                    out << "equinox: 1950.0\n";
                }
            }
            if ( name == "jepoch" ) {
                out << "epoch: " << value << '\n';
            }
        }
    }
}

/**
 *  Write a version 1.1 COOSYS element as table parameters. Transforms the
 *  VOTable system values into AST compatible systems (as best as I can
 *  determine).
 */
void VOTable::table_coosys( const NS::COOSYS& coosys, ofstream& out )
{
    //    System - ICRS
    //           - eq_FK5
    //           - eq_FK4
    //           - ecl_FK5  (ecliptic, equinox = J2000)
    //           - ecl_FK4  (ecliptic, equinox = B1950)
    //           - galactic
    //           - supergalactic
    //           - barycentric (I'm guessing that means BCRS, nearly ICRS w/o
    //                          time, but who knows)
    //           - geo_app
    string system;
    string epoch;
    string equinox;
    to_lower( coosys.system(), system );
    if ( system == "eq_fk5" ) {
        system = "FK5";
        equinox = "J2000";
    }
    else if ( system == "eq_fk4" ) {
        system = "FK4";
        equinox = "B1950";
    }
    else if ( system == "ecl_fk5" ) {
        system = "ECLIPTIC";
        equinox = "J2000";
    }
    else if ( system == "ecl_fk4" ) {
        system = "ECLIPTIC";
        equinox = "B1950";
    }
    else if ( system == "galactic" ) {
        system = "GALACTIC";
    }
    else if ( system == "supergalactic" ) {
        system = "SUPERGALACTIC";
    }
    else if ( system == "barycentric" ) {
        system = "ICRS";
    }
    else if ( system == "geo_app" ) {
        system = "GEOCENTRIC";
    }
    out << "system: " << system << '\n';

    //  Pick out epoch and equinox.
    if ( coosys.equinox() ) {
        out << "equinox: " << coosys.equinox() << '\n';
    }
    else if ( equinox != "" ) {
        out << "equinox: " << equinox << '\n';
    }

    if ( coosys.epoch() ) {
        out << "epoch: " << coosys.epoch() << '\n';
    }
    else if ( epoch != "" ) {
        out << "epoch: " << epoch << '\n';
    }
    out << '\n';
}

/**
 *  Write the DATA element of a table to Skycat format. RA and Dec columns
 *  are converted from radians to degrees if needed.
 */
int VOTable::table_columns( const NS::TABLE& table, ofstream& out,
                            int& id_index, int& ra_index, bool& ra_radians,
                            string& ra_unit, int& dec_index, bool& dec_radians,
                            string& dec_unit )
{
    using namespace NS;

    //  Locate the DATA element of this TABLE.
    const TABLE::DATA_optional odata( table.DATA() );

    //  Empty tables are OK.
    if ( odata ) {

        //  Four variants, TABLEDATA, BINARY, BINARY2 and FITS.
        const DATA::TABLEDATA_optional tdata( odata.get().TABLEDATA() );
        if ( tdata ) {
            return data_tabledata( table, tdata.get(), out, id_index,
                                   ra_index, ra_radians, ra_unit,
                                   dec_index, dec_radians, dec_unit );
        }

        const DATA::BINARY_optional bdata( odata.get().BINARY() );
        if ( bdata ) {
            return data_binarydata( false, table, bdata.get(), out, id_index,
                                    ra_index, ra_radians, dec_index,
                                    dec_radians );
        }

        /*  Only in 1.3 and later */
#if NSVERS == 13

        const DATA::BINARY2_optional bdata2( odata.get().BINARY2() );
        if ( bdata2 ) {
            return data_binarydata2( true, table, bdata2.get(), out, id_index,
                                     ra_index, ra_radians, dec_index,
                                     dec_radians );
        }
#endif

        const DATA::FITS_optional fdata( odata.get().FITS() );
        if ( fdata ) {
            return data_fitsdata( fdata.get(), out, id_index, ra_index,
                                  ra_radians, dec_index, dec_radians );
        }
    }
    return 1;
}

/**
 *  Write a TABLEDATA element of a table to Skycat format. RA and Dec columns
 *  are converted from radians to degrees if needed and the HMS & DMS forms
 *  may be normalised.
 */
int VOTable::data_tabledata( const NS::TABLE& table, const NS::TABLEDATA& tdata,
                    ofstream& out, int& id_index,
                    int& ra_index, bool& ra_radians, string& ra_unit,
                    int& dec_index, bool& dec_radians, string& dec_unit )
{
    using namespace NS;

    //  Iterate again over all FIELD elements in this TABLE to look for any
    //  null settings.
    TABLE::FIELD_const_iterator fiter( table.FIELD().begin() );
    TABLE::FIELD_const_iterator fend( table.FIELD().end() );
    vector<string> nullvalues;

    for ( ; fiter != fend; ++fiter ) {
        FIELD::VALUES_optional values( fiter->VALUES() );
        if ( values ) {
            VALUES::null_optional nullv( values.get().null() );
            if ( &nullv.get() != 0 ) {
                if ( ! nullv.get().empty() ) {
                    nullvalues.push_back( nullv.get() );
                }
                else {
                    nullvalues.push_back( "" );
                }
            }
            else {
                nullvalues.push_back( "" );
            }
        }
        else {
            nullvalues.push_back( "" );
        }
    }

    //  TABLEDATA consists of rows of <TR> with each cell as a <TD> element.
    TABLEDATA::TR_const_iterator triter( tdata.TR().begin() );
    TABLEDATA::TR_const_iterator trend( tdata.TR().end() );
    int nrow = 1;
    string cell;
    for ( ; triter != trend; ++triter ) {
        TR::TD_const_iterator tditer( triter->TD().begin() );
        TR::TD_const_iterator tdend( triter->TD().end() );

        for ( int ncol = 0; tditer != tdend; ++tditer, ncol++ ) {

            //  Clean string of newlines. Should be trivial formatting
            //  within a cell.
            cell = *tditer;
            replace( cell.begin(), cell.end(), '\n', ' ' );

            //  Test if this is the null value (usually "" for tabledata).
            if ( cell == nullvalues[ncol] ) {
                out << " \t";
            }
            else if ( ncol == ra_index || ncol == dec_index ) {
                if ( ra_radians || dec_radians ) {

                    //  RA and Dec in radians, need degrees.
                    double rad;
                    if ( from_string( cell, rad, scientific ) ) {
                        rad *= R2D;
                        out << scientific << rad << '\t';
                    }
                    else {
                        out << "*****\t";
                    }
                }
                else if ( ra_unit.find( "hms" ) != string::npos ||
                          ra_unit.find( "h:m:s" ) != string::npos ||
                          dec_unit.find( "dms" ) !=  string::npos ||
                          dec_unit.find( "d:m:s" ) != string::npos ) {

                    //  Check we have hh:mm:ss.ss and dd:mm:ss.ss, if not try
                    //  to normalize.
                    istringstream hms( cell );
                    string tmp;
                    string norm;
                    if ( hms.str().find( ':' ) == string::npos ) {
                        while ( std::getline( hms, tmp, ' ' ) ) {
                            norm += tmp;
                            norm += ':';
                        }
                        if ( norm.size() > 0 ) {
                            norm.erase( norm.size() - 1 );
                        }
                        else {
                            norm = hms.str();
                        }
                        out << norm << '\t';
                    }
                    else {
                        out << cell << '\t';
                    }
                }
                else {
                    out << cell << '\t';
                }
            }
            else {
                out << cell << '\t';
            }
        }
        if ( id_index == -1 ) {
            out << nrow << '\t';
            nrow++;
        }

        out << '\n';
    }
    return 1;
}

/**
 *  Write a BINARY2 element of a table to Skycat format. RA and Dec
 *  columns are converted from radians to degrees if needed.
 */
#if NSVERS == 13
int VOTable::data_binarydata2( bool binary2, const NS::TABLE& table, const NS::BINARY2& bdata,
                               ofstream& out, int& id_index, int& ra_index,
                               bool& ra_radians, int& dec_index, bool& dec_radians )
{
    using namespace NS;

    //  See if we need to decode the data. Support base64 and gzip and
    //  native. See if this is needed by checking the encodingType.
    BINARY2::STREAM_type stream( bdata.STREAM() );
    string encoding( stream.encoding() );
    STREAM::href_optional href( stream.href() );

    return data_binarystream( binary2, table, stream, encoding, href,
                              out, id_index, ra_index,
                              ra_radians, dec_index, dec_radians );
}
#endif

/**
 *  Write a BINARY element of a table to Skycat format. RA and Dec
 *  columns are converted from radians to degrees if needed.
 */
int VOTable::data_binarydata( bool binary2, const NS::TABLE& table, const NS::BINARY& bdata,
                              ofstream& out, int& id_index, int& ra_index,
                              bool& ra_radians, int& dec_index, bool& dec_radians )
{
    using namespace NS;

    //  See if we need to decode the data. Support base64 and gzip and
    //  native. See if this is needed by checking the encodingType.
    BINARY::STREAM_type stream( bdata.STREAM() );
    string encoding( stream.encoding() );
    STREAM::href_optional href( stream.href() );

    return data_binarystream( binary2, table, stream, encoding, href,
                              out, id_index, ra_index,
                              ra_radians, dec_index, dec_radians );
}

/**
 *  Read a stringstream wrapping a BINARY or BINARY2 element of a table to
 *  Skycat format. RA and Dec columns are converted from radians to degrees if
 *  needed.
 */
int VOTable::data_binarystream( bool binary2, const NS::TABLE& table,
                                const string& stream, const string& encoding,
                                NS::STREAM::href_optional& href,
                                ofstream& out, int& id_index, int& ra_index,
                                bool& ra_radians, int& dec_index, bool& dec_radians )
{
    using namespace NS;

    streambuf *inbuf;
    stringstream *istr;
    HTTP http; //  Keep in scope for memory management.

    if ( href ) {

        //  Remote resource. Need to access it. HTTP class supports access to
        //  file: and http: forms. XXX ftp support?
        string url = href.get();
        ostringstream ostring;
        if ( http.get( url.c_str(), ostring ) ) {
            return 0;
        }
        istr = new stringstream( ostring.str() );
        inbuf = istr->rdbuf();
    }
    else {
        //  Values in VOTable.
        istr = new stringstream( stream );
        inbuf = istr->rdbuf();
    }

    if ( encoding == "base64" ) {

        //  Wrap into a streambuf that decodes this content.
        string str = istr->str();
        size_t length = str.size();
        char *dest = new char[length];
        decode_base64( str.c_str(), dest, &length );
        inbuf = new stringbuf( string( dest, length ) );
        delete dest;
    }
    else if ( encoding == "gzip" ) {
        //  Wrap into a streambuf that decodes this content.
        string str = istr->str();
        size_t length = str.size();
        char *dest;
        decode_gzip( str.c_str(), length, length, dest );
        inbuf = new stringbuf( string( dest, length ) );
        free_gzip( dest );
    }

    //  For binary data we need to understand the properties of each column,
    //  so an additional pass through the FIELD elements is required.
    vector<VOTableStream::datatype> field_types;
    vector<int> arraysizes;
    vector<bool> havenull;
    vector<string> nullvalues;

    //  Iterate over all FIELD elements in this TABLE.
    TABLE::FIELD_const_iterator fiter( table.FIELD().begin() );
    TABLE::FIELD_const_iterator fend( table.FIELD().end() );

    for ( ; fiter != fend; ++fiter ) {

        string type;
        to_lower( fiter->datatype().get(), type );

        if ( type == "boolean" ) {
            field_types.push_back( VOTableStream::BOOLEAN );
        }
        else if ( type == "bit" ) {
            field_types.push_back( VOTableStream::BITARRAY );
        }
        else if ( type == "unsignedbyte" ) {
            field_types.push_back( VOTableStream::BYTE );
        }
        else if ( type == "char" ) {
            field_types.push_back( VOTableStream::CHAR );
        }
        else if ( type == "unicodechar" ) {
            field_types.push_back( VOTableStream::UNICODE );
        }
        else if ( type == "short" ) {
            field_types.push_back( VOTableStream::SHORT );
        }
        else if ( type == "int" ) {
            field_types.push_back( VOTableStream::INT );
        }
        else if ( type == "long" ) {
            field_types.push_back( VOTableStream::LONG );
        }
        else if ( type == "double" ) {
            field_types.push_back( VOTableStream::DOUBLE );
        }
        else if ( type == "float" ) {
            field_types.push_back( VOTableStream::FLOAT );
        }
        else if ( type == "floatcomplex" ) {
            field_types.push_back( VOTableStream::FLOATCOMPLEX );
        }
        else if ( type == "doublecomplex" ) {
            field_types.push_back( VOTableStream::DOUBLECOMPLEX );
        }

        //  Number of this type required.
        arraysizes.push_back( field_arraysize( *fiter ) );

        //  Check for a null attribute in the optional VALUES element.
        //  Not used in BINARY2, null bits are encoded for each row.
        FIELD::VALUES_optional values( fiter->VALUES() );

        if ( values ) {
            VALUES::null_optional nullv( values.get().null() );
            if ( &nullv.get() != 0 ) {
                if ( ! nullv.get().empty() ) {
                    havenull.push_back( true );
                    nullvalues.push_back( nullv.get() );
                }
                else {
                    havenull.push_back( false );
                    nullvalues.push_back( "" );
                }
            }
            else {
                havenull.push_back( false );
                nullvalues.push_back( "" );
            }
        }
        else {
            havenull.push_back( false );
            nullvalues.push_back( "" );
        }
    }

    /*  Now write the rows. */
    VOTableStream os( inbuf );
    bool ok = true;
    int nrow = 1;

    //  Number of bytes used for nulls in BINARY2 format.
    int b2bytes = (int) (field_types.size() + 7 ) / 8;
    bool *b2mask = new bool[b2bytes * 8];

    while ( ok ) {
        if ( binary2 ) {
            // First field is null bit array.
            ok = os.readBitMask( b2bytes, b2mask );
            if ( ! ok ) {
                break;
            }
        }
        for ( int i = 0; i < (int) field_types.size(); i++ ) {
            if ( binary2 ) {
                if ( b2mask[i] ) {
                    ok = os.readSkip( field_types[i], arraysizes[i] );
                    out << " ";
                }
                else {
                    ok = os.readPrint( field_types[i], arraysizes[i],
                                       havenull[i], nullvalues[i], &out );
                }
            }
            else {
                ok = os.readPrint( field_types[i], arraysizes[i], havenull[i],
                                   nullvalues[i], &out );
            }
            if ( ok ) {
                out << '\t';
            }
            else {
                break;
            }
        }
        if ( id_index == -1 && ok ) {
            out << nrow << '\t';
            nrow++;
        }
        if ( ok ) out << '\n';
    }

    delete istr;
    delete[] b2mask;

    return 1;
}

/**
 *  Write a FITS element of a table to Skycat format. RA and Dec columns
 *  are converted from radians to degrees if needed.
 */
int VOTable::data_fitsdata( const NS::FITS& fdata, ofstream& out, int& id_index,
                            int& ra_index, bool& ra_radians, int& dec_index,
                            bool& dec_radians )
{
    using namespace NS;

    //  Check for the extension number. For a table in a file must be 1 or
    //  greater, not sure what this would be for an inline FITS structure.
    //  Leave default at 1.
    int extnum = 1;
    if ( fdata.extnum() ) {
        extnum = fdata.extnum().get();
    }

    //  Keep in scope for later (C string can be used in Mem object).
    ostringstream ostring;

    //  Access uses a Skycat FitsIO object.
    FitsIO *fits = NULL;

    //  Usually have a href, when not true the data maybe inline, so
    //  try that.
    FITS::STREAM_type stream( fdata.STREAM() );
    STREAM::href_optional href( stream.href() );
    if ( href ) {
        string url = href.get();

        //  Get the FITS file. Note gzip is handled directly.
        if ( url.find( "file:" ) == 0 ) {

            //  Strip three '/' (legally, file:///, file://localhost/).
            size_t idx = url.find( '/' );
            idx = url.find( '/', idx + 1 );
            idx = url.find( '/', idx + 1 );
            string file = url.substr( idx );
            fits = FitsIO::read( file.c_str(), O_RDONLY | S_IRUSR);
        }
        else {
            //  Remote resource, which we read into memory (may need to read
            //  these to a local file if large, the below would use memory
            //  mapping in that instance).
            HTTP http;
            if ( http.get( url.c_str(), ostring ) ) {
                return 0;
            }

            //  Access the FITS data and gunzip if needed. Otherwise just
            //  create a memory FITS object.
            char *dest;
            size_t length = ostring.str().size();
            Mem *mem;

            if ( stream.encoding() == "base64" ) {
                dest = (char *) malloc( length );
                decode_base64( ostring.str().c_str(), dest, &length );
                mem = new Mem( (void *) dest, length, 1 );
            }
            else if ( stream.encoding() == "gzip" ) {
                decode_gzip( ostring.str().c_str(), length, length, dest );
                mem = new Mem( (void *) dest, length, 1 );
            }
            else {
                //  Simple file, memory wrap it.
                dest = (char *) ostring.str().c_str();
                mem = new Mem( (void *) dest, length, 0 );
            }
            fits = FitsIO::initialize( *mem );
            delete mem; //  Should persist until fits is deleted.
        }
    }
    else {
        //  No href, data must be inline, hopefully in base64, but let's
        //  be flexible.
        char *dest;
        size_t length = stream.size();
        Mem *mem;

        if ( stream.encoding() == "base64" ) {
            dest = (char *) malloc( length );
            decode_base64( stream.c_str(), dest, &length );
            mem = new Mem( (void *) dest, length, 1 );
        }
        else if ( stream.encoding() == "gzip" ) {
            decode_gzip( stream.c_str(), length, length, dest );
            mem = new Mem( (void *) dest, length, 1 );
        }
        else {
            //  Simple inline (probably will not work).
            dest = (char *) stream.c_str();
            mem = new Mem( (void *) dest, length, 0 );
        }
        fits = FitsIO::initialize( *mem );
        delete mem; //  Should persist until fits is deleted.
    }

    if ( !fits || fits->status() != 0 ) {
        return 0;
    }

    if ( extnum != 0 ) {
        fits->setHDU( extnum + 1 );
    }

    //  Check size of table.
    long nrows = 0;
    int ncols = 0;
    if ( fits->getTableDims( nrows, ncols ) != 0 ) {
        return 0;
    }

    //  Write the data.
    double rascale = 1.0;
    double decscale = 1.0;
    if ( ra_radians ) {
        rascale = R2D;
    }
    if ( dec_radians ) {
        decscale = R2D;
    }

    char *s;
    for ( long nrow = 1; nrow <= nrows; nrow++ ) {
        for ( long col = 1; col <= ncols; col++ ) {
            if ( col == ( ra_index + 1 ) ) {
                s = fits->getTableValue( nrow, col, rascale );
            }
            else if ( col == ( dec_index + 1 ) ) {
                s = fits->getTableValue( nrow, col, decscale );
            }
            else {
                s = fits->getTableValue( nrow, col, 1.0 );
            }
            if ( ! s ) {
                return 0;
            }
            out << s;

            if ( col < ncols ) {
                out << '\t';
            }
        }
        if ( id_index == -1 ) {
            out << '\t' << nrow;
        }
        out << '\n';
    }
    return 1;
}

/**
 *  Determine an arraysizes value. Will be 1 by default and 0 if the arraysize
 *  is set to "*". If a multi-dimensional size is encountered then we indicate
 *  this by a single size. Those are not supported by GAIA.
 */
int VOTable::field_arraysize( const NS::FIELD& field )
{
    using namespace NS;

    FIELD::arraysize_optional fas( field.arraysize() );
    int arraysize;
    if ( fas ) {
        string as( fas.get() );
        if ( as == "*" ) {
            arraysize = 0;
        }
        else if ( as == "" ) {
            arraysize = 1;
        }
        else if ( as.find( "x" ) == string::npos ) {
            //  Multi-dimensional. XXX untested.
            size_t pos1 = 0;
            size_t pos2 = 0;
            int dim = 0;
            arraysize = 1;
            while ( ( pos2 = as.find( "x", pos1 ) ) != string::npos ) {
                from_string( as.substr( pos2, pos1 - pos2 ), dim, dec );
                arraysize *= dim;
                pos1 = pos2 + 1;
            }
            //  Last element.
            from_string( as.substr( pos1 ), dim, dec );
            arraysize *= dim;
        }
        else {
            from_string( as, arraysize, dec );
        }
    }
    else {
        arraysize = 1;
    }
    return arraysize;
}

