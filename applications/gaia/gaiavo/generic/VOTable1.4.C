// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "VOTable1.4.hxx"

namespace votable_14
{
  // anyTEXT
  // 

  const anyTEXT::any_sequence& anyTEXT::
  any () const
  {
    return this->any_;
  }

  anyTEXT::any_sequence& anyTEXT::
  any ()
  {
    return this->any_;
  }

  void anyTEXT::
  any (const any_sequence& s)
  {
    this->any_ = s;
  }

  const ::xercesc::DOMDocument& anyTEXT::
  dom_document () const
  {
    return *dom_document_;
  }

  ::xercesc::DOMDocument& anyTEXT::
  dom_document ()
  {
    return *dom_document_;
  }


  // astroYear
  // 


  // ucdType
  // 


  // arrayDEF
  // 


  // encodingType
  // 

  encodingType::
  encodingType (value v)
  : ::xml_schema::nmtoken (_xsd_encodingType_literals_[v])
  {
  }

  encodingType::
  encodingType (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  encodingType::
  encodingType (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  encodingType::
  encodingType (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  encodingType::
  encodingType (const encodingType& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  encodingType& encodingType::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_encodingType_literals_[v]);

    return *this;
  }


  // dataType
  // 

  dataType::
  dataType (value v)
  : ::xml_schema::nmtoken (_xsd_dataType_literals_[v])
  {
  }

  dataType::
  dataType (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  dataType::
  dataType (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  dataType::
  dataType (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  dataType::
  dataType (const dataType& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  dataType& dataType::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_dataType_literals_[v]);

    return *this;
  }


  // precType
  // 


  // yesno
  // 

  yesno::
  yesno (value v)
  : ::xml_schema::nmtoken (_xsd_yesno_literals_[v])
  {
  }

  yesno::
  yesno (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  yesno::
  yesno (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  yesno::
  yesno (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  yesno::
  yesno (const yesno& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  yesno& yesno::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_yesno_literals_[v]);

    return *this;
  }


  // MIN
  // 

  const MIN::value_type& MIN::
  value () const
  {
    return this->value_.get ();
  }

  MIN::value_type& MIN::
  value ()
  {
    return this->value_.get ();
  }

  void MIN::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void MIN::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const MIN::inclusive_type& MIN::
  inclusive () const
  {
    return this->inclusive_.get ();
  }

  MIN::inclusive_type& MIN::
  inclusive ()
  {
    return this->inclusive_.get ();
  }

  void MIN::
  inclusive (const inclusive_type& x)
  {
    this->inclusive_.set (x);
  }

  void MIN::
  inclusive (::std::auto_ptr< inclusive_type > x)
  {
    this->inclusive_.set (x);
  }

  const MIN::inclusive_type& MIN::
  inclusive_default_value ()
  {
    return inclusive_default_value_;
  }


  // MAX
  // 

  const MAX::value_type& MAX::
  value () const
  {
    return this->value_.get ();
  }

  MAX::value_type& MAX::
  value ()
  {
    return this->value_.get ();
  }

  void MAX::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void MAX::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const MAX::inclusive_type& MAX::
  inclusive () const
  {
    return this->inclusive_.get ();
  }

  MAX::inclusive_type& MAX::
  inclusive ()
  {
    return this->inclusive_.get ();
  }

  void MAX::
  inclusive (const inclusive_type& x)
  {
    this->inclusive_.set (x);
  }

  void MAX::
  inclusive (::std::auto_ptr< inclusive_type > x)
  {
    this->inclusive_.set (x);
  }

  const MAX::inclusive_type& MAX::
  inclusive_default_value ()
  {
    return inclusive_default_value_;
  }


  // OPTION
  // 

  const OPTION::OPTION1_sequence& OPTION::
  OPTION1 () const
  {
    return this->OPTION1_;
  }

  OPTION::OPTION1_sequence& OPTION::
  OPTION1 ()
  {
    return this->OPTION1_;
  }

  void OPTION::
  OPTION1 (const OPTION1_sequence& s)
  {
    this->OPTION1_ = s;
  }

  const OPTION::name_optional& OPTION::
  name () const
  {
    return this->name_;
  }

  OPTION::name_optional& OPTION::
  name ()
  {
    return this->name_;
  }

  void OPTION::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void OPTION::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void OPTION::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const OPTION::value_type& OPTION::
  value () const
  {
    return this->value_.get ();
  }

  OPTION::value_type& OPTION::
  value ()
  {
    return this->value_.get ();
  }

  void OPTION::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void OPTION::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // VALUES
  // 

  const VALUES::MIN_optional& VALUES::
  MIN () const
  {
    return this->MIN_;
  }

  VALUES::MIN_optional& VALUES::
  MIN ()
  {
    return this->MIN_;
  }

  void VALUES::
  MIN (const MIN_type& x)
  {
    this->MIN_.set (x);
  }

  void VALUES::
  MIN (const MIN_optional& x)
  {
    this->MIN_ = x;
  }

  void VALUES::
  MIN (::std::auto_ptr< MIN_type > x)
  {
    this->MIN_.set (x);
  }

  const VALUES::MAX_optional& VALUES::
  MAX () const
  {
    return this->MAX_;
  }

  VALUES::MAX_optional& VALUES::
  MAX ()
  {
    return this->MAX_;
  }

  void VALUES::
  MAX (const MAX_type& x)
  {
    this->MAX_.set (x);
  }

  void VALUES::
  MAX (const MAX_optional& x)
  {
    this->MAX_ = x;
  }

  void VALUES::
  MAX (::std::auto_ptr< MAX_type > x)
  {
    this->MAX_.set (x);
  }

  const VALUES::OPTION_sequence& VALUES::
  OPTION () const
  {
    return this->OPTION_;
  }

  VALUES::OPTION_sequence& VALUES::
  OPTION ()
  {
    return this->OPTION_;
  }

  void VALUES::
  OPTION (const OPTION_sequence& s)
  {
    this->OPTION_ = s;
  }

  const VALUES::ID_optional& VALUES::
  ID () const
  {
    return this->ID_;
  }

  VALUES::ID_optional& VALUES::
  ID ()
  {
    return this->ID_;
  }

  void VALUES::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void VALUES::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void VALUES::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const VALUES::type_type& VALUES::
  type () const
  {
    return this->type_.get ();
  }

  VALUES::type_type& VALUES::
  type ()
  {
    return this->type_.get ();
  }

  void VALUES::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void VALUES::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const VALUES::type_type& VALUES::
  type_default_value ()
  {
    return type_default_value_;
  }

  const VALUES::null_optional& VALUES::
  null () const
  {
    return this->null_;
  }

  VALUES::null_optional& VALUES::
  null ()
  {
    return this->null_;
  }

  void VALUES::
  null (const null_type& x)
  {
    this->null_.set (x);
  }

  void VALUES::
  null (const null_optional& x)
  {
    this->null_ = x;
  }

  void VALUES::
  null (::std::auto_ptr< null_type > x)
  {
    this->null_.set (x);
  }

  const VALUES::ref_optional& VALUES::
  ref () const
  {
    return this->ref_;
  }

  VALUES::ref_optional& VALUES::
  ref ()
  {
    return this->ref_;
  }

  void VALUES::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void VALUES::
  ref (const ref_optional& x)
  {
    this->ref_ = x;
  }

  void VALUES::
  ref (::std::auto_ptr< ref_type > x)
  {
    this->ref_.set (x);
  }


  // LINK
  // 

  const LINK::ID_optional& LINK::
  ID () const
  {
    return this->ID_;
  }

  LINK::ID_optional& LINK::
  ID ()
  {
    return this->ID_;
  }

  void LINK::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void LINK::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void LINK::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const LINK::content_role_optional& LINK::
  content_role () const
  {
    return this->content_role_;
  }

  LINK::content_role_optional& LINK::
  content_role ()
  {
    return this->content_role_;
  }

  void LINK::
  content_role (const content_role_type& x)
  {
    this->content_role_.set (x);
  }

  void LINK::
  content_role (const content_role_optional& x)
  {
    this->content_role_ = x;
  }

  void LINK::
  content_role (::std::auto_ptr< content_role_type > x)
  {
    this->content_role_.set (x);
  }

  const LINK::content_type_optional& LINK::
  content_type () const
  {
    return this->content_type_;
  }

  LINK::content_type_optional& LINK::
  content_type ()
  {
    return this->content_type_;
  }

  void LINK::
  content_type (const content_type_type& x)
  {
    this->content_type_.set (x);
  }

  void LINK::
  content_type (const content_type_optional& x)
  {
    this->content_type_ = x;
  }

  void LINK::
  content_type (::std::auto_ptr< content_type_type > x)
  {
    this->content_type_.set (x);
  }

  const LINK::title_optional& LINK::
  title () const
  {
    return this->title_;
  }

  LINK::title_optional& LINK::
  title ()
  {
    return this->title_;
  }

  void LINK::
  title (const title_type& x)
  {
    this->title_.set (x);
  }

  void LINK::
  title (const title_optional& x)
  {
    this->title_ = x;
  }

  void LINK::
  title (::std::auto_ptr< title_type > x)
  {
    this->title_.set (x);
  }

  const LINK::value_optional& LINK::
  value () const
  {
    return this->value_;
  }

  LINK::value_optional& LINK::
  value ()
  {
    return this->value_;
  }

  void LINK::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void LINK::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void LINK::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const LINK::href_optional& LINK::
  href () const
  {
    return this->href_;
  }

  LINK::href_optional& LINK::
  href ()
  {
    return this->href_;
  }

  void LINK::
  href (const href_type& x)
  {
    this->href_.set (x);
  }

  void LINK::
  href (const href_optional& x)
  {
    this->href_ = x;
  }

  void LINK::
  href (::std::auto_ptr< href_type > x)
  {
    this->href_.set (x);
  }

  const LINK::gref_optional& LINK::
  gref () const
  {
    return this->gref_;
  }

  LINK::gref_optional& LINK::
  gref ()
  {
    return this->gref_;
  }

  void LINK::
  gref (const gref_type& x)
  {
    this->gref_.set (x);
  }

  void LINK::
  gref (const gref_optional& x)
  {
    this->gref_ = x;
  }

  void LINK::
  gref (::std::auto_ptr< gref_type > x)
  {
    this->gref_.set (x);
  }

  const LINK::action_optional& LINK::
  action () const
  {
    return this->action_;
  }

  LINK::action_optional& LINK::
  action ()
  {
    return this->action_;
  }

  void LINK::
  action (const action_type& x)
  {
    this->action_.set (x);
  }

  void LINK::
  action (const action_optional& x)
  {
    this->action_ = x;
  }

  void LINK::
  action (::std::auto_ptr< action_type > x)
  {
    this->action_.set (x);
  }


  // INFO
  // 

  const INFO::ID_optional& INFO::
  ID () const
  {
    return this->ID_;
  }

  INFO::ID_optional& INFO::
  ID ()
  {
    return this->ID_;
  }

  void INFO::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void INFO::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void INFO::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const INFO::name_type& INFO::
  name () const
  {
    return this->name_.get ();
  }

  INFO::name_type& INFO::
  name ()
  {
    return this->name_.get ();
  }

  void INFO::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void INFO::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const INFO::value_type& INFO::
  value () const
  {
    return this->value_.get ();
  }

  INFO::value_type& INFO::
  value ()
  {
    return this->value_.get ();
  }

  void INFO::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void INFO::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const INFO::unit_optional& INFO::
  unit () const
  {
    return this->unit_;
  }

  INFO::unit_optional& INFO::
  unit ()
  {
    return this->unit_;
  }

  void INFO::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void INFO::
  unit (const unit_optional& x)
  {
    this->unit_ = x;
  }

  void INFO::
  unit (::std::auto_ptr< unit_type > x)
  {
    this->unit_.set (x);
  }

  const INFO::xtype_optional& INFO::
  xtype () const
  {
    return this->xtype_;
  }

  INFO::xtype_optional& INFO::
  xtype ()
  {
    return this->xtype_;
  }

  void INFO::
  xtype (const xtype_type& x)
  {
    this->xtype_.set (x);
  }

  void INFO::
  xtype (const xtype_optional& x)
  {
    this->xtype_ = x;
  }

  void INFO::
  xtype (::std::auto_ptr< xtype_type > x)
  {
    this->xtype_.set (x);
  }

  const INFO::ref_optional& INFO::
  ref () const
  {
    return this->ref_;
  }

  INFO::ref_optional& INFO::
  ref ()
  {
    return this->ref_;
  }

  void INFO::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void INFO::
  ref (const ref_optional& x)
  {
    this->ref_ = x;
  }

  void INFO::
  ref (::std::auto_ptr< ref_type > x)
  {
    this->ref_.set (x);
  }

  const INFO::ucd_optional& INFO::
  ucd () const
  {
    return this->ucd_;
  }

  INFO::ucd_optional& INFO::
  ucd ()
  {
    return this->ucd_;
  }

  void INFO::
  ucd (const ucd_type& x)
  {
    this->ucd_.set (x);
  }

  void INFO::
  ucd (const ucd_optional& x)
  {
    this->ucd_ = x;
  }

  void INFO::
  ucd (::std::auto_ptr< ucd_type > x)
  {
    this->ucd_.set (x);
  }

  const INFO::utype_optional& INFO::
  utype () const
  {
    return this->utype_;
  }

  INFO::utype_optional& INFO::
  utype ()
  {
    return this->utype_;
  }

  void INFO::
  utype (const utype_type& x)
  {
    this->utype_.set (x);
  }

  void INFO::
  utype (const utype_optional& x)
  {
    this->utype_ = x;
  }

  void INFO::
  utype (::std::auto_ptr< utype_type > x)
  {
    this->utype_.set (x);
  }


  // COOSYS
  // 

  const COOSYS::ID_type& COOSYS::
  ID () const
  {
    return this->ID_.get ();
  }

  COOSYS::ID_type& COOSYS::
  ID ()
  {
    return this->ID_.get ();
  }

  void COOSYS::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void COOSYS::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const COOSYS::equinox_optional& COOSYS::
  equinox () const
  {
    return this->equinox_;
  }

  COOSYS::equinox_optional& COOSYS::
  equinox ()
  {
    return this->equinox_;
  }

  void COOSYS::
  equinox (const equinox_type& x)
  {
    this->equinox_.set (x);
  }

  void COOSYS::
  equinox (const equinox_optional& x)
  {
    this->equinox_ = x;
  }

  void COOSYS::
  equinox (::std::auto_ptr< equinox_type > x)
  {
    this->equinox_.set (x);
  }

  const COOSYS::epoch_optional& COOSYS::
  epoch () const
  {
    return this->epoch_;
  }

  COOSYS::epoch_optional& COOSYS::
  epoch ()
  {
    return this->epoch_;
  }

  void COOSYS::
  epoch (const epoch_type& x)
  {
    this->epoch_.set (x);
  }

  void COOSYS::
  epoch (const epoch_optional& x)
  {
    this->epoch_ = x;
  }

  void COOSYS::
  epoch (::std::auto_ptr< epoch_type > x)
  {
    this->epoch_.set (x);
  }

  const COOSYS::system_type& COOSYS::
  system () const
  {
    return this->system_.get ();
  }

  COOSYS::system_type& COOSYS::
  system ()
  {
    return this->system_.get ();
  }

  void COOSYS::
  system (const system_type& x)
  {
    this->system_.set (x);
  }

  void COOSYS::
  system (::std::auto_ptr< system_type > x)
  {
    this->system_.set (x);
  }

  const COOSYS::system_type& COOSYS::
  system_default_value ()
  {
    return system_default_value_;
  }


  // Timeorigin
  // 


  // TimeSystem
  // 

  const TimeSystem::ID_type& TimeSystem::
  ID () const
  {
    return this->ID_.get ();
  }

  TimeSystem::ID_type& TimeSystem::
  ID ()
  {
    return this->ID_.get ();
  }

  void TimeSystem::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void TimeSystem::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const TimeSystem::timeorigin_optional& TimeSystem::
  timeorigin () const
  {
    return this->timeorigin_;
  }

  TimeSystem::timeorigin_optional& TimeSystem::
  timeorigin ()
  {
    return this->timeorigin_;
  }

  void TimeSystem::
  timeorigin (const timeorigin_type& x)
  {
    this->timeorigin_.set (x);
  }

  void TimeSystem::
  timeorigin (const timeorigin_optional& x)
  {
    this->timeorigin_ = x;
  }

  void TimeSystem::
  timeorigin (::std::auto_ptr< timeorigin_type > x)
  {
    this->timeorigin_.set (x);
  }

  const TimeSystem::timescale_type& TimeSystem::
  timescale () const
  {
    return this->timescale_.get ();
  }

  TimeSystem::timescale_type& TimeSystem::
  timescale ()
  {
    return this->timescale_.get ();
  }

  void TimeSystem::
  timescale (const timescale_type& x)
  {
    this->timescale_.set (x);
  }

  void TimeSystem::
  timescale (::std::auto_ptr< timescale_type > x)
  {
    this->timescale_.set (x);
  }

  const TimeSystem::refposition_type& TimeSystem::
  refposition () const
  {
    return this->refposition_.get ();
  }

  TimeSystem::refposition_type& TimeSystem::
  refposition ()
  {
    return this->refposition_.get ();
  }

  void TimeSystem::
  refposition (const refposition_type& x)
  {
    this->refposition_.set (x);
  }

  void TimeSystem::
  refposition (::std::auto_ptr< refposition_type > x)
  {
    this->refposition_.set (x);
  }


  // DEFINITIONS
  // 

  const DEFINITIONS::COOSYS_sequence& DEFINITIONS::
  COOSYS () const
  {
    return this->COOSYS_;
  }

  DEFINITIONS::COOSYS_sequence& DEFINITIONS::
  COOSYS ()
  {
    return this->COOSYS_;
  }

  void DEFINITIONS::
  COOSYS (const COOSYS_sequence& s)
  {
    this->COOSYS_ = s;
  }

  const DEFINITIONS::TIMESYS_sequence& DEFINITIONS::
  TIMESYS () const
  {
    return this->TIMESYS_;
  }

  DEFINITIONS::TIMESYS_sequence& DEFINITIONS::
  TIMESYS ()
  {
    return this->TIMESYS_;
  }

  void DEFINITIONS::
  TIMESYS (const TIMESYS_sequence& s)
  {
    this->TIMESYS_ = s;
  }

  const DEFINITIONS::PARAM_sequence& DEFINITIONS::
  PARAM () const
  {
    return this->PARAM_;
  }

  DEFINITIONS::PARAM_sequence& DEFINITIONS::
  PARAM ()
  {
    return this->PARAM_;
  }

  void DEFINITIONS::
  PARAM (const PARAM_sequence& s)
  {
    this->PARAM_ = s;
  }


  // FIELD
  // 

  const FIELD::DESCRIPTION_optional& FIELD::
  DESCRIPTION () const
  {
    return this->DESCRIPTION_;
  }

  FIELD::DESCRIPTION_optional& FIELD::
  DESCRIPTION ()
  {
    return this->DESCRIPTION_;
  }

  void FIELD::
  DESCRIPTION (const DESCRIPTION_type& x)
  {
    this->DESCRIPTION_.set (x);
  }

  void FIELD::
  DESCRIPTION (const DESCRIPTION_optional& x)
  {
    this->DESCRIPTION_ = x;
  }

  void FIELD::
  DESCRIPTION (::std::auto_ptr< DESCRIPTION_type > x)
  {
    this->DESCRIPTION_.set (x);
  }

  const FIELD::VALUES_optional& FIELD::
  VALUES () const
  {
    return this->VALUES_;
  }

  FIELD::VALUES_optional& FIELD::
  VALUES ()
  {
    return this->VALUES_;
  }

  void FIELD::
  VALUES (const VALUES_type& x)
  {
    this->VALUES_.set (x);
  }

  void FIELD::
  VALUES (const VALUES_optional& x)
  {
    this->VALUES_ = x;
  }

  void FIELD::
  VALUES (::std::auto_ptr< VALUES_type > x)
  {
    this->VALUES_.set (x);
  }

  const FIELD::LINK_sequence& FIELD::
  LINK () const
  {
    return this->LINK_;
  }

  FIELD::LINK_sequence& FIELD::
  LINK ()
  {
    return this->LINK_;
  }

  void FIELD::
  LINK (const LINK_sequence& s)
  {
    this->LINK_ = s;
  }

  const FIELD::ID_optional& FIELD::
  ID () const
  {
    return this->ID_;
  }

  FIELD::ID_optional& FIELD::
  ID ()
  {
    return this->ID_;
  }

  void FIELD::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void FIELD::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void FIELD::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const FIELD::unit_optional& FIELD::
  unit () const
  {
    return this->unit_;
  }

  FIELD::unit_optional& FIELD::
  unit ()
  {
    return this->unit_;
  }

  void FIELD::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void FIELD::
  unit (const unit_optional& x)
  {
    this->unit_ = x;
  }

  void FIELD::
  unit (::std::auto_ptr< unit_type > x)
  {
    this->unit_.set (x);
  }

  const FIELD::datatype_optional& FIELD::
  datatype () const
  {
    return this->datatype_;
  }

  FIELD::datatype_optional& FIELD::
  datatype ()
  {
    return this->datatype_;
  }

  void FIELD::
  datatype (const datatype_type& x)
  {
    this->datatype_.set (x);
  }

  void FIELD::
  datatype (const datatype_optional& x)
  {
    this->datatype_ = x;
  }

  void FIELD::
  datatype (::std::auto_ptr< datatype_type > x)
  {
    this->datatype_.set (x);
  }

  const FIELD::precision_optional& FIELD::
  precision () const
  {
    return this->precision_;
  }

  FIELD::precision_optional& FIELD::
  precision ()
  {
    return this->precision_;
  }

  void FIELD::
  precision (const precision_type& x)
  {
    this->precision_.set (x);
  }

  void FIELD::
  precision (const precision_optional& x)
  {
    this->precision_ = x;
  }

  void FIELD::
  precision (::std::auto_ptr< precision_type > x)
  {
    this->precision_.set (x);
  }

  const FIELD::width_optional& FIELD::
  width () const
  {
    return this->width_;
  }

  FIELD::width_optional& FIELD::
  width ()
  {
    return this->width_;
  }

  void FIELD::
  width (const width_type& x)
  {
    this->width_.set (x);
  }

  void FIELD::
  width (const width_optional& x)
  {
    this->width_ = x;
  }

  const FIELD::xtype_optional& FIELD::
  xtype () const
  {
    return this->xtype_;
  }

  FIELD::xtype_optional& FIELD::
  xtype ()
  {
    return this->xtype_;
  }

  void FIELD::
  xtype (const xtype_type& x)
  {
    this->xtype_.set (x);
  }

  void FIELD::
  xtype (const xtype_optional& x)
  {
    this->xtype_ = x;
  }

  void FIELD::
  xtype (::std::auto_ptr< xtype_type > x)
  {
    this->xtype_.set (x);
  }

  const FIELD::ref_optional& FIELD::
  ref () const
  {
    return this->ref_;
  }

  FIELD::ref_optional& FIELD::
  ref ()
  {
    return this->ref_;
  }

  void FIELD::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void FIELD::
  ref (const ref_optional& x)
  {
    this->ref_ = x;
  }

  void FIELD::
  ref (::std::auto_ptr< ref_type > x)
  {
    this->ref_.set (x);
  }

  const FIELD::name_optional& FIELD::
  name () const
  {
    return this->name_;
  }

  FIELD::name_optional& FIELD::
  name ()
  {
    return this->name_;
  }

  void FIELD::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void FIELD::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void FIELD::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const FIELD::ucd_optional& FIELD::
  ucd () const
  {
    return this->ucd_;
  }

  FIELD::ucd_optional& FIELD::
  ucd ()
  {
    return this->ucd_;
  }

  void FIELD::
  ucd (const ucd_type& x)
  {
    this->ucd_.set (x);
  }

  void FIELD::
  ucd (const ucd_optional& x)
  {
    this->ucd_ = x;
  }

  void FIELD::
  ucd (::std::auto_ptr< ucd_type > x)
  {
    this->ucd_.set (x);
  }

  const FIELD::utype_optional& FIELD::
  utype () const
  {
    return this->utype_;
  }

  FIELD::utype_optional& FIELD::
  utype ()
  {
    return this->utype_;
  }

  void FIELD::
  utype (const utype_type& x)
  {
    this->utype_.set (x);
  }

  void FIELD::
  utype (const utype_optional& x)
  {
    this->utype_ = x;
  }

  void FIELD::
  utype (::std::auto_ptr< utype_type > x)
  {
    this->utype_.set (x);
  }

  const FIELD::arraysize_optional& FIELD::
  arraysize () const
  {
    return this->arraysize_;
  }

  FIELD::arraysize_optional& FIELD::
  arraysize ()
  {
    return this->arraysize_;
  }

  void FIELD::
  arraysize (const arraysize_type& x)
  {
    this->arraysize_.set (x);
  }

  void FIELD::
  arraysize (const arraysize_optional& x)
  {
    this->arraysize_ = x;
  }

  void FIELD::
  arraysize (::std::auto_ptr< arraysize_type > x)
  {
    this->arraysize_.set (x);
  }

  const FIELD::type_optional& FIELD::
  type () const
  {
    return this->type_;
  }

  FIELD::type_optional& FIELD::
  type ()
  {
    return this->type_;
  }

  void FIELD::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void FIELD::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void FIELD::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }


  // PARAM
  // 

  const PARAM::value_optional& PARAM::
  value () const
  {
    return this->value_;
  }

  PARAM::value_optional& PARAM::
  value ()
  {
    return this->value_;
  }

  void PARAM::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void PARAM::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void PARAM::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // GROUP
  // 

  const GROUP::DESCRIPTION_optional& GROUP::
  DESCRIPTION () const
  {
    return this->DESCRIPTION_;
  }

  GROUP::DESCRIPTION_optional& GROUP::
  DESCRIPTION ()
  {
    return this->DESCRIPTION_;
  }

  void GROUP::
  DESCRIPTION (const DESCRIPTION_type& x)
  {
    this->DESCRIPTION_.set (x);
  }

  void GROUP::
  DESCRIPTION (const DESCRIPTION_optional& x)
  {
    this->DESCRIPTION_ = x;
  }

  void GROUP::
  DESCRIPTION (::std::auto_ptr< DESCRIPTION_type > x)
  {
    this->DESCRIPTION_.set (x);
  }

  const GROUP::FIELDref_sequence& GROUP::
  FIELDref () const
  {
    return this->FIELDref_;
  }

  GROUP::FIELDref_sequence& GROUP::
  FIELDref ()
  {
    return this->FIELDref_;
  }

  void GROUP::
  FIELDref (const FIELDref_sequence& s)
  {
    this->FIELDref_ = s;
  }

  const GROUP::PARAMref_sequence& GROUP::
  PARAMref () const
  {
    return this->PARAMref_;
  }

  GROUP::PARAMref_sequence& GROUP::
  PARAMref ()
  {
    return this->PARAMref_;
  }

  void GROUP::
  PARAMref (const PARAMref_sequence& s)
  {
    this->PARAMref_ = s;
  }

  const GROUP::PARAM_sequence& GROUP::
  PARAM () const
  {
    return this->PARAM_;
  }

  GROUP::PARAM_sequence& GROUP::
  PARAM ()
  {
    return this->PARAM_;
  }

  void GROUP::
  PARAM (const PARAM_sequence& s)
  {
    this->PARAM_ = s;
  }

  const GROUP::GROUP1_sequence& GROUP::
  GROUP1 () const
  {
    return this->GROUP1_;
  }

  GROUP::GROUP1_sequence& GROUP::
  GROUP1 ()
  {
    return this->GROUP1_;
  }

  void GROUP::
  GROUP1 (const GROUP1_sequence& s)
  {
    this->GROUP1_ = s;
  }

  const GROUP::ID_optional& GROUP::
  ID () const
  {
    return this->ID_;
  }

  GROUP::ID_optional& GROUP::
  ID ()
  {
    return this->ID_;
  }

  void GROUP::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void GROUP::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void GROUP::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const GROUP::name_optional& GROUP::
  name () const
  {
    return this->name_;
  }

  GROUP::name_optional& GROUP::
  name ()
  {
    return this->name_;
  }

  void GROUP::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void GROUP::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void GROUP::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const GROUP::ref_optional& GROUP::
  ref () const
  {
    return this->ref_;
  }

  GROUP::ref_optional& GROUP::
  ref ()
  {
    return this->ref_;
  }

  void GROUP::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void GROUP::
  ref (const ref_optional& x)
  {
    this->ref_ = x;
  }

  void GROUP::
  ref (::std::auto_ptr< ref_type > x)
  {
    this->ref_.set (x);
  }

  const GROUP::ucd_optional& GROUP::
  ucd () const
  {
    return this->ucd_;
  }

  GROUP::ucd_optional& GROUP::
  ucd ()
  {
    return this->ucd_;
  }

  void GROUP::
  ucd (const ucd_type& x)
  {
    this->ucd_.set (x);
  }

  void GROUP::
  ucd (const ucd_optional& x)
  {
    this->ucd_ = x;
  }

  void GROUP::
  ucd (::std::auto_ptr< ucd_type > x)
  {
    this->ucd_.set (x);
  }

  const GROUP::utype_optional& GROUP::
  utype () const
  {
    return this->utype_;
  }

  GROUP::utype_optional& GROUP::
  utype ()
  {
    return this->utype_;
  }

  void GROUP::
  utype (const utype_type& x)
  {
    this->utype_.set (x);
  }

  void GROUP::
  utype (const utype_optional& x)
  {
    this->utype_ = x;
  }

  void GROUP::
  utype (::std::auto_ptr< utype_type > x)
  {
    this->utype_.set (x);
  }


  // FIELDref
  // 

  const FIELDref::ref_type& FIELDref::
  ref () const
  {
    return this->ref_.get ();
  }

  FIELDref::ref_type& FIELDref::
  ref ()
  {
    return this->ref_.get ();
  }

  void FIELDref::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void FIELDref::
  ref (::std::auto_ptr< ref_type > x)
  {
    this->ref_.set (x);
  }

  const FIELDref::ucd_optional& FIELDref::
  ucd () const
  {
    return this->ucd_;
  }

  FIELDref::ucd_optional& FIELDref::
  ucd ()
  {
    return this->ucd_;
  }

  void FIELDref::
  ucd (const ucd_type& x)
  {
    this->ucd_.set (x);
  }

  void FIELDref::
  ucd (const ucd_optional& x)
  {
    this->ucd_ = x;
  }

  void FIELDref::
  ucd (::std::auto_ptr< ucd_type > x)
  {
    this->ucd_.set (x);
  }

  const FIELDref::utype_optional& FIELDref::
  utype () const
  {
    return this->utype_;
  }

  FIELDref::utype_optional& FIELDref::
  utype ()
  {
    return this->utype_;
  }

  void FIELDref::
  utype (const utype_type& x)
  {
    this->utype_.set (x);
  }

  void FIELDref::
  utype (const utype_optional& x)
  {
    this->utype_ = x;
  }

  void FIELDref::
  utype (::std::auto_ptr< utype_type > x)
  {
    this->utype_.set (x);
  }


  // PARAMref
  // 

  const PARAMref::ref_type& PARAMref::
  ref () const
  {
    return this->ref_.get ();
  }

  PARAMref::ref_type& PARAMref::
  ref ()
  {
    return this->ref_.get ();
  }

  void PARAMref::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void PARAMref::
  ref (::std::auto_ptr< ref_type > x)
  {
    this->ref_.set (x);
  }

  const PARAMref::ucd_optional& PARAMref::
  ucd () const
  {
    return this->ucd_;
  }

  PARAMref::ucd_optional& PARAMref::
  ucd ()
  {
    return this->ucd_;
  }

  void PARAMref::
  ucd (const ucd_type& x)
  {
    this->ucd_.set (x);
  }

  void PARAMref::
  ucd (const ucd_optional& x)
  {
    this->ucd_ = x;
  }

  void PARAMref::
  ucd (::std::auto_ptr< ucd_type > x)
  {
    this->ucd_.set (x);
  }

  const PARAMref::utype_optional& PARAMref::
  utype () const
  {
    return this->utype_;
  }

  PARAMref::utype_optional& PARAMref::
  utype ()
  {
    return this->utype_;
  }

  void PARAMref::
  utype (const utype_type& x)
  {
    this->utype_.set (x);
  }

  void PARAMref::
  utype (const utype_optional& x)
  {
    this->utype_ = x;
  }

  void PARAMref::
  utype (::std::auto_ptr< utype_type > x)
  {
    this->utype_.set (x);
  }


  // DATA
  // 

  const DATA::TABLEDATA_optional& DATA::
  TABLEDATA () const
  {
    return this->TABLEDATA_;
  }

  DATA::TABLEDATA_optional& DATA::
  TABLEDATA ()
  {
    return this->TABLEDATA_;
  }

  void DATA::
  TABLEDATA (const TABLEDATA_type& x)
  {
    this->TABLEDATA_.set (x);
  }

  void DATA::
  TABLEDATA (const TABLEDATA_optional& x)
  {
    this->TABLEDATA_ = x;
  }

  void DATA::
  TABLEDATA (::std::auto_ptr< TABLEDATA_type > x)
  {
    this->TABLEDATA_.set (x);
  }

  const DATA::BINARY_optional& DATA::
  BINARY () const
  {
    return this->BINARY_;
  }

  DATA::BINARY_optional& DATA::
  BINARY ()
  {
    return this->BINARY_;
  }

  void DATA::
  BINARY (const BINARY_type& x)
  {
    this->BINARY_.set (x);
  }

  void DATA::
  BINARY (const BINARY_optional& x)
  {
    this->BINARY_ = x;
  }

  void DATA::
  BINARY (::std::auto_ptr< BINARY_type > x)
  {
    this->BINARY_.set (x);
  }

  const DATA::BINARY2_optional& DATA::
  BINARY2 () const
  {
    return this->BINARY2_;
  }

  DATA::BINARY2_optional& DATA::
  BINARY2 ()
  {
    return this->BINARY2_;
  }

  void DATA::
  BINARY2 (const BINARY2_type& x)
  {
    this->BINARY2_.set (x);
  }

  void DATA::
  BINARY2 (const BINARY2_optional& x)
  {
    this->BINARY2_ = x;
  }

  void DATA::
  BINARY2 (::std::auto_ptr< BINARY2_type > x)
  {
    this->BINARY2_.set (x);
  }

  const DATA::FITS_optional& DATA::
  FITS () const
  {
    return this->FITS_;
  }

  DATA::FITS_optional& DATA::
  FITS ()
  {
    return this->FITS_;
  }

  void DATA::
  FITS (const FITS_type& x)
  {
    this->FITS_.set (x);
  }

  void DATA::
  FITS (const FITS_optional& x)
  {
    this->FITS_ = x;
  }

  void DATA::
  FITS (::std::auto_ptr< FITS_type > x)
  {
    this->FITS_.set (x);
  }

  const DATA::INFO_sequence& DATA::
  INFO () const
  {
    return this->INFO_;
  }

  DATA::INFO_sequence& DATA::
  INFO ()
  {
    return this->INFO_;
  }

  void DATA::
  INFO (const INFO_sequence& s)
  {
    this->INFO_ = s;
  }


  // TABLEDATA
  // 

  const TABLEDATA::TR_sequence& TABLEDATA::
  TR () const
  {
    return this->TR_;
  }

  TABLEDATA::TR_sequence& TABLEDATA::
  TR ()
  {
    return this->TR_;
  }

  void TABLEDATA::
  TR (const TR_sequence& s)
  {
    this->TR_ = s;
  }


  // TD
  // 

  const TD::encoding_optional& TD::
  encoding () const
  {
    return this->encoding_;
  }

  TD::encoding_optional& TD::
  encoding ()
  {
    return this->encoding_;
  }

  void TD::
  encoding (const encoding_type& x)
  {
    this->encoding_.set (x);
  }

  void TD::
  encoding (const encoding_optional& x)
  {
    this->encoding_ = x;
  }

  void TD::
  encoding (::std::auto_ptr< encoding_type > x)
  {
    this->encoding_.set (x);
  }


  // TR
  // 

  const TR::TD_sequence& TR::
  TD () const
  {
    return this->TD_;
  }

  TR::TD_sequence& TR::
  TD ()
  {
    return this->TD_;
  }

  void TR::
  TD (const TD_sequence& s)
  {
    this->TD_ = s;
  }

  const TR::ID_optional& TR::
  ID () const
  {
    return this->ID_;
  }

  TR::ID_optional& TR::
  ID ()
  {
    return this->ID_;
  }

  void TR::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void TR::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void TR::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }


  // FITS
  // 

  const FITS::STREAM_type& FITS::
  STREAM () const
  {
    return this->STREAM_.get ();
  }

  FITS::STREAM_type& FITS::
  STREAM ()
  {
    return this->STREAM_.get ();
  }

  void FITS::
  STREAM (const STREAM_type& x)
  {
    this->STREAM_.set (x);
  }

  void FITS::
  STREAM (::std::auto_ptr< STREAM_type > x)
  {
    this->STREAM_.set (x);
  }

  const FITS::extnum_optional& FITS::
  extnum () const
  {
    return this->extnum_;
  }

  FITS::extnum_optional& FITS::
  extnum ()
  {
    return this->extnum_;
  }

  void FITS::
  extnum (const extnum_type& x)
  {
    this->extnum_.set (x);
  }

  void FITS::
  extnum (const extnum_optional& x)
  {
    this->extnum_ = x;
  }


  // BINARY
  // 

  const BINARY::STREAM_type& BINARY::
  STREAM () const
  {
    return this->STREAM_.get ();
  }

  BINARY::STREAM_type& BINARY::
  STREAM ()
  {
    return this->STREAM_.get ();
  }

  void BINARY::
  STREAM (const STREAM_type& x)
  {
    this->STREAM_.set (x);
  }

  void BINARY::
  STREAM (::std::auto_ptr< STREAM_type > x)
  {
    this->STREAM_.set (x);
  }


  // BINARY2
  // 

  const BINARY2::STREAM_type& BINARY2::
  STREAM () const
  {
    return this->STREAM_.get ();
  }

  BINARY2::STREAM_type& BINARY2::
  STREAM ()
  {
    return this->STREAM_.get ();
  }

  void BINARY2::
  STREAM (const STREAM_type& x)
  {
    this->STREAM_.set (x);
  }

  void BINARY2::
  STREAM (::std::auto_ptr< STREAM_type > x)
  {
    this->STREAM_.set (x);
  }


  // STREAM
  // 

  const STREAM::type_type& STREAM::
  type () const
  {
    return this->type_.get ();
  }

  STREAM::type_type& STREAM::
  type ()
  {
    return this->type_.get ();
  }

  void STREAM::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void STREAM::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const STREAM::type_type& STREAM::
  type_default_value ()
  {
    return type_default_value_;
  }

  const STREAM::href_optional& STREAM::
  href () const
  {
    return this->href_;
  }

  STREAM::href_optional& STREAM::
  href ()
  {
    return this->href_;
  }

  void STREAM::
  href (const href_type& x)
  {
    this->href_.set (x);
  }

  void STREAM::
  href (const href_optional& x)
  {
    this->href_ = x;
  }

  void STREAM::
  href (::std::auto_ptr< href_type > x)
  {
    this->href_.set (x);
  }

  const STREAM::actuate_type& STREAM::
  actuate () const
  {
    return this->actuate_.get ();
  }

  STREAM::actuate_type& STREAM::
  actuate ()
  {
    return this->actuate_.get ();
  }

  void STREAM::
  actuate (const actuate_type& x)
  {
    this->actuate_.set (x);
  }

  void STREAM::
  actuate (::std::auto_ptr< actuate_type > x)
  {
    this->actuate_.set (x);
  }

  const STREAM::actuate_type& STREAM::
  actuate_default_value ()
  {
    return actuate_default_value_;
  }

  const STREAM::encoding_type& STREAM::
  encoding () const
  {
    return this->encoding_.get ();
  }

  STREAM::encoding_type& STREAM::
  encoding ()
  {
    return this->encoding_.get ();
  }

  void STREAM::
  encoding (const encoding_type& x)
  {
    this->encoding_.set (x);
  }

  void STREAM::
  encoding (::std::auto_ptr< encoding_type > x)
  {
    this->encoding_.set (x);
  }

  const STREAM::encoding_type& STREAM::
  encoding_default_value ()
  {
    return encoding_default_value_;
  }

  const STREAM::expires_optional& STREAM::
  expires () const
  {
    return this->expires_;
  }

  STREAM::expires_optional& STREAM::
  expires ()
  {
    return this->expires_;
  }

  void STREAM::
  expires (const expires_type& x)
  {
    this->expires_.set (x);
  }

  void STREAM::
  expires (const expires_optional& x)
  {
    this->expires_ = x;
  }

  void STREAM::
  expires (::std::auto_ptr< expires_type > x)
  {
    this->expires_.set (x);
  }

  const STREAM::rights_optional& STREAM::
  rights () const
  {
    return this->rights_;
  }

  STREAM::rights_optional& STREAM::
  rights ()
  {
    return this->rights_;
  }

  void STREAM::
  rights (const rights_type& x)
  {
    this->rights_.set (x);
  }

  void STREAM::
  rights (const rights_optional& x)
  {
    this->rights_ = x;
  }

  void STREAM::
  rights (::std::auto_ptr< rights_type > x)
  {
    this->rights_.set (x);
  }


  // TABLE
  // 

  const TABLE::DESCRIPTION_optional& TABLE::
  DESCRIPTION () const
  {
    return this->DESCRIPTION_;
  }

  TABLE::DESCRIPTION_optional& TABLE::
  DESCRIPTION ()
  {
    return this->DESCRIPTION_;
  }

  void TABLE::
  DESCRIPTION (const DESCRIPTION_type& x)
  {
    this->DESCRIPTION_.set (x);
  }

  void TABLE::
  DESCRIPTION (const DESCRIPTION_optional& x)
  {
    this->DESCRIPTION_ = x;
  }

  void TABLE::
  DESCRIPTION (::std::auto_ptr< DESCRIPTION_type > x)
  {
    this->DESCRIPTION_.set (x);
  }

  const TABLE::INFO_sequence& TABLE::
  INFO () const
  {
    return this->INFO_;
  }

  TABLE::INFO_sequence& TABLE::
  INFO ()
  {
    return this->INFO_;
  }

  void TABLE::
  INFO (const INFO_sequence& s)
  {
    this->INFO_ = s;
  }

  const TABLE::FIELD_sequence& TABLE::
  FIELD () const
  {
    return this->FIELD_;
  }

  TABLE::FIELD_sequence& TABLE::
  FIELD ()
  {
    return this->FIELD_;
  }

  void TABLE::
  FIELD (const FIELD_sequence& s)
  {
    this->FIELD_ = s;
  }

  const TABLE::PARAM_sequence& TABLE::
  PARAM () const
  {
    return this->PARAM_;
  }

  TABLE::PARAM_sequence& TABLE::
  PARAM ()
  {
    return this->PARAM_;
  }

  void TABLE::
  PARAM (const PARAM_sequence& s)
  {
    this->PARAM_ = s;
  }

  const TABLE::GROUP_sequence& TABLE::
  GROUP () const
  {
    return this->GROUP_;
  }

  TABLE::GROUP_sequence& TABLE::
  GROUP ()
  {
    return this->GROUP_;
  }

  void TABLE::
  GROUP (const GROUP_sequence& s)
  {
    this->GROUP_ = s;
  }

  const TABLE::LINK_sequence& TABLE::
  LINK () const
  {
    return this->LINK_;
  }

  TABLE::LINK_sequence& TABLE::
  LINK ()
  {
    return this->LINK_;
  }

  void TABLE::
  LINK (const LINK_sequence& s)
  {
    this->LINK_ = s;
  }

  const TABLE::DATA_optional& TABLE::
  DATA () const
  {
    return this->DATA_;
  }

  TABLE::DATA_optional& TABLE::
  DATA ()
  {
    return this->DATA_;
  }

  void TABLE::
  DATA (const DATA_type& x)
  {
    this->DATA_.set (x);
  }

  void TABLE::
  DATA (const DATA_optional& x)
  {
    this->DATA_ = x;
  }

  void TABLE::
  DATA (::std::auto_ptr< DATA_type > x)
  {
    this->DATA_.set (x);
  }

  const TABLE::ID_optional& TABLE::
  ID () const
  {
    return this->ID_;
  }

  TABLE::ID_optional& TABLE::
  ID ()
  {
    return this->ID_;
  }

  void TABLE::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void TABLE::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void TABLE::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const TABLE::name_optional& TABLE::
  name () const
  {
    return this->name_;
  }

  TABLE::name_optional& TABLE::
  name ()
  {
    return this->name_;
  }

  void TABLE::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void TABLE::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void TABLE::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const TABLE::ref_optional& TABLE::
  ref () const
  {
    return this->ref_;
  }

  TABLE::ref_optional& TABLE::
  ref ()
  {
    return this->ref_;
  }

  void TABLE::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void TABLE::
  ref (const ref_optional& x)
  {
    this->ref_ = x;
  }

  void TABLE::
  ref (::std::auto_ptr< ref_type > x)
  {
    this->ref_.set (x);
  }

  const TABLE::ucd_optional& TABLE::
  ucd () const
  {
    return this->ucd_;
  }

  TABLE::ucd_optional& TABLE::
  ucd ()
  {
    return this->ucd_;
  }

  void TABLE::
  ucd (const ucd_type& x)
  {
    this->ucd_.set (x);
  }

  void TABLE::
  ucd (const ucd_optional& x)
  {
    this->ucd_ = x;
  }

  void TABLE::
  ucd (::std::auto_ptr< ucd_type > x)
  {
    this->ucd_.set (x);
  }

  const TABLE::utype_optional& TABLE::
  utype () const
  {
    return this->utype_;
  }

  TABLE::utype_optional& TABLE::
  utype ()
  {
    return this->utype_;
  }

  void TABLE::
  utype (const utype_type& x)
  {
    this->utype_.set (x);
  }

  void TABLE::
  utype (const utype_optional& x)
  {
    this->utype_ = x;
  }

  void TABLE::
  utype (::std::auto_ptr< utype_type > x)
  {
    this->utype_.set (x);
  }

  const TABLE::nrows_optional& TABLE::
  nrows () const
  {
    return this->nrows_;
  }

  TABLE::nrows_optional& TABLE::
  nrows ()
  {
    return this->nrows_;
  }

  void TABLE::
  nrows (const nrows_type& x)
  {
    this->nrows_.set (x);
  }

  void TABLE::
  nrows (const nrows_optional& x)
  {
    this->nrows_ = x;
  }


  // RESOURCE
  // 

  const RESOURCE::DESCRIPTION_optional& RESOURCE::
  DESCRIPTION () const
  {
    return this->DESCRIPTION_;
  }

  RESOURCE::DESCRIPTION_optional& RESOURCE::
  DESCRIPTION ()
  {
    return this->DESCRIPTION_;
  }

  void RESOURCE::
  DESCRIPTION (const DESCRIPTION_type& x)
  {
    this->DESCRIPTION_.set (x);
  }

  void RESOURCE::
  DESCRIPTION (const DESCRIPTION_optional& x)
  {
    this->DESCRIPTION_ = x;
  }

  void RESOURCE::
  DESCRIPTION (::std::auto_ptr< DESCRIPTION_type > x)
  {
    this->DESCRIPTION_.set (x);
  }

  const RESOURCE::INFO_sequence& RESOURCE::
  INFO () const
  {
    return this->INFO_;
  }

  RESOURCE::INFO_sequence& RESOURCE::
  INFO ()
  {
    return this->INFO_;
  }

  void RESOURCE::
  INFO (const INFO_sequence& s)
  {
    this->INFO_ = s;
  }

  const RESOURCE::COOSYS_sequence& RESOURCE::
  COOSYS () const
  {
    return this->COOSYS_;
  }

  RESOURCE::COOSYS_sequence& RESOURCE::
  COOSYS ()
  {
    return this->COOSYS_;
  }

  void RESOURCE::
  COOSYS (const COOSYS_sequence& s)
  {
    this->COOSYS_ = s;
  }

  const RESOURCE::TIMESYS_sequence& RESOURCE::
  TIMESYS () const
  {
    return this->TIMESYS_;
  }

  RESOURCE::TIMESYS_sequence& RESOURCE::
  TIMESYS ()
  {
    return this->TIMESYS_;
  }

  void RESOURCE::
  TIMESYS (const TIMESYS_sequence& s)
  {
    this->TIMESYS_ = s;
  }

  const RESOURCE::GROUP_sequence& RESOURCE::
  GROUP () const
  {
    return this->GROUP_;
  }

  RESOURCE::GROUP_sequence& RESOURCE::
  GROUP ()
  {
    return this->GROUP_;
  }

  void RESOURCE::
  GROUP (const GROUP_sequence& s)
  {
    this->GROUP_ = s;
  }

  const RESOURCE::PARAM_sequence& RESOURCE::
  PARAM () const
  {
    return this->PARAM_;
  }

  RESOURCE::PARAM_sequence& RESOURCE::
  PARAM ()
  {
    return this->PARAM_;
  }

  void RESOURCE::
  PARAM (const PARAM_sequence& s)
  {
    this->PARAM_ = s;
  }

  const RESOURCE::LINK_sequence& RESOURCE::
  LINK () const
  {
    return this->LINK_;
  }

  RESOURCE::LINK_sequence& RESOURCE::
  LINK ()
  {
    return this->LINK_;
  }

  void RESOURCE::
  LINK (const LINK_sequence& s)
  {
    this->LINK_ = s;
  }

  const RESOURCE::TABLE_sequence& RESOURCE::
  TABLE () const
  {
    return this->TABLE_;
  }

  RESOURCE::TABLE_sequence& RESOURCE::
  TABLE ()
  {
    return this->TABLE_;
  }

  void RESOURCE::
  TABLE (const TABLE_sequence& s)
  {
    this->TABLE_ = s;
  }

  const RESOURCE::RESOURCE1_sequence& RESOURCE::
  RESOURCE1 () const
  {
    return this->RESOURCE1_;
  }

  RESOURCE::RESOURCE1_sequence& RESOURCE::
  RESOURCE1 ()
  {
    return this->RESOURCE1_;
  }

  void RESOURCE::
  RESOURCE1 (const RESOURCE1_sequence& s)
  {
    this->RESOURCE1_ = s;
  }

  const RESOURCE::any_sequence& RESOURCE::
  any () const
  {
    return this->any_;
  }

  RESOURCE::any_sequence& RESOURCE::
  any ()
  {
    return this->any_;
  }

  void RESOURCE::
  any (const any_sequence& s)
  {
    this->any_ = s;
  }

  const RESOURCE::name_optional& RESOURCE::
  name () const
  {
    return this->name_;
  }

  RESOURCE::name_optional& RESOURCE::
  name ()
  {
    return this->name_;
  }

  void RESOURCE::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void RESOURCE::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void RESOURCE::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const RESOURCE::ID_optional& RESOURCE::
  ID () const
  {
    return this->ID_;
  }

  RESOURCE::ID_optional& RESOURCE::
  ID ()
  {
    return this->ID_;
  }

  void RESOURCE::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void RESOURCE::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void RESOURCE::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const RESOURCE::utype_optional& RESOURCE::
  utype () const
  {
    return this->utype_;
  }

  RESOURCE::utype_optional& RESOURCE::
  utype ()
  {
    return this->utype_;
  }

  void RESOURCE::
  utype (const utype_type& x)
  {
    this->utype_.set (x);
  }

  void RESOURCE::
  utype (const utype_optional& x)
  {
    this->utype_ = x;
  }

  void RESOURCE::
  utype (::std::auto_ptr< utype_type > x)
  {
    this->utype_.set (x);
  }

  const RESOURCE::type_type& RESOURCE::
  type () const
  {
    return this->type_.get ();
  }

  RESOURCE::type_type& RESOURCE::
  type ()
  {
    return this->type_.get ();
  }

  void RESOURCE::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void RESOURCE::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const RESOURCE::type_type& RESOURCE::
  type_default_value ()
  {
    return type_default_value_;
  }

  const RESOURCE::any_attribute_set& RESOURCE::
  any_attribute () const
  {
    return this->any_attribute_;
  }

  RESOURCE::any_attribute_set& RESOURCE::
  any_attribute ()
  {
    return this->any_attribute_;
  }

  void RESOURCE::
  any_attribute (const any_attribute_set& s)
  {
    this->any_attribute_ = s;
  }

  const ::xercesc::DOMDocument& RESOURCE::
  dom_document () const
  {
    return *dom_document_;
  }

  ::xercesc::DOMDocument& RESOURCE::
  dom_document ()
  {
    return *dom_document_;
  }


  // type
  // 

  type::
  type (value v)
  : ::xml_schema::nmtoken (_xsd_type_literals_[v])
  {
  }

  type::
  type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type::
  type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type::
  type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type::
  type (const type& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  type& type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_type_literals_[v]);

    return *this;
  }


  // system
  // 

  system::
  system (value v)
  : ::xml_schema::nmtoken (_xsd_system_literals_[v])
  {
  }

  system::
  system (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  system::
  system (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  system::
  system (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  system::
  system (const system& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  system& system::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_system_literals_[v]);

    return *this;
  }


  // type1
  // 

  type1::
  type1 (value v)
  : ::xml_schema::nmtoken (_xsd_type1_literals_[v])
  {
  }

  type1::
  type1 (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type1::
  type1 (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type1::
  type1 (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type1::
  type1 (const type1& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  type1& type1::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_type1_literals_[v]);

    return *this;
  }


  // type2
  // 

  type2::
  type2 (value v)
  : ::xml_schema::nmtoken (_xsd_type2_literals_[v])
  {
  }

  type2::
  type2 (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type2::
  type2 (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type2::
  type2 (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type2::
  type2 (const type2& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  type2& type2::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_type2_literals_[v]);

    return *this;
  }


  // actuate
  // 

  actuate::
  actuate (value v)
  : ::xml_schema::nmtoken (_xsd_actuate_literals_[v])
  {
  }

  actuate::
  actuate (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  actuate::
  actuate (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  actuate::
  actuate (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  actuate::
  actuate (const actuate& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  actuate& actuate::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_actuate_literals_[v]);

    return *this;
  }


  // type3
  // 

  type3::
  type3 (value v)
  : ::xml_schema::nmtoken (_xsd_type3_literals_[v])
  {
  }

  type3::
  type3 (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type3::
  type3 (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type3::
  type3 (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type3::
  type3 (const type3& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  type3& type3::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_type3_literals_[v]);

    return *this;
  }


  // VOTABLE
  // 

  const VOTABLE::DESCRIPTION_optional& VOTABLE::
  DESCRIPTION () const
  {
    return this->DESCRIPTION_;
  }

  VOTABLE::DESCRIPTION_optional& VOTABLE::
  DESCRIPTION ()
  {
    return this->DESCRIPTION_;
  }

  void VOTABLE::
  DESCRIPTION (const DESCRIPTION_type& x)
  {
    this->DESCRIPTION_.set (x);
  }

  void VOTABLE::
  DESCRIPTION (const DESCRIPTION_optional& x)
  {
    this->DESCRIPTION_ = x;
  }

  void VOTABLE::
  DESCRIPTION (::std::auto_ptr< DESCRIPTION_type > x)
  {
    this->DESCRIPTION_.set (x);
  }

  const VOTABLE::DEFINITIONS_optional& VOTABLE::
  DEFINITIONS () const
  {
    return this->DEFINITIONS_;
  }

  VOTABLE::DEFINITIONS_optional& VOTABLE::
  DEFINITIONS ()
  {
    return this->DEFINITIONS_;
  }

  void VOTABLE::
  DEFINITIONS (const DEFINITIONS_type& x)
  {
    this->DEFINITIONS_.set (x);
  }

  void VOTABLE::
  DEFINITIONS (const DEFINITIONS_optional& x)
  {
    this->DEFINITIONS_ = x;
  }

  void VOTABLE::
  DEFINITIONS (::std::auto_ptr< DEFINITIONS_type > x)
  {
    this->DEFINITIONS_.set (x);
  }

  const VOTABLE::COOSYS_sequence& VOTABLE::
  COOSYS () const
  {
    return this->COOSYS_;
  }

  VOTABLE::COOSYS_sequence& VOTABLE::
  COOSYS ()
  {
    return this->COOSYS_;
  }

  void VOTABLE::
  COOSYS (const COOSYS_sequence& s)
  {
    this->COOSYS_ = s;
  }

  const VOTABLE::TIMESYS_sequence& VOTABLE::
  TIMESYS () const
  {
    return this->TIMESYS_;
  }

  VOTABLE::TIMESYS_sequence& VOTABLE::
  TIMESYS ()
  {
    return this->TIMESYS_;
  }

  void VOTABLE::
  TIMESYS (const TIMESYS_sequence& s)
  {
    this->TIMESYS_ = s;
  }

  const VOTABLE::GROUP_sequence& VOTABLE::
  GROUP () const
  {
    return this->GROUP_;
  }

  VOTABLE::GROUP_sequence& VOTABLE::
  GROUP ()
  {
    return this->GROUP_;
  }

  void VOTABLE::
  GROUP (const GROUP_sequence& s)
  {
    this->GROUP_ = s;
  }

  const VOTABLE::PARAM_sequence& VOTABLE::
  PARAM () const
  {
    return this->PARAM_;
  }

  VOTABLE::PARAM_sequence& VOTABLE::
  PARAM ()
  {
    return this->PARAM_;
  }

  void VOTABLE::
  PARAM (const PARAM_sequence& s)
  {
    this->PARAM_ = s;
  }

  const VOTABLE::INFO_sequence& VOTABLE::
  INFO () const
  {
    return this->INFO_;
  }

  VOTABLE::INFO_sequence& VOTABLE::
  INFO ()
  {
    return this->INFO_;
  }

  void VOTABLE::
  INFO (const INFO_sequence& s)
  {
    this->INFO_ = s;
  }

  const VOTABLE::RESOURCE_sequence& VOTABLE::
  RESOURCE () const
  {
    return this->RESOURCE_;
  }

  VOTABLE::RESOURCE_sequence& VOTABLE::
  RESOURCE ()
  {
    return this->RESOURCE_;
  }

  void VOTABLE::
  RESOURCE (const RESOURCE_sequence& s)
  {
    this->RESOURCE_ = s;
  }

  const VOTABLE::ID_optional& VOTABLE::
  ID () const
  {
    return this->ID_;
  }

  VOTABLE::ID_optional& VOTABLE::
  ID ()
  {
    return this->ID_;
  }

  void VOTABLE::
  ID (const ID_type& x)
  {
    this->ID_.set (x);
  }

  void VOTABLE::
  ID (const ID_optional& x)
  {
    this->ID_ = x;
  }

  void VOTABLE::
  ID (::std::auto_ptr< ID_type > x)
  {
    this->ID_.set (x);
  }

  const VOTABLE::version_optional& VOTABLE::
  version () const
  {
    return this->version_;
  }

  VOTABLE::version_optional& VOTABLE::
  version ()
  {
    return this->version_;
  }

  void VOTABLE::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void VOTABLE::
  version (const version_optional& x)
  {
    this->version_ = x;
  }

  void VOTABLE::
  version (::std::auto_ptr< version_type > x)
  {
    this->version_.set (x);
  }


  // version
  // 

  version::
  version (value v)
  : ::xml_schema::nmtoken (_xsd_version_literals_[v])
  {
  }

  version::
  version (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  version::
  version (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  version::
  version (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  version::
  version (const version& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  version& version::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_version_literals_[v]);

    return *this;
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace votable_14
{
  // anyTEXT
  //

  anyTEXT::
  anyTEXT ()
  : ::xml_schema::type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->dom_document ())
  {
  }

  anyTEXT::
  anyTEXT (const anyTEXT& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (x.any_, this->dom_document ())
  {
  }

  anyTEXT::
  anyTEXT (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->dom_document ())
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void anyTEXT::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // any
      //
      if (true)
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->dom_document ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_ .push_back (r);
        continue;
      }

      break;
    }
  }

  anyTEXT* anyTEXT::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class anyTEXT (*this, f, c);
  }

  anyTEXT::
  ~anyTEXT ()
  {
  }

  // astroYear
  //

  astroYear::
  astroYear ()
  : ::xml_schema::token ()
  {
  }

  astroYear::
  astroYear (const char* _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  astroYear::
  astroYear (const ::std::string& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  astroYear::
  astroYear (const ::xml_schema::token& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  astroYear::
  astroYear (const astroYear& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  astroYear::
  astroYear (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  astroYear::
  astroYear (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  astroYear::
  astroYear (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  astroYear* astroYear::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class astroYear (*this, f, c);
  }

  astroYear::
  ~astroYear ()
  {
  }

  // ucdType
  //

  ucdType::
  ucdType ()
  : ::xml_schema::token ()
  {
  }

  ucdType::
  ucdType (const char* _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  ucdType::
  ucdType (const ::std::string& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  ucdType::
  ucdType (const ::xml_schema::token& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  ucdType::
  ucdType (const ucdType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  ucdType::
  ucdType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  ucdType::
  ucdType (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  ucdType::
  ucdType (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  ucdType* ucdType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ucdType (*this, f, c);
  }

  ucdType::
  ~ucdType ()
  {
  }

  // arrayDEF
  //

  arrayDEF::
  arrayDEF ()
  : ::xml_schema::token ()
  {
  }

  arrayDEF::
  arrayDEF (const char* _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  arrayDEF::
  arrayDEF (const ::std::string& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  arrayDEF::
  arrayDEF (const ::xml_schema::token& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  arrayDEF::
  arrayDEF (const arrayDEF& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  arrayDEF::
  arrayDEF (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  arrayDEF::
  arrayDEF (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  arrayDEF::
  arrayDEF (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  arrayDEF* arrayDEF::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class arrayDEF (*this, f, c);
  }

  arrayDEF::
  ~arrayDEF ()
  {
  }

  // encodingType
  //

  encodingType::
  encodingType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_encodingType_convert ();
  }

  encodingType::
  encodingType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_encodingType_convert ();
  }

  encodingType::
  encodingType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_encodingType_convert ();
  }

  encodingType* encodingType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class encodingType (*this, f, c);
  }

  encodingType::value encodingType::
  _xsd_encodingType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_encodingType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_encodingType_indexes_,
                      _xsd_encodingType_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_encodingType_indexes_ + 4 || _xsd_encodingType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const encodingType::
  _xsd_encodingType_literals_[4] =
  {
    "gzip",
    "base64",
    "dynamic",
    "none"
  };

  const encodingType::value encodingType::
  _xsd_encodingType_indexes_[4] =
  {
    ::votable_14::encodingType::base64,
    ::votable_14::encodingType::dynamic,
    ::votable_14::encodingType::gzip,
    ::votable_14::encodingType::none
  };

  // dataType
  //

  dataType::
  dataType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_dataType_convert ();
  }

  dataType::
  dataType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_dataType_convert ();
  }

  dataType::
  dataType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_dataType_convert ();
  }

  dataType* dataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dataType (*this, f, c);
  }

  dataType::value dataType::
  _xsd_dataType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_dataType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_dataType_indexes_,
                      _xsd_dataType_indexes_ + 12,
                      *this,
                      c));

    if (i == _xsd_dataType_indexes_ + 12 || _xsd_dataType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const dataType::
  _xsd_dataType_literals_[12] =
  {
    "boolean",
    "bit",
    "unsignedByte",
    "short",
    "int",
    "long",
    "char",
    "unicodeChar",
    "float",
    "double",
    "floatComplex",
    "doubleComplex"
  };

  const dataType::value dataType::
  _xsd_dataType_indexes_[12] =
  {
    ::votable_14::dataType::bit,
    ::votable_14::dataType::boolean,
    ::votable_14::dataType::char_,
    ::votable_14::dataType::double_,
    ::votable_14::dataType::doubleComplex,
    ::votable_14::dataType::float_,
    ::votable_14::dataType::floatComplex,
    ::votable_14::dataType::int_,
    ::votable_14::dataType::long_,
    ::votable_14::dataType::short_,
    ::votable_14::dataType::unicodeChar,
    ::votable_14::dataType::unsignedByte
  };

  // precType
  //

  precType::
  precType ()
  : ::xml_schema::token ()
  {
  }

  precType::
  precType (const char* _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  precType::
  precType (const ::std::string& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  precType::
  precType (const ::xml_schema::token& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  precType::
  precType (const precType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  precType::
  precType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  precType::
  precType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  precType::
  precType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  precType* precType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class precType (*this, f, c);
  }

  precType::
  ~precType ()
  {
  }

  // yesno
  //

  yesno::
  yesno (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_yesno_convert ();
  }

  yesno::
  yesno (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_yesno_convert ();
  }

  yesno::
  yesno (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_yesno_convert ();
  }

  yesno* yesno::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class yesno (*this, f, c);
  }

  yesno::value yesno::
  _xsd_yesno_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_yesno_literals_);
    const value* i (::std::lower_bound (
                      _xsd_yesno_indexes_,
                      _xsd_yesno_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_yesno_indexes_ + 2 || _xsd_yesno_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const yesno::
  _xsd_yesno_literals_[2] =
  {
    "yes",
    "no"
  };

  const yesno::value yesno::
  _xsd_yesno_indexes_[2] =
  {
    ::votable_14::yesno::no,
    ::votable_14::yesno::yes
  };

  // MIN
  //

  const MIN::inclusive_type MIN::inclusive_default_value_ (
    "yes");

  MIN::
  MIN (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, ::xml_schema::flags (), this),
    inclusive_ (inclusive_default_value (), ::xml_schema::flags (), this)
  {
  }

  MIN::
  MIN (const MIN& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this),
    inclusive_ (x.inclusive_, f, this)
  {
  }

  MIN::
  MIN (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (f, this),
    inclusive_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void MIN::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        this->value_.set (r);
        continue;
      }

      if (n.name () == "inclusive" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< inclusive_type > r (
          inclusive_traits::create (i, f, this));

        this->inclusive_.set (r);
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }

    if (!inclusive_.present ())
    {
      this->inclusive_.set (inclusive_default_value ());
    }
  }

  MIN* MIN::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MIN (*this, f, c);
  }

  MIN::
  ~MIN ()
  {
  }

  // MAX
  //

  const MAX::inclusive_type MAX::inclusive_default_value_ (
    "yes");

  MAX::
  MAX (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, ::xml_schema::flags (), this),
    inclusive_ (inclusive_default_value (), ::xml_schema::flags (), this)
  {
  }

  MAX::
  MAX (const MAX& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this),
    inclusive_ (x.inclusive_, f, this)
  {
  }

  MAX::
  MAX (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (f, this),
    inclusive_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void MAX::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        this->value_.set (r);
        continue;
      }

      if (n.name () == "inclusive" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< inclusive_type > r (
          inclusive_traits::create (i, f, this));

        this->inclusive_.set (r);
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }

    if (!inclusive_.present ())
    {
      this->inclusive_.set (inclusive_default_value ());
    }
  }

  MAX* MAX::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MAX (*this, f, c);
  }

  MAX::
  ~MAX ()
  {
  }

  // OPTION
  //

  OPTION::
  OPTION (const value_type& value)
  : ::xml_schema::type (),
    OPTION1_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this),
    value_ (value, ::xml_schema::flags (), this)
  {
  }

  OPTION::
  OPTION (const OPTION& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    OPTION1_ (x.OPTION1_, f, this),
    name_ (x.name_, f, this),
    value_ (x.value_, f, this)
  {
  }

  OPTION::
  OPTION (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    OPTION1_ (f, this),
    name_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void OPTION::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OPTION
      //
      if (n.name () == "OPTION" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< OPTION1_type > r (
          OPTION1_traits::create (i, f, this));

        this->OPTION1_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        this->value_.set (r);
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  OPTION* OPTION::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OPTION (*this, f, c);
  }

  OPTION::
  ~OPTION ()
  {
  }

  // VALUES
  //

  const VALUES::type_type VALUES::type_default_value_ (
    "legal");

  VALUES::
  VALUES ()
  : ::xml_schema::type (),
    MIN_ (::xml_schema::flags (), this),
    MAX_ (::xml_schema::flags (), this),
    OPTION_ (::xml_schema::flags (), this),
    ID_ (::xml_schema::flags (), this),
    type_ (type_default_value (), ::xml_schema::flags (), this),
    null_ (::xml_schema::flags (), this),
    ref_ (::xml_schema::flags (), this)
  {
  }

  VALUES::
  VALUES (const VALUES& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    MIN_ (x.MIN_, f, this),
    MAX_ (x.MAX_, f, this),
    OPTION_ (x.OPTION_, f, this),
    ID_ (x.ID_, f, this),
    type_ (x.type_, f, this),
    null_ (x.null_, f, this),
    ref_ (x.ref_, f, this)
  {
  }

  VALUES::
  VALUES (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    MIN_ (f, this),
    MAX_ (f, this),
    OPTION_ (f, this),
    ID_ (f, this),
    type_ (f, this),
    null_ (f, this),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void VALUES::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MIN
      //
      if (n.name () == "MIN" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< MIN_type > r (
          MIN_traits::create (i, f, this));

        if (!this->MIN_)
        {
          this->MIN_.set (r);
          continue;
        }
      }

      // MAX
      //
      if (n.name () == "MAX" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< MAX_type > r (
          MAX_traits::create (i, f, this));

        if (!this->MAX_)
        {
          this->MAX_.set (r);
          continue;
        }
      }

      // OPTION
      //
      if (n.name () == "OPTION" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< OPTION_type > r (
          OPTION_traits::create (i, f, this));

        this->OPTION_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "null" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< null_type > r (
          null_traits::create (i, f, this));

        this->null_.set (r);
        continue;
      }

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref_type > r (
          ref_traits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!type_.present ())
    {
      this->type_.set (type_default_value ());
    }
  }

  VALUES* VALUES::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VALUES (*this, f, c);
  }

  VALUES::
  ~VALUES ()
  {
  }

  // LINK
  //

  LINK::
  LINK ()
  : ::xml_schema::type (),
    ID_ (::xml_schema::flags (), this),
    content_role_ (::xml_schema::flags (), this),
    content_type_ (::xml_schema::flags (), this),
    title_ (::xml_schema::flags (), this),
    value_ (::xml_schema::flags (), this),
    href_ (::xml_schema::flags (), this),
    gref_ (::xml_schema::flags (), this),
    action_ (::xml_schema::flags (), this)
  {
  }

  LINK::
  LINK (const LINK& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ID_ (x.ID_, f, this),
    content_role_ (x.content_role_, f, this),
    content_type_ (x.content_type_, f, this),
    title_ (x.title_, f, this),
    value_ (x.value_, f, this),
    href_ (x.href_, f, this),
    gref_ (x.gref_, f, this),
    action_ (x.action_, f, this)
  {
  }

  LINK::
  LINK (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ID_ (f, this),
    content_role_ (f, this),
    content_type_ (f, this),
    title_ (f, this),
    value_ (f, this),
    href_ (f, this),
    gref_ (f, this),
    action_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void LINK::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "content-role" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< content_role_type > r (
          content_role_traits::create (i, f, this));

        this->content_role_.set (r);
        continue;
      }

      if (n.name () == "content-type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< content_type_type > r (
          content_type_traits::create (i, f, this));

        this->content_type_.set (r);
        continue;
      }

      if (n.name () == "title" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< title_type > r (
          title_traits::create (i, f, this));

        this->title_.set (r);
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        this->value_.set (r);
        continue;
      }

      if (n.name () == "href" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< href_type > r (
          href_traits::create (i, f, this));

        this->href_.set (r);
        continue;
      }

      if (n.name () == "gref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< gref_type > r (
          gref_traits::create (i, f, this));

        this->gref_.set (r);
        continue;
      }

      if (n.name () == "action" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< action_type > r (
          action_traits::create (i, f, this));

        this->action_.set (r);
        continue;
      }
    }
  }

  LINK* LINK::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LINK (*this, f, c);
  }

  LINK::
  ~LINK ()
  {
  }

  // INFO
  //

  INFO::
  INFO (const name_type& name,
        const value_type& value)
  : ::xml_schema::string (),
    ID_ (::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this),
    value_ (value, ::xml_schema::flags (), this),
    unit_ (::xml_schema::flags (), this),
    xtype_ (::xml_schema::flags (), this),
    ref_ (::xml_schema::flags (), this),
    ucd_ (::xml_schema::flags (), this),
    utype_ (::xml_schema::flags (), this)
  {
  }

  INFO::
  INFO (const char* _xsd_string_base,
        const name_type& name,
        const value_type& value)
  : ::xml_schema::string (_xsd_string_base),
    ID_ (::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this),
    value_ (value, ::xml_schema::flags (), this),
    unit_ (::xml_schema::flags (), this),
    xtype_ (::xml_schema::flags (), this),
    ref_ (::xml_schema::flags (), this),
    ucd_ (::xml_schema::flags (), this),
    utype_ (::xml_schema::flags (), this)
  {
  }

  INFO::
  INFO (const ::std::string& _xsd_string_base,
        const name_type& name,
        const value_type& value)
  : ::xml_schema::string (_xsd_string_base),
    ID_ (::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this),
    value_ (value, ::xml_schema::flags (), this),
    unit_ (::xml_schema::flags (), this),
    xtype_ (::xml_schema::flags (), this),
    ref_ (::xml_schema::flags (), this),
    ucd_ (::xml_schema::flags (), this),
    utype_ (::xml_schema::flags (), this)
  {
  }

  INFO::
  INFO (const ::xml_schema::string& _xsd_string_base,
        const name_type& name,
        const value_type& value)
  : ::xml_schema::string (_xsd_string_base),
    ID_ (::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this),
    value_ (value, ::xml_schema::flags (), this),
    unit_ (::xml_schema::flags (), this),
    xtype_ (::xml_schema::flags (), this),
    ref_ (::xml_schema::flags (), this),
    ucd_ (::xml_schema::flags (), this),
    utype_ (::xml_schema::flags (), this)
  {
  }

  INFO::
  INFO (const INFO& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    ID_ (x.ID_, f, this),
    name_ (x.name_, f, this),
    value_ (x.value_, f, this),
    unit_ (x.unit_, f, this),
    xtype_ (x.xtype_, f, this),
    ref_ (x.ref_, f, this),
    ucd_ (x.ucd_, f, this),
    utype_ (x.utype_, f, this)
  {
  }

  INFO::
  INFO (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    ID_ (f, this),
    name_ (f, this),
    value_ (f, this),
    unit_ (f, this),
    xtype_ (f, this),
    ref_ (f, this),
    ucd_ (f, this),
    utype_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void INFO::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        this->value_.set (r);
        continue;
      }

      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_type > r (
          unit_traits::create (i, f, this));

        this->unit_.set (r);
        continue;
      }

      if (n.name () == "xtype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< xtype_type > r (
          xtype_traits::create (i, f, this));

        this->xtype_.set (r);
        continue;
      }

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref_type > r (
          ref_traits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }

      if (n.name () == "ucd" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ucd_type > r (
          ucd_traits::create (i, f, this));

        this->ucd_.set (r);
        continue;
      }

      if (n.name () == "utype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< utype_type > r (
          utype_traits::create (i, f, this));

        this->utype_.set (r);
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  INFO* INFO::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class INFO (*this, f, c);
  }

  INFO::
  ~INFO ()
  {
  }

  // COOSYS
  //

  const COOSYS::system_type COOSYS::system_default_value_ (
    "eq_FK5");

  COOSYS::
  COOSYS (const ID_type& ID)
  : ::xml_schema::string (),
    ID_ (ID, ::xml_schema::flags (), this),
    equinox_ (::xml_schema::flags (), this),
    epoch_ (::xml_schema::flags (), this),
    system_ (system_default_value (), ::xml_schema::flags (), this)
  {
  }

  COOSYS::
  COOSYS (const char* _xsd_string_base,
          const ID_type& ID)
  : ::xml_schema::string (_xsd_string_base),
    ID_ (ID, ::xml_schema::flags (), this),
    equinox_ (::xml_schema::flags (), this),
    epoch_ (::xml_schema::flags (), this),
    system_ (system_default_value (), ::xml_schema::flags (), this)
  {
  }

  COOSYS::
  COOSYS (const ::std::string& _xsd_string_base,
          const ID_type& ID)
  : ::xml_schema::string (_xsd_string_base),
    ID_ (ID, ::xml_schema::flags (), this),
    equinox_ (::xml_schema::flags (), this),
    epoch_ (::xml_schema::flags (), this),
    system_ (system_default_value (), ::xml_schema::flags (), this)
  {
  }

  COOSYS::
  COOSYS (const ::xml_schema::string& _xsd_string_base,
          const ID_type& ID)
  : ::xml_schema::string (_xsd_string_base),
    ID_ (ID, ::xml_schema::flags (), this),
    equinox_ (::xml_schema::flags (), this),
    epoch_ (::xml_schema::flags (), this),
    system_ (system_default_value (), ::xml_schema::flags (), this)
  {
  }

  COOSYS::
  COOSYS (const COOSYS& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    ID_ (x.ID_, f, this),
    equinox_ (x.equinox_, f, this),
    epoch_ (x.epoch_, f, this),
    system_ (x.system_, f, this)
  {
  }

  COOSYS::
  COOSYS (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    ID_ (f, this),
    equinox_ (f, this),
    epoch_ (f, this),
    system_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void COOSYS::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "equinox" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< equinox_type > r (
          equinox_traits::create (i, f, this));

        this->equinox_.set (r);
        continue;
      }

      if (n.name () == "epoch" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< epoch_type > r (
          epoch_traits::create (i, f, this));

        this->epoch_.set (r);
        continue;
      }

      if (n.name () == "system" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< system_type > r (
          system_traits::create (i, f, this));

        this->system_.set (r);
        continue;
      }
    }

    if (!ID_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ID",
        "");
    }

    if (!system_.present ())
    {
      this->system_.set (system_default_value ());
    }
  }

  COOSYS* COOSYS::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class COOSYS (*this, f, c);
  }

  COOSYS::
  ~COOSYS ()
  {
  }

  // Timeorigin
  //

  Timeorigin::
  Timeorigin ()
  : ::xml_schema::token ()
  {
  }

  Timeorigin::
  Timeorigin (const char* _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  Timeorigin::
  Timeorigin (const ::std::string& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  Timeorigin::
  Timeorigin (const ::xml_schema::token& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  Timeorigin::
  Timeorigin (const Timeorigin& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  Timeorigin::
  Timeorigin (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  Timeorigin::
  Timeorigin (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  Timeorigin::
  Timeorigin (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  Timeorigin* Timeorigin::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Timeorigin (*this, f, c);
  }

  Timeorigin::
  ~Timeorigin ()
  {
  }

  // TimeSystem
  //

  TimeSystem::
  TimeSystem (const ID_type& ID,
              const timescale_type& timescale,
              const refposition_type& refposition)
  : ::xml_schema::string (),
    ID_ (ID, ::xml_schema::flags (), this),
    timeorigin_ (::xml_schema::flags (), this),
    timescale_ (timescale, ::xml_schema::flags (), this),
    refposition_ (refposition, ::xml_schema::flags (), this)
  {
  }

  TimeSystem::
  TimeSystem (const char* _xsd_string_base,
              const ID_type& ID,
              const timescale_type& timescale,
              const refposition_type& refposition)
  : ::xml_schema::string (_xsd_string_base),
    ID_ (ID, ::xml_schema::flags (), this),
    timeorigin_ (::xml_schema::flags (), this),
    timescale_ (timescale, ::xml_schema::flags (), this),
    refposition_ (refposition, ::xml_schema::flags (), this)
  {
  }

  TimeSystem::
  TimeSystem (const ::std::string& _xsd_string_base,
              const ID_type& ID,
              const timescale_type& timescale,
              const refposition_type& refposition)
  : ::xml_schema::string (_xsd_string_base),
    ID_ (ID, ::xml_schema::flags (), this),
    timeorigin_ (::xml_schema::flags (), this),
    timescale_ (timescale, ::xml_schema::flags (), this),
    refposition_ (refposition, ::xml_schema::flags (), this)
  {
  }

  TimeSystem::
  TimeSystem (const ::xml_schema::string& _xsd_string_base,
              const ID_type& ID,
              const timescale_type& timescale,
              const refposition_type& refposition)
  : ::xml_schema::string (_xsd_string_base),
    ID_ (ID, ::xml_schema::flags (), this),
    timeorigin_ (::xml_schema::flags (), this),
    timescale_ (timescale, ::xml_schema::flags (), this),
    refposition_ (refposition, ::xml_schema::flags (), this)
  {
  }

  TimeSystem::
  TimeSystem (const TimeSystem& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    ID_ (x.ID_, f, this),
    timeorigin_ (x.timeorigin_, f, this),
    timescale_ (x.timescale_, f, this),
    refposition_ (x.refposition_, f, this)
  {
  }

  TimeSystem::
  TimeSystem (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    ID_ (f, this),
    timeorigin_ (f, this),
    timescale_ (f, this),
    refposition_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void TimeSystem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "timeorigin" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< timeorigin_type > r (
          timeorigin_traits::create (i, f, this));

        this->timeorigin_.set (r);
        continue;
      }

      if (n.name () == "timescale" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< timescale_type > r (
          timescale_traits::create (i, f, this));

        this->timescale_.set (r);
        continue;
      }

      if (n.name () == "refposition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< refposition_type > r (
          refposition_traits::create (i, f, this));

        this->refposition_.set (r);
        continue;
      }
    }

    if (!ID_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ID",
        "");
    }

    if (!timescale_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "timescale",
        "");
    }

    if (!refposition_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "refposition",
        "");
    }
  }

  TimeSystem* TimeSystem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TimeSystem (*this, f, c);
  }

  TimeSystem::
  ~TimeSystem ()
  {
  }

  // DEFINITIONS
  //

  DEFINITIONS::
  DEFINITIONS ()
  : ::xml_schema::type (),
    COOSYS_ (::xml_schema::flags (), this),
    TIMESYS_ (::xml_schema::flags (), this),
    PARAM_ (::xml_schema::flags (), this)
  {
  }

  DEFINITIONS::
  DEFINITIONS (const DEFINITIONS& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    COOSYS_ (x.COOSYS_, f, this),
    TIMESYS_ (x.TIMESYS_, f, this),
    PARAM_ (x.PARAM_, f, this)
  {
  }

  DEFINITIONS::
  DEFINITIONS (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    COOSYS_ (f, this),
    TIMESYS_ (f, this),
    PARAM_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void DEFINITIONS::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // COOSYS
      //
      if (n.name () == "COOSYS" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< COOSYS_type > r (
          COOSYS_traits::create (i, f, this));

        this->COOSYS_.push_back (r);
        continue;
      }

      // TIMESYS
      //
      if (n.name () == "TIMESYS" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< TIMESYS_type > r (
          TIMESYS_traits::create (i, f, this));

        this->TIMESYS_.push_back (r);
        continue;
      }

      // PARAM
      //
      if (n.name () == "PARAM" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< PARAM_type > r (
          PARAM_traits::create (i, f, this));

        this->PARAM_.push_back (r);
        continue;
      }

      break;
    }
  }

  DEFINITIONS* DEFINITIONS::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DEFINITIONS (*this, f, c);
  }

  DEFINITIONS::
  ~DEFINITIONS ()
  {
  }

  // FIELD
  //

  FIELD::
  FIELD ()
  : ::xml_schema::type (),
    DESCRIPTION_ (::xml_schema::flags (), this),
    VALUES_ (::xml_schema::flags (), this),
    LINK_ (::xml_schema::flags (), this),
    ID_ (::xml_schema::flags (), this),
    unit_ (::xml_schema::flags (), this),
    datatype_ (::xml_schema::flags (), this),
    precision_ (::xml_schema::flags (), this),
    width_ (::xml_schema::flags (), this),
    xtype_ (::xml_schema::flags (), this),
    ref_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this),
    ucd_ (::xml_schema::flags (), this),
    utype_ (::xml_schema::flags (), this),
    arraysize_ (::xml_schema::flags (), this),
    type_ (::xml_schema::flags (), this)
  {
  }

  FIELD::
  FIELD (const FIELD& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DESCRIPTION_ (x.DESCRIPTION_, f, this),
    VALUES_ (x.VALUES_, f, this),
    LINK_ (x.LINK_, f, this),
    ID_ (x.ID_, f, this),
    unit_ (x.unit_, f, this),
    datatype_ (x.datatype_, f, this),
    precision_ (x.precision_, f, this),
    width_ (x.width_, f, this),
    xtype_ (x.xtype_, f, this),
    ref_ (x.ref_, f, this),
    name_ (x.name_, f, this),
    ucd_ (x.ucd_, f, this),
    utype_ (x.utype_, f, this),
    arraysize_ (x.arraysize_, f, this),
    type_ (x.type_, f, this)
  {
  }

  FIELD::
  FIELD (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DESCRIPTION_ (f, this),
    VALUES_ (f, this),
    LINK_ (f, this),
    ID_ (f, this),
    unit_ (f, this),
    datatype_ (f, this),
    precision_ (f, this),
    width_ (f, this),
    xtype_ (f, this),
    ref_ (f, this),
    name_ (f, this),
    ucd_ (f, this),
    utype_ (f, this),
    arraysize_ (f, this),
    type_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void FIELD::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DESCRIPTION
      //
      if (n.name () == "DESCRIPTION" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< DESCRIPTION_type > r (
          DESCRIPTION_traits::create (i, f, this));

        if (!this->DESCRIPTION_)
        {
          this->DESCRIPTION_.set (r);
          continue;
        }
      }

      // VALUES
      //
      if (n.name () == "VALUES" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< VALUES_type > r (
          VALUES_traits::create (i, f, this));

        if (!this->VALUES_)
        {
          this->VALUES_.set (r);
          continue;
        }
      }

      // LINK
      //
      if (n.name () == "LINK" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< LINK_type > r (
          LINK_traits::create (i, f, this));

        this->LINK_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_type > r (
          unit_traits::create (i, f, this));

        this->unit_.set (r);
        continue;
      }

      if (n.name () == "datatype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< datatype_type > r (
          datatype_traits::create (i, f, this));

        this->datatype_.set (r);
        continue;
      }

      if (n.name () == "precision" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< precision_type > r (
          precision_traits::create (i, f, this));

        this->precision_.set (r);
        continue;
      }

      if (n.name () == "width" && n.namespace_ ().empty ())
      {
        this->width_.set (width_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "xtype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< xtype_type > r (
          xtype_traits::create (i, f, this));

        this->xtype_.set (r);
        continue;
      }

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref_type > r (
          ref_traits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "ucd" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ucd_type > r (
          ucd_traits::create (i, f, this));

        this->ucd_.set (r);
        continue;
      }

      if (n.name () == "utype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< utype_type > r (
          utype_traits::create (i, f, this));

        this->utype_.set (r);
        continue;
      }

      if (n.name () == "arraysize" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< arraysize_type > r (
          arraysize_traits::create (i, f, this));

        this->arraysize_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }
    }
  }

  FIELD* FIELD::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FIELD (*this, f, c);
  }

  FIELD::
  ~FIELD ()
  {
  }

  // PARAM
  //

  PARAM::
  PARAM ()
  : ::votable_14::FIELD (),
    value_ (::xml_schema::flags (), this)
  {
  }

  PARAM::
  PARAM (const PARAM& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::votable_14::FIELD (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  PARAM::
  PARAM (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::votable_14::FIELD (e, f | ::xml_schema::flags::base, c),
    value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void PARAM::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::votable_14::FIELD::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        this->value_.set (r);
        continue;
      }
    }
  }

  PARAM* PARAM::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PARAM (*this, f, c);
  }

  PARAM::
  ~PARAM ()
  {
  }

  // GROUP
  //

  GROUP::
  GROUP ()
  : ::xml_schema::type (),
    DESCRIPTION_ (::xml_schema::flags (), this),
    FIELDref_ (::xml_schema::flags (), this),
    PARAMref_ (::xml_schema::flags (), this),
    PARAM_ (::xml_schema::flags (), this),
    GROUP1_ (::xml_schema::flags (), this),
    ID_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this),
    ref_ (::xml_schema::flags (), this),
    ucd_ (::xml_schema::flags (), this),
    utype_ (::xml_schema::flags (), this)
  {
  }

  GROUP::
  GROUP (const GROUP& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DESCRIPTION_ (x.DESCRIPTION_, f, this),
    FIELDref_ (x.FIELDref_, f, this),
    PARAMref_ (x.PARAMref_, f, this),
    PARAM_ (x.PARAM_, f, this),
    GROUP1_ (x.GROUP1_, f, this),
    ID_ (x.ID_, f, this),
    name_ (x.name_, f, this),
    ref_ (x.ref_, f, this),
    ucd_ (x.ucd_, f, this),
    utype_ (x.utype_, f, this)
  {
  }

  GROUP::
  GROUP (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DESCRIPTION_ (f, this),
    FIELDref_ (f, this),
    PARAMref_ (f, this),
    PARAM_ (f, this),
    GROUP1_ (f, this),
    ID_ (f, this),
    name_ (f, this),
    ref_ (f, this),
    ucd_ (f, this),
    utype_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void GROUP::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DESCRIPTION
      //
      if (n.name () == "DESCRIPTION" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< DESCRIPTION_type > r (
          DESCRIPTION_traits::create (i, f, this));

        if (!this->DESCRIPTION_)
        {
          this->DESCRIPTION_.set (r);
          continue;
        }
      }

      // FIELDref
      //
      if (n.name () == "FIELDref" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< FIELDref_type > r (
          FIELDref_traits::create (i, f, this));

        this->FIELDref_.push_back (r);
        continue;
      }

      // PARAMref
      //
      if (n.name () == "PARAMref" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< PARAMref_type > r (
          PARAMref_traits::create (i, f, this));

        this->PARAMref_.push_back (r);
        continue;
      }

      // PARAM
      //
      if (n.name () == "PARAM" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< PARAM_type > r (
          PARAM_traits::create (i, f, this));

        this->PARAM_.push_back (r);
        continue;
      }

      // GROUP
      //
      if (n.name () == "GROUP" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< GROUP1_type > r (
          GROUP1_traits::create (i, f, this));

        this->GROUP1_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref_type > r (
          ref_traits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }

      if (n.name () == "ucd" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ucd_type > r (
          ucd_traits::create (i, f, this));

        this->ucd_.set (r);
        continue;
      }

      if (n.name () == "utype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< utype_type > r (
          utype_traits::create (i, f, this));

        this->utype_.set (r);
        continue;
      }
    }
  }

  GROUP* GROUP::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GROUP (*this, f, c);
  }

  GROUP::
  ~GROUP ()
  {
  }

  // FIELDref
  //

  FIELDref::
  FIELDref (const ref_type& ref)
  : ::xml_schema::type (),
    ref_ (ref, ::xml_schema::flags (), this),
    ucd_ (::xml_schema::flags (), this),
    utype_ (::xml_schema::flags (), this)
  {
  }

  FIELDref::
  FIELDref (const FIELDref& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ref_ (x.ref_, f, this),
    ucd_ (x.ucd_, f, this),
    utype_ (x.utype_, f, this)
  {
  }

  FIELDref::
  FIELDref (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ref_ (f, this),
    ucd_ (f, this),
    utype_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void FIELDref::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref_type > r (
          ref_traits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }

      if (n.name () == "ucd" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ucd_type > r (
          ucd_traits::create (i, f, this));

        this->ucd_.set (r);
        continue;
      }

      if (n.name () == "utype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< utype_type > r (
          utype_traits::create (i, f, this));

        this->utype_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ref",
        "");
    }
  }

  FIELDref* FIELDref::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FIELDref (*this, f, c);
  }

  FIELDref::
  ~FIELDref ()
  {
  }

  // PARAMref
  //

  PARAMref::
  PARAMref (const ref_type& ref)
  : ::xml_schema::type (),
    ref_ (ref, ::xml_schema::flags (), this),
    ucd_ (::xml_schema::flags (), this),
    utype_ (::xml_schema::flags (), this)
  {
  }

  PARAMref::
  PARAMref (const PARAMref& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ref_ (x.ref_, f, this),
    ucd_ (x.ucd_, f, this),
    utype_ (x.utype_, f, this)
  {
  }

  PARAMref::
  PARAMref (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ref_ (f, this),
    ucd_ (f, this),
    utype_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void PARAMref::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref_type > r (
          ref_traits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }

      if (n.name () == "ucd" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ucd_type > r (
          ucd_traits::create (i, f, this));

        this->ucd_.set (r);
        continue;
      }

      if (n.name () == "utype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< utype_type > r (
          utype_traits::create (i, f, this));

        this->utype_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ref",
        "");
    }
  }

  PARAMref* PARAMref::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PARAMref (*this, f, c);
  }

  PARAMref::
  ~PARAMref ()
  {
  }

  // DATA
  //

  DATA::
  DATA ()
  : ::xml_schema::type (),
    TABLEDATA_ (::xml_schema::flags (), this),
    BINARY_ (::xml_schema::flags (), this),
    BINARY2_ (::xml_schema::flags (), this),
    FITS_ (::xml_schema::flags (), this),
    INFO_ (::xml_schema::flags (), this)
  {
  }

  DATA::
  DATA (const DATA& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    TABLEDATA_ (x.TABLEDATA_, f, this),
    BINARY_ (x.BINARY_, f, this),
    BINARY2_ (x.BINARY2_, f, this),
    FITS_ (x.FITS_, f, this),
    INFO_ (x.INFO_, f, this)
  {
  }

  DATA::
  DATA (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    TABLEDATA_ (f, this),
    BINARY_ (f, this),
    BINARY2_ (f, this),
    FITS_ (f, this),
    INFO_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void DATA::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TABLEDATA
      //
      if (n.name () == "TABLEDATA" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< TABLEDATA_type > r (
          TABLEDATA_traits::create (i, f, this));

        if (!this->TABLEDATA_)
        {
          this->TABLEDATA_.set (r);
          continue;
        }
      }

      // BINARY
      //
      if (n.name () == "BINARY" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< BINARY_type > r (
          BINARY_traits::create (i, f, this));

        if (!this->BINARY_)
        {
          this->BINARY_.set (r);
          continue;
        }
      }

      // BINARY2
      //
      if (n.name () == "BINARY2" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< BINARY2_type > r (
          BINARY2_traits::create (i, f, this));

        if (!this->BINARY2_)
        {
          this->BINARY2_.set (r);
          continue;
        }
      }

      // FITS
      //
      if (n.name () == "FITS" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< FITS_type > r (
          FITS_traits::create (i, f, this));

        if (!this->FITS_)
        {
          this->FITS_.set (r);
          continue;
        }
      }

      // INFO
      //
      if (n.name () == "INFO" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< INFO_type > r (
          INFO_traits::create (i, f, this));

        this->INFO_.push_back (r);
        continue;
      }

      break;
    }
  }

  DATA* DATA::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DATA (*this, f, c);
  }

  DATA::
  ~DATA ()
  {
  }

  // TABLEDATA
  //

  TABLEDATA::
  TABLEDATA ()
  : ::xml_schema::type (),
    TR_ (::xml_schema::flags (), this)
  {
  }

  TABLEDATA::
  TABLEDATA (const TABLEDATA& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    TR_ (x.TR_, f, this)
  {
  }

  TABLEDATA::
  TABLEDATA (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    TR_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TABLEDATA::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TR
      //
      if (n.name () == "TR" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< TR_type > r (
          TR_traits::create (i, f, this));

        this->TR_.push_back (r);
        continue;
      }

      break;
    }
  }

  TABLEDATA* TABLEDATA::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TABLEDATA (*this, f, c);
  }

  TABLEDATA::
  ~TABLEDATA ()
  {
  }

  // TD
  //

  TD::
  TD ()
  : ::xml_schema::string (),
    encoding_ (::xml_schema::flags (), this)
  {
  }

  TD::
  TD (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    encoding_ (::xml_schema::flags (), this)
  {
  }

  TD::
  TD (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    encoding_ (::xml_schema::flags (), this)
  {
  }

  TD::
  TD (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    encoding_ (::xml_schema::flags (), this)
  {
  }

  TD::
  TD (const TD& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    encoding_ (x.encoding_, f, this)
  {
  }

  TD::
  TD (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    encoding_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void TD::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "encoding" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< encoding_type > r (
          encoding_traits::create (i, f, this));

        this->encoding_.set (r);
        continue;
      }
    }
  }

  TD* TD::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TD (*this, f, c);
  }

  TD::
  ~TD ()
  {
  }

  // TR
  //

  TR::
  TR ()
  : ::xml_schema::type (),
    TD_ (::xml_schema::flags (), this),
    ID_ (::xml_schema::flags (), this)
  {
  }

  TR::
  TR (const TR& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    TD_ (x.TD_, f, this),
    ID_ (x.ID_, f, this)
  {
  }

  TR::
  TR (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    TD_ (f, this),
    ID_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TR::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TD
      //
      if (n.name () == "TD" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< TD_type > r (
          TD_traits::create (i, f, this));

        this->TD_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }
    }
  }

  TR* TR::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TR (*this, f, c);
  }

  TR::
  ~TR ()
  {
  }

  // FITS
  //

  FITS::
  FITS (const STREAM_type& STREAM)
  : ::xml_schema::type (),
    STREAM_ (STREAM, ::xml_schema::flags (), this),
    extnum_ (::xml_schema::flags (), this)
  {
  }

  FITS::
  FITS (::std::auto_ptr< STREAM_type >& STREAM)
  : ::xml_schema::type (),
    STREAM_ (STREAM, ::xml_schema::flags (), this),
    extnum_ (::xml_schema::flags (), this)
  {
  }

  FITS::
  FITS (const FITS& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    STREAM_ (x.STREAM_, f, this),
    extnum_ (x.extnum_, f, this)
  {
  }

  FITS::
  FITS (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    STREAM_ (f, this),
    extnum_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void FITS::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // STREAM
      //
      if (n.name () == "STREAM" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< STREAM_type > r (
          STREAM_traits::create (i, f, this));

        if (!STREAM_.present ())
        {
          this->STREAM_.set (r);
          continue;
        }
      }

      break;
    }

    if (!STREAM_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "STREAM",
        "http://www.ivoa.net/xml/VOTable/v1.3");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "extnum" && n.namespace_ ().empty ())
      {
        this->extnum_.set (extnum_traits::create (i, f, this));
        continue;
      }
    }
  }

  FITS* FITS::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FITS (*this, f, c);
  }

  FITS::
  ~FITS ()
  {
  }

  // BINARY
  //

  BINARY::
  BINARY (const STREAM_type& STREAM)
  : ::xml_schema::type (),
    STREAM_ (STREAM, ::xml_schema::flags (), this)
  {
  }

  BINARY::
  BINARY (::std::auto_ptr< STREAM_type >& STREAM)
  : ::xml_schema::type (),
    STREAM_ (STREAM, ::xml_schema::flags (), this)
  {
  }

  BINARY::
  BINARY (const BINARY& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    STREAM_ (x.STREAM_, f, this)
  {
  }

  BINARY::
  BINARY (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    STREAM_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void BINARY::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // STREAM
      //
      if (n.name () == "STREAM" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< STREAM_type > r (
          STREAM_traits::create (i, f, this));

        if (!STREAM_.present ())
        {
          this->STREAM_.set (r);
          continue;
        }
      }

      break;
    }

    if (!STREAM_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "STREAM",
        "http://www.ivoa.net/xml/VOTable/v1.3");
    }
  }

  BINARY* BINARY::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BINARY (*this, f, c);
  }

  BINARY::
  ~BINARY ()
  {
  }

  // BINARY2
  //

  BINARY2::
  BINARY2 (const STREAM_type& STREAM)
  : ::xml_schema::type (),
    STREAM_ (STREAM, ::xml_schema::flags (), this)
  {
  }

  BINARY2::
  BINARY2 (::std::auto_ptr< STREAM_type >& STREAM)
  : ::xml_schema::type (),
    STREAM_ (STREAM, ::xml_schema::flags (), this)
  {
  }

  BINARY2::
  BINARY2 (const BINARY2& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    STREAM_ (x.STREAM_, f, this)
  {
  }

  BINARY2::
  BINARY2 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    STREAM_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void BINARY2::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // STREAM
      //
      if (n.name () == "STREAM" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< STREAM_type > r (
          STREAM_traits::create (i, f, this));

        if (!STREAM_.present ())
        {
          this->STREAM_.set (r);
          continue;
        }
      }

      break;
    }

    if (!STREAM_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "STREAM",
        "http://www.ivoa.net/xml/VOTable/v1.3");
    }
  }

  BINARY2* BINARY2::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BINARY2 (*this, f, c);
  }

  BINARY2::
  ~BINARY2 ()
  {
  }

  // STREAM
  //

  const STREAM::type_type STREAM::type_default_value_ (
    "locator");

  const STREAM::actuate_type STREAM::actuate_default_value_ (
    "onRequest");

  const STREAM::encoding_type STREAM::encoding_default_value_ (
    "none");

  STREAM::
  STREAM ()
  : ::xml_schema::string (),
    type_ (type_default_value (), ::xml_schema::flags (), this),
    href_ (::xml_schema::flags (), this),
    actuate_ (actuate_default_value (), ::xml_schema::flags (), this),
    encoding_ (encoding_default_value (), ::xml_schema::flags (), this),
    expires_ (::xml_schema::flags (), this),
    rights_ (::xml_schema::flags (), this)
  {
  }

  STREAM::
  STREAM (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type_default_value (), ::xml_schema::flags (), this),
    href_ (::xml_schema::flags (), this),
    actuate_ (actuate_default_value (), ::xml_schema::flags (), this),
    encoding_ (encoding_default_value (), ::xml_schema::flags (), this),
    expires_ (::xml_schema::flags (), this),
    rights_ (::xml_schema::flags (), this)
  {
  }

  STREAM::
  STREAM (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type_default_value (), ::xml_schema::flags (), this),
    href_ (::xml_schema::flags (), this),
    actuate_ (actuate_default_value (), ::xml_schema::flags (), this),
    encoding_ (encoding_default_value (), ::xml_schema::flags (), this),
    expires_ (::xml_schema::flags (), this),
    rights_ (::xml_schema::flags (), this)
  {
  }

  STREAM::
  STREAM (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type_default_value (), ::xml_schema::flags (), this),
    href_ (::xml_schema::flags (), this),
    actuate_ (actuate_default_value (), ::xml_schema::flags (), this),
    encoding_ (encoding_default_value (), ::xml_schema::flags (), this),
    expires_ (::xml_schema::flags (), this),
    rights_ (::xml_schema::flags (), this)
  {
  }

  STREAM::
  STREAM (const STREAM& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    type_ (x.type_, f, this),
    href_ (x.href_, f, this),
    actuate_ (x.actuate_, f, this),
    encoding_ (x.encoding_, f, this),
    expires_ (x.expires_, f, this),
    rights_ (x.rights_, f, this)
  {
  }

  STREAM::
  STREAM (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    type_ (f, this),
    href_ (f, this),
    actuate_ (f, this),
    encoding_ (f, this),
    expires_ (f, this),
    rights_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void STREAM::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "href" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< href_type > r (
          href_traits::create (i, f, this));

        this->href_.set (r);
        continue;
      }

      if (n.name () == "actuate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< actuate_type > r (
          actuate_traits::create (i, f, this));

        this->actuate_.set (r);
        continue;
      }

      if (n.name () == "encoding" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< encoding_type > r (
          encoding_traits::create (i, f, this));

        this->encoding_.set (r);
        continue;
      }

      if (n.name () == "expires" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< expires_type > r (
          expires_traits::create (i, f, this));

        this->expires_.set (r);
        continue;
      }

      if (n.name () == "rights" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< rights_type > r (
          rights_traits::create (i, f, this));

        this->rights_.set (r);
        continue;
      }
    }

    if (!type_.present ())
    {
      this->type_.set (type_default_value ());
    }

    if (!actuate_.present ())
    {
      this->actuate_.set (actuate_default_value ());
    }

    if (!encoding_.present ())
    {
      this->encoding_.set (encoding_default_value ());
    }
  }

  STREAM* STREAM::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class STREAM (*this, f, c);
  }

  STREAM::
  ~STREAM ()
  {
  }

  // TABLE
  //

  TABLE::
  TABLE ()
  : ::xml_schema::type (),
    DESCRIPTION_ (::xml_schema::flags (), this),
    INFO_ (::xml_schema::flags (), this),
    FIELD_ (::xml_schema::flags (), this),
    PARAM_ (::xml_schema::flags (), this),
    GROUP_ (::xml_schema::flags (), this),
    LINK_ (::xml_schema::flags (), this),
    DATA_ (::xml_schema::flags (), this),
    ID_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this),
    ref_ (::xml_schema::flags (), this),
    ucd_ (::xml_schema::flags (), this),
    utype_ (::xml_schema::flags (), this),
    nrows_ (::xml_schema::flags (), this)
  {
  }

  TABLE::
  TABLE (const TABLE& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DESCRIPTION_ (x.DESCRIPTION_, f, this),
    INFO_ (x.INFO_, f, this),
    FIELD_ (x.FIELD_, f, this),
    PARAM_ (x.PARAM_, f, this),
    GROUP_ (x.GROUP_, f, this),
    LINK_ (x.LINK_, f, this),
    DATA_ (x.DATA_, f, this),
    ID_ (x.ID_, f, this),
    name_ (x.name_, f, this),
    ref_ (x.ref_, f, this),
    ucd_ (x.ucd_, f, this),
    utype_ (x.utype_, f, this),
    nrows_ (x.nrows_, f, this)
  {
  }

  TABLE::
  TABLE (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DESCRIPTION_ (f, this),
    INFO_ (f, this),
    FIELD_ (f, this),
    PARAM_ (f, this),
    GROUP_ (f, this),
    LINK_ (f, this),
    DATA_ (f, this),
    ID_ (f, this),
    name_ (f, this),
    ref_ (f, this),
    ucd_ (f, this),
    utype_ (f, this),
    nrows_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TABLE::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DESCRIPTION
      //
      if (n.name () == "DESCRIPTION" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< DESCRIPTION_type > r (
          DESCRIPTION_traits::create (i, f, this));

        if (!this->DESCRIPTION_)
        {
          this->DESCRIPTION_.set (r);
          continue;
        }
      }

      // INFO
      //
      if (n.name () == "INFO" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< INFO_type > r (
          INFO_traits::create (i, f, this));

        this->INFO_.push_back (r);
        continue;
      }

      // FIELD
      //
      if (n.name () == "FIELD" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< FIELD_type > r (
          FIELD_traits::create (i, f, this));

        this->FIELD_.push_back (r);
        continue;
      }

      // PARAM
      //
      if (n.name () == "PARAM" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< PARAM_type > r (
          PARAM_traits::create (i, f, this));

        this->PARAM_.push_back (r);
        continue;
      }

      // GROUP
      //
      if (n.name () == "GROUP" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< GROUP_type > r (
          GROUP_traits::create (i, f, this));

        this->GROUP_.push_back (r);
        continue;
      }

      // LINK
      //
      if (n.name () == "LINK" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< LINK_type > r (
          LINK_traits::create (i, f, this));

        this->LINK_.push_back (r);
        continue;
      }

      // DATA
      //
      if (n.name () == "DATA" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< DATA_type > r (
          DATA_traits::create (i, f, this));

        if (!this->DATA_)
        {
          this->DATA_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref_type > r (
          ref_traits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }

      if (n.name () == "ucd" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ucd_type > r (
          ucd_traits::create (i, f, this));

        this->ucd_.set (r);
        continue;
      }

      if (n.name () == "utype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< utype_type > r (
          utype_traits::create (i, f, this));

        this->utype_.set (r);
        continue;
      }

      if (n.name () == "nrows" && n.namespace_ ().empty ())
      {
        this->nrows_.set (nrows_traits::create (i, f, this));
        continue;
      }
    }
  }

  TABLE* TABLE::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TABLE (*this, f, c);
  }

  TABLE::
  ~TABLE ()
  {
  }

  // RESOURCE
  //

  const RESOURCE::type_type RESOURCE::type_default_value_ (
    "results");

  RESOURCE::
  RESOURCE ()
  : ::xml_schema::type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    DESCRIPTION_ (::xml_schema::flags (), this),
    INFO_ (::xml_schema::flags (), this),
    COOSYS_ (::xml_schema::flags (), this),
    TIMESYS_ (::xml_schema::flags (), this),
    GROUP_ (::xml_schema::flags (), this),
    PARAM_ (::xml_schema::flags (), this),
    LINK_ (::xml_schema::flags (), this),
    TABLE_ (::xml_schema::flags (), this),
    RESOURCE1_ (::xml_schema::flags (), this),
    any_ (this->dom_document ()),
    name_ (::xml_schema::flags (), this),
    ID_ (::xml_schema::flags (), this),
    utype_ (::xml_schema::flags (), this),
    type_ (type_default_value (), ::xml_schema::flags (), this),
    any_attribute_ (this->dom_document ())
  {
  }

  RESOURCE::
  RESOURCE (const RESOURCE& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    DESCRIPTION_ (x.DESCRIPTION_, f, this),
    INFO_ (x.INFO_, f, this),
    COOSYS_ (x.COOSYS_, f, this),
    TIMESYS_ (x.TIMESYS_, f, this),
    GROUP_ (x.GROUP_, f, this),
    PARAM_ (x.PARAM_, f, this),
    LINK_ (x.LINK_, f, this),
    TABLE_ (x.TABLE_, f, this),
    RESOURCE1_ (x.RESOURCE1_, f, this),
    any_ (x.any_, this->dom_document ()),
    name_ (x.name_, f, this),
    ID_ (x.ID_, f, this),
    utype_ (x.utype_, f, this),
    type_ (x.type_, f, this),
    any_attribute_ (x.any_attribute_, this->dom_document ())
  {
  }

  RESOURCE::
  RESOURCE (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    DESCRIPTION_ (f, this),
    INFO_ (f, this),
    COOSYS_ (f, this),
    TIMESYS_ (f, this),
    GROUP_ (f, this),
    PARAM_ (f, this),
    LINK_ (f, this),
    TABLE_ (f, this),
    RESOURCE1_ (f, this),
    any_ (this->dom_document ()),
    name_ (f, this),
    ID_ (f, this),
    utype_ (f, this),
    type_ (f, this),
    any_attribute_ (this->dom_document ())
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void RESOURCE::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DESCRIPTION
      //
      if (n.name () == "DESCRIPTION" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< DESCRIPTION_type > r (
          DESCRIPTION_traits::create (i, f, this));

        if (!this->DESCRIPTION_)
        {
          this->DESCRIPTION_.set (r);
          continue;
        }
      }

      // INFO
      //
      if (n.name () == "INFO" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< INFO_type > r (
          INFO_traits::create (i, f, this));

        this->INFO_.push_back (r);
        continue;
      }

      // COOSYS
      //
      if (n.name () == "COOSYS" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< COOSYS_type > r (
          COOSYS_traits::create (i, f, this));

        this->COOSYS_.push_back (r);
        continue;
      }

      // TIMESYS
      //
      if (n.name () == "TIMESYS" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< TIMESYS_type > r (
          TIMESYS_traits::create (i, f, this));

        this->TIMESYS_.push_back (r);
        continue;
      }

      // GROUP
      //
      if (n.name () == "GROUP" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< GROUP_type > r (
          GROUP_traits::create (i, f, this));

        this->GROUP_.push_back (r);
        continue;
      }

      // PARAM
      //
      if (n.name () == "PARAM" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< PARAM_type > r (
          PARAM_traits::create (i, f, this));

        this->PARAM_.push_back (r);
        continue;
      }

      // LINK
      //
      if (n.name () == "LINK" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< LINK_type > r (
          LINK_traits::create (i, f, this));

        this->LINK_.push_back (r);
        continue;
      }

      // TABLE
      //
      if (n.name () == "TABLE" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< TABLE_type > r (
          TABLE_traits::create (i, f, this));

        this->TABLE_.push_back (r);
        continue;
      }

      // RESOURCE
      //
      if (n.name () == "RESOURCE" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< RESOURCE1_type > r (
          RESOURCE1_traits::create (i, f, this));

        this->RESOURCE1_.push_back (r);
        continue;
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.ivoa.net/xml/VOTable/v1.3"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->dom_document ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_ .push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "utype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< utype_type > r (
          utype_traits::create (i, f, this));

        this->utype_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      // any_attribute
      //
      if ((!n.namespace_ ().empty () &&
           n.namespace_ () != "http://www.ivoa.net/xml/VOTable/v1.3" &&
           n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
           n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
      {
        ::xercesc::DOMAttr* r (
          static_cast< ::xercesc::DOMAttr* > (
            this->dom_document ().importNode (
              const_cast< ::xercesc::DOMAttr* > (&i), true)));
        this->any_attribute_ .insert (r);
        continue;
      }
    }

    if (!type_.present ())
    {
      this->type_.set (type_default_value ());
    }
  }

  RESOURCE* RESOURCE::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RESOURCE (*this, f, c);
  }

  RESOURCE::
  ~RESOURCE ()
  {
  }

  // type
  //

  type::
  type (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_type_convert ();
  }

  type::
  type (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_type_convert ();
  }

  type::
  type (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_type_convert ();
  }

  type* type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type (*this, f, c);
  }

  type::value type::
  _xsd_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_type_indexes_,
                      _xsd_type_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_type_indexes_ + 2 || _xsd_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type::
  _xsd_type_literals_[2] =
  {
    "legal",
    "actual"
  };

  const type::value type::
  _xsd_type_indexes_[2] =
  {
    ::votable_14::type::actual,
    ::votable_14::type::legal
  };

  // system
  //

  system::
  system (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_system_convert ();
  }

  system::
  system (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_system_convert ();
  }

  system::
  system (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_system_convert ();
  }

  system* system::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class system (*this, f, c);
  }

  system::value system::
  _xsd_system_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_system_literals_);
    const value* i (::std::lower_bound (
                      _xsd_system_indexes_,
                      _xsd_system_indexes_ + 10,
                      *this,
                      c));

    if (i == _xsd_system_indexes_ + 10 || _xsd_system_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const system::
  _xsd_system_literals_[10] =
  {
    "eq_FK4",
    "eq_FK5",
    "ICRS",
    "ecl_FK4",
    "ecl_FK5",
    "galactic",
    "supergalactic",
    "xy",
    "barycentric",
    "geo_app"
  };

  const system::value system::
  _xsd_system_indexes_[10] =
  {
    ::votable_14::system::ICRS,
    ::votable_14::system::barycentric,
    ::votable_14::system::ecl_FK4,
    ::votable_14::system::ecl_FK5,
    ::votable_14::system::eq_FK4,
    ::votable_14::system::eq_FK5,
    ::votable_14::system::galactic,
    ::votable_14::system::geo_app,
    ::votable_14::system::supergalactic,
    ::votable_14::system::xy
  };

  // type1
  //

  type1::
  type1 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_type1_convert ();
  }

  type1::
  type1 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_type1_convert ();
  }

  type1::
  type1 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_type1_convert ();
  }

  type1* type1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type1 (*this, f, c);
  }

  type1::value type1::
  _xsd_type1_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type1_literals_);
    const value* i (::std::lower_bound (
                      _xsd_type1_indexes_,
                      _xsd_type1_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_type1_indexes_ + 4 || _xsd_type1_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type1::
  _xsd_type1_literals_[4] =
  {
    "hidden",
    "no_query",
    "trigger",
    "location"
  };

  const type1::value type1::
  _xsd_type1_indexes_[4] =
  {
    ::votable_14::type1::hidden,
    ::votable_14::type1::location,
    ::votable_14::type1::no_query,
    ::votable_14::type1::trigger
  };

  // type2
  //

  type2::
  type2 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_type2_convert ();
  }

  type2::
  type2 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_type2_convert ();
  }

  type2::
  type2 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_type2_convert ();
  }

  type2* type2::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type2 (*this, f, c);
  }

  type2::value type2::
  _xsd_type2_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type2_literals_);
    const value* i (::std::lower_bound (
                      _xsd_type2_indexes_,
                      _xsd_type2_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_type2_indexes_ + 2 || _xsd_type2_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type2::
  _xsd_type2_literals_[2] =
  {
    "locator",
    "other"
  };

  const type2::value type2::
  _xsd_type2_indexes_[2] =
  {
    ::votable_14::type2::locator,
    ::votable_14::type2::other
  };

  // actuate
  //

  actuate::
  actuate (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_actuate_convert ();
  }

  actuate::
  actuate (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_actuate_convert ();
  }

  actuate::
  actuate (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_actuate_convert ();
  }

  actuate* actuate::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class actuate (*this, f, c);
  }

  actuate::value actuate::
  _xsd_actuate_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_actuate_literals_);
    const value* i (::std::lower_bound (
                      _xsd_actuate_indexes_,
                      _xsd_actuate_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_actuate_indexes_ + 4 || _xsd_actuate_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const actuate::
  _xsd_actuate_literals_[4] =
  {
    "onLoad",
    "onRequest",
    "other",
    "none"
  };

  const actuate::value actuate::
  _xsd_actuate_indexes_[4] =
  {
    ::votable_14::actuate::none,
    ::votable_14::actuate::onLoad,
    ::votable_14::actuate::onRequest,
    ::votable_14::actuate::other
  };

  // type3
  //

  type3::
  type3 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_type3_convert ();
  }

  type3::
  type3 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_type3_convert ();
  }

  type3::
  type3 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_type3_convert ();
  }

  type3* type3::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type3 (*this, f, c);
  }

  type3::value type3::
  _xsd_type3_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type3_literals_);
    const value* i (::std::lower_bound (
                      _xsd_type3_indexes_,
                      _xsd_type3_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_type3_indexes_ + 2 || _xsd_type3_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type3::
  _xsd_type3_literals_[2] =
  {
    "results",
    "meta"
  };

  const type3::value type3::
  _xsd_type3_indexes_[2] =
  {
    ::votable_14::type3::meta,
    ::votable_14::type3::results
  };

  // VOTABLE
  //

  VOTABLE::
  VOTABLE ()
  : ::xml_schema::type (),
    DESCRIPTION_ (::xml_schema::flags (), this),
    DEFINITIONS_ (::xml_schema::flags (), this),
    COOSYS_ (::xml_schema::flags (), this),
    TIMESYS_ (::xml_schema::flags (), this),
    GROUP_ (::xml_schema::flags (), this),
    PARAM_ (::xml_schema::flags (), this),
    INFO_ (::xml_schema::flags (), this),
    RESOURCE_ (::xml_schema::flags (), this),
    ID_ (::xml_schema::flags (), this),
    version_ (::xml_schema::flags (), this)
  {
  }

  VOTABLE::
  VOTABLE (const VOTABLE& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DESCRIPTION_ (x.DESCRIPTION_, f, this),
    DEFINITIONS_ (x.DEFINITIONS_, f, this),
    COOSYS_ (x.COOSYS_, f, this),
    TIMESYS_ (x.TIMESYS_, f, this),
    GROUP_ (x.GROUP_, f, this),
    PARAM_ (x.PARAM_, f, this),
    INFO_ (x.INFO_, f, this),
    RESOURCE_ (x.RESOURCE_, f, this),
    ID_ (x.ID_, f, this),
    version_ (x.version_, f, this)
  {
  }

  VOTABLE::
  VOTABLE (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DESCRIPTION_ (f, this),
    DEFINITIONS_ (f, this),
    COOSYS_ (f, this),
    TIMESYS_ (f, this),
    GROUP_ (f, this),
    PARAM_ (f, this),
    INFO_ (f, this),
    RESOURCE_ (f, this),
    ID_ (f, this),
    version_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void VOTABLE::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DESCRIPTION
      //
      if (n.name () == "DESCRIPTION" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< DESCRIPTION_type > r (
          DESCRIPTION_traits::create (i, f, this));

        if (!this->DESCRIPTION_)
        {
          this->DESCRIPTION_.set (r);
          continue;
        }
      }

      // DEFINITIONS
      //
      if (n.name () == "DEFINITIONS" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< DEFINITIONS_type > r (
          DEFINITIONS_traits::create (i, f, this));

        if (!this->DEFINITIONS_)
        {
          this->DEFINITIONS_.set (r);
          continue;
        }
      }

      // COOSYS
      //
      if (n.name () == "COOSYS" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< COOSYS_type > r (
          COOSYS_traits::create (i, f, this));

        this->COOSYS_.push_back (r);
        continue;
      }

      // TIMESYS
      //
      if (n.name () == "TIMESYS" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< TIMESYS_type > r (
          TIMESYS_traits::create (i, f, this));

        this->TIMESYS_.push_back (r);
        continue;
      }

      // GROUP
      //
      if (n.name () == "GROUP" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< GROUP_type > r (
          GROUP_traits::create (i, f, this));

        this->GROUP_.push_back (r);
        continue;
      }

      // PARAM
      //
      if (n.name () == "PARAM" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< PARAM_type > r (
          PARAM_traits::create (i, f, this));

        this->PARAM_.push_back (r);
        continue;
      }

      // INFO
      //
      if (n.name () == "INFO" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< INFO_type > r (
          INFO_traits::create (i, f, this));

        this->INFO_.push_back (r);
        continue;
      }

      // RESOURCE
      //
      if (n.name () == "RESOURCE" && n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
      {
        ::std::auto_ptr< RESOURCE_type > r (
          RESOURCE_traits::create (i, f, this));

        this->RESOURCE_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID_type > r (
          ID_traits::create (i, f, this));

        this->ID_.set (r);
        continue;
      }

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< version_type > r (
          version_traits::create (i, f, this));

        this->version_.set (r);
        continue;
      }
    }
  }

  VOTABLE* VOTABLE::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VOTABLE (*this, f, c);
  }

  VOTABLE::
  ~VOTABLE ()
  {
  }

  // version
  //

  version::
  version (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_version_convert ();
  }

  version::
  version (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_version_convert ();
  }

  version::
  version (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_version_convert ();
  }

  version* version::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class version (*this, f, c);
  }

  version::value version::
  _xsd_version_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_version_literals_);
    const value* i (::std::lower_bound (
                      _xsd_version_indexes_,
                      _xsd_version_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_version_indexes_ + 2 || _xsd_version_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const version::
  _xsd_version_literals_[2] =
  {
    "1.3",
    "1.4"
  };

  const version::value version::
  _xsd_version_indexes_[2] =
  {
    ::votable_14::version::cxx_1_3,
    ::votable_14::version::cxx_1_4
  };
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace votable_14
{
  ::std::auto_ptr< ::votable_14::VOTABLE >
  VOTABLE_read (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::votable_14::VOTABLE > r (
      ::votable_14::VOTABLE_read (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::votable_14::VOTABLE >
  VOTABLE_read (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::votable_14::VOTABLE > r (
      ::votable_14::VOTABLE_read (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::votable_14::VOTABLE >
  VOTABLE_read (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::votable_14::VOTABLE > r (
      ::votable_14::VOTABLE_read (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::votable_14::VOTABLE >
  VOTABLE_read (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::votable_14::VOTABLE_read (isrc, f, p);
  }

  ::std::auto_ptr< ::votable_14::VOTABLE >
  VOTABLE_read (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::votable_14::VOTABLE_read (isrc, h, f, p);
  }

  ::std::auto_ptr< ::votable_14::VOTABLE >
  VOTABLE_read (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::votable_14::VOTABLE_read (isrc, h, f, p);
  }

  ::std::auto_ptr< ::votable_14::VOTABLE >
  VOTABLE_read (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::votable_14::VOTABLE_read (isrc, f, p);
  }

  ::std::auto_ptr< ::votable_14::VOTABLE >
  VOTABLE_read (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::votable_14::VOTABLE_read (isrc, h, f, p);
  }

  ::std::auto_ptr< ::votable_14::VOTABLE >
  VOTABLE_read (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::votable_14::VOTABLE_read (isrc, h, f, p);
  }

  ::std::auto_ptr< ::votable_14::VOTABLE >
  VOTABLE_read (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::votable_14::VOTABLE > r (
      ::votable_14::VOTABLE_read (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::votable_14::VOTABLE >
  VOTABLE_read (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::votable_14::VOTABLE > r (
      ::votable_14::VOTABLE_read (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::votable_14::VOTABLE >
  VOTABLE_read (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::votable_14::VOTABLE > r (
      ::votable_14::VOTABLE_read (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::votable_14::VOTABLE >
  VOTABLE_read (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::votable_14::VOTABLE > r (
        ::votable_14::VOTABLE_read (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "VOTABLE" &&
        n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
    {
      ::std::auto_ptr< ::votable_14::VOTABLE > r (
        ::xsd::cxx::tree::traits< ::votable_14::VOTABLE, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "VOTABLE",
      "http://www.ivoa.net/xml/VOTable/v1.3");
  }

  ::std::auto_ptr< ::votable_14::VOTABLE >
  VOTABLE_read (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "VOTABLE" &&
        n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
    {
      ::std::auto_ptr< ::votable_14::VOTABLE > r (
        ::xsd::cxx::tree::traits< ::votable_14::VOTABLE, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "VOTABLE",
      "http://www.ivoa.net/xml/VOTable/v1.3");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace votable_14
{
  void
  operator<< (::xercesc::DOMElement& e, const anyTEXT& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // any
    //
    for (anyTEXT::any_const_iterator
         b (i.any ().begin ()), n (i.any ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const astroYear& i)
  {
    e << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const astroYear& i)
  {
    a << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const astroYear& i)
  {
    l << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ucdType& i)
  {
    e << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ucdType& i)
  {
    a << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const ucdType& i)
  {
    l << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const arrayDEF& i)
  {
    e << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const arrayDEF& i)
  {
    a << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const arrayDEF& i)
  {
    l << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const encodingType& i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const encodingType& i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const encodingType& i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const dataType& i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const dataType& i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const dataType& i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const precType& i)
  {
    e << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const precType& i)
  {
    a << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const precType& i)
  {
    l << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const yesno& i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const yesno& i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const yesno& i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const MIN& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }

    // inclusive
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "inclusive",
          e));

      a << i.inclusive ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MAX& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }

    // inclusive
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "inclusive",
          e));

      a << i.inclusive ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const OPTION& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // OPTION
    //
    for (OPTION::OPTION1_const_iterator
         b (i.OPTION1 ().begin ()), n (i.OPTION1 ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "OPTION",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.name ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VALUES& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // MIN
    //
    if (i.MIN ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MIN",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *i.MIN ();
    }

    // MAX
    //
    if (i.MAX ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MAX",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *i.MAX ();
    }

    // OPTION
    //
    for (VALUES::OPTION_const_iterator
         b (i.OPTION ().begin ()), n (i.OPTION ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "OPTION",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // ID
    //
    if (i.ID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ID",
          e));

      a << *i.ID ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }

    // null
    //
    if (i.null ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "null",
          e));

      a << *i.null ();
    }

    // ref
    //
    if (i.ref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << *i.ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LINK& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ID
    //
    if (i.ID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ID",
          e));

      a << *i.ID ();
    }

    // content-role
    //
    if (i.content_role ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "content-role",
          e));

      a << *i.content_role ();
    }

    // content-type
    //
    if (i.content_type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "content-type",
          e));

      a << *i.content_type ();
    }

    // title
    //
    if (i.title ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "title",
          e));

      a << *i.title ();
    }

    // value
    //
    if (i.value ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << *i.value ();
    }

    // href
    //
    if (i.href ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "href",
          e));

      a << *i.href ();
    }

    // gref
    //
    if (i.gref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "gref",
          e));

      a << *i.gref ();
    }

    // action
    //
    if (i.action ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "action",
          e));

      a << *i.action ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const INFO& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // ID
    //
    if (i.ID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ID",
          e));

      a << *i.ID ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }

    // unit
    //
    if (i.unit ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit",
          e));

      a << *i.unit ();
    }

    // xtype
    //
    if (i.xtype ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "xtype",
          e));

      a << *i.xtype ();
    }

    // ref
    //
    if (i.ref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << *i.ref ();
    }

    // ucd
    //
    if (i.ucd ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ucd",
          e));

      a << *i.ucd ();
    }

    // utype
    //
    if (i.utype ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "utype",
          e));

      a << *i.utype ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const COOSYS& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // ID
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ID",
          e));

      a << i.ID ();
    }

    // equinox
    //
    if (i.equinox ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "equinox",
          e));

      a << *i.equinox ();
    }

    // epoch
    //
    if (i.epoch ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "epoch",
          e));

      a << *i.epoch ();
    }

    // system
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "system",
          e));

      a << i.system ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Timeorigin& i)
  {
    e << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Timeorigin& i)
  {
    a << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Timeorigin& i)
  {
    l << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimeSystem& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // ID
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ID",
          e));

      a << i.ID ();
    }

    // timeorigin
    //
    if (i.timeorigin ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "timeorigin",
          e));

      a << *i.timeorigin ();
    }

    // timescale
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "timescale",
          e));

      a << i.timescale ();
    }

    // refposition
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "refposition",
          e));

      a << i.refposition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DEFINITIONS& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // COOSYS
    //
    for (DEFINITIONS::COOSYS_const_iterator
         b (i.COOSYS ().begin ()), n (i.COOSYS ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "COOSYS",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // TIMESYS
    //
    for (DEFINITIONS::TIMESYS_const_iterator
         b (i.TIMESYS ().begin ()), n (i.TIMESYS ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TIMESYS",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // PARAM
    //
    for (DEFINITIONS::PARAM_const_iterator
         b (i.PARAM ().begin ()), n (i.PARAM ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PARAM",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const FIELD& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // DESCRIPTION
    //
    if (i.DESCRIPTION ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DESCRIPTION",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *i.DESCRIPTION ();
    }

    // VALUES
    //
    if (i.VALUES ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "VALUES",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *i.VALUES ();
    }

    // LINK
    //
    for (FIELD::LINK_const_iterator
         b (i.LINK ().begin ()), n (i.LINK ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "LINK",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // ID
    //
    if (i.ID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ID",
          e));

      a << *i.ID ();
    }

    // unit
    //
    if (i.unit ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit",
          e));

      a << *i.unit ();
    }

    // datatype
    //
    if (i.datatype ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "datatype",
          e));

      a << *i.datatype ();
    }

    // precision
    //
    if (i.precision ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "precision",
          e));

      a << *i.precision ();
    }

    // width
    //
    if (i.width ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "width",
          e));

      a << *i.width ();
    }

    // xtype
    //
    if (i.xtype ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "xtype",
          e));

      a << *i.xtype ();
    }

    // ref
    //
    if (i.ref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << *i.ref ();
    }

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.name ();
    }

    // ucd
    //
    if (i.ucd ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ucd",
          e));

      a << *i.ucd ();
    }

    // utype
    //
    if (i.utype ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "utype",
          e));

      a << *i.utype ();
    }

    // arraysize
    //
    if (i.arraysize ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "arraysize",
          e));

      a << *i.arraysize ();
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PARAM& i)
  {
    e << static_cast< const ::votable_14::FIELD& > (i);

    // value
    //
    if (i.value ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << *i.value ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GROUP& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // DESCRIPTION
    //
    if (i.DESCRIPTION ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DESCRIPTION",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *i.DESCRIPTION ();
    }

    // FIELDref
    //
    for (GROUP::FIELDref_const_iterator
         b (i.FIELDref ().begin ()), n (i.FIELDref ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FIELDref",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // PARAMref
    //
    for (GROUP::PARAMref_const_iterator
         b (i.PARAMref ().begin ()), n (i.PARAMref ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PARAMref",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // PARAM
    //
    for (GROUP::PARAM_const_iterator
         b (i.PARAM ().begin ()), n (i.PARAM ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PARAM",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // GROUP
    //
    for (GROUP::GROUP1_const_iterator
         b (i.GROUP1 ().begin ()), n (i.GROUP1 ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "GROUP",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // ID
    //
    if (i.ID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ID",
          e));

      a << *i.ID ();
    }

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.name ();
    }

    // ref
    //
    if (i.ref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << *i.ref ();
    }

    // ucd
    //
    if (i.ucd ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ucd",
          e));

      a << *i.ucd ();
    }

    // utype
    //
    if (i.utype ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "utype",
          e));

      a << *i.utype ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const FIELDref& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.ref ();
    }

    // ucd
    //
    if (i.ucd ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ucd",
          e));

      a << *i.ucd ();
    }

    // utype
    //
    if (i.utype ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "utype",
          e));

      a << *i.utype ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PARAMref& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.ref ();
    }

    // ucd
    //
    if (i.ucd ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ucd",
          e));

      a << *i.ucd ();
    }

    // utype
    //
    if (i.utype ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "utype",
          e));

      a << *i.utype ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DATA& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // TABLEDATA
    //
    if (i.TABLEDATA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TABLEDATA",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *i.TABLEDATA ();
    }

    // BINARY
    //
    if (i.BINARY ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "BINARY",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *i.BINARY ();
    }

    // BINARY2
    //
    if (i.BINARY2 ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "BINARY2",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *i.BINARY2 ();
    }

    // FITS
    //
    if (i.FITS ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FITS",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *i.FITS ();
    }

    // INFO
    //
    for (DATA::INFO_const_iterator
         b (i.INFO ().begin ()), n (i.INFO ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "INFO",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TABLEDATA& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // TR
    //
    for (TABLEDATA::TR_const_iterator
         b (i.TR ().begin ()), n (i.TR ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TR",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TD& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // encoding
    //
    if (i.encoding ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "encoding",
          e));

      a << *i.encoding ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TR& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // TD
    //
    for (TR::TD_const_iterator
         b (i.TD ().begin ()), n (i.TD ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TD",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // ID
    //
    if (i.ID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ID",
          e));

      a << *i.ID ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const FITS& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // STREAM
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "STREAM",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << i.STREAM ();
    }

    // extnum
    //
    if (i.extnum ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "extnum",
          e));

      a << *i.extnum ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BINARY& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // STREAM
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "STREAM",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << i.STREAM ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BINARY2& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // STREAM
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "STREAM",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << i.STREAM ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const STREAM& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }

    // href
    //
    if (i.href ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "href",
          e));

      a << *i.href ();
    }

    // actuate
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "actuate",
          e));

      a << i.actuate ();
    }

    // encoding
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "encoding",
          e));

      a << i.encoding ();
    }

    // expires
    //
    if (i.expires ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "expires",
          e));

      a << *i.expires ();
    }

    // rights
    //
    if (i.rights ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "rights",
          e));

      a << *i.rights ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TABLE& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // DESCRIPTION
    //
    if (i.DESCRIPTION ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DESCRIPTION",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *i.DESCRIPTION ();
    }

    // INFO
    //
    for (TABLE::INFO_const_iterator
         b (i.INFO ().begin ()), n (i.INFO ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "INFO",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // FIELD
    //
    for (TABLE::FIELD_const_iterator
         b (i.FIELD ().begin ()), n (i.FIELD ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FIELD",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // PARAM
    //
    for (TABLE::PARAM_const_iterator
         b (i.PARAM ().begin ()), n (i.PARAM ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PARAM",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // GROUP
    //
    for (TABLE::GROUP_const_iterator
         b (i.GROUP ().begin ()), n (i.GROUP ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "GROUP",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // LINK
    //
    for (TABLE::LINK_const_iterator
         b (i.LINK ().begin ()), n (i.LINK ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "LINK",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // DATA
    //
    if (i.DATA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DATA",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *i.DATA ();
    }

    // ID
    //
    if (i.ID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ID",
          e));

      a << *i.ID ();
    }

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.name ();
    }

    // ref
    //
    if (i.ref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << *i.ref ();
    }

    // ucd
    //
    if (i.ucd ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ucd",
          e));

      a << *i.ucd ();
    }

    // utype
    //
    if (i.utype ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "utype",
          e));

      a << *i.utype ();
    }

    // nrows
    //
    if (i.nrows ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "nrows",
          e));

      a << *i.nrows ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RESOURCE& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // any_attribute
    //
    for (RESOURCE::any_attribute_const_iterator
         b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMAttr* a (
        static_cast< ::xercesc::DOMAttr* > (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

      if (a->getLocalName () == 0)
        e.setAttributeNode (a);
      else
        e.setAttributeNodeNS (a);
    }

    // DESCRIPTION
    //
    if (i.DESCRIPTION ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DESCRIPTION",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *i.DESCRIPTION ();
    }

    // INFO
    //
    for (RESOURCE::INFO_const_iterator
         b (i.INFO ().begin ()), n (i.INFO ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "INFO",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // COOSYS
    //
    for (RESOURCE::COOSYS_const_iterator
         b (i.COOSYS ().begin ()), n (i.COOSYS ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "COOSYS",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // TIMESYS
    //
    for (RESOURCE::TIMESYS_const_iterator
         b (i.TIMESYS ().begin ()), n (i.TIMESYS ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TIMESYS",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // GROUP
    //
    for (RESOURCE::GROUP_const_iterator
         b (i.GROUP ().begin ()), n (i.GROUP ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "GROUP",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // PARAM
    //
    for (RESOURCE::PARAM_const_iterator
         b (i.PARAM ().begin ()), n (i.PARAM ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PARAM",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // LINK
    //
    for (RESOURCE::LINK_const_iterator
         b (i.LINK ().begin ()), n (i.LINK ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "LINK",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // TABLE
    //
    for (RESOURCE::TABLE_const_iterator
         b (i.TABLE ().begin ()), n (i.TABLE ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TABLE",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // RESOURCE
    //
    for (RESOURCE::RESOURCE1_const_iterator
         b (i.RESOURCE1 ().begin ()), n (i.RESOURCE1 ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RESOURCE",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // any
    //
    for (RESOURCE::any_const_iterator
         b (i.any ().begin ()), n (i.any ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.name ();
    }

    // ID
    //
    if (i.ID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ID",
          e));

      a << *i.ID ();
    }

    // utype
    //
    if (i.utype ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "utype",
          e));

      a << *i.utype ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }
  }

  void
  VOTABLE_write (::std::ostream& o,
                 const ::votable_14::VOTABLE& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::votable_14::VOTABLE_write (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  VOTABLE_write (::std::ostream& o,
                 const ::votable_14::VOTABLE& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::votable_14::VOTABLE_write (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  VOTABLE_write (::std::ostream& o,
                 const ::votable_14::VOTABLE& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::votable_14::VOTABLE_write (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  VOTABLE_write (::xercesc::XMLFormatTarget& t,
                 const ::votable_14::VOTABLE& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::votable_14::VOTABLE_write (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  VOTABLE_write (::xercesc::XMLFormatTarget& t,
                 const ::votable_14::VOTABLE& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::votable_14::VOTABLE_write (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  VOTABLE_write (::xercesc::XMLFormatTarget& t,
                 const ::votable_14::VOTABLE& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::votable_14::VOTABLE_write (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  VOTABLE_write (::xercesc::DOMDocument& d,
                 const ::votable_14::VOTABLE& s,
                 ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "VOTABLE" &&
        n.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.3")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "VOTABLE",
        "http://www.ivoa.net/xml/VOTable/v1.3");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  VOTABLE_write (const ::votable_14::VOTABLE& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "VOTABLE",
        "http://www.ivoa.net/xml/VOTable/v1.3",
        m, f));

    ::votable_14::VOTABLE_write (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const type& i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const type& i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const type& i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const system& i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const system& i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const system& i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const type1& i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const type1& i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const type1& i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const type2& i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const type2& i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const type2& i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const actuate& i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const actuate& i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const actuate& i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const type3& i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const type3& i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const type3& i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const VOTABLE& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // DESCRIPTION
    //
    if (i.DESCRIPTION ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DESCRIPTION",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *i.DESCRIPTION ();
    }

    // DEFINITIONS
    //
    if (i.DEFINITIONS ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DEFINITIONS",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *i.DEFINITIONS ();
    }

    // COOSYS
    //
    for (VOTABLE::COOSYS_const_iterator
         b (i.COOSYS ().begin ()), n (i.COOSYS ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "COOSYS",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // TIMESYS
    //
    for (VOTABLE::TIMESYS_const_iterator
         b (i.TIMESYS ().begin ()), n (i.TIMESYS ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TIMESYS",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // GROUP
    //
    for (VOTABLE::GROUP_const_iterator
         b (i.GROUP ().begin ()), n (i.GROUP ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "GROUP",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // PARAM
    //
    for (VOTABLE::PARAM_const_iterator
         b (i.PARAM ().begin ()), n (i.PARAM ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PARAM",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // INFO
    //
    for (VOTABLE::INFO_const_iterator
         b (i.INFO ().begin ()), n (i.INFO ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "INFO",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // RESOURCE
    //
    for (VOTABLE::RESOURCE_const_iterator
         b (i.RESOURCE ().begin ()), n (i.RESOURCE ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RESOURCE",
          "http://www.ivoa.net/xml/VOTable/v1.3",
          e));

      s << *b;
    }

    // ID
    //
    if (i.ID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ID",
          e));

      a << *i.ID ();
    }

    // version
    //
    if (i.version ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "version",
          e));

      a << *i.version ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const version& i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const version& i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const version& i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

