\documentstyle[11pt,twoside]{article}
\setcounter{tocdepth}{2}
\pagestyle{myheadings}

%--------------------------------------------------------------------------
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocnumber}    {141.2}
\newcommand{\stardocauthors}   {Alan J. Penny}
\newcommand{\stardocdate}      {1995 December 6}
\newcommand{\stardoctitle}     {{\sman STARMAN} \\[10.0ex]
                                {\Huge \bf A Stellar Photometry and \\
                                Image/Table Handling Package \\[2.5ex]
                                Version 2.0}}
\font\sman=cmr17 scaled 4300
%--------------------------------------------------------------------------

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markright{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}


%------------------------------------------------------------------------------


\newcommand{\routine}[3]
{\hbadness=10000
  \vbox
  {
    \rule{\textwidth}{0.3mm}\\
    {\Large {\bf #1} \hfill #2 \hfill {\bf #1}}\\
    \setlength{\oldspacing}{\topsep}
    \setlength{\topsep}{0.3ex}
    \begin{description}
      #3
    \end{description}
    \setlength{\topsep}{\oldspacing}
  }
}


%------------------------------------------------------------------------------

\newcommand{\starman}{{\it Starman}\hspace{1.0ex}}
\newcommand{\undersc}{{\_}\hspace{0.2ex}}
\pagenumbering{arabic}
\newcommand{\ajhsect}[2]{ \markboth
      { $ \:\:\:\:\:\: \bullet \:\: $ #1 $ \:\: \cdot \:\: $ #2
        \hfill SUN/\stardocnumber}
      { SUN/\stardocnumber \hfill #2 $ \:\: \cdot \:\: $ #1 $ \:\: \bullet
        \:\:\:\:\:\: $ }
                          }
\newcommand{\ajpbox}[1]{\rule{0mm}{6.5mm}\fbox{\framebox[21mm][l]{
\rule[-0.6mm]{0mm}{3.0mm}#1}}}
\newcommand{\ajpbboxa}{\rule{0mm}{6.5mm}\fbox{\framebox[21mm][l]{
\rule[-0.6mm]{0mm}{3.0mm}image}} \newline
                       \rule{0mm}{6.5mm}\fbox{\framebox[21mm][l]{
\rule[-0.6mm]{0mm}{3.0mm}im\_get\_disp}}}
\newcommand{\ajpbboxb}{\vspace*{-2mm}\fbox{\fbox{\parbox[t]{19mm}{
                                   \hspace*{0.2mm}\fbox{WAITING} \newline
                                   \hspace*{4mm}HELP }}}}

%------------------------------------------------------------------------------

\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}

\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-4.45pt}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

\newcommand{\sstdescription}[1]{\item[Description:] #1}

\newcommand{\sstusage}[1]{\item[Usage:] \mbox{} \\[1.3ex] {\ssttt #1}}

\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

\newcommand{\sstresparameters}[1]{
   \item[Results Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

\newcommand{\sstgraphparameters}[1]{
   \item[Graphics-style Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

\newcommand{\sstsubsection}[1]{\item[{#1}] \mbox{} \\}

\newcommand{\sstexamplesubsection}[1]{\item[{\ssttt #1}] \mbox{} \\}

\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.0em}:}]
 \mbox{} \\[1.3ex] #2}

\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

\newcommand{\sstitem}{\item}

%------------------------------------------------------------------------------

\begin{document}
\thispagestyle{empty}

CCLRC / {\sc Rutherford Appleton Laboratory} \hfill {\bf \stardocname}\\
{\large Particle Physics \& Astronomy Research Council}\\
{\large Starlink Project}\\
{\large \stardoccategory\ \stardocnumber}
\begin{flushright}
\stardocauthors\\
\stardocdate
\end{flushright}
\vspace{-4mm}
\rule{\textwidth}{0.5mm}
\vspace{5mm}
\begin{center}
{\stardoctitle }
\end{center}

\begin{center}
\begin{picture}(160,90)
\put(-3,-10){\special{psfile=sun141_cover.ps}}
\end {picture}
\end{center}

\clearpage

\phantom{aa}

\newpage

\vspace{-1.5mm}
\begin{center}
{\LARGE \bf Starman } \\
{ \vspace*{2mm} \Large \bf A Stellar Photometry } \\
{ \vspace*{2mm} \Large \bf and Image and Table Handling Package } \\
{ \vspace*{4mm} \large \bf Version 2.0  }
\end{center}

{\vspace*{-3mm} \large \bf General \vspace*{-1mm} }


\vspace*{0.2mm}
\starman is a stellar photometry package designed for the reduction of data
from imaging systems. Its main components are:- crowded-field photometry
programs; aperture photometry programs; a star finding program; a CCD
reduction program.

Image and table handling are served by a large number of programs which have a
general use in photometry and other types of work.

The package is a coherent whole, for use in the entire process of stellar
photometry from raw images to the final standard-system magnitudes and
their plotting as colour-magnitude and colour-colour diagrams.


{\vspace*{1mm} \large \bf Stellar Photometry Programs \vspace*{-1mm} }

\hspace*{3ex} \begin{tabular}{lp{5.5in}}
- & Converter of raw CCD images to calibrated ones. \\
- & `Dust-ring' flat-field dealer. \\
- & Star position finder. \\
- & Stellar profile determiner. \\
- & Crowded-field, and also simple, stellar photometry measurers. \\
- & Averager of photometry estimates from different images. \\
- & Colour-magnitude and colour-colour diagram plotters. \\
- & Adder of `fake' stars to an image. \\
- & Automatic aperture photometry for all bright well isolated stars. \\
\end{tabular}

{\vspace*{1mm} \large \bf Image Handling Programs \vspace*{-1mm} }

\hspace*{3ex} \begin{tabular}{lp{5.5in}}
- & Image display. \\
- & Interactive image work. {\it Display:} {\it Inspection:}
    zoom/pan, pixel value, `slice', solid-body plots, colour,
    crowded-field stellar photometry output, etc.;
    {\it Measurement:} interactive aperture photometry, interactive
    position file making, etc.; {\it Manipulation:} maths, rotation,
    weeding, etc.; {\it `GUI'-like interaction}. \\
- & Extensive general programs: Maths, joining, cutting, reading, etc.. \\
\end{tabular}

{\vspace*{1mm} \large \bf Table Handling Programs \vspace*{-1mm} }

\hspace*{3ex} \begin{tabular}{lp{5.5in}}
- & Spread-sheet, Calculator. \\
- & Input, Output, Listing. \\
- & Graphical Plot, Star Chart. \\
- & Joining. \\
- & Extensive general programs: sort, weed, statistics,
    matching, position transforming, etc.. \\
\end{tabular}


{\vspace*{1mm} \large \bf Not an Acronym \vspace*{-1mm} }

\vspace*{0.2mm}
`Starman' is not an acronym, and so should only have the first letter of
its name in capitals.


\newpage

\phantom{aa}

\newpage

\tableofcontents
\setlength{\parskip}{\medskipamount}
\markright{\stardocname}

\newpage

\section{Classified List of Programs}
\label{se:class}
\ajhsect{\arabic{section}}{CLASSIFIED LIST}

\subsection{Stellar Photometry Programs}

\label{ap:summary}
\begin{tabular}{ll}
{\bf  Addstars:} &	Add or subtract stars to an image with noise \\
{\bf  Automag:} &	Aperture Photometry on isolated stars and extinction correcting \\
{\bf  Average:} &	Take the average of a number of outputs from MEASURE \\
{\bf  Chi:} &		Put thresholds on the goodness of fit of MEASURE output \\
{\bf  Diagram:} &	Plotsa Colour-Magnitude or Two-Colour diagram \\
{\bf  Dustring:} &      Add or remove 'dustrings' from an image \\
{\bf  Interact:} &      General image display and interaction program \\
                 &      \hspace{2ex} -- Perform interactive aperture photometry \\
                 &      \hspace{2ex} -- Perform interactive Gaussian photometry \\
                 &      \hspace{2ex} -- Zoom, pan, blink\\
                 &      \hspace{2ex} -- Inspect image values, slice, plot,  make hard-copy\\
                 &      \hspace{2ex} -- Set and alter colour Look-Up Table \\
                 &      \hspace{2ex} -- Mark and/or display position lists \\
                 &      \hspace{2ex} -- Scrutinise the output of MEASURE \\
{\bf  Measure:} &	Measure stars in an image \\
{\bf  Profile:} &	Find the mean profile of a number of stars \\
{\bf  Simplemag:} &	Simple aperture or profile photometry on isolated stars \\
{\bf  Sprinkle:} &      Make a table of stars with randomised positions, magnitudes \\
{\bf  Starfind:} &	stars in an image \\
{\bf  Unccd:} &         Process a raw CCD image to remove detector effects \\
\end{tabular}

\subsection{General Image Handling Programs}

\begin{tabular}{ll}
{\bf  Imcalc:} &         Perform mathematical operations on image(s) \\
{\bf  Imcube:} &         Make a 2-D image from a 3-D or 4-D one (real:integer:short) \\
{\bf  Imcut:} &          Make another image (sectioned,binned,inverted) \\
{\bf  Imdes:} &          View:copy:write:delete the descriptors of an image \\
{\bf  Imfits{\undersc}dr:} &      Read simple FITS image from disk \\
{\bf  Imflash:} &        Simple display of image \\
{\bf  Imjoin:} &         Join a number of images together \\
{\bf  Imkey:} &          Insert:change image pixel values from keyboard \\
{\bf  Import:} &         Load descriptors from other packages \\
{\bf  Imrotate:} &       Rotate an image anti-clockwise by 90,180, or 270 degrees \\
{\bf  Imsmooth:} &       Smooth an image \\
{\bf  Imstat:} &         Get statistics of an image \\
{\bf  Imtype:} &         Convert files between (real;integer;16-bit integer) \\
{\bf  Imweed:} &         Set a range of pixel values to Invalid \\
{\bf  }          &       \\
{\bf  Interact:} &      General image display and interaction program \\
{\bf  Tbplot:} &         Plot table graph/histogram - image picture/contour \\
\end{tabular}

\subsection{General Table Handling Programs}

\begin{tabular}{ll}
{\bf  Tbcalc:} &         Calculate table elements \\
{\bf  Tbchart:} &        Plot out a realistic star map \\
{\bf  Tbcomps:} &        Find stars within/not within an annulus of each other \\
{\bf  Tbcut:} &          Cut out parts of a table \\
{\bf  Tbdes:} &          View:write:copy:delete the descriptors of a table \\
{\bf  Tbjoin:} &         Join tables together \\
{\bf  Tbkey:} &          Input numbers from keyboard into a table \\
{\bf  Tblist:} &         Type and/or put in file the contents of a table \\
{\bf  Tbload:} &         Input an ASCII text file into a table \\
\end{tabular}

\begin{tabular}{ll}
{\bf  Tbmatch:} &        Extract entries with matching names in two tables \\
{\bf  Tbnative:} &       Convert table format to native machine style \\
{\bf  Tbnmatch:} &       Put tables in the same order of names \\
{\bf  Tbplot:} &         Plot table graph/histogram - image picture/contour \\
{\bf  Tbpmatch:} &       Extract entries with matching or nonmatching positions
                          in two tables  \\
{\bf  Tbrenum:} &        Renumber names in a table \\
{\bf  Tbsheet:} &        Spread-sheet program for inspection/insertion/etc \\
{\bf  Tbsort:} &         Sort entries in a table \\
{\bf  Tbstat:} &         Perform statistics on column(s) in tables(s) \\
{\bf  Tbtran{\undersc}auto:} &  Transform one XY table to another automatically \\
{\bf  Tbtran{\undersc}do:} & Transform XY table positions using transform eqns \\
{\bf  Tbtran{\undersc}load:} & Calc transform eqn from a given rotn, shift, magn \\
{\bf  Tbtran{\undersc}make:} & Calc transform eqn from two matched XY tables \\
{\bf  Tbvalue:} &        Get a single value out of a table \\
{\bf  Tbweed:} &        Make a table with only those entries with a parameter
                  in a range \\
{\bf  }          &       \\
{\bf  Interact:} &      General image display and interaction program \\
\end{tabular}

\subsection{Help, Gripe and Demonstration Programs/Scripts}
\begin{tabular}{ll}
{\bf  Starmanhelp:}       & Help on the \starman package \\
{\bf  Starmanhyperhelp:}  & Hypertext help on the \starman package \\
{\bf  Starmangripe:}      & Comment/complain/etc on the \starman package \\
{\bf  Starmanhypergripe:} & Hypertext comment/complain/etc on the \starman package \\
{\bf  Starmandemo:}       & Four demonstrations of the \starman package \\
\end{tabular}

\subsection{Additional Programs}
\label{se:addi}

The KAPPA package has general purpose image processing programs,
and these are useful. [Remember that KAPPA can mainly only deal with
32-bit 'real' images.]

 In the KAPPA set of programs, these are quite useful:-

\begin{tabular}{ll}
{\bf  Fitsin:} &          Read data off tape device to disk NDF file \\
{\bf  Fitsout:} &         Put data onto tape device from disk NDF file \\
{\bf  Fitsdout:} &        Put data from disk NDF file onto disk FITS file \\
\end{tabular}

\newpage

\section{Introduction}
\ajhsect{\arabic{section}}{INTRODUCTION}

\starman has been constructed as a package of programs to aid the reduction of
globular-cluster stellar photometry. After the programs that deal with the
actual measuring of star magnitudes were written, it became apparent that it
was necessary to have a large number of other programs to support those core
programs, if actual astronomy was to be done. Thus the package has became
capable of dealing with many of the diverse problems that occur when
performing stellar photometry on images. For this reason, it has became
worth releasing to the community as a general purpose stellar-photometry
tool.

In the `support' component of the \starman package, there are a number of
general purpose programs for image and table handling and for display.
These are thus useful in other, non-stellar-photometry, astronomical data
reduction studies.

\subsection{Running the Programs }

Each of the programs in \starman can be run simply in the user's
normal C Shell. Scripts can be written to combine programs or to
run them repeatedly.

You can also run the programs from inside the Starlink ICL environment.

The programs have been written in the Starlink {\bf ADAM} Environment. This
has the advantage that there are a number of useful programs in the {\bf
KAPPA} packages which supplement \starman, and that some of the \starman
programs in turn are useful for current users of such packages.

Particularly, the standard data format NDF is used. (You can see
this as all data files have the '.sdf' suffixes.)

Users wishing to know more about the {\bf ADAM} Environment and the
{\bf KAPPA} programs should read the relevant documents
SG~4 and SUN~95.













\section { Photometry}
\ajhsect{\arabic{section}}{PHOTOMETRY }


\subsection{Learning to Do Photometry}

The \starman package provides the tools for doing stellar photometry.
However the user will also need some expertise in doing photometry if she is
to use the tools properly. The amount of expertise one needs to do such
photometry depends on the accuracy desired and the precise type of
photometry being done. \starman provides the {\it tools\/} for photometry,
but cannot provide the {\it expertise}. There is a later section of this
guide which lists some reading that might be useful for novices in
photometry.

\subsection{Crowded-field Stellar Photometry and Further Reading}


No help available yet, sorry.

\subsection{`Classical' Photo-electric Photometry}

There is a major photometry mode, that of the `Classical' Photo-Electric
photometry mode (with data either from P-E photometers or CCDs). This mode
is one where a (possibly large) number of individual magnitude estimates
are made during a night, each of a single star, scattered over the sky, and
it is desired to reduce them to a standard-magnitude system. \starman cannot
deal efficiently with  reducing magnitudes made in this mode.

There is the \starman program AUTOMAG which is designed to take CCD
images and do part of this work, looking up standard magnitudes and allowing
for extinction. However the output from that program needs extensive
further work, such as allowing for errors in the night's extinction,
allowing for colour, time, and/or azimuth dependent extinction, determining
colour equations. If there is only a limited amount of such data, this
further work can be done by hand. If a large amount has to be reduced, then
special purpose programs need to be written by the user.




\newpage

\section{Run Through}
\label{se:run_through}
\ajhsect{\arabic{section}}{RUN THROUGH}

On this and the following three pages is an annotated example of a \starman
session invocated from the command line. On the facing pages are
explanations and commentary associated with each annotation.


{\small
\begin{enumerate}

\item To run any \starman program, you must have loaded the `Starman' system.
The `Starman' command does this.  You can still use shell commands
in this mode.

\item Let's run a \starman application.  IMCUT cuts a section out of an
image.

\item The input image is profile{\undersc}in.sdf in the sub-directory
\$STARMAN{\undersc}DATA (whose logical name was set up in the Starlink login).
You must omit the `.SDF' qualifier.  The image is a standard \starman ADAM
.SDF image. These have either `real' 32-bit real values, or `short' 16-bit
integer values, and can have the `BSCALE' and `BZERO' values, and
`magic pixel values' indicating `bad' pixels.

\item The program now asks for the X range of pixels to be cut out,
and give the default start and end value. A question mark to any
\starman request will bring the help on that request, as it does here.

\item The request is now repeated, and you take the default, the whole
X range.

\item Now you are asked for the Y range. You want to select the range
from 21 to 200. You enter 21. As you have put in only
one parameter, and two are asked for, the second parameter is
taken as the default value shown, in this case 200.

\item A request on how much to bin the output image. You tell it to
      bin by a factor of x1 in X and x2 in Y.

\item How to make the average of the box. You choose one of the two
      possible character strings `average' or `sample'. By just doing
      `return' you accept the default `average'.

\item This is asks whether set `invalid' if any `invalid'.
      Many questions will be in this `logical' mode, where the
      acceptable answers are `yes', or `no'.

\item The name of the new file to contain the output image is requested.
      Do not include the `.sdf' qualifier. Never use the name of an
      existing file, the programs do not deal with version numbers
      of files.

\item All images have a `TITLE' header, which can be used to contain
      some information and the image.

\item You decide to do another `imcut'

\item But you change your mind. At any request by any program for input,
      if you type `!!', the program ends, loosing any output.

\item If a program ends in a non-normal way, you sometimes get a rather
      strange ADAM error message. You can generally ignore these.

\item Now let's run look at the new image. IMFLASH displays the image with
      a high contrast around the `sky' level. Notice that the parameters
      qualifying IMFLASH are located on the command line, separated by spaces.
      Up to eight such parameters can be input on the command line. Parameter
      values on the command line are not subsequently prompted for by the
      application. Note also that the name of the image, `fred', has no parameter
      name in front of it. A later section of the manual will describe when the
      parameter name may be omitted. The display device will be the X window
      that user is using.

\item The program displays the image on your screen.
      As you can see, the binning has `squished' the image in the Y direction.
      The program also types out some information about the image and its
      display.

\item Press `return' when you have seen enough. The image now disappears.
      (To keep the image displayed, leave the program running, and open
       another UNIX window to run a fresh \starman session to do your
       work in.)

\end{enumerate}
}

\newpage

{\footnotesize
\begin{quote}
\begin{tabbing} % Not clear why this is needed, but leading spaces get
                % lost otherwise.
\verb#> starman                                                                    # \fbox{1}\\
\verb#                                                                        #\\
\verb#  ____________________________________________________________________  #\\
\verb# |  Starman - Stellar Photometry               Version 2.0    Nov 94  | #\\
\verb# |            Image and Table Handling                                | #\\
\verb# |                                                                    | #\\
\verb# |1) Help:                         starmanhyperhelp / starmanhelp     | #\\
\verb# |2) Advice/Bug Reports:           starmanhypergripe / starmangripe   | #\\
\verb# |                                   - or - mail alan.penny@rl.ac.uk  | #\\
\verb# |3) Prompts in programs:          ? or ?? for help : !! to exit      | #\\
\verb# |4) Default data for a prompt:    $STARMAN_DATA/progam_parameter     | #\\
\verb# |                                    e.g. $STARMAN_DATA/measure_in   | #\\
\verb# |5) Demonstration:                starmandemo                        | #\\
\verb# |                                                                    | #\\
\verb# |All rights reserved. Starlink copyright and disclaimer notices apply| #\\
\verb#  --------------------------------------------------------------------  #\\
\verb#                                                             #\\
\verb#>imcut                                                                       # \fbox{2}\\
\verb#IN - Input image /!/ > $STARMAN_DATA/profile_in                              # \fbox{3}\\
\verb#XRANGE - X range to cut out /[1,200]/ > ?                                    # \fbox{4}\\
\verb#  Imcut                                                      # \\
\verb#                                                             # \\
\verb#     Parameters                                              # \\
\verb#                                                             # \\
\verb#        Xrange                                               # \\
\verb#                                                             # \\
\verb#          (Default - 1,input image X size     Range - 1 to input image X size)  # \\
\verb#                                                             # \\
\verb#          X start and X end of the area of image to cut out and put in new image.     # \\
\verb#          If the X end is smaller than the X start, then the output image is # \\
\verb#          inverted in X.                                     # \\
\verb#                                                             # \\
\verb#XRANGE - X range to cut out /[1,200]/ >                                      # \fbox{5}\\
\verb#YRANGE - Y range to cut out /[1,200]/ > 21,180                               # \fbox{6}\\
\verb#BIN - XY size of box for binning of pixels /[1,1]/ > 1,2                     # \fbox{7}\\
\verb#SAMPLE - BLH pixel or average of binning box? (sample:average) /'average'/ > # \fbox{8}\\
\verb#CHECK - If any box pixel invalid, output invalid? (yes:no) /NO/ >            # \fbox{9}\\
\verb#OUT - Output image /!/ > fred                                               # \fbox{10}\\
\verb#TITLE - Title to add to output image /'Profile_in'/ > fred title            # \fbox{11}\\
\verb#>                                                           #\\
\verb#                                                            #\\
\verb#>imcut                                                                      # \fbox{12}\\
\verb#IN - Input image /!/ > !!                                                   # \fbox{13}\\
\verb#!! Application exit status Status value:148013867                           # \fbox{14}\\
\verb#>                                                            #\\
\verb#                                                             #\\
\verb#>imflash fred                                                               # \fbox{15}\\
\verb#Title is: A trial run of Starman                                            # \fbox{16}\\
\verb#Display values: Min =   3322.042  Max = 2420,425                           #\\
\verb#Size = 200 by 90                                                           #\\
\verb#ENOUGH/yes/:=                                                               # \fbox{17}\\
\verb#>                                                            #\\
\end{tabbing}
\end{quote}
}

\newpage


{\small
\begin{enumerate}
\setcounter{enumi}{17}

\item Now let's look more closely at the `profile{\undersc}in' image.
      Note that the name of the image to work with for now is
      input on the command line.

\item Select the suggested option of the standard way of inputting an
      image.

\item The image is displayed, some details typed out, and a window with
      a `panel' of control buttons and a window with help in it are
      displayed.

\item Control is now transferred to the panel, with the keyboard only
      being used to input information from time to time. When control has
      to be shifted between the keyboard, the panel, and the image, it is
      sometimes necessary to click on those areas to shift attention to
      them before they can be used. We shall now have a short trip round
      a few of the extensive capabilities of `Interact'.

      (`LHB' = click left-hand button on cursor when the
        cursor is placed at the  appropriate place. `MHB' = middle, `RHB'
        = right-hand button. `click' = press and release)

      \begin{tabular}{p{1.2in}p{4.3in}}
        \underline{Action} & \underline{Further Action/Result} \\
        LHB on `Zoom'    & Move cursor round image and watch the panel
                           display the pixel values. Place cursor in image
                           centre and click twice (slight pause between
                           clicks) the cursor middle
                           button. The image should zoom up by x2. Click
                           once on cursor right-hand button to return to
                           panel control. \\
        LHB on `HELP'    & The `help' for these buttons is typed out. Press
                           carriage return on the keyboard a number of times,
                           until control is returned to the panel. \\
        LHB on `Colour'  & Panel for affecting colour display appears. \\
        LHB on `Load'    & Load a new Look-Up Table, by replying `4' on
                           keyboard when asked `LUTNUM/1/:='. \\
        LHB on `Scale'   & Hold cursor left-hand button down and move about image.
                           See how the LUT changes. Release button. \\
        LHB on `Load'    & Load the origional Look-Up Table, by replying `1' on
                           keyboard when asked `LUTNUM/1/:='. \\
        LHB on `RETURN'  & Go back to `Interact' panel buttons. \\
        LHB on `Aperture' & `Aperture' buttons loaded. This enables the
                             aperture photometry options. You first have to
                             choose whether `annulus' or `separate'
                             measuring mode. Choose the default with a
                             carriage return to the keyboard question
                             `METHOD/annulus/:='. Move the cursor to the
                             screen, and shrink the `star' aperture by
                             clicking the left-hand cursor button. Accept
                             the new size by clicking the right-hand button.
                             Accept the present inner and outer radii of
                             the sky annulus by clicking the right-hand
                             button twice. Then LHB on `Measure' to select
                             the option of measuring. Move the cursor to
                             a star in the image. Click the cursor left-hand
                             button and see the measurement put out
                             on the keyboard window. Click the cursor
                             right-hand button to return to the panel. \\
           LHB on `RETURN' & Return to `Interact' buttons. The program
                             will then ask you if you want to store the
                             measurement in a file. As you do not, you
                             reply `no' on the keyboard. \\
           LHB on `EXIT'   & Exit from the program. \\
      \end{tabular}


\end{enumerate}
}

\newpage


{\footnotesize

\begin{quote}
\begin{tabbing} % Not clear why this is needed, but leading spaces get
                % lost otherwise.
\verb#>interact $STARMAN_DATA/profile_in                                         # \fbox{18}\\
\verb#EASYSTART - Use the standard start sequence of operations? /YES/ >         # \fbox{19}\\
\verb# Title is: Profile_in                                                      # \fbox{20}\\
\verb# Display values: Min = 1531.723  Max = 528.4710         # \\
\verb# Size = 200x200  :  Type = SHORT                        # \\
\verb#                                                                     # \fbox{21} -- \fbox{25}\\
\end{tabbing}
\end{quote}

\vspace*{-2mm}\begin{center}
\begin{tabular}{||p{25mm}p{50mm}||}\hline \hline
\multicolumn{2}{||c||}{Interact -- Main} \\ \hline
{\bf FUNCTION} & \ajpbox{display} \\
\ajpbox{aperture} & \ajpbox{flash} \\
\ajpbox{colour} & \ajpbox{open} \\
\ajpbox{inspect} & \ajpbox{reset} \\
\ajpbox{fit\_magn} & \ajpbox{zoom} \\
\ajpbox{positions} & {\bf CONTROL} \\
\ajpbox{scrutiny} & \ajpbox{panel} \\
\rule{0mm}{6.5mm}{\bf IMAGE}             & \ajpbox{exit} \\
\ajpbboxa & \ajpbboxb \\
\rule{0mm}{6.5mm}{\bf DISPLAY}           & \\
\ajpbox{area} & \\
\ajpbox{clear} & \\
\ajpbox{close} & \\
\ajpbox{compress} & \\
\ajpbox{cvalues} & \\ \hline \hline
\end{tabular}
\end{center}

\vspace*{0.2mm}\hspace*{12mm}\fbox{\fbox{
\parbox[t]{120mm}{\hspace*{20mm}Help for Interact -- Main \newline
\vspace*{-4mm}\hspace*{-2mm}\rule[4mm]{122mm}{0.2mm} \newline
\vspace*{-4mm}\hspace*{-2mm}\rule{122mm}{0.2mm} \newline
\hspace*{-2mm}\rule[4mm]{122mm}{0.2mm}\newline
To execute a choice, click mouse with pointer in the panel button. \newline
To return from a choice, generally, click on mouse right-hand button. \newline
For guide to options displayed on buttons, click on HELP panel button. \newline
For help on individual options, position pointer on button, and a  \newline
short help will automatically appear in the Panel Help window. \newline
(Usually cursor has to be in a relevant, ACTIVE, window.)
}}}
}

\newpage

\section{A Photometry Run-through}
\ajhsect{\arabic{section}}{A Photometry Run-through}

 The first goal of \starman is to provide tools for performing stellar
 photometry on images. To give an introduction on how to use these tools,
 a list is given below of a basic run through of how to get from the
 data on tape to the output astronomy.

 \begin{enumerate}

 \item IMFITS{\undersc}DR \newline
       Read the data from a FITS disk file into \starman format files.

 \item UNCCD \newline
       Process your raw image into one without CCD effects.

 \item INTERACT \newline    Make a table of the (X,Y) positions of about six bright
                isolated stars.

 \item PROFILE \newline    Use those stars to define the mean star profile.

 \item STARFIND (+INTERACT) or just INTERACT \newline
        Make a table of the (X,Y) positions of all the stars in the image
        you want to measure, and also all the stars that
        affect them. If you are measuring stars on a series
        of exposures to the same field, you should first make a
        'deep' exposure by adding all the exposures together
        with IMJOIN, and then marking the positions on that.
        This will enable you to mark the very faintest stars.
        Wether it is worth the effort if you have to align the
        images first is another matter.

 \item MEASURE   \newline Do the fitting, using the profile and star position
                list already made.

 \item INTERACT    \newline Have a look at the cleaned image and/or the places
          stars fitted etc, to do a quality control check
          You may at this stage wish to go back a number of steps.

 \item  CHI \newline Take the magnitude list output of MEASURE and define
                the Chi-squared values for an acceptable fit.

 \item AVERAGE     \newline Average all acceptable fits from several different
                exposures measured using the same star list.

 \item DIAGRAM  \newline   Combine the magnitudes to make a colour-magnitude
                or colour-colour diagram.

 \item AUTOMAG \newline Perform automatic aperture photometry on the images
               with the standard stars, and correct for atmospheric
               extinction.

\end{enumerate}


\newpage


\section{Demonstration}
\label{se:demo}
\ajhsect{\arabic{section}}{DEMONSTRATION}


  There is one main demonstration program, `starmandemo'. This
  is actually a script which has four options for automatically
  running through a simple series of Starman programs. This is
  decribed below.

  One can also write your own shell scripts to do this in the
  C Shell, or in the ICL system. This is decribed below.

\subsection{Starmandemo}


  Runs four demonstrations:-

 \begin{enumerate}
 \item Runs from a test data image to mag list

  This script will take an image of a star field
  and automatically find the stars, measure their PSFs, and measure
  the stars.

 The image is in file \$STARMAN\_DATA/stars\_v.sdf. This is copied
  into the present directory.


 \item Runs from 2 test data images to CMD diagram

  This script will take two images (non-aligned) of a star field
  and automatically find the stars, work out the transformation
  between the images, measure their PSFs, measure the stars, and
  display a colour/magnitude diagram.

  The two images are in files \$STARMAN\_DATA/stars\_v.sdf  and
  \newline
   \$STARMAN\_DATA/stars\_r\_rotated.sdf. These are copied into
  the present directory.

 \item Runs from a user image to mag list

  This script will take an image of a star field
  and automatically find the stars, measure their PSFs, and measure
  the stars.

 \item Runs from 2 user images to CMD diagram

  This script will take two images (non-aligned) of a star field
  and automatically find the stars, work out the transformation
  between the images, measure their PSFs, measure the stars, and
  display a colour/magnitude diagram.


 \end{enumerate}


\subsection{Starman C Shell Scripts}

For {\it starman}, the C shell is used. So one can write scripts to perform
a sequence of \starman commands.

As an example of a script, we can make a file called \verb|doit_starman|.
which will measure the stars in an image.

\begin{verbatim}

#!/bin/csh

############################################
# DOIT_STARMAN
#  Runs through Starman from image to measures
#
#   alan penny             ral          1994 Nov

alias echo 'echo > /dev/null'
  setenv STARMAN_DIR  /home/user1/ajp/snew1
  alias starman source $STARMAN_DIR/starman
  starman
unalias echo


if ( $1 == "" ) then
echo "Input image name"
set file1 = $<
else
set file1 = $1
endif

echo " "
echo "STARTING - doing starfind - to find all stars"
echo " "

 starfind $file1 radius=2 out=temp_xy_1 \\

echo " "
echo "DONE STARFIND - doing tbsort - to sort with bright ones first"
echo " "

 tbsort temp_xy_1 numcol=3 option='descending' out=temp_xy_1_a \\

echo " "
echo "DONE TBSORT - doing tbcut - to get brightest stars"
echo " "

 tbcut temp_xy_1_a col_1=\[1,6\] row_1=\[1,8\] out=temp_xy_1_b \\

echo " "
echo "DONE TBCUT - doing profile - to determine stellar point-spread-function"
echo " "

 profile $file1 instars=temp_xy_1_b mode='auto' outprof=prof_$file1 \\

echo " "
echo "DONE PROFILE - doing measure - to measure magnitudes of all stars"
echo " "

 measure $file1 instars=temp_xy_1_a profile=prof_$file1 out=mag_$file1 \
         outim=clean_$file1 \\


\end{verbatim}

\subsection{Starman ICL Scripts}

{\small ICL} scripts may be run in the normal way for {\it Starman}.



\section{Getting started}
\ajhsect{\arabic{section}}{GETTING STARTED}

\subsection{Quotas}

Simple programs in \starman run correctly with normal the normal quotas
set for you by your Starlink node manager.

\subsection{Setting Up Starman}

  {\bf \hspace*{2ex} Setting up your system to be able to use Starman.}

On Starlink machines, when Starman has been set up by the system
manager, just type `starman'.  You will need to have set up the
Starlink software with {\tt `source /star/etc/login'} in your {\tt
\$HOME/.login} file and {\tt `source /star/etc/cshrc'} in your {\tt
\$HOME/.cshrc} file.

On other machines, find where the Starman programs are, and run the
shell script 'starman', for example:-

      \verb# source /home/user1/ajp/snew1/starman #

\subsection{Running Starman}

To run \starman from the shell just enter the command

\begin{verbatim}
     > starman
\end{verbatim}

This executes a procedure which you stay in while executing \starman
commands. It also defines some logical names. You now can mix \starman
commands with the familiar {\small Unix } ones.  While setting up the
names, some information about the current version is given out.

You can now run the \starman programs by just typing their names.

So what do you get for your trouble?  Section~\ref{se:class} gave a
classified list of the programs available. These are explained in more
detail in Sections~\ref{se:progs}, \ref{se:progim}, and
\ref{se:progtb}.

\subsection{Issuing Commands}

To run an application you then can just give its name---you will be
prompted for any required parameters. Alternatively, you may enter
parameter values on the command line specified by position or by
keyword.  More on this in Section~\ref{se:param}.

Remember that Unix is case sensitive, so keep the names in lower case.

\subsection{Answering Questions}

{\bf \hspace*{2ex} Answering questions on the keyboard}

    When running a program, it will generally ask you a series of
    questions. These will come either as simple questions or as
    questions with default choices.

    An example of a simple question is (say), when the program wants
    the name of an input image. You will see appear on the screen
    something like:-

\begin{verbatim}
      IN -  Input image file name? /!/ > \end{verbatim}

    You should then type the name of file containing the image.  If you
    just press `return', then the program will take this as the same as
    entering a `blank'. Such an input will have the effect that the
    particular stage of the program desires.  Thus, for eaxmple, it may
    decide that you dont want any input image. Or it may decide that,
    to continue, it needs this name, and this case may either ask you
    again or it may just stop.


    An example of a question with a default, is when the program wants
    you to tell which of a list of options you want it do next.  It may
    have some idea of what you likely reponse should be, or it may just
    guess (probably incorrectly). In this case, you will see something
    like:-

\begin{verbatim}
      OPTION - Which action to perform? /'image/' > \end{verbatim}

    In this case, again you would type in the name of the option you
    want it to perform. However it is suggesting (correctly or
    incorrectly) that you should want the `image' option. In this case,
    if you press `return', then it assumes that the this is the same as
    if you have typed `image', and will go and perform the image
    option. This suggestion is referred to as the `default' in the rest
    of the Starman help system.

\subsection{Obtaining Help}

The \starman help system may be entered either whilst you are not
running a program, or whilst you are running a program and inputting a
parameter value.

When you are not actually running a program, then an introduction to
\starman can be obtained in hypertext with

\begin{verbatim}
     >starmanhyperhelp \end{verbatim}

or in line mode with

\begin{verbatim}
     > starmanhelp \end{verbatim}

This puts you in the top level of the \starman help and you can explore
all the sub-topics. There is a sub-topic for each program and then more
general helps:-

\begin{tabular}[c]{ll} \hspace{4ex}  Author  & Information on the
Starman author \\ \hspace{4ex}  Guide   & A short run-through on using
Starman \\ \hspace{4ex}  Help    & More information on the HELP system
\\ \hspace{4ex}  Images  & Information on Images \\ \hspace{4ex}
Menu    & A list of programs with a one line description \\
\hspace{4ex}  Starman & General information on the Starman package \\
\hspace{4ex}  Tables  & Information on Tables \\ \end{tabular}

When you are inside a program, the help system is available every time
you are asked by \starman for a parameter. Then by replying with a
question mark, you get the help on that particular parameter.

\begin{verbatim}
     IN -  Input image file name? /!/ > ?  \end{verbatim}

If you want more general help on the program you are running, then
respond to the parameter query with:-

\begin{verbatim}
     IN -  Input image file name? /!/ > ??  \end{verbatim}

which gets into the general \starman help.

\subsection{Upper and lower case}

 Generally, Starman does not mind if your typed in input is in upper
 and/or lower case.

 Of course, in UNIX, file names are case sensitive, and so the
 directory names, such as {\$}STARMAN{\undersc}DATA, also are case
 sensitive.

 However, some times you are asked for text input, for example the
 `title' to add to an image. The case of the characters is then
 preserved.

\subsection{Exiting a Program }

If you are inside a \starman program and wish to stop running it, then
if you are putting in a parameter, just put in two exclamation marks
(!!). If the program is running by itself either press the {\tt CTRL}
and {\tt C} buttons or the {\tt CTRL} and {\tt Z} ones.

If you have finished using \starman altogether, you need take no
action, unless you are in ICL, in which case type

\begin{verbatim}
     ICL> exit \end{verbatim}

which returns you to the shell.





\section{Examples} \ajhsect{\arabic{section}}{Examples}

  This has examples of running programs.

\vspace*{2mm}{\bf \hspace*{2ex}  Program name }\vspace*{2mm}

 You run a program by typing its name on the command line:-

\begin{verbatim}
     tblist \end{verbatim}

 The program then asks you for various parameters.

\vspace*{2mm}{\bf \hspace*{2ex}    Parameter name }\vspace*{2mm}

 You can also put some of the parameters on the command line:-

\begin{verbatim}
     tblist in=$STARMAN_DATA/tblist_in \end{verbatim}

 There must be no gaps between the parameter name and the `equals'
 sign, or between the `equals' sign and the value.

 Those parameters which are not specified on the command line, are
 asked for in the normal way when the program runs.

\vspace*{2mm}{\bf \hspace*{2ex}    Parameter position }\vspace*{2mm}

 Often the command line can take the parameters in order, without
 having to specify their name. Thus:-

\begin{verbatim}
     tblist in=$STARMAN_DATA/tblist_in \end{verbatim}

 is equivalent to:-

\begin{verbatim}
     tblist $STARMAN_DATA/tblist_in \end{verbatim}

\vspace*{2mm}{\bf \hspace*{2ex}    `in' and `out' parameters
}\vspace*{2mm}

 In most programs, there is a single `input' file and a single `output'
 file. These are then the first two parameters of a program. Thus:-

\begin{verbatim}
    imcut in=$STARMAN_DATA/imcut_in out=fred \end{verbatim}

 is equivalent to:-

\begin{verbatim}
    imcut $STARMAN_DATA/imcut_in fred \end{verbatim}

\vspace*{2mm}{\bf \hspace*{2ex}     Multi-variable parameter
}\vspace*{2mm}

 If a parameter has more than value, then these can be put in, grouped
 inside square brackets:-

\begin{verbatim}
    imcut in=$STARMAN_DATA/imcut_in xrange=\[40,60\] \end{verbatim}

\vspace*{2mm}{\bf \hspace*{2ex}     More than one line }\vspace*{2mm}

 You can also put some of the parameters on subsequent command lines:-

\begin{verbatim}
    imcut in=$STARMAN_DATA/imcut_in \
          xrange=\[40,60\]
\end{verbatim}

\vspace*{2mm}{\bf \hspace*{2ex}     Default values }\vspace*{2mm}

 For default values, one can put an entry on the command line:-

\begin{verbatim}
    imcut in=$STARMAN_DATA/imcut_in title=\\ \end{verbatim}

\vspace*{2mm}{\bf \hspace*{2ex}     Default remaining parameters
}\vspace*{2mm}

 You can also put some of the parameters on the command line and tell
 it to take the default values for all other parameters:-

\begin{verbatim}
    tblist in=$STARMAN_DATA/tblist_in \\ \end{verbatim}

 If a parameter does not have a default, then you are asked for the
 value when the program runs.

\vspace*{2mm}{\bf \hspace*{2ex}     Image sub-areas }\vspace*{2mm}

 For images, you can define a sub-area on the command line:-

\begin{verbatim}
    imflash in=$STARMAN_DATA/imflash_in\(1:100,1:100\) \end{verbatim}

 where this selects the b.l.h. 100x100 of the 300x300 image.

 There are different types of specifying a sub-area of the 300x300
 image:-

\begin{verbatim}
                               X range covered   Y range covered
    imflash_in\(1:100,1:100\)      1 - 100           1 - 100
    imflash_in\(1:100,\)           1 - 100           1 - 300
    imflash_in\(100~50,\)         75 - 124           1 - 300
    imflash_in\(~50,\)           125 - 174           1 - 300
\end{verbatim}

\vspace*{2mm}{\bf \hspace*{2ex}     Character strings }\vspace*{2mm}

 For character strings, one can put entries on the command line within
 quotations marks:-

\begin{verbatim}
    imcut in=$STARMAN_DATA/imcut_in title=\"Test output\"
\end{verbatim}





\section{Help} \ajhsect{\arabic{section}}{Help}


  Here there is on-line help on the :-

\begin{list}{{-}}{} \item Starman in general under `Starman'.  \item
Starman suite in 'guide' \item Individual programs under their names
\item Image system under 'images'.  \item Table system under 'tables'.
\item A list of programs is in 'menu'.  \end{list}

If lost, read the Starman manual SUN141 and other Starlink manuals.

Outside a program, type 'starmanhelp' to access the help system, and
  'starmanbrowse' to access the hypertext help system.


  Inside a program you can access the help when asked for a  parameter
  - replying with a '?' will get you help on that parameter, and
  replying with a '??' will get you into the general help system, at
  the point of that parameter, from where you can go back up the  help
  system and down to any desired point.


When you put the cursor over a push-button when using a panel, then
help for that button is automatically displayed in a separate 'help'
window. An example of this is the help window when starting aperture
photometry in the \verb|interact| program.






\section{Parameters} \label{se:param}
\ajhsect{\arabic{section}}{PARAMETERS}

\starman is a command-driven package.  Thus to run the program
\verb|imcut|, you  type `\verb|imcut|'. Commands in their turn have
{\em parameters\/} by which you can qualify their behaviour. Thus to
tell the \verb|imcut| program that you want the first 50 pixels in X
cut out, you have to set the \verb|imcut| parameter \verb|xrange| to
`1,50'. The values of parameters are obtained by the programs in one of
seven ways:-

\begin{tabular}{ll}
\hspace{4ex} 1) & By your responses to a prompt \\
\hspace{4ex} 2) & When you supply them on the command line when starting
		  the program \\
\hspace{4ex} 3) & When there is a `$\backslash\backslash$' on the
                  command line \\
\hspace{4ex} 4) & From `hidden' values \\
\hspace{4ex} 5) & By using the `Advanced Interfacing' described in
                  Section~\ref{se:advance} \\
\hspace{4ex} 6) & By making a new .ifl `interface' file \\
\end{tabular}


This is the {\bf ADAM} parameter system which is described in the {\bf
ADAM} SUN~4 document. For convenience, the main aspects of this
parameter system as seen by a user of \starman are described below.
[Most of what follows is thus applicable to any {\bf ADAM}
application.]

\subsection{Response to Prompts}

When a program is running, and wants to know the value of the (say)
`\verb|XXX|' parameter, it will output a request in the format:-

\begin{verbatim}
      XXX - prompt/ >

  or

      XXX - prompt/default/ > \end{verbatim}

You respond with the value that you want the parameter to have. If a
single value is needed, just input that. If more than one value is
needed, input them separated by commas. Character strings may have
spaces. If you reply with a `carriage return', then the default value,
if any is taken. There are rules on defaults (see
Section~\ref{se:param_def}), acceptable values (see
Section~\ref{se:param_acc}), and on getting help (see
Section~\ref{se:param_hel}).

\subsection{Command Line Setting}

Parameters may be assigned values on the command line. Thus to run
IMCUT where you want the cut out first 50 pixels in X of the image, you
could type:-

\begin{verbatim}
     > imcut $STARMAN_DATA/imcut_in out=fred xrange=\[1,50\]
     yrange=\[1,99\] bin=\ \end{verbatim}

or

\begin{verbatim}
     > imcut $STARMAN_DATA/imcut_in out=fred xrange=\[1,50\] \\
\end{verbatim}


The first 50 pixels in X and the first 99 pixels in Y will be cut out
with no binning. In the first example. you will only now need the
on-line input of the `\verb|TITLE|' whilst running the program,

This example illustrates a number of facets of inputting parameter
values on the command line. The rules about command line input are:-
You have to put the parameter name and an equals sign before the
parameter value. If you do not, then that parameter value is taken to
refer to the parameter which is in the same position in the program
`interface' file, the file which \starman uses to access parameters.
{\em Generally}, the first two parameters in an interface file will be
the `\verb|IN|' and `\verb|OUT|' parameters, but this is not an
iron-clad rule. If the parameter name and `$>$' are followed by a blank
space, the default values are taken.

\subsection{`Hidden' Setting}

Some programs have parameter values that you cannot normally get at.
The program will automatically assign the default values to these
parameters.  These parameters are known as `hidden' parameters.

These defaulted parameters enable programs to have many options, say
for controlling the appearance of some graphical output, without making
routine operations tedious because of a large number of prompts. These
defaulted values are described in the HELP for each program.

If you wish to change the values of these parameters, you may do so by
inputting them on the command line.


\subsection{Advanced Screen Interface Setting}

For certain parameters in certain programs, one can use the flexible
Advanced Screen Interface described in Section~\ref{se:advance}.

\subsection{New Interface Files}

The \starman programs pick up information about the parameters from the
`interface' file. Thus there is an interface file for (say) the
\verb|imcut| program.

This can be looked at:- \begin{verbatim}

 > ls $STARMAN_BIN/bin/imcut.ifl

                         (EXTRACT FROM)
# # IMCUT.IFL # interface IMCUT
   helplib   '$STARMAN_HELP IMCUT parameters' parameter IN
      type    NDF access  READ helpkey 'IN' ppath   'dynamic,default'
      default !  position 1 prompt 'Input image' endparameter parameter
   OUT
      type    NDF access  WRITE helpkey 'OUT' ppath   'dynamic,default'
      default !  position 2 prompt 'Output image' endparameter
   parameter XRANGE
      type    '_INTEGER' ppath   'dynamic' position 3 helpkey 'XRANGE'
      prompt 'X range to cut out' endparameter parameter CHECK
      type    '_LOGICAL' ppath   'dynamic' position 7 helpkey 'CHECK'
      prompt  'If any box pixel invalid, output invalid? (yes:no)'
   endparameter parameter TITLE
      type    'LITERAL' ppath   'dynamic' position 8 helpkey 'TITLE'
      prompt  'Title to add to output image' endparameter endinterface
\end{verbatim}

You can set you own `permanent' parameter values by making your own
interface file. \verb|cp| the file from the `starman' directory into
the directory you are working in (as `NAME'.ifl), and alter the lines.
Thus to set the XRANGE to `1,50', add into the XRANGE parameter part:-

\begin{verbatim}
     VPATH 'default' DEFAULT '1,50' \end{verbatim}

Then every time you run IMCUT {\em when you are in this directory}, the
XRANGE parameter will be `hidden' and set at this value. This will be
true even if you exit from \starman and later re-enter. However this
only works if your default directory is this directory where your new
interface file is.

\subsection{Defaults} \label{se:param_def}

When you are inputting parameters by responding to a prompt, you may be
given a `default' value. Thus if you are using IMCUT, when you are
asked for the range in X pixels to cut out, for an input image with 100
pixels in X, you would get:- \begin{verbatim}
    XRANGE - prompt/[1,100]/ > \end{verbatim}

Thus the default values are to take the entire X range. There are three
types of responses you can make. You can:- input your own values to
override the defaults (in this case `2,99' would override); input some
of your own values. If there is more than one value to input, if you do
not put all the values in, the remaining ones are set at the default
(in this example `2' would results in values of `2,100' being taken);
you can just press `carriage return', when the defaults are taken.

Help on the defaults is given in the normal help system

\subsection{Acceptable Inputs} \label{se:param_acc}

For some parameters, there are checks on the input. Thus for the
\verb|imcut xrange| parameters, any input of X pixel range which would
fall outside the image would be refused.

If an unacceptable value is input, a help on what is wrong is output,
and then either the parameter is asked for again, or the program will
take some other action.

Help on acceptable values is given in the normal help system.

\subsection{Help on Parameters} \label{se:param_hel}

Help on the parameters of a program is available via the normal help
for the program. Thus to get a list of all the parameters for the
program \verb|imcut|, type:- \begin{verbatim}
     > starmanhelp imcut param \end{verbatim}

You will then also be able to get the help on the individual
parameters.

When you are actually running the program, respond with `?', and the
help on the parameter will be given.


\subsection{Menus}

Some \starman parameters are menus from which you select an option.
You do not have to enter the full option string, but merely a string
that selects a choice unambiguously.  In many cases this can be as
little as a single character.  Here is an example from IMCUT:-

\begin{verbatim}
     SAMPLE - prompt/'yes'/ > \end{verbatim}

The acceptable values you could input now are `yes' or `no'. But `y' or
`n' would also be acceptable.



\section{Screen Display} \ajhsect{\arabic{section}}{SCREEN DISPLAY}

\subsection{Image Display}

Images can be displayed on any X windows display.

The display must have an 8-bit display (i.e. 256 colours available at
any one time). It may not work on mono or 24-bit displays.

Also any device, including hardcopy, can be used to output a greyscale
plot of an image by using the image graphical output in the INSPECT
option in the INTERACT program.


\subsubsection{Use of Pointer and Buttons}

To mark a position, one puts the pointer on the desired position, and
marks that point by pressing one of the buttons on the mouse. Each
button will often have a different effect, and one should look at the
`help' for the program to see what the buttons actually do in any
particular case.  Usually, the right-hand button denotes 'exit' from
the particular function being performed.  \starman can work with either
two or three buttons available for use on the mouse. If only two
buttons can be used, then the action of the third button is simulated
by pressing the two buttons together, with the middle one being pressed
shortly before the left-hand one. In this case also use of the middle
button by itself has to followed by a half-second pause.

(To see how to set up for the actual number, look at the 'help' for
'Numbutt' in the desired program.)

\subsubsection{Look-Up Table}

\starman can only be used to display images on devices that have 8-bit
colour displays. This nominally gives the use of 256 different
colours.

\starman allocates the first two colours to black and white, the next
eight to the

`red:green:blue:cyan:magenta:yellow:coral:palegreen'

colours of PGPLOT. The next five are then various shades of grey from
black to white for the `panel' and other uses.

Images are then displayed using the next 150 colours. The default when
you run any of these programs is these colours are black to white,
going through shades of grey. An image is displayed by taking the pixel
values, translating them into numbers between 1 and 150, and loading
them in the display device. The display device then has has a colour
for corresponding to each of the numbers between 1 and 150. These
colours are linear combinations of (red, green and blue).  Thus white
is (1.0,1.0,1.0), black is (0.0,0.0,0.0), blue is (0.0,0.0,1.0), and so
on.

(When an image is displayed, the default is displayed so that high
pixel values are given low look-up table (LUT) values, and thus come
out as blacked than low pixel values. Thus images are generally shown
as `negatives'.)

When the LUT is altered, it is the colours that correspond to those 150
numbers that are changed, not the numbers themselves. Thus if a pixel
value has been loaded into the display as (say) 15, it will first of
all be a dark grey (colour - 0.1,0.1,0.1). If the LUT is changed, the
colour could now be anything (say pink - 0.7,0.5,0.5).

However, with X window devices, some or all of the 256 possible colours
may have already been allocated by another program, and thus be
inaccessible to the \starman program. In this case, the \starman
program first of tries to use only 75 LUT colours, and then only 50 LUT
colours. If these are available, it uses those, and has to make a
coarser binning of the display.  If there are less than 50 colours
available, then the program will use those `default' colours available
to all programs on the device. They may well be very few of these, and
thus the display may be very simplistic.

\subsection{Graphical User Interface} \label{se:advance}

\starman has two modes whereby when inside some its programs, one can
get away from the old-fashioned interaction of typing in lines of
commands.

\subsubsection{Macintosh-like Interaction}

For a number of programs, to do with image and graph display the
`OPTION' parameters, where the program is repeatedly asking for
different options, one can set up a `panel' of `push-buttons' which you
click on with the cursor to choose the desired option. This is much
like the way you use a Macintosh.

To do this you need to be at a workstation. The programs where this is
possible and the parameters where it can be done are:-

\hspace{4ex}\begin{tabular}{|l|l|} \hline Program    & Option Parameter
\\ \hline Diagram &   `Option' \\ Dustring & `Option' \\ Interact  &
`Option' `Aloption' `Aoption' `Coption' `Goption'
	    `Ioption' `Soption' \\
Profile & `Option' `Doption', `Moption', `Roption' `Woption' \\
Tbchart  & `Option' \\ Tbplot & `Option' \\ \hline \end{tabular}

If, in response to a request for these parameters, one inputs `panel',
then a panel of the various options is put up on the workstation
screen, and one can choose the options by clicking on the `buttons' in
the `panel'.


\subsection{Graph Display}


\starman uses the PGPLOT/GKS packages to output graphs. This means that
nearly all graphical output devices, including hardcopy, on Starlink
can be used. When a graph is to be plotted, you are asked for the value
of the `GTYPE' parameter. You then input the GNS name of the device you
want. If you choose the default `ask', you then get another question
and you can then type `?'. This will give you the list of the names of
the available devices. You will have to consult your system manager to
see which physical device is attached to which name.

The usual names re `xwindows' and `ps', for X window devices and
Postcript printers.


\subsubsection{Use of Pointer and Buttons}

With PGPLOT, one puts the pointer on the desired position, and marks
that point by pressing any key on the {\em keyboard}.

\subsection{Tables Spread-Sheet}

There is a spread-sheet for interacting with tables, which works, to a
limited extent, like the spread-sheet programs on your PC.  This is the
TBSHEET program. If you have a terminal that supports graphics, however
simply, then you can use this to inspect and change the values in the
table. Also simple applications like SORTing and WEEDing may be done.

The table is put up on the screen in a grid, and all the options to
inspect and/or change the table are put up as boxes. One uses the
cursor to click on values to change them, or on options to undertake
those options.
















\section{Batch Jobs} \ajhsect{\arabic{section}}{BATCH JOBS}

To run \starman programs as batch jobs, consult the ADAM manual.




















\section{Images} \ajhsect{\arabic{section}}{IMAGES}


\starman has some image handlers ready for use. These are the
IM-programs, and they have their own help. There is also the 'Interact'
program, the main image display interaction program.

\subsection{Formats}

In an ideal world you would not need to know how your data are stored.
The storage mechanism would be transparent, and you would perceive your
data directly through the programs.  However, for historical reasons
there are numerous data formats in astronomical software, and at the
moment you have to be aware how your data is stored. \starman is no
exception to this.  It uses the {\bf ADAM} image format and you need to
know a little bit about this to use the programs properly.


The \starman suite of programs uses a simple data format for storing
images in. Images are stored on disk as `SDF' files. Thus an called
'fred' will be stored as 'fred.sdf' on disk. (As with the tables,
inside any \starman program, you do not use the `.sdf' suffix in
referring to the image.)

Both 'real' format and 'short' format images can be used. The 'real'
format uses 4 bytes per pixel, and the 'short' format only 2 bytes per
pixel. However, the 'short' format needs care with handling.

IT IS IMPORTANT TO UNDERSTAND THE LIMITATIONS OF THE PRECISION. SEE THE
`Precision' HELP BELOW.

There is some progress being made for a system whereby the programs can
read images in a number of other formats (e.g. IRAF, FITS, etc.), but
this is only just becominmg available. Check whether this is here by
trying to read data in such formats.


\subsection{What is in an image}

An image is a 2-D array of numbers. The numbers in an image are
considered as stored in individual `pixels'. The coordinates are called
`X' and `Y'.

The numbers are stored with a precision of about 1 in 10 million for
'real' images, and with a precision of about 1 in 50000 for 'short'
images, but see the `help' in Section~\ref{se:im_prec} for more detail
on this.

Each image also has two descriptors, BSCALE and BZERO. These are used
so that the value of a pixel is:-

\begin{verbatim}
      Value = BSCALE*(disk value) + BZERO \end{verbatim}

Generally you need not be aware of this, but again see
Section~\ref{se:im_prec} for more detail.

Each image also has a pixel magic value descriptor, `INVAL'.  This is
used to flag `bad' pixels. A pixel having this value (its `stored'
value, not necessarily its `true' value) will be considered by the
programs as being a `bad' one and dealt with specially.

The image also has a descriptor `TITLE', a 50 long character string. It
does not form any part of the image itself, but can be accessed by the
user as a source of additional personal information about the image.
Thus for example an image called `VFLAT' (stored as \verb|vflat.sdf| on
disk), could have a title of:- \begin{verbatim}
       `This is a flat field for the V filter' \end{verbatim}

This title is then available for inspection by the user, say by the
program \verb|Imdes|, and may be put out to the user by some programs
to show the user something about the image.

The image may also have any number of further descriptors, added by the
user, or input via \verb|imfits_dr|, or by some other programs.

\subsection{Precision} \label{se:im_prec}

The numbers in an image can have any value, but there is an actual
storage matter. On the disk (or on tape), the numbers are coded either
into 16-bit integers (short format) or as 32-bit reals (real format).

Each image has assigned a scale (BSCALE) and a zero (BZERO), which are
applied to all the numbers in an image. Thus the number actually stored
is:-

\begin{verbatim}
          Stored value = (true value-BZERO)/BSCALE
\end{verbatim}

Thus if an image has BZERO 900,000.0 and BSCALE 10.0, then a value of
1,000,000 will be stored as 10,000.

Similarly, when a program reads an image from disk or tape, it will get
the true value by:-

\begin{verbatim}
          True value = (Stored value)*BSCALE + BZERO
\end{verbatim}


All calculations {\em inside} a program are done in real single
precision arithmetic, accurate to about 1 part in 10 million.


\subsubsection{Real Format}

Numbers are stored as 32-bit real numbers, with possible values between
+/- 10 to the 37. The accuracy is about 1 part in 10 million.


In most real images, BSCALE is set at 1.0, and BZERO at 0.0.


\subsubsection{Short Format}

Numbers are stored into 16-bit integers.

Thus if a program wants to store a number of value (say) 1,000,000 it
cannot do this directly, as a 16-bit number can only have a value
between -32768 and +32767. So each image often has to make use of the
scale (BSCALE) and zero (BZERO) values, which are applied to all the
numbers in an image.


The advantage of this is that images are generally half the size of a
`normal' image. This means that disk and tape storage problems are
halved, and reading and writing images into and out of programs is
faster.

A disadvantage of this is that the precision of stored values is only
about 1 in 60000. This is however good enough for most astronomical
work.

Another disadvantage is that one has to be careful about dynamic range.
If one wanted to store an image whose values varied between 0.8 and
1.2, with a precision of 0.0001 (say a flat field), then it would be no
good storing this with the common default of (BSCALE=1.0,BZERO=0.0), as
the values would actually stored as the INTEGERS `0' and `1', and on
reaccessing them, they would then only have the values of 0.0 and 1.0.
They way round this is to put the BSCALE and BZERO appropriately. Thus
for this example, a BSCALE of 0.0001 and a BZERO of 0.0 would store the
numbers as integers between 8000 and 12000, which would then be able to
be accessed as values between 0.8 and 1.2 with steps of 0.0001, as is
desired.

The programs in most cases deal with this without you having to think
about it, but some programs (\verb|imfits_dr| for example in certain
cases) will not do this, so you have to think before you use them.

\subsection{Coordinates}

The bottom-left-hand pixel in an image is called the (1,1) pixel. Each
pixel is thought of stretching for one pixel coordinate wide. Thus the
blh pixel is thought of as stretching from 0.0 to 0.9999.. in X and Y,
with its centre at (0.5,0.5).


\subsection{Menu}

The general programs to deal with images as images are:-


\begin{tabular}{ll}
{\bf  Imcalc:} &
Perform mathematical operations on image(s) \\
{\bf  Imcube:} &
Make a 2-D image from a 3-D or 4-D one (real:integer:short) \\
{\bf  Imcut:} &
Make another image (sectioned,binned,inverted) \\
{\bf  Imdes:} &
View:copy:write:delete the descriptors of an image \\
{\bf Imfits{\undersc}dr:} &
Read simple FITS image off disk \\
{\bf Imflash:} &
Simple display of image \\
{\bf  Imjoin:} &
Join a number of images together \\
{\bf  Imkey:} &
Insert:change image pixel values from keyboard \\
{\bf  Import:} &
Load descriptors from other packages \\
{\bf  Imrotate:} &
Rotate an image anti-clockwise by 90,180, or 270 degrees \\
{\bf  Imsmooth:} &
Smooth an image \\
{\bf  Imstat:} &
Get statistics of an image \\
{\bf  Imtype:} &
Convert files between (real;integer;16-bit integer) \\
{\bf  Imweed:} &
Set a range of pixel values to Invalid \\
{\bf  }          &
 \\
{\bf Interact:} &
General image display and interaction program \\
{\bf  Tbplot:} &
Plot table graph/histogram - image picture/contour \\
\end{tabular}


\subsection{Image Display}

Images can be simply displayed on any X-device.

Sometimes if you are on a remote device, you will need to do the
Starlink utility `xdisplay'.

Also any device, including hardcopy, can be used to output a greyscle
plot of an image  by using the image graphical output in the INSPECT
option in the INTERACT program.


\subsection{Conversion from other systems}

If you have images in the FITS, FIGARO, or non-Starlink ADAM formats,
there are programs in \starman and in ADAM and Figaro which you can use
to convert them to the .SDF format used by {\it Starman}.

\hspace{4ex} \begin{tabular}[c]{|l|l|} \hline
   Format              &   Conversion program \\ \hline FITS
   (disk)         &   \verb|imfits_dr| \\ ADAM (=HDS/NDF/SDF) &
   \verb|import| \\ Figaro (=DST)       &   \verb|dst2ndf| in KAPPA,
   then \verb|import| \\ FITS                &   \verb|fitsin| in
   KAPPA, then \verb|import| \\ \hline \end{tabular}

As the ADAM and Figaro conversion programs usually give you `Real'
images, you can then use \verb|imtype| to convert them to the 16-bit
Integer*2 `Short' formats option used by {\it Starman}. (Remember the
possible use of scaling to avoid under/overflow.)

The image made from Figaro or HDS may be 3-D or 4-D. As it is a real
image, you can use the \verb|imcube| program to extract the desired 2-D
plane out of the image, before using \verb|i,type|.

If you are in real trouble, use those packages to write a FITS tape and
read the files in with \verb|fitsin| in KAPPA.

\subsection{Conversion to other systems}

To put images into the FITS/ADAM/FIGARO formats, there programs in in
ADAM and Figaro which you can use to convert them to the desired format
from the .SDF format used by {\it Starman}.

\hspace{4ex} \begin{tabular}[c]{|l|l|} \hline
   Format              &   Conversion program \\ \hline ADAM
  (=HDS/NDF/SDF)  &  import in \starman (converts descriptors) \\
  Figaro (=DST)        &  dst2ndf2dst in KAPPA, after import \\
  FITS                 &  fitsout in KAPPA, after import \\ FITS
  (disk)          &  dfitsout in KAPPA, after import \\ \hline
\end{tabular}

If your \starman images are in the `short' format, then as the ADAM and
Figaro conversion programs usually work with `real' images, you will
have to use \verb|imtype| to convert the normal \starman 16-bit
Integer*2 `short' formats to `real', before converting them.

You should then use \verb|import| to copy descriptors in the FITS or
FIGARO extensions.
















\section{Tables} \ajhsect{\arabic{section}}{TABLES}

The \starman suite of programs uses a simple table system for passing
tabular information back and forth between programs and to and from the
user.

These tables are actually stored on disk as `SDF' files. Thus a table
called `fred' will be stored as `fred.sdf' on disk.  (As with the
images, inside any \starman program you do not use the `.sdf' suffix in
referring to the table.)

\starman has some simple table handlers ready for use. These are the
TB-programs, and they have their own help.

\subsection{What is in a table}

A `table' may be considered as being made up of `rows', where a row
contains a name and set up numbers. Then the table itself contains a
number of these `rows'.

The numbers in a row are set into `columns'. The information in a
particular column generally concerns the same `aspect' from row to
row.

Each column can also have a name (its header).

Thus, for example, if one wanted to make a table of the positions of
stars, one could put the `X' position in the first column and the `Y'
position in the second column. So if one had three stars, `fred',
`george', and `arthur', with X,Y positions of (1.2,2.3), (3.4,4.5), and
(5.6,6.7) respectively, and the columns are to have the names `X' and
`Y', then the table would look like this:-

\hspace{4ex} \begin{tabular}[c]{|l|l|l|l|} \hline
	  &  Name       & Column 1    & Column 2  \\ \hline Header
   &             &  `X'        &  `Y'      \\ \hline Row 1  &
   fred       &  1.2        &  2.3      \\ Row 2  &  george     &
   3.4        &  4.5      \\ Row 3  &  arthur     &  5.6        &
   6.7      \\ \hline \end{tabular}

A table also has a `TITLE'. This is a character string which can be
added to the file containing the table. It does not form any part of
the table itself, but can be accessed by the user as a source of
additional personal information about the table. Thus for example a
table called `BADPIXELS' (stored as badpixels.sdf on disk), could have
a title of:-

\begin{verbatim}
       `This is a list of bad areas on my CCD'.  \end{verbatim}

This title is then available for inspection by the user, say by the
program `Tblist', and may be put out to the user by some programs to
show the user something about the table.

The `name' of a row may be up to 20 characters long. (A common default
usage is for them not to have names like `arthur', but to be in the
form `\#n', e.g.  `\#201', `\#1456'.

The numbers in the columns are 32-bit real numbers, thus having a
precision of about 6 decimal places, and a possible range of about
-10**38 to + 10**38.

The table may also have any number of further descriptors, added by the
user or some programs.

\subsection{Menu}

A listing of the available table handling programs:-

\begin{tabular}{ll}
{\bf  Tbcalc:} &
Calculate table elements \\
{\bf  Tbchart:} &
Plot out a realistic star map \\
{\bf Tbcomps:} &
Find stars within/not within an annulus of each other \\
{\bf  Tbcut:} &
Cut out parts of a table \\
{\bf Tbdes:} &
View:write:copy:delete the descriptors of a table \\
{\bf  Tbjoin:} &
Join tables together \\
{\bf  Tbkey:} &
Input numbers from keyboard into a table \\
{\bf  Tblist:} &
Type and/or put in file the contents of a table \\
{\bf Tbload:} &
Input an ASCII text file into a table \\
{\bf Tbmatch:} &
Extract entries with matching names in two tables \\
{\bf  Tbnative:} &
Convert table format to native machine style \\
{\bf  Tbnmatch:} &
Put tables in the same order of names \\
{\bf  Tbplot:} &
Plot out graph/histogram \\
{\bf  Tbpmatch:} &
Extract entries with matching or nonmatching positions two tables  \\
{\bf  Tbrenum:} &
Renumber names in a table \\
{\bf  Tbsheet:} &
Spread-sheet program for inspection/insertion/etc \\
{\bf Tbsort:} &         Sort entries in a table \\
{\bf  Tbstat:} &
Perform statistics on column(s) in tables(s) \\
{\bf Tbtran{\undersc}auto:} &
Transform one XY table to another automatically \\
{\bf  Tbtran{\undersc}do:}   &
Transform XY table positions using transform eqn \\
{\bf  Tbtran{\undersc}load:} &
Calc transform eqn from a given rotn, shift, mag   \\
{\bf Tbtran{\undersc}make:} &
Calc transform eqn from two matched XY tables \\
{\bf  Tbvalue:} &
Get a single value out of a table \\
{\bf Tbweed:} &
Make a table with only those entries with a parameter a range \\
{\bf  }          &
      \\
{\bf  Interact:} &
General image display and interaction program \\
\end{tabular}



\subsection{Structure}

(Some of this information is for people who want to access the tables
directly via their own programs.)

Data are stored in .SDF files as real*4 values. The first 5 values in a
row code a row name, and the data columns start after that.  Programs
which ask for parameter number or column number start their numbering
from the first data column. Each file must have at least two columns.

There are also file `descriptors' which can contain individual items of
information, in a way analogous to FITS descriptors.

Some programs assign to each data column a header parameter and some
programs use these parameters to find the column containing the desired
data. Some programs just rely on the column positions. These column
header parameters are stored as descriptors of the SDF image.  The
header for column 1 is stored as the value of parameter HEAD001, that
for 2 in HEAD002, and so on. The headers are character strings up to 20
characters long.

Although in actuality inside the computer the identifier is stored in
the same way as the columns, taking up five columns, it is not thought
of as occupying a column, and the data columns are numbered from 1. The
`size' of a row in a file, given by the `NITEM' descriptor, is thus
five more than the number of columns.

The number of rows in a table is given by the `LSTLEN' descriptor of
the file.

\subsection{The Onlie Begetter}

As a matter of interest to more sophisticated users and programmers ,
this is an enhanced version of the Starlink {\bf Interim} Environment
EDRS table system, copyright R.F.Warren-Smith.





\section{Using KAPPA } \label{se:packs}
\ajhsect{\arabic{section}}{Using KAPPA }

\subsection{Access}

The additional useful programs which back up \starman are those already
existing in the KAPPA package which are listed in
Section~\ref{se:addi}.

To use these, you must add the KAPPA package. Do:-

\begin{verbatim}
     > kappa \end{verbatim}

To access help on KAPPA programs, do:-

\begin{verbatim}
     > kaphelp \end{verbatim}



\section { A Programmer's Guide to Starman}
\ajhsect{\arabic{section}}{PROGRAMMER'S GUIDE }

\subsection{Introduction}

For the best guide, browse through the source code, with
`starmanhyperhelp'.

Starman has evolved from the {\it Interim} environment ASPIC GRASP
suite of programs, with the influence of the IRAF SPP programming
language.  It now runs under the Starlink ADAM environment.

The aim has been to produce readable code, and to protect against
future changes in the environment.

Thus the code is written in what seems to me to be a nice and neat, but
not too curt, style. Sub-routine calls to the outside world are
insulated through subroutines, and all non-public domain libraries have
been excluded.

\subsubsection{Use of the ADAM Environmant}

To understand the basic rules of using the ADAM Environment, resd the
Starlink document -- Starlink Guide/4.

All communication with the ADAM system goes through the routines in the
`starflib\_adam.f' file. (Although IMPORT avoids this.) These routines
provide simple interface calls for the programmer.

The ADAM use of the `.ifl' interface files for communication with the
outside world is normal.

\subsubsection{Programming Style}

The style generally follows the IRAF SPP style. Features are:-

\begin{enumerate}

\item Use of include files with COMMON for passing numbers around
      the programs.  \item Use of `implicit none' to check on
varaibles.  \item Use of a standard way of starting a subroutine -

\begin{quote} \begin{tabbing}
\verb#CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC # \\
\verb#C s/r name -- one line description                           # \\
\verb#C    lines of description                                    # \\
\verb#C                                                            # \\
\verb#C   author              institution              date        # \\
\verb#                                                             # \\
\verb#      subroutine name ( param1, param2, etc. )               # \\
\verb#                                                             # \\
\verb#      implicit none                                          # \\
\verb#      include files                                          # \\
\verb#                                                             # \\
\verb#      type       param1       !i: description                # \\
\verb#      type       param2       !o: description                # \\
\verb#C--                                                          # \\
\verb#      types    work variables                                # \\
\verb#Cbegin                                                       # \\
\verb#                                                             # \\
\verb#        s/r code                                             # \\
\end{tabbing} \end{quote}

\item The use of the ``--'' double minus sign indicates the start and
      end of the s/r description. So in no other location are two minus
      signs to be used.

\item Extensive use of comments.

\item Use of comments to be restricted to after column 80, preceeded
      by an exclamation mark. Sometimes comments starting from line 1
      (with a ``C'') have to be present for readability.

\item No sub-routine to extend over more than 200 lines (including
      start and comment lines).

\item All programs to work as sub-routines to the ADAM system. Thus a
      program should start with a special subroutine whose only
      purposes are to be linked in with the ADAM `top' system, and in
      its turn call the real program, which starts with a subroutine of
      name `t\_PROGRAM', and to set up the Starman programming start
      values, and to translate those back to the ADAM system when
      leaving the programe

\begin{quote} \begin{tabbing}
\verb#CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC # \\
\verb#C `name' -- (Program) `one line description'                 # \\
\verb#C                                                            # \\
\verb#C   author              institution              date        # \\
\verb#                                                             # \\
\verb#      subroutine `name' ( ierradam )                         # \\
\verb#                                                             # \\
\verb#      implicit none                                          # \\
\verb#                                                             # \\
\verb#      integer    ierradam       !o: ADAM error flag          # \\
\verb#C--                                                          # \\
\verb#Cbegin                                                       # \\
\verb#                                                             # \\
\verb#        call starman_start                                   # \\
\verb#                                                             # \\
\verb#        call t_`name'                                        # \\
\verb#                                                             # \\
\verb#        call starman_end ( ierradam )                        # \\
\verb#                                                             # \\
\verb#        end                                                  # \\
\end{tabbing} \end{quote}


\item Use of a common `ST\_FAILED' variable to show program failure.

\item Exit from s/rs on `ST\_FAILED' being set.

\item Code to be in lower case.

\item Indentation by three columns at each step.

\item Variables in COMMON to be in upper case.

\item Often used variables relating to images and tables to
      be given standard names and be loaded by the use of the
      `image.inc' and `table.inc' include files.

\item The top level sub-routine to be mainly just a small set of
      calls to sub-routinesw which do the actual work.

\end{enumerate}

\subsubsection{Starman General Sub-routines}

In the `/lib' sub-directory, there are a large number of subroutines
which are used by more than one program. The programmer should browse
through the files there.

The routines which address the ADAM routines are kept in one file, the
`starflib\_adam.f' file. There is also a file which has routines that
whilst they are not {\em too} peculiar, do have some Unix specific
calls and have thus been separated to ease in porting, into the file
`starflib\_unix.f'.

Amongst the routines are a number of sets of sub-routines which are of
general use in writing programs. These general sets include:-

\begin{enumerate}

\item {\bf Typing out: \\ }
      There are two sr/s, \verb|printo| which types out a line of text,
      and \verb|printd| which does the same, but can insert variables
      in it, in the fashion of the C routine \verb|printf|.  To make
      that work, you need to start the program with \verb|pargbeg| to
      set up the system. Then the routines \verb|parg(cilr)| let you
      load character strings, integers, logicals and reals, which are
      then inserted in a \verb|printd| s/r as

       \hspace*{\fill}  \verb|call printd ( ' text \%c \%d \%l \%f ' )
       |  \hspace*{\fill}

\item {\bf Text: \\ }
      There are useful s/rs for dealing with text strings. These are
      \verb|lbgone, lens, charln,| \verb|lowcase, uppcase|.

\item {\bf Vector Arithmetic: \\ }
      Arrays of numbers may be simply manipulated with the routines
      found in `starflibv.f'.  An example of this is \verb|call aaddr (
      a, b, c, n )| which will add the two real arrays, `a' and `b', to
      produce the array `c', doing it for the first `n' items in the
      arrays. These routines do not deal with `magic' values.

\item {\bf Image I/O: \\ }
      Opening images for reading and writing is done with the
      \verb|opim(isur)(rw)|, \verb|opimz(rw)|, \verb|opim4zr|, and
      \verb|opim4(irs)w| routines (these in turn use the ADAM
      environment calls to do the actual work). Images are closed with
      the \verb|canpar| routine. There are also routines for accessing
      descriptors of images, \verb|gtimzd|, \verb|gtdes(cir)|,
      \verb|gtdesn|, \verb|gtdesn_gen|, \verb|gtim(irs)d|,
      \verb|ptdes(cir)|, \verb|gtdescn|,

\item {\bf Table I/O: \\ }
      Opening tables for reading and writing is done with the
      \verb|optab(rw)| routines (these in turn use the ADAM environment
      calls to do the actual work). Tables are closed with the
      \verb|canpar| routine. There are also a number of routines for
      accessing names and headers in tables.

\item {\bf Parameter I/O: \\ }
       Getting parameters from the user are done with the
      \verb|get1(bcir)|  and \verb|get(2345)(ir)| routines. These
      parameters are cancelled with the \verb|canpar| routine. Putting
      parameters is done with the \verb|put(123)(ir)| routines. These
      routines in turn call ADAM ones.

\item {\bf Work Space: \\ }
      Work space is opened with the \verb|gtwrk(irs)| routines, and
      closed with the \verb|wrkcan| one.

\item {\bf Image Display: \\ }
     The image DS\_ display routines work for X-windows.  One can also
     use the PGPLOT routines through GKS to access other output devices

\item {\bf Graphics: \\ }
      There are routines which can be used as an interface to some of
      the PGPLOT routines, These are mainly to do with opening and
      closing devices, where it has been found useful to have them in a
      standard form. There are some other packs of PGPLOT routines that
      have been found useful.

\item {\bf Copying Arrays: \\}
      There are a number of routines that copy data between arrays in a
      number of useful fashions.

\item {\bf Maths: \\}
      There are a number of useful mathematical routines. These have
      been provided to escape from the straight-jacket of the NAG
      system, and thus make the suite portable. There is a complete
      `sort' set in these.

\end{enumerate}

\subsubsection{Needed Outside Libraries}

The needed libraries, outside of those of Starman, are:-

\begin{list}{{-}}{}

\item {\bf Graphics: \\ }
     The graphics works through PGPLOT. For the Starlink
     implementation, PGPLOT uses GKS and GNS libraries, and the EMS\_
     and CHR\_ libraries.

\item {\bf Image Display: \\ }
     The image DS\_ display routines work for X-windows. Thus the
     libraries for X drivers are needed. The PGPLOT routines are needed
     for the GKS calls in PGPLOT to access other output devices.

\item {\bf Astrometry: \\ }
      The Starlink SLALIB astrometry library.

\end{list}

\subsection{Directory Structure}


The main Starman directory contains Starman start script and the help
file.


The sub-directories contain:-


\begin{list}{{-}}{}

\item {\bf /bin -- } Executables and \verb|.ifl| interface files

\item {\bf /`program' -- } Each sub-directory contains the code for one
      of the Starman programs, together with its makefile. These are
      not the general purpose image and table programs, which are in
      the \verb|/image| and \verb|/table|  sub-directories.

\item {\bf /image -- } Code for the `image' programs, for example
		       \verb|imcalc|, \verb|imcut|, etc.

\item {\bf /table -- } Code for the `table' programs, for example
		       \verb|tbcalc|, \verb|tbcut|, etc.

\item {\bf /lib -- } General purpose subroutines and subroutines to
		     access the ADAM environment.

\item {\bf /disp -- } Display subroutines.

\item {\bf /docs /help /hyper -- } Documentation

\item {\bf /build -- } Package build under the Starlink system.

\item {\bf /monolith -- } Files for building the monolithic version.

\end{list}


\subsection{Making the programs}

Starman uses the normal Unix {\bf make} system. It has its top level
makefile.

\subsubsection{Monolith version}

To enable things to load quickly, all programs are statically linked.
However, this does case problems in disk space, as each executable is
large.  To save on this disk space, all the programs can be loaded into
one monolith, which is not much larger than a single executable.

This does not mean that the programs can be used singly, as each
program is set up as a separate (small) file, which then points to the
monolith.

This is loaded from the \verb|/monolith| sub-directory, together with
the \verb|load_monolith| script and the \verb|mono_link| in the
\verb|/bin| sub-directory.

This makes the \verb|starman_mon| executable, with the
\verb|starman_mon.ifl| interface file, which is only needed when the
program runs in ICL.






\section{Version} \ajhsect{\arabic{section}}{Version}

  Version 2.0       \hspace*{20mm} 1995 January


\section{Author} \ajhsect{\arabic{section}}{Author}

  This was all written by me, Alan Penny.

  With considerable help by Pat Morris, especially in the last four
  years, including with the conversion to Unix, and the making of a
  `stand-alone' Fits version

  Many people over the years have aided the development of this package,
  and their help is sincerely acknowledged:-

  John Pilkington of RGO introduced me to 2-D Gaussian profile fitting
  for stellar photometry.  Rakos of Vienna was the source of the basic
  Lorentz profile.  Rodney Warren-Smith was the author of a
  table-handling system which was the starting point for the one used
  here.  Gordon Robertson of the AAO helped me with extending the
  Lorentzian to 2-D.  Bill Sparks of STScI suggested the base algorithm
  for Starfind.  Kenneth Mighell of ESO was the inspiration for the
  base idea for one of the speed-ups done for in Measure and Profile.
  Peter Stetson of DAO was the inspiration for the base idea for
  Tbtran{\undersc}auto.

  RGO 1971-1985; SAAO 1972-75 and 1978-81; RAL 1986; STScI 1986 - 1988;
  RAL 1988-

\newpage

\section{General Programs} \ajhsect{\arabic{section}}{GENERAL PROGRAMS}
\label{se:progs}

\newpage

\begin{small}

\addcontentsline{toc}{subsection}{ Addstars}

\ajhsect{\arabic{section}}{General Programs - \hspace*{0.2in} ADDSTARS}

\sstroutine{ADDSTARS}{
   Adds or subtracts stars into an image}{

\sstdescription{
 This program adds or subtracts stars into an image. Noise can
 be added to these stars. A sky (with noise) can be added, as can a
 separate noise level, and as can a separate input image.

 The stars are input via a file with a table of X,Y positions and
 heights. A common star profile can be used to add the stars,
 or they can all have individual profiles (which profiles are fed in
 as extra parameters of the star table in addition to the normal
 profile image file input).

 The program takes care of pixel averaging (for small radius stars) and
 and calculates the profile out to the point where it has a value of 0.2.

}\sstdiytopic{Use}{
\begin{list}{{--}}{}
 \item Input an image to add to, or input the size of the new
       image to make.
\item Feed the list of stars as a list of (X,Y star positions,
       and heights, [and optionally profile] ).
\item Feed in a profile file.
      If the list of star positions has profile parameters for
       each star, then they are adopted for each star, otherwise the standard
       profile is used for all the stars. The star heights must be the actual
      heights.
 \item Choose whether or not to:-

\begin{list}{{-}}{}
 \item use the profile map
 \item use the profile file
 \item override any profile parameters in the input star position table
 \item have the stars as positive or negative stars
 \item feed in any scaling for the star noise
 \item feed in any sky background, and any scaling for the sky noise
 \item feed in the standard deviation for any extra sky noise
\end{list}

  \item Specify the output image.
\end{list}

}\sstdiytopic{Method}{
 Each star is given a profile, and an x,y position and a height. Then
 for each pixel near the star, the mean intensity of the star is
 calculated. If the radius is small, then when the profile is
 changing rapidly the mean is made from calculations of sub-pixel
 values in the pixel.

 Then this mean is then added or subtracted from each pixel.

 This is done for all pixels round the star, out to the place where
 the star value is 0.2.


 The mathematical expression of this star value is:-


$$I(x,y)= H.\left(\frac{1}{1+d_{1}^{P(1+d_{2})}}+
HQ.e^{-d_{Q}^{PQ}}+F(x,y)\right)+A+B.x+C.y$$


where

\vspace*{1mm}

\begin{tabular}{l l l}

 $ I(x,y)$ &$=$& the value of the star profile at pixel position x,y \\

$H $&$=$&  the star peak Lorentz height (Gaussian and map are an added
fraction) \\

$x_{0}, y_{0} $&$=$& the star centre position \\

 $A, B, C $&$=$& the sloping background \\


\vspace*{2mm}


$ d_{1} $&$=$&$ \sqrt{\left(\frac{x_{1}}{R_(maj)}\right)^2+
\left(\frac{y_{1}}{R_{min}}\right)^2}$ \\

$ d_{2} $&$=$&$ \sqrt{\left(\frac{x_{1}}{RP_{maj}}\right)^2+
\left(\frac{y_{1}}{RP_{min}}\right)^2}$ \\

$x_{1} $&$=$&$ (x-x_{0}).cos(\theta) + (y-y_{0}).sin(\theta)$ \\

$y_{1} $&$=$&$ -(x-x_{0}).sin(\theta) + (y-y_{0}).cos(\theta)$ \\

\vspace*{2mm}

$d_{Q} $&$=$&$\frac{\sqrt{\left(x-x_{0}\right)^2+
\left(y-y_{0}\right)^2}}{RQ}$ \\

\end{tabular}


$F$  is an empirical function of $x$ and $y$.

(For a full description of this see the `profile' section in the \starman
manual.)


   If noise is wanted in the star images, then each pixel can be looked
   at and Poisson noise added. The pixel are treated as
   scaled levels. Thus the Poisson noise is calculated as if each
   pixel value is the photon counts divided by some scaling.

   The sky is added as a flat back ground with optional Poisson noise
   (scaled as for the stars, but with a different scaling factor).

   A separate noise level (not scaled) can be added.

   An input image can be added.

}\sstparameters{
\sstsubsection{ADD = LITERAL (Read)}{
  (Default - 'add'   \hspace{6ex}   Choice - 'add:sub' )

  Do you want the stars to be added into, or subtracted from the
  image?

}\sstsubsection{DOMAP = LITERAL (Read)}{
  (Default - 'yes'      \hspace{6ex} Choice - 'yes:no')

  Whether to use the empirical profile map in the profile file.

}\sstsubsection{IN = SDF (Read) }{
  (Default - null)

  The name of the file containing the image to add stars to.

  The image has to be an .SDF file. Either a 16-bit integer*2 or a
  32-bit real*4 one.

  If a null response is given, then no image is input and a new one of
  a size defined by the user and having a given flat background is
  used to add the stars to.

}\sstsubsection{INSTARS = SDF (Read) }{
  (Default - null)

  The name of the file containing the table of star positions and heights,
  and optionally profiles.

  The x, y, heights must either be the first three parameters, or
  there must be pointers to them in the standard header format of
  parameter 'HEAD00n' being X, Y, and HEIGHT for parameter being in
  column n.

  If the profile parameters are there, then the list must have the
  standard profile headers RX, RY, P, PRX, PRY, THETA, QH, QR, QP,
  MAPNUM, MAPX, MAPY, MAGNIF.


}\sstsubsection{OUT = SDF (Write) }{
  (Default - null)

  The name of the new file to contain the output image.

  This will be an ADAM .SDF image. It will be 32-bit real (real) or
  16-bit integer (short) format depending on the users choice -
  through 'OUTTYPE'.

}\sstsubsection{OUTTYPE = LITERAL (Read)}{
  (Default - 'real'      \hspace{6ex} Choice - 'real:short')

  Should the type of the output image be 'real', with 32-bit Reals
  or 'short' with 16-bit integers?

}\sstsubsection{PIXNOISE = {\undersc}REAL (Read) }{
  (Default - 0.0     \hspace{6ex}     Range - 0.0 to 1.0e8)

  The standard deviation of any extra Poisson noise to be added
  to the sky.

  This is = std dev of (true no of detected photons in pixel).

  This may not be the std dev of the actual sky counts, as the
  `SKYGAIN' parameter, which is used to translate the actual pixel
  counts into their Poisson equivalent, may not be 1.0

  The Std dev of the actual pixel counts added will be =
  `Pixnoise'/`Skygain'

  If 0.0 is entered, no extra noise is added

}\sstsubsection{PROFILE = SDF (Read) }{
  (Default - null)

  The name of the file containing the image with the
  standard star profile.

  This must not be null. (Although sometimtes its profile may never
  be used, in the case if, for all the stars, it is overridden by
  their own (optional) profiles contained in the 'INSTARS' file.)

  The image contains the parameters of the profile as its
  descriptors, and the empirical map as its pixel values. It is
  a 16-bit integer image, usually made as the output of the
  'profile' program.

}\sstsubsection{PYES = LITERAL (Read) }{
  (Default - 'yes'      \hspace{6ex}  Choice - 'yes:no')

  Whether to have the profile parameters in the profile file override
  any profile parameters in the star list.

}\sstsubsection{SEED = {\undersc}INTEGER (Read) }{
  (Default - 1234567891      \hspace{6ex} Range - 1200000001 to 1400000001)

  The random number generator seed. This should be an odd number
  between 1,200,000,001 and 1,240,000,001.

  This applies to the star images or the sky background, depending
  on the previous answer. It is only asked for if the stars or
  sky are/is to be added with noise. The seed is only asked for
  for the sky noise, if there is no star noise.

  The seed only has to supplied once, if at all, as the random
  number generator is not reset after doing the stars.

}\sstsubsection{SKY = {\undersc}REAL (Read) }{
  (Default - 0.0 if input image, 100.0 if no input image.
     \hspace{6ex} Range - -1.0e9 to +1.0e9)

  Sky value to add to output image.

}\sstsubsection{SKYGAIN = {\undersc}REAL (Read) }{
  (Default - 1.0     \hspace{6ex}   Range - 0.0 to 1.0e8)

  The conversion, for the sky, between the numbers that go in
  the image and the number of independant Poisson events.

  This is = (true no of detected photons in pixel)/(pixel counts).

  One way this can be is for a CCD, where it would be
             = electrons/adu

  If 0.0 is entered, then no sky noise is added

}\sstsubsection{SKYPOIS = LITERAL (Read)}{
  (Default - 'yes'      \hspace{6ex} Choice - 'yes:no')

  Add in noise coming from the Poisson nature of the sky flux?

}\sstsubsection{SIZE = {\undersc}INTEGER(2) (Read) }{
  (Default - 100,100.      \hspace{6ex}    Range - 1 to 4096)

  X and Y size of new image to add stars to.

  This is only asked for if there is no input image, and a  new
  one is to be made.

}\sstsubsection{STARGAIN = {\undersc}REAL (Read) }{
  (Default - 1.0      \hspace{6ex}      Range - 0.0 to 1.0e8)

  The conversion, for the stars, between the numbers that go in
  the image and the number of independant Poisson events.

  This is = (true no of detected photons in pixel)/(pixel counts).

  One way this can be is for a CCD, where it would be
             = electrons/adu

  If 0.0 is returned, then no noise is added.

}\sstsubsection{STARPOIS = LITERAL (Read)}{
  (Default - 'yes'      \hspace{6ex} Choice - 'yes:no')

  Add in noise coming from the Poisson nature of the star flux?

}\sstsubsection{TITLE = LITERAL (Read) }{
 (Default - Input image title or 'Output from ADDSTARS')

  Title to add to the output image.
}}}


\addcontentsline{toc}{subsection}{ Automag}

\ajhsect{\arabic{section}}{General Programs - \hspace*{0.2in} AUTOMAG}

\sstroutine{AUTOMAG}{Simple aperture photometry on stars}{

\sstdescription{
  This does simple aperture photometry on stars in an image. It works
  automatically, finding the stars, doing the aperture photometry and
  outputting the results. It uses the (optional) presence of an
  exposure time descriptor to correct the magnitude to that for a
  1 second exposure.

  It can also, depending on the presence of the appropriate information
  in the image descriptors and the users wish:-

\hspace{4ex}\begin{tabular}{lp{5in}}
   - &Find the Zenith distance (either from the image or a standards file) \\
   - &Find the Filter used \\
   - &Apply the extinction correction \\
   - &Look up the object name in a file and find the appropriate
      standard magnitude, which it then compares to the measured magnitude \\
   - &Output results to a text file as well as the terminal \\
\end{tabular}

  It works best if the stars are widely dispersed in the image.
  A density of one star per 100x100 pixel area is fine, although
  somewhat higher densities are acceptable.

}\sstdiytopic{Use}{
  The program starts off by asking you what type of measuring
  do you want to do:-

  \begin{list}{{-}}{}
     \item Measure one or a number of images with the same parameters
     \item Use the Gaussian centering after the centroid finding
     \item Make an output results file
     \item Calculate the zenith distance of the image
     \item Use the image filter to determine the extinction correction
        (needs SecZ calculation)
     \item Use a standard position and magnitude file to calculate the
        difference from the standard magnitude (needs SecZ and filter
        calculation)
\end{list}

  It then asks you for a number of parameters associated with the
  the star finding and measuring process.

  Then there are a number of sections of parameter questions that are
  asked depending on which of the measuring options you have chosen

\begin{list}{{-}}{}
    \item Output file
    \item Zenith distance (Star position in RA and Dec and site latitude)
    \item Use of filters for extinction calculations
    \item Use of standard file for standard magnitude calculations
\end{list}

  Then the name of the input image file is asked for, and then the user
  is given the chance to correct the exposure time.

  The program then does the calculations and outputs the results to
  the terminal and (optionally) the file.

  If the user is doing more than one image, the program loops back
  to ask for the new image file name ( and the new corrected exposure
  time), and does the new calculations. This loop is repeated until
  a blank is input as the file name.

}\sstdiytopic{Method}{
\vspace*{2mm}{\bf Measuring the Stars}\vspace*{2mm}

  It finds stars as groups of pixels which are more than a certain value
  above the sky level. It then finds the centre of these groups, and puts
  an aperture round them, giving the flux in the aperture. It then
  finds the sky level in up to four apertures located around the star,
  finds the mean sky level, deducts that from the star aperture flux, to
  give the star flux.

  This flux is then turned into a magnitude by the formula

       $$        Magnitude = 30.0 - 2.5*log_{10}(flux) $$

\vspace*{2mm}{\bf Correcting for Exposure time}\vspace*{2mm}

  This magnitude is then corrected for the exposure time. The flux
  is changed to that it would have had in a 1 second exposure, that is

    $$               Magnitude = magnitude + 2.5*log_{10}(exp time) $$

\vspace*{2mm}{\bf Correcting for Extinction }\vspace*{2mm}

  If the user desires, then the magnitude can be corrected for extinction.

  This is done by taking the RA and Dec and Sidereal time from the image
  descriptors, and working out the Sec Z of the exposure. Then the filter
  that was used in the exposure is found from an image descriptor, and
  used with the extinction input by the user for such a filter to work
  out the extinction.

  The Sec Z is worked out in first order terms as:-

  $$  SecZ =  \frac{1.0}{sin(lat)*sin(dec)+cos(lat)*cos(dec)*cos(ha)} $$

  A corrected magnitude is then worked out as:-

  $$                  Magnitude = magnitude - Extinction*(SecZ-1.0) $$

  It is possible to get the image RA and Dec not from the image
  descriptors, but from the standards file. In this case the
  star name in the image descriptors is taken, and that name looked
  for in the standards file.

\vspace*{2mm}{\bf   Checking Against a Standard Magnitude}\vspace*{2mm}

  If the user desires, the standard magnitude of the star in the
  waveband used may be found from the input standards file. In this
  case, the star name in the image descriptors is taken, and that
  name looked for in the standards file. The magnitude in the
  waveband used, for that star is then output, together with the
  difference between the `observed' magnitude and the standard
  magnitude.

}\sstdiytopic{Sky Locations}{
  The number and location of the sky apertures is defined by the
  user. Up to four apertures may be used. These are distributed
  in an X-Y frame around the star aperture, where the X-Y offsets
  give the X-Y distances in pixels between the star aperture
  centre and the sky aperture centres.

  The default is a star aperture diameter of 40 pixels, and four
  sky apertures, each of 20 pixels diameter, located to the left
  right, up and down from the star aperture with star-sky
  centre distances of 40 pixels. Thus the sky apertures come within
  10 pixels of the star aperture.

}\sstdiytopic{Star Finding}{
  The program finds stars by looking for blocks of pixels above the
  sky level.

  The position found by the program is the centroid of the contiguous
  pixels above the threshold level above the overall image sky level.
  This centroid gives equal weight to all these pixels, regardless
  of their pixel values. The search for contiguous pixels is only
  done in a box of size which is input by the user (with a default of
  side 100 pixels). This box is such that the first pixel found
  (in a search along X lines, goin up in the Y direction line-by-line),
  is centered in the box in the X direction, and at the bottom of
  the box in the Y direction.

  If the star images are reasonably in focus, then it is possible
  to refine this position by fitting a Gaussian with a variable
  profile at that location.

  This gives a more accurate centering, but has the risk that the
  star image may be so strange as to cause the Gaussian fitting
  subroutine to fail catastrophically.

  Also if the stars are not in focus, then the fit may well fail
  or give the wrong position.

  Stars with positions within a box of side 16 pixels centered on any
  other star found are rejected.

  Up to 200 stars can be found. If there are more then they are
  ignored. There is the possibility that this may result in less than
  200 stars, as some of them may be close to others, and will thus
  be ignored.

}\sstdiytopic{Sky Levels}{
\vspace*{2mm}{\bf     Level in a Single Aperture}\vspace*{2mm}

 The sky levels are calculated for each sky aperture. All `good'
 pixels are taken in the area, and the mean taken.

 It is important that this is the mean, because these sky levels
 will be used to subtract a sky from the star aperture. If a
 value was used which discarded high values (due to faint stars),
 such as medians or other methods, then there will be a systematic
 error introduced into the star magnitudes.

 This is because there will be faint stars in the star aperture
 and these will be simply added in, so the same proceedure must
 be used for the sky apertures.

 The problem of a bright star falling by chance in a sky aperture
 is dealt with in the averaging described below.

\vspace*{2mm}{\bf   Mean Level Used }\vspace*{2mm}

 When more than one sky aperture is used, then a mean level is
 calculated. For the case of two apertures, a simple mean is
 taken. For three or four apertures, the two apertures whose
 levels are closest together is taken, and then any other
 aperture whose level is within a user input fractional tolerance
 of that level. The default value for this tolerance
 is 0.1 of the star flux. The value used is input through AVLIM.

 Then the mean is made from the selected apertures.

\vspace*{2mm}{\bf    Record of Differences }\vspace*{2mm}

 To see if any of the apertures is contaminated (say by a bright
 star), the magnitudes that would have been calculated if each
 aperture in turn was taken as the sole sky level is calculated.
 The differences of these from the actually calculated mean is
 calculated and typed out (as the `Sk1', `Sk2', etc.). So the
 user can see from these if there was any contamination that has
 disturbed the mean.

 If there are more than two apertures, often only one is contaminated,
 and this is thrown out by the averaging process described above. So
 the mean may well be correct. A good indicator of this is that two or
 three of the apertures show very good agreement with the mean, and
 one is distant from it. This tells you that the mean was made without
 the discordant aperture.

}\sstdiytopic{Image Descriptors}{
  The image can contain much necessary ancillary information as
  descriptors. This is used by the program. Unfortunately there is
  no standard naming or format scheme. So the program is as flexible
  as possible on the input. The user can define the names of the
  descriptors carrying the relevant information.

  The user can even say where in some descriptor the information is.
  This is because sometimes information, such as the object name, does
  not take up the entire descriptor, but is placed within the descriptor.

\hspace{4ex}\begin{tabular}{|l|l|l|}\hline
  Descriptor Content   &  Default Name  &  Select Location? \\ \hline
  Object name          &   OBJECT       &       yes \\
  Right Ascension      &   RA           &       no \\
  Declination          &   DEC          &       no \\
  Exposure time        &   EXPOSURE     &       yes \\
  Sidereal time        &   SIDTIME      &       yes \\
  Filter name          &   FILTER       &       yes \\ \hline
\end{tabular}

}\sstdiytopic{Input}{
  The input image is the standard \starman image file. It must
  be the integer*2 16-bit image. It can have the `BSCALE' and `BZERO'
  pixel value scaling, and the bad pixel magic value `INVAL'.

  The optional standards file is a \starman table of the
  positions and magnitudes of stars. It has to have:-

\hspace{4ex}\begin{tabular}{ll}
       - &the standard Identifiers (star names) \\
       - &the Right Ascension of the star (in radians) \\
       - &the Declination of the star (in radians) \\
       - &the Equinox of the position (Julian epoch - e.g. 1990.234) \\
       - &at least one magnitude \\
\end{tabular}

  The magnitudes of different colours must be as magnitudes, not colours.
  I.e., a star with V=16.00 and B-V of 1.00 would have two entries, one
  for V=16.00 and one for B=17.00.

  The columns containing the magnitudes must have descriptors telling
  what waveband is in each column. In the example above, for example, the
  V column could have a descriptor with `V', and the B column one of `B'.

  The column descriptors must be in the standard \starman table style, as
  HEADxxx, where xxx = 001, 002, etc. Thus in the example above the
  descriptors would be:-

\hspace{4ex}\begin{tabular}{|l|l|}\hline
          name     & content \\ \hline
          HEAD001  & RA \\
          HEAD002  & DEC \\
          HEAD003  & EQUINOX \\
          HEAD004  & V \\
          HEAD005  & B \\ \hline
\end{tabular}

}\sstdiytopic{Date}{
 If a standard magnitude file is used, then the user has to input the
 date of the exposure. This is because there is no standard format
 for date formats. It should be input in format YYYY/MM/DD. A default
 reply is acceptable.

 The date is used for the precession of the standard star positions
 to the date of the observation.

}\sstdiytopic{Error}{
 The error in the output magnitude is calculated.

 The calculations are done on the assumption that the pixel values in
 the image are the result of a Poissonian noise signal. There are two
 modifiers to this. First, that the numbers in the image have been scaled,
 so that a gain is needed to reconstruct the original Poissonian values.
 Second, that an extra source of noise has been added to each pixel. Thus
 if a pixel has a raw value of k (and the image has scale of BSCALE, and
 zero of BZERO), then the true pixel value is BSCALE.k + BZERO. Then if
 the Poissonian gain is GAIN, and the extra noise is NOISE, the noise in
 the pixel is:-

  \hspace{4ex}   square root[GAIN.(BSCALE.k+BZERO) + NOISE.NOISE]

 Following on from this assumption, the error in the star magnitude
 is calculated as:-

  The variance of the sky estimate is:-

  \hspace{4ex}       varsky = [(BSCALE.skyfl+BZERO).GAIN + skypix.NOISE.NOISE]/skypix

 The variance of the star estimate is then:-

  \hspace{4ex} varstar = (BSCALE.starfl+BZERO).GAIN + starpix.NOISE.NOISE + starpix.varsky

  \hspace{2ex} The RMS star error is then:- \\
  \hspace{4ex} err = sqrt(varstar)/((BSCALE.starfl+BZERO)*GAIN) \\
  \hspace{4ex} RMS = 2.5.alog10(1.0+err)

  \hspace{6ex} where   skyfl   = total flux in all used sky apertures \\
  \hspace{14ex} starfl  = total flux in star aperture \\
  \hspace{14ex} skypix  = total no of pixels in all used sky apertures \\
  \hspace{14ex} starpix = no of pixels in star aperture \\

}\sstdiytopic{Exposure}{
 The exposure time is used for correcting the magnitude of the star.
 This is done by calculating the flux that the star would have had
 if the exposure had been 1 second long.

 The actual exposure time used in this calculation is not
 necessarily that in the image descriptor. First of all the image
 exposure time descriptor is read, and then offered to the user as
 the default exposure time. The user can then accept this, or input
 any value she likes. The point of allowing the user to do this is
 that sometimes the time loaded in the exposure time descriptor is
 missing or wrong.

 There is then added an extra time, input by the user via the `EXPOFF'
 parameter, to give the final adopted exposure time. This extra offset,
 which is added to all the times of the images measured, is intended
 to allow for shutter timing mechanisms which introduce an offset
 between the actual and recorded exposure times.

}\sstdiytopic{Star RA and Dec}{
 The program takes the position of the star either to be the
 position in the standards file, precessed to the date of the
 observation, or the RA, Dec of the image as noted in its header.
 This second method depends on the telescope pointing being good
 and the offset of the star in the image from the (RA,Dec)
 reference point not to be too large.

 If both the standard file and image position descriptors are
 present, then the user has the option of deciding which will
 be used to determine the position.

}\sstdiytopic{Sec Z}{
  The Sec Z is worked out in first order terms as:-

  $$  SecZ =  \frac{1.0}{sin(lat)*sin(dec)+cos(lat)*cos(dec)*cos(ra-sidt)} $$

}\sstdiytopic{Output}{
 The output of the program is typed to the terminal, and can optionally
 be output to a text ASCII file (with a .DAT modifier). The file contains
 a copy of what is put out to the terminal, except that there is one line
 of header information at the start.

 The listing below gives an example of the output:-

 {\bf Example Output of AUTOMAG }

\rule{5in}{0.2mm}

\hspace{2ex} Image name is :-  fred{\undersc}1 \\
\hspace{3ex}\begin{tabular}{lllllllll}
   Star     &X      &Y        &Top     &Mag   &Rms    &Sk1   &Sk2 \hspace{3ex}  Sk3   &Sk4 \\
      1    &100.0  &100.0    &1000.0  &23.263 &0.003 &-0.001 &0.002-0.003 &0.003 \\
\end{tabular}


\hspace{3ex}\begin{tabular}{llll}
  Filter:= V &Sec Z= 1.059  &:Exp time= 101.000 & \\
  Image:-    &RA= 13  0 29  & :Dec= +12 12 12   &:Sid T= 12 34 56 \\
   File:-    &RA= 12 13 23  & :Dec= +11 27 30   & \\
\end{tabular}

\hspace{3ex}\begin{tabular}{llll}
  Raw Mag    & Sec Z Corrected    & Std    & Mag-Std \\
      23.263 &   23.245         & 18.100   & 5.145 \\
\end{tabular}

\rule{5in}{0.2mm}

  Comments:-

  \begin{list}{{-}}{}
   \item The `Sk1', `Sk2', etc., give the corrections that would have to be
      added to the mean magnitude, if the sky level in the associated
      sky aperture alone were to be used to estimate the sky level.
    \item In this particular case, the `File' position was selected to be
      used instead of the `Image' position in calculating the SecZ.
    \item The final magnitude has been calculated using the mean sky
      level from all four sky apertures, as they all lie with a user
      input tolerance (usually +/- 10\%) of the mean.
    \item The exposure time put out is the image exposure time (perhaps
      changed by the user) plus the offset input by the user via the
      `EXPOFF' parameter. It is then time used in the calculations.
   \end{list}

}\sstparameters{
\sstsubsection{AVLIM = {\undersc}REAL (Read)}{
  (Default - 0.1 \hspace{6ex}  Range 0.0 - 1.0e8)


  When averaging the flux estimates of the star when subtracting
  each of the (up to) four sky levels, how far away (in fractional terms
  - roughly magnitudes) can a measure be from the mean of the two nearest
  pair of estimates? If an estimate is more than 'avlim' times the mean
  flux, it is rejected and the mean recalculated. This stops if none are
  that far away of if only two estimates left.

}\sstsubsection{BOX = {\undersc}INTEGER (Read)}{
  (Default - 100       \hspace{6ex}           Range - 1 to 10000)

  Side of box within which to search for a star's pixels.

  The search for contiguous pixels above the threshold level which
  denote a star is only done in a box of this size. This box is such
  that the first pixel found (in a search along X lines, goin up in
  the Y direction line-by-line), is centered in the box in the X
  direction, and at the bottom of the box in the Y direction.

  If the box is too large, the search takes too long. If it is too
  small (in relation to the star image size), then star pixels may be
  missed, skewing the location of the centroid.

  The default is probably a good compromise for `normal' images. However
  for very out-of-focus images, the star `size' may be larger than than
  100 pixels, so you should select a larger box.

}\sstsubsection{DATE = LITERAL (Read)}{
  (Default - `2001/01/01'         \hspace{6ex}  Range - see below)

  The date of the observation. This is asumed to be the same for all
  of the images to be used. It is input as Julian epoch number. The
  month must be in the range 01 to 12, and the day 01 to the end of
  the month input. The format must be as the default - `YYYY/MM/DD'.

  This is used to precess the standards file positions to the date of
  the observation, so it does not need to be very precise.

}\sstsubsection{DECNAME = LITERAL (Read)}{
  ( Default - `DEC'          \hspace{6ex}  Choice - see below)

  The name of the descriptor in the image file where the Declination
  of the exposure may be found.

  'none' is valid entry. The Declination will then be got from the
  standards file, if this image has a star name and that name is in it.

}\sstsubsection{DOCENTRE = LITERAL (Read)}{
  (Default - `No'               \hspace{6ex}  Choice - `Yes/No')

  Should the position found by the program be refined by fitting
  a Gaussian to the location?

  The position found by the program is a centroid of the contiguous
  pixels above the threshold level above the overall image sky level.
  (For details on this see the `Method - Star Location' help section.)

  If the star images are reasonably in focus, then it is possible
  to refine this position by fitting a Gaussian with a variable
  profile at that location.

  This gives a more accurate centering, but has the risk that the
  star image may be so strange as to cause the Gaussian fitting
  subroutine to fail catastrophically.

  Also if the stars are not in focus, then the fit may well fail
  or give the wrong position.

}\sstsubsection{DOFILE = LITERAL (Read)}{
  (Default - `No'               \hspace{6ex}  Choice - 'Yes/No')

  Output a copy of the results, which are put on the output terminal,
  to an output text ASCII file?

}\sstsubsection{DOFILT = LITEAL (Read)}{
  (Default - `No'               \hspace{6ex}  Choice - `Yes/No')

  Get the filter information in the image descriptors?

  This is used (together with the calculated SecZ and input extinction)
  to calculate the extinction correction to be applied to the measured
  magnitude.

}\sstsubsection{DOMULT = LITERAL (Read)}{
  (Default - `No'               \hspace{6ex}  Choice - `Yes/No')

  Do calculations on a number of input images (`Yes'), or on just one
  (`No')?

}\sstsubsection{DOSECZ = LITERAL (Read)}{
  (Default - `No'               \hspace{6ex}  Choice - `Yes/No')

  Calculate the zenith distance (as SecZ) of the exposure?

}\sstsubsection{DOSTDS = LITERAL (Read)}{
  (Default - `No'               \hspace{6ex}  Choice - `Yes/No')

  Use the magnitudes in a standards file to calculate the difference
  between the observed magnitude and the standard magnitude?

}\sstsubsection{EXPLOC = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,79                \hspace{6ex}  Range - 1 to 256)

  The location in the image exposure time descriptor of the
  characters which give the exposure time.

  If they are the only characters in the descriptor, then the
  default can be taken.

}\sstsubsection{EXPNAME = LITERAL (Read)}{
  ( Default - `EXPOSED'          \hspace{6ex}  Choice - see below)

  The name of the descriptor in the image file where the exposure time
  of the exposure may be found.

  If `none' is input, then no descriptor is looked for, and the
  time is set at 1.0 seconds.

}\sstsubsection{EXPOFF = {\undersc}REAL (Read)}{
  (Default - 0.0             \hspace{6ex}  Range - -1.0e8 to 1.0e8)

  The offset to add to the exposure time when doing all the
  calculations that involve the exposure time.

  This time is added to the exposure time in the image descriptor
  (possibly modified in the program by the user).

}\sstsubsection{EXTINC = {\undersc}REAL (Read)}{
  (Default - 0.68              \hspace{6ex}  Range - 0.0 to 1.0e8)

The extinction at unit airmass for the filter input by the user.

  These are up to the nine parameters 'EXT1', 'EXT2', ... 'EXT9'
  for the extinctions at unit airmass for the nine possible
  filters whose names are input with the 'FNAME1', 'FNAME2', ...
  'FNAME9' parameters. The matching is asked for each of the 'FNAME'
  parameters input.

  The default extinctions for the first, second, third, ... filters are:-
       0.68, 0.28, 0.15, 0.10, 0.07, 0.10, 0.04, 0.06, 0.06
  which are designed for the UBVRIJHKL extinctions.

}\sstsubsection{ }{
   {\large \bf This is repeated for EXT1 to EXT9 }

   \vspace*{2mm}

}\sstsubsection{FILTLOC = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,79                \hspace{6ex}  Range - 1 to 256)

  The location in the image filter descriptor of the
  characters which give the filter used.

  If they are the only characters in the descriptor, then the
  default can be taken.

}\sstsubsection{FILTNAME = LITERAL (Read)}{
  ( Default - `FILTER'          \hspace{6ex}  Choice - see below)

  The name of the descriptor in the image file where the filter
  of the exposure may be found.

}\sstsubsection{FNAME = LITERAL (Read)}{
  (Default = ` '               \hspace{6ex}  Choice - see below)

 The name (character string) in the image filter descriptor that
  will denote the nth filter name.

  This parameter is asked for repeatedly, until either all nine
  names have been asked for, or until, a null entry is given, meaning
  that there are no more filter names to enter.

}\sstsubsection{ }{
   {\large \bf This is repeated for FNAME1 to FNAME9 }

   \vspace*{2mm}

}\sstsubsection{FSNAME = LITERAL (Read)}{
  (Default = name of image first filter name          \hspace{6ex}  Choice - see below)

 The name (character string) in a column header in the standards table
  file that will denote the matching (to the 'FNAME' filter name) filter
  name in the standards table.

  This parameter is asked for, for each of the 'FNAME1', 'FNAME2', ...
  'FNAME9' entries that are input for possible 'filter name' names
  in the images.

}\sstsubsection{ }{
   {\large \bf This is repeated for FSNAME2 to FSNAME9 }

   \vspace*{2mm}

}\sstsubsection{GAIN = {\undersc}REAL (Read)}{
  (Default - 1.0          \hspace{6ex}  Range - 1.0e8 to 1.0e8)

  The gain of the numbers in the image.

  This is the number of independent, Poissonian, events per pixel
  value. Thus for a CCD it would be electrons/adu.

}\sstsubsection{HEADER = LITERAL (Read)}{
  (Default - ` '         \hspace{6ex}  Choice - see below)

 The line of text to put at the top the output text file.

 This is used as a way of putting a comment into the output file.

}\sstsubsection{IN = SDF (Read)}{
  (Default - null)

  The name of the file containing the input image.

  The input image is a standard ADAM .sdf file.

  It must be either an `short', integer*2 16-bit, or `real', real  32-bit,
  image. It can have the `BSCALE' and `BZERO' pixel value scaling, and
  the bad pixel magic value `INVAL'.

}\sstsubsection{LATITUDE = LITERAL (Read)}{
  (Default - `00 00 00'        \hspace{6ex}  Choice - see below)

  A character string giving the latitude of the observatory where
  the exposure was made.

  This is used in calculating the zenith distance of the observation.
  it must be in the default format. Thus possibilities are:-

\hspace{4ex}\begin{tabular}{l}
    +90 00 00 \\
    +01 59 59 \\
    +00 01 23 \\
    -00 01 23 \\
    -30 00 00 \\
    -90 00 00 \\
\end{tabular}

  It is important that the negative sign should be in the right place.

}\sstsubsection{NOISE = {\undersc}REAL (Read)}{
  (Default - 0.0                \hspace{6ex}  Range - 0.0 to 1.0e8)

  The extra Poisson noise that a pixel value of zero would have.

  Thus after processing, an image pixel values will not be an exact
  value of the input. So the calculations of the errors, which assume
  on the pixel values being Poissonian noise woulf be wrong.

  This is the std. dev. the program should expect for a pixel value of
  zero. Thus if a 'bias level' has been subtracted, this could be the
  'bias noise' value.

}\sstsubsection{NSKY = {\undersc}INTEGER (Read)}{
  (Default - 4                   \hspace{6ex}  Range - 1 to 4)

  The number of sky apertures to use for each star estimate.

  Four is best, but you might not have room for them around the stars.

}\sstsubsection{OBJLOC = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,79                \hspace{6ex}  Range - 1 to 256)

  The location in the image object name descriptor of the
  characters which give the object name.

  If they are the only characters in the descriptor, then the
  default can be taken.

}\sstsubsection{OBJNAME = LITERAL (Read)}{
  ( Default - `OBJECT'          \hspace{6ex}  Choice - see below)

  The name of the descriptor in the image file where the object name
  of the exposure may be found.

  If `none' is input, then no descriptor is looked for, and the
  name is given the value ` '.

}\sstsubsection{OFFSET = {\undersc}REAL(2) (Read)}{
  (Default - (star aperture diameter),0.0      \hspace{6ex}
   Range - 1.0 to 1.0e8)

  The offset in pixels in X,Y from the centre of the star aperture
  to the centre of the first sky aperture.

  These are the (up to) four XY offsets 'OFFSET1', 'OFFSET2', 'OFFSET2',
  'OFFSET4' that are asked for the (up to) four sky spertures, where
  the actual number used is input with the 'NSKY' parameter.

  The offset in pixels in X,Y from the centre of the star aperture
  to the centre of the third sky aperture.

}\sstsubsection{ }{
   {\large \bf This is repeated for OFFSET1 to OFFSET4 }

   \vspace*{2mm}

}\sstsubsection{OUT = ASCII (Write)}{
  (Default = null)

  The name of the file into which a copy of the terminal output, giving
  the results of the program, is to be written.

  This is a new text ASCII file. It will made with a .DAT modifier.

  The file contains a copy of what is put out to the terminal, except that
  there is one line of header information at the start.

 The listing below gives an example of the output:-

 {\bf Example Output of AUTOMAG }

\rule{5in}{0.2mm}

\hspace{2ex} Image name is :-  fred{\undersc}1 \\
\hspace{3ex}\begin{tabular}{lllllllll}
   Star     &X      &Y        &Top     &Mag   &Rms    &Sk1   &Sk2 \hspace{3ex}  Sk3   &Sk4 \\
      1    &100.0  &100.0    &1000.0  &23.263 &0.003 &-0.001 &0.002-0.003 &0.003 \\
\end{tabular}


\hspace{3ex}\begin{tabular}{llll}
  Filter:= V &Sec Z= 1.059  &:Exp time= 101.000 & \\
  Image:-    &RA= 13  0 29  & :Dec= +12 12 12   &:Sid T= 12 34 56 \\
   File:-    &RA= 12 13 23  & :Dec= +11 27 30   & \\
\end{tabular}

\hspace{3ex}\begin{tabular}{llll}
  Raw Mag    & Sec Z Corrected    & Std    & Mag-Std \\
      23.263 &   23.245         & 18.100   & 5.145 \\
\end{tabular}

\rule{5in}{0.2mm}

  Comments:-

\begin{list}{{-}}{}
    \item The `Sk1', `Sk2', etc., give the corrections that would have to be
      added to the mean magnitude, if the sky level in the associated
      sky aperture alone were to be used to estimate the sky level.
    \item  In this particular case, the `File' position was selected to be
      used instead of the `Image' position in calculating the SecZ.
    \item  The final magnitude has been calculated using the mean sky
      level from all four sky apertures, as they all lie within a user
      input tolerance (usually +/- 10\%) of the mean.
    \item  The exposure time put out is the image exposure time (perhaps
      changed by the user) plus the offset input by the user via the
      `EXPOFF' parameter. It is then time used in the calculations.
\end{list}

}\sstsubsection{POSNTYPE = LITERAL (Read)}{
  (Default - `degrees'   \hspace{6ex}  Choice - `degrees/radians/string')

  The format that the RA and DEC entries have in the RA and DEC
  descriptors.

  The `degrees' and `radians' choices are obvious. For the string
  input:-

  \begin{list}{{-}}{}
    \item  the RA numbers must be in the HHxMMxSS.SS format

    \item  the DEC numbers must be in the SDDxMMxSS.SS format
  \end{list}

   where `x' must not be 0-9, `+', `-', or `.'

   the decimal places are optional

}\sstsubsection{RANAME = LITERAL (Read)}{
  (Default - `RA'          \hspace{6ex}  Choice - see below)


  The name of the descriptor in the image file where the Right Ascencion
  of the exposure may be found.

  'none' is valid entry. The RA will then be got from the standards
  file, if this image has a star name and that name is in it.

}\sstsubsection{SIDTLOC = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,79                \hspace{6ex}  Range - 1 to 256)

  The location in the image sidereal descriptor of the
  characters which give the sidereal time.

  If they are the only characters in the descriptor, then the
  default can be taken.

}\sstsubsection{SIDTNAME = LITERAL (Read)}{
  ( Default - `STSTART'          \hspace{6ex}  Choice - see below)

  The name of the descriptor in the image file where the sidereal
  time of the exposure may be found.

}\sstsubsection{SKYDIA = {\undersc}REAL (Read)}{
  (Default - 1/2 the Star aperture diameter     \hspace{6ex}
   Range - 1.0 to 1.0e8)

  The diameter of all the sky apertures in pixels.

}\sstsubsection{STARDIA = {\undersc}REAL (Read)}{
  (Default - 40.0              \hspace{6ex}  Range - 1.0 to 1.0e8)

  The diamter of the star aperture in pixels.

}\sstsubsection{STDMAST = LITERAL (Read)}{
  (Default - `Yes'               \hspace{6ex}  Choice - `Yes/No')

  If you are using the standard magnitudes file and there is
  RA and DEC information in the image descriptors, you have two
  ways of calculating the RA and DEC. In this case, do you want
  to use the standards file positions (`Yes'), or the image
  descriptor positions (`No') ?

}\sstsubsection{STDS = SDF (Read)}{
  (Default - null)

  The name of the file containing the input table of standard star
  positions and magnitudes.

  The file is a \starman table of the positions and magnitudes
  of stars. It has to have:-

  \begin{list}{{-}}{}
       \item  the standard Identifiers (star names)
       \item  the Right Ascension of the star (in radians)
       \item  the Declination of the star (in radians)
       \item  the Equinox of the position (Julian epoch - e.g. 1990.234)
       \item  at least one magnitude
\end{list}

  The magnitudes of different colours must be as magnitudes, not colours.
  I.e., a star with $V=16.00$ and $B-V=1.00$ would have two entries, one
  for $V=16.00$ and one for $B=17.00$.

  The columns containing the magnitudes must have descriptors telling
  what waveband is in each column. In the example above, for example, the
  V column could have a descriptor with `V', and the B column one of `B'.

  The column descriptors must be in the standard \starman table style, as
  HEADxxx, where xxx = 001, 002, etc. Thus in the example above the
  descriptors would be:-

\hspace{4ex}\begin{tabular}{|l|l|}\hline
name & content \\ \hline
HEAD001 &  RA \\
HEAD002 &  DEC \\
HEAD003 &  EQUINOX \\
HEAD004 &  V \\
HEAD005 &  B \\ \hline
\end{tabular}

}\sstsubsection{THRESH = {\undersc}REAL (Read)}{
  (Default - 100.0                \hspace{6ex}  Range - 1.0e-8 to 1.0e8)

  The threshold, above the mean sky level for the entire image,
  when a pixel which is above that value is considered to be part
  of a star.

}\sstsubsection{TIME = {\undersc}REAL (Read)}{
  (Default - image exposure time             \hspace{6ex}  Range - 0.0 to 1.0e8)

  A chance to correct the exposure time read off the image.

  The actual time used in the calculations is this time plus the `exposure
  time offset`, input via the `EXPOFF' parameter.

}}}




\addcontentsline{toc}{subsection}{ Average}


\ajhsect{\arabic{section}}{General Programs - \hspace*{0.2in} AVERAGE}

\sstroutine{AVERAGE}{Averages the Magnitudes from Different MEASURE Outputs}{


\sstdescription{
 This takes the output tables created by the stellar photometry
 program MEASURE (or any other program), and averages them to a table
 with weighted mean magnitudes. It also makes a text file with the
 details of the averaging.

 It can do this automatically, or the user can modify some of the
 rejection and averaging procedures.

}\sstdiytopic{Method}{

\begin{description}

\item[1)] Criteria for rejecting measures for intrinsic faults are input by
    the user. Then in the rest of the calculations star measures which
    violate these criteria are ignored.

\item[2)] The program calculates, for each (excluding the first) input
    table, the mean difference in star magnitude of the measures in
    the table from those in the first input table. This gives the
    'zero-points' of the magnitudes in each table compared to the
    first table.

\item[3)] Optionally, the user can refine the `zero-points'. The
    program plots out, for each input table, the scatter of these
    differences, relative to the 'zero-points'. The user can then put
    (via cursor and/or keyboard) in more accurate values for the
    'zero-points'.

\item[4)] These mean differences are subtracted from the magnitudes in
    the tables, putting them all on the zero point of the first table.

\item[5)] The rejection criteria for discarding magnitude estimates are set
    up. This is either done either interactively by setting discordance
    limits at each magnitude range, or automatically, by calculating
    these discordance limits or by using the input magnitude error
    estimates.

\item[6)] Weighted means are made for each star of its magnitudes from the
    input tables. At this point discordant input magnitudes may be
    rejected.

\item[7)] Some of the other parameters in the input tables (See the help
    on the input and output files to see which) are noted.

\item[8)] The results are then put to the output file.

    A text file can also be made which gives some the details of the
    actual star by star averaging and measure rejection.

\end{description}

}\sstdiytopic{Making Means}{
 A mean magnitude is made for a star by:-

\begin{list}{{-}}{}

 \item Taking all the magnitudes from the input tables.

 \item Discarding those magnitudes where the fit parameters for the star in
   that particular input table suggest the measure is `bad'. This
   method is here refered to as `intrinsic' rejecting.

 \item Taking all the good measures and calculating a weighted mean. This
    is done in a complex way:-

   \begin{list}{{-}}{}
    \item The weights are from the input error for the star in each table
      (subject to a switch `usesigma' and a minimum limit- see
       `sigmamin').

    \item A rejection method is used for discarding measures which lie
      significantly away from the mean. This method is here refered to
      as `means' rejecting. This `means' rejecting may be done in one of
      three ways.
    \end{list}

\end{list}

}\sstdiytopic{Use of Weights}{
 The weights are from the input error for each star in each table.

 The weighting may be switched off and the unweighted means used (see
 `usesigma'). A minimum error may be set, so that any input error less
 than that minimum is set at that minimum (see `sigmamin').

 Whether to use weights or not, and if so, what value to give to
 `sigmamin' will depend on your estimate of the validity or otherwise,
 in each case, of the input error estimates.

 This method should only be used if the errors in the input magnitude
 files are good estimates. MEASURE caclculates this error but it is
 only correct if the correct noises and gains have been input to the
 MEASURE runs, and there were no other contributory sources of error.
 It is advisable to check on this, and you can do so by having a trial run
 with the `means' rejecting method, when the input errors are plotted
 against those found from the scatter between files.

}\sstdiytopic{Rejection -- Intrinsic }{
 A star magnitude estimate from a particular input file can be
 rejected by some of the other characteristics of the fit it was made
 in. These are:-

\begin{list}{{-}}{}
 \item star centering in fit
 \item no of iterations taken in the fit
 \item chi-squared of the fit
 \item theoretical error estimate
 \item important companions
 \item invalid pixels in fit area
\end{list}

 The extent to which these have to be `good' is under the user's
 control.

}\sstdiytopic{Rejection -- `Means'}{
  The basic technique here is to look at the scatter of the
  magnitude estimates, for a star, from the input tables. Then
  estimates which diverge too much from the mean are rejected.

  There are three methods of this `means' rejecting, which are, in essence,
  two ways of defining what is meant by `too much':-

\begin{list}{{---}}{}
  \item {\bf `Default' method}

      An estimate is only rejected if it lies more than 0.5mag from the
      mean.

  \item {\bf Scatter between the different estimates}

      For its magnitude, it differs from the mean by more than the
      level set for the user (or a default 0.5mag) for that magnitude
      value.

  \item {\bf Theoretical expected error in each magnitude estimate}

      This method should only be used if the errors in the input
      magnitude files are good estimates. MEASURE caclculates this
      error but it is only correct if the correct noises and gains
      have beeb input to the MEASURE runs, and there were no other
      contributory sources of error. It is advisable to check on
      this, and to look at the check plot described below.

      Use the error estimate from MEASURE for a star for each file:-

      \begin{enumerate}
      \item The weighted mean magnitude for this star from all the files
         (after the zero point corrections) is calculated.
      \item The theoretical error in the mean (from taking all the input
         errors for this star from all the files) is calculated. This
         takes the input error estimates and does the proper
         calculation - akin to sqrt(sum[sigma.sigma]/((n-1)(n-2))) - to
         calculate what error in the mean magnitude should be expected
         from magnitudes having those errors.
      \item This theoretical error expected for this star from this file
         is noted.
      \item The difference of the magnitude for this star from this file
         from the mean is calculated.
      \item The number of standard deviations (diff/theoretical error)
         from the mean that this difference represents is calculated,
         using the calculated errors in the mean and in this measure.
      \item If this number of std. devs. is larger than a (user input -
         ERRMUL parameter) certain value, then that magnitude for that
         star from that file is rejected.
      \item There is also a (user input - ERRLIM parameter) minimum value
         below which the `calculated error' cannot fall. This stops
         unrealistic error estimates causing false rejections.
      \end{enumerate}

      If this method is adopted, then a plot is displayed of the `found
      error' (the difference of a single magnitude estimate from the
      mean magnitude) versus the `calculated error' (the expected
      value of this difference). The plot should show a linear
      relation with a slope of one. The `found errors' should scatter
      about the `calculated error'.

      If the plot looks OK, but the slope is not unity, then a
      conversion factor is needed to convert the input error estimates
      into true ones. Read this from the slope, and input it via the
      `ERRFAC' parameter.

      If the plot looks strange, then there is probably something
      strange about the input error estimates from MEASURE, and this
      method should be viewed with suspicion.

\end{list}

}\sstsubsection{Scatter between Files}{
 This sets at each magnitude (on the zero point of the first table) a
 maximum difference from the mean that is allowed, and then for each
 star to reject all measures that exceed that difference for the star.


 A histogram is calculated of the differences from the means of
 all the measures at each magnitude level.

 Then either an interactive selection of the rejection difference
 made, by plotting the histogram and the user selecting via a cursor
 the value, or automatically, by calculating the `width' of this
 histogram and using the user input multiplier of this width to
 select a value.

 The rejection is done star-by-star, with the most divergent star
 (weighted inversely by a magnitudes tolerance level - remember
 `Errlim') being rejected first. Then the mean is recalculated, and
 the process started again, with all previously rejected stars not
 used. This process continues until no more stars are rejected.

}\sstsubsection{Theoretical Errors}{
 This, for each star and each table, looks at the input calculated
 theoretical error as given in the tables, and then to reject that
 measure if it is farther from the mean by some constant times that
 theoretical error. Thus one might want to reject all star measures
 more than three input theoretical standard deviations from the mean of
 all the measures.

 A problem is that the input theoretical errors may not be a good
 indicator of the actual errors. To help in evaluating this, the
 program, for each table, plots out the run of the theoretical error
 of a measure in a list of a star versus the error calculated from the
 scatter in the measures of that star in the all the tables. (This is
 actually done in bins of the theoretical error levels.) The user can
 then see if there is any systematic difference.

 If there is (say the difference errors are commonly twice the
 theoretical ones) then the rejection criteria can be adjusted (in
 this example by doubling the limit), if the user wants to believe the
 difference errors.

 There is also the option to accept up to a certain limit, even if
 the theoretical errors indicate a smaller limit. Thus for very
 well-exposed stars, a theoretical error limit of 0.002mag may be
 indicated, but the user might well feel that measures differing by
 0.01mag are realy ok.

 Thus after the plot is displayed, the user inputs via the keyboard the
 factor to multiply the theoretical errors to get the rejection limit,
 also the minimum rejection limit.

}\sstsubsection{Which is Better?}{
 The scatter method is a good method when the input tables are all on
 roughly the same zero point, as it shows and uses the actual errors
 being encountered.

 However, if the tables have different zero points, then a measure from
 a long exposure will have a smaller error than one from a short one,
 and one would wish to use stricter criteria in rejecting it. Thus the
 theoretical method is better. The trouble with using the theoretical
 method is that the theoretical errors are not perfect indicators of
 the actual errors, and so should only be used (as described above)
 when the input errors are valid.

}\sstdiytopic{Star Names}{
 The files can either have the same stars in the same order (the
 default assumption), in which case there is a simple one-to-one
 correspondance between the stars in the input files and those in the
 output file.

 Or the star names in each file can be matched up. Then the output file
 has all the stars mentioned in all the input files. (Duplicate names
 in any file but the first are to be avoided.) The output file
 magnitudes are then means of those estimates in the input files that
 have estimates for those stars.

 The order of stars in the output file in this case, is:-

\begin{list}{{-}}{}
   \item The order of stars in the 1st input file
   \item The order of any stars in the 2nd input file that were not in the
       1st file
   \item The order of any stars in the 3rd input file that were not in the
       1st file or the 2nd file
   \item       etc
\end{list}

}\sstdiytopic{Automatic Use }{

There are two ways of running this program, automatic and
interactive:-

\begin{description}

\item[auto]  The program runs through on the parameters input by the
            user at the start of the program.

\item[inter] The user interacts with the program, in addition to the
            input parameters. The interactions are through graphs:-

  \begin{description}
   \item[a)] to refine the `zero-point' differences between the files
               calculated by the program.

   \item[b)] to select the rejection criteria (for each magnitude level)
               in using the scatter between estimates of a star, to
               reject estimates as being too far from the mean.

   \item[c)] If the user selects using the errors calculated by
               MEASURE, then the program plots a graph using these
               errors and those calculated by the scatter between
               measures of each star. The user uses this to put in
               a correction factor to make the input errors proper.
               (As I have always felt doubtful of the MEASURE error
               calculations.)

  \end{description}
\end{description}

}\sstdiytopic{Rejection Criteria}{

 A star magnitude estimate from a particular input file can be
 rejected by some of the characteristics of the MEASURE fit it
 was made in. These are:-

\begin{description}
  \item[a)] Star found far from input position, in terms of the stellar radii.
  \item[b)] MEASURE took too many iterations to make the fit.
  \item[c)] Too many INVALID pixels in the area fitted when fitting.
  \item[d)] Chi squared value too high.
  \item[e)] Too many 'companions' to fit.
  \item[f)] The error calculated by MEASURE.
\end{description}

 The extent to which these have to be 'good' is under the user's
 control.

 A further rejection for each star can be done by the scatter of
 the estimates from the input files. Any that are too far from the
 mean can be rejected.

}\sstdiytopic{Use of Graphics Buttons}{
  To mark a  point on a graph, place the cursor at the desired point,
  and press any of the appropriate buttons.

  To end the selection of points, place to the left of the Y-axis and
  press a button.


}\sstparameters{

\sstsubsection{AGAIN = LITERAL (Read)}{
  (Default - `No' \hspace{6ex} Choice - `Yes/No')

   Flag for redisplaying plot and reusing cursor.

}\sstsubsection{CENACC = LITERAL (Read)}{
  (Default - `No'     \hspace{6ex}    Choice - `Yes/No')

  Flag for accepting a star measure if its only fault is that it is
  too far off centre.

}\sstsubsection{CHIPRIN = {\undersc}REAL (Read)}{
 (Default - 1.0   \hspace{6ex}    Range - 0.0 to 1.0e10)

 Factor for use on the printing of the matches. The Chi-squareds are
 printed as integers. If they are small you may want them put out
 multiplied by a factor so that they dont all look like `0's, `1's,
 `2's, etc.

}\sstsubsection{ERRFAC = {\undersc}REAL (Read)}{
  (Default - 1.0      \hspace{6ex}     Range - 0.0 to 1.0e9)

  When using the input magnitude error estimates to see which input
  magnitudes for a star to reject, this is the factor to multiply
  the input error estimates for a file to get `true' estimates.

  You will already have used a graph to show the relationship
  between the input estimates and the `true' values, as found from
  the scatter between the input magnitudes for this file and the mean
  from all the input files. This will have then given you the
  factor.

}\sstsubsection{ERRLIM = {\undersc}REAL (Read)}{
  (Default - 0.01      \hspace{6ex}      Range - 0.0 to 1.0e9)

  Used when using the input magnitude error estimates to see which
  input magnitudes for a star to reject.

  This is the value for the minimum tolerance level.

  This parameter says that this value is then checked to see if it
  is at least as big as `ERRLIM', and if not, then increased to that
  value. This stops a number of unrealistically small input error
  estimates setting a too stringent check level.

}\sstsubsection{ERRMUL = {\undersc}REAL (Read)}{
  (Default - 3.0       \hspace{6ex}     Range - 0.0 to 1.0e9)

  Used when using the input magnitude error estimates to see which
  input magnitudes for a star to reject.

  The number of standard deviations (of the input error estimates for
  stars in this file) that an input magnitude can be and still be
  accepted.

}\sstsubsection{FILENUM = {\undersc}INTEGER (Read)}{
  (Default - next        \hspace{6ex} Range - 0 to number of input files)

  When calculating the relationship between input error estimates and
  `true' errors, this calculation should be done for all files. This
  parameter allows you to calculate it in any order and to recalculate
  the factors for a file.

}\sstsubsection{FPRINT = TEXT FILE (Write)}{
  (Default - ` '        \hspace{6ex}        Choice - any)

  The name of the file to take the text version of the output. This
  has much informative information that is not in the main table
  output.

  A null response means that no such file is produced.

}\sstsubsection{GTYPE = LITERAL (Read)}{
  (Default - `ask'  \hspace{6ex}            Choice - any)

  A character string giving the local name for the graphics
  display type.

  `xwindows' will put it out on the screen of your workstation,
  if you are using one.

  If `ask' is input, then the program asks a very similar question,
  in a different way. A response here of `?' will bring up a listing
  of all the possible names of graphics devices which are supported
  on your machine, and you then input the appropriate name.

}\sstsubsection{IN =  NDF (Read)}{
  (Default - null)
 The names of the input files containing the star magnitude tables.

 These are \starman NDF Table format files.

 These parameters are actually IN1, IN2, IN3, ...., IN50.

 After the first one, you can end the repeated asking for input files
 by responding with just the 'return' key, that is a null input.

}\sstsubsection{INCHI = NDF (Read)}{
  (Default - null)

The name of the file containing the table of Chi-squared values, at
 0.2mag steps, above which a star is rejected.

 These are \starman NDF Table format files.

 These parameters are actually INCHI1, INCHI2, INCHI3, ... INCHI50.

 These tables, if used, must have the Chi-squared value of the
 faintest mag first, and be in steps of 0.2mags starting at the faint
 mag.

 If there are less than 100 values in the table, then the
 Chi-squared values are filled up to 100 values with the last value.
 Values after the first 100 values are ignored.

 Such files are automatically produced by Chi (qv).

}\sstsubsection{LINECOL = LITERAL (Read)}{
  (Default - `black'  \hspace{6ex}       Choice - `black:white')

 Colour of plot lines. This is determined by whether you have a
 black or white background to your plots.

}\sstsubsection{MEANREJ = LITERAL (Read)}{
  (Default - `mag'  \hspace{6ex}       Choice - `mag:error:default:ok')

  Method to reject a magnitude for a star from a particular file
  because its value (after the file mean correction) differs too
  much from the mean of the measures from all the files (including
  the file itself).

  This defines the `means' rejecting method.

  This is asked for repeatedly. At the start the `default' of
  0.5 mag is set up. You can then set up any of the three ways.
  When you are happy, reply `ok' to continue to the next step.

  This rejection can be done in one of three ways.

 {\vspace*{2mm} \bf 1. \hspace{4ex} `Default'  \vspace*{2mm}}

   If mag is more than 0.5 from the mean.

 {\vspace*{2mm} \bf 2. \hspace{4ex} `Mag'  \vspace*{2mm}}

   For its magnitude, it differs from the mean by more than
   the level set for the user for that magnitude value.

              The tolerance levels are user input by the program
              calculating (at unit magnitude steps) histograms  of the
              scatter of magnitude estimates from the mean. The user
              then looks at these histograms and sets tolerance levels
              where the outliers are rejected.

 {\vspace*{2mm} \bf 3. \hspace{4ex} `Error'  \vspace*{2mm}}

{\bf See the warning about this method in the sections on `Method'
     and `Making Means'}

      This method should only be used if the errors in the input
      magnitude files are good estimates. MEASURE caclculates this
      error but it is only correct if the correct noises and gains
      have beeb input to the MEASURE runs, and there were no other
      contributory sources of error. It is advisable to check on
      this, and to look at the check plot described below.

              Use the error estimate from MEASURE for a star for each
              file:-

               \begin{enumerate}
               \item The weighted mean magnitude for this star from all
                  the files (after the zero point corrections) is
                  calculated.
               \item The theoretical error in the mean (from taking all
                  the input errors for this star from all the files) is
                  calculated.
               \item This theoretical error expected for this star from
                  this file is noted.
               \item The difference of the magnitude for this star from
                  this file from the mean is calculated.
               \item  The number of standard deviations (diff/theoretical
                  error) from the mean that this difference represents
                  is calculated, using the calculated errors in the
                  mean and in this measure.
               \item If this number of std. devs. is larger than a (user
                  input - ERRMUL parameter) certain value, then that
                  magnitude for that
                  star from that file is rejected.
               \item There is also a (user input - ERRLIM parameter)
                  minimum value below which the `calculated error'
                  cannot fall. This stops unrealistic error estimates
                  causing false rejections.
               \end{enumerate}

               If this method is adopted, then a plot is
               displayed of the `found error' (the difference of a
               single magnitude estimate from the mean magnitude)
               versus the `calculated error' (the expected value of
               this difference). The plot should show a linear
               relation with a slope of one. The `found errors' should
               scatter about the `calculated error'.

               If the plot looks OK, but the slope is not unity, then
               a conversion factor is needed to convert the input
               error estimates into true ones. Read this from the slope,
               and input it via the `ERRFAC' parameter.

               If the plot looks strange, then there is probably
               something strange about the input error estimates from
               MEASURE, and this method should be viewed with suspicion.

}\sstsubsection{NAMES = LITERAL (Read)}{
  (Default - `no'   \hspace{6ex}        Choice - `yes:no')

  Take the individual measures from the input files by matching
  up the names of the stars in the files.

  If `no' is taken, then it is assumed that each file contains the
  same stars in the same order.

}\sstsubsection{NEWMEAN = {\undersc}REAL (Read)}{
  (Default - default value     \hspace{6ex}      Range - -1.0e10 to 1.0e10)

  After finding the new mean difference between file magnitude systems
  by using the graph plot, the found value can be corrected by this
  parameter.

}\sstsubsection{NUMINV = {\undersc}INTEGER (Read)}{
  (Default - 0         \hspace{6ex}    Range - 0 to 1000000)

 The maximum number of `invalid' pixels noted in a star fit that will
 be allowed for saying the star magnitude is acceptable.

}\sstsubsection{NUMITS = {\undersc}INTEGER (Read)}{
  (Default - 29       \hspace{6ex}     Range - 0 to 100)

 The maximum number of iterations done in a star fit that will be
 allowed for saying the star magnitude is acceptable.

}\sstsubsection{OFFCEN = {\undersc}REAL (Read)}{
   (Default - 2.0      \hspace{6ex}      Range - 0.0 to 1000.0)

 Distance, in multiples of the stellar radius, in X or Y that the star
 position can be from the fit starting position for saying the star
 magnitude is acceptable.

}\sstsubsection{OUT = NDF (Write)}{
 (default - null)
 The name of the new output file containing the mean magnitude table.

 This is a \starman NDF Table format files.

}\sstsubsection{PLHISTX = {\undersc}REAL(2) (Read)}{
  (Default - 0.0,0.5    \hspace{6ex}        Range - 0.0 to 1.0e8)

 The range of differences of individual magnitude estimates from
 the mean to plot out in the histogram of number of stars with
 such differences.

}\sstsubsection{PLHISTY = {\undersc}REAL(2) (Read)}{
  (Default - 0.0,1.2*max number    \hspace{6ex}   Range - 0.0 to 1.0e8)

 The range of numbers of individual magnitude estimates with
 values differing from the mean in certain ranges to plot out
 in the histogram of number of stars with such differences.

}\sstsubsection{PLOTXLIM = {\undersc}REAL(2) (Read)}{
  (Default - -5\%,+10\% of actual range     \hspace{6ex}    Range - -1.0e8 to 1.0e8)

  The range of magnitudes to plot out in the graph of differences,
  of individual magnitudes from the means, versus magnitude.

}\sstsubsection{PLOTYLIM = {\undersc}REAL(2) (Read)}{
  (Default - -5\%,+10\% of actual range    \hspace{6ex}     Range - -1.0e8 to 1.0e8)

  The range of differences to plot out in the graph of differences,
  of individual magnitudes from the means, versus magnitude.

}\sstsubsection{SIGMALIM = {\undersc}REAL (Read)}{
  (Default - 0.5       \hspace{6ex}       Range - 0.0 to 100.0)

 Maximum overall value of the star error that will be allowed for
 saying the star magnitude is acceptable.

}\sstsubsection{SIGMAMIN = {\undersc}REAL (Read)}{
  (Default - 0.01       \hspace{6ex}      Range - 0.00001 to 100.0)

 The minimum `true' acceptable error value for a star. This is in
 (+/-)magnitude.

 If a star in an input table has an error less than this, the error is
 read in as though it were this minimum error.

 This is used as the errors are calculated as Poisson noise. This is,
 for bright stars, often less than the real errors, which have error
 sources such as flat-field errors, etc. Thus a bright star might have
 such a low error that the weighted averaging would place undue weight
 on that particular measure.

 Generally, if you are uncertain about whether the input error estimates
 are valid, then a high value of `sigmamin', say 0.05mag, is a good idea
 as this will weight all stars equally, except those that have a very
 high error estimate (in this case above 0.05mag).

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - `Output from Average')

 The Title to be added as a descriptor to the output file containing
 the mean magnitude table.

}\sstsubsection{USE = LITERAL (Read)}{
  (Default - `inter'   \hspace{6ex}        Choice - `auto:inter')

\begin{description}

\item[auto]  The program runs through on the parameters input by the
            user at the start of the program.

\item[inter] The user interacts with the program, in addition to the
            input parameters. The interactions are through graphs:-

  \begin{description}
   \item[a)] to refine the `zero-point' differences between the files
               calculated by the program.

   \item[b)] to select the rejection criteria (for each magnitude level)
               in using the scatter between estimates of a star, to
               reject estimates as being too far from the mean.

   \item[c)] If the user selects using the errors calculated by
               MEASURE, then the program plots a graph using these
               errors and those calculated by the scatter between
               measures of each star. The user uses this to put in
               a correction factor to make the input errors proper.
               (As I have always felt doubtful of the MEASURE error
               calculations.)

  \end{description}
\end{description}

}\sstsubsection{USECHI = LITERAL (Read)}{
  (Default - `No'     \hspace{6ex}     Choice - `Yes/No')

 Flag for testing the chi-squared value when deciding to use a
 magnitude estimate.

}\sstsubsection{USESIGMA = LITERAL (Read)}{
  (Default - `No'     \hspace{6ex}     Choice - `Yes/No')

 Flag for using the input magnitude error estimates to weight the
 input magnitudes in calculating the mean.
}}}


\addcontentsline{toc}{subsection}{ Chi}

\ajhsect{\arabic{section}}{General Programs - \hspace*{0.2in} CHI}

\sstroutine{CHI}{Make a Table of Rejection Chi-squared values}{

\sstdescription{
This takes the output from MEASURE and, using the Chi-squared
  values and the magnitudes, makes a table of the maximum acceptable
  Chi-squared value versus magnitude. This can then be input to the
  AVERAGE program to reject stars with poor fits.

  This can be done either in the automatic mode, or in an interactive
  mode.

  In the automatic mode, it is assumed that in each one-magnitude
  step there are a number of stars with 'good' chi-squared values,
  and a few with higher values. The spread of values is then used
  to determine an upper limit.

  In the interactive mode, a graph of the Chi-squared value versus
  magnitude is plotted out for the stars. The user then uses the
  cursor to define a series of (Magnitude,Chi) pairs. These are then
  used to define a table defining the run of maximum acceptable
  Chi-squared values versus magnitude.

}\sstdiytopic{Use}{
  This is used for deciding which stars in the output of MEASURE
  have residuals which are significantly higher than the average for a
  star of that magnitude and is thus probably a poor measure. It makes
  a file with a table of max acceptable Chi values at different
  magnitude levels levels for use in AVERAGE.

  Before entry, poor measures may be pre-secreened by saying putting
  limits on three of the measure parameters (the number of invalid
  pixels in the star image, the number of iterations taken to fit the
  star, and the distance the star was found from its input position).

  In the interactive mode, the values of Magnitude vs Chi excess are
  plotted out, and the cursor
  is then used to define the highest acceptable Chi value at any number
  of Mag values (up to 1000 positions). The cursor is used to draw an
  imaginary line cutting off the high bad Chis from the low accepetble
  Chis. The line is not plotted out as you mark the points, but when
  you finish, straight lines are drawn between the points displaying
  the line.
  After the Mag,Chi positions have been input by the cursor the program
  interpolates between them and puts constant  values outside them to
  get a smooth limit curve. This line is then plotted. The whole
  display and cursor work can be repeated.

  In the automatic mode, this part is done automatically.

  The program then calculates the values at 0.2mag intervals from the
  faintest mag up to 20mag brighter, and stores them in an output file
  containing a table for use with the AVERAGE program.

  With some data, the chi-squared values increase significantly for
  bright stars. The program looks for such a trend, and if it finds
  it, subtracts a curving base level to make the use of the cursor
  easy. See the HELP section on base level.

}\sstdiytopic{Base Level}{
  With some data, the chi-squared values increase significantly for
  bright stars. The program looks for such a trend, and if it finds
  it, subtracts a curving base level to make the use of the cursor
  easy.

  In such a case, the Chi values plotted are ones scaled down at each
  magnitude value to try and make some allowance for the fact that, for
  bright stars that are perfectly OK, the Chi value is higher than for a
  faint star.

  The value shown is an excess above an estimated typical minimum value
  at each magnitude. The excess values are displayed by fitting to the
  envelope of minimum Chi values  a line of the form

$$           Y = zero + sl.starflux $$

  and displaying the Chi values as

$$            Chi  = zero + \frac{Chi-Y}{\sqrt{error/zero}} $$

  The true Chi values can be seen from the numbers plotted out when
  using the cursor (or by inspection of the output file).

  This makes use of the cursor easy and gives a fair idea of the
  importance of the relative Chi errors.

}\sstparameters{

\sstsubsection{AGAIN = LITERAL (Read)}{
  (Default- `no'  \hspace{6ex}    Choice - `yes:no')

   Do you want to put out the graph again and define a new upper limit
   curve?

}\sstsubsection{ALLSTARS = LITERAL (Read)}{
   (Default - `no'  \hspace{6ex} Choice - `yes:no')

   Flag for accepting a star for plotting out, even if it could be
   rejected. (i.e. as too far from starting posn, or too many fitting
   iterations were taken, or image contained invalid points,  or
   magnitude flagged as 0.0 or 50.0)

}\sstsubsection{DEVLIMX = {\undersc}INTEGER(2) (Read)}{
   (Default - 1,X size    \hspace{6ex}   Range - 1,X size)
   (Whole)

  The X limits of the plots in Chi residuals and Magnitudes.
  (NB. The Chi residuals are those above the allowance curve.)

  Use this to select the range of magnitudes you really want to use.

  The default is for the whole range of magnitudes.

  What you do is to plot the whole range, the first time round, look
  at it, decide what limits you really want, exit from the graph and
  replot using your new limits.

}\sstsubsection{DEVLIMY = {\undersc}INTEGER(2) (Read)}{
   (Default - 1,Y size    \hspace{6ex}   Range - 1,Y size)

  The Y limits of the plots in Chi residuals and Magnitudes.
  (NB. The Chi residuals are those above the allowance curve.)

  Use this to select the range of residuals you really want to use.

  The default is for the whole range of residuals. This shows you the
  overview, but usally you want to look at the residuals near unity,
  and so you should plot just a restricted range.

  What you do is to plot the whole range, the first time round, look
  at it, decide what limits you really want, exit from the graph and
  replot using your new limits.


}\sstsubsection{GRAPH = LITERAL (Read)}{
  (Default - `no'    \hspace{6ex}    Choice - 'yes:no')

  When doing the automatic fitting, put out graph with plot of chi-squared
  values versus magnitude, with rejection limit line?

}\sstsubsection{GTYPE = LITERAL (Read)}{
  (Default - `ask'    \hspace{6ex}    Choice - any)

  A character string giving the local name for the graphics
  display type.

  `xwindows' will put it out on the screen of your workstation,
  if you are using one.

  If `ask' is input, then the program asks a very similar question,
  in a different way. A response here of `?' will bring up a listing
  of all the possible names of graphics devices which are supported
  on your machine, and you then input the appropriate name.

}\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The name of the file containg the input table of fit results.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.


}\sstsubsection{LINECOL = LITERAL (Read)}{
  (Default - `black'    \hspace{6ex}    Choice - 'black:white')

    Colour of plot lines. This is determined by whether you have a
    black or white background to your plots.

}\sstsubsection{NUMINV  = {\undersc}INTEGER (Read)}{
  (Default - 0     \hspace{6ex}        Range - 0 to 1000000)

  If you are going to reject a star for plotting as having too
  many invalid pixels, this is the limit to the number of
  such pixels that is acceptable.

}\sstsubsection{NUMITS = {\undersc}INTEGER (Read)}{
  (Default - 35        \hspace{6ex}     Range - 0 to 1000)

  If you are going to reject a star for plotting as having had
  too many fitting iterations, this is the limit to the number of
  iterations that are acceptable.

}\sstsubsection{OFFCEN = {\undersc}REAL(2) (Read)}{
   (Default - 2.0          \hspace{6ex}    Range - 0.0 to 1.0e10)

   If going to reject a star for plotting as being too far from
   the starting position in the fitting, this is the distance away
   in X or Y that is the limit of acceptance

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

  The name of the file to contain the output table.

  The table will be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{TITLE =  LITERAL (Read)}{
  (Default - input table title, or `Output from Chi' \hspace{6ex} Choice - any)

  The charcter string to put into the output table as a title.

}\sstsubsection{USE = LITERAL (Read)}{
  (Default - `auto'    \hspace{6ex}    Choice - 'auto:inter')

Select the automatic mode of operation, or the interactive mode?

}}}





\addcontentsline{toc}{subsection}{ Diagram}

\ajhsect{\arabic{section}}{General Programs - \hspace*{0.2in} DIAGRAM}

\sstroutine{DIAGRAM}{Plot out Colour-Magnitude or Colour-Colour Diagram}{

\sstdescription{
 This plots out an HR or Two-Colour diagram from tables containing
 star magnitude data. It can also output a file containing the
 plotted values.

 There can be up to 48 input files open at once (if your computer set
 up allows this. Many systems will have lower limits).



}\sstdiytopic{Running the Program}{


 There are two options when running 'diagram', selected by your
 answer to the 'easycmd' parameter:-

\begin{description}
 \item[1) Easycmd='yes']

    Do a standard run through to plot a CMD: -

    The program asks for the input to take two tables and put a CMD
    up on the x-windows window. The program then asks for further
    options, expecting the answer - 'exit'.

    If you put the `${\backslash}{\backslash}$` on the command line,
    the program will then end, leaving the CMD displayed in its
    window.

    If you choose to continue, you will find yourself in the middle
    of 'easycmd=no' mode, being repeatedly asked what you want to do
    through the 'option' parameter. You should choose the 'panel'
    option, and then interact with the program through the 'panel'.

\item[2) Easycmd='no']

    Do what you want: -

    The program first asks you if you want to plot a CMD or a
    colour-colour diagram. You choose, and then the program asks
    for what are the 'codes' of which colours to plot.

    After this, the program goes in the looping 'options' mode,
    repeatedly asking which option of action you want to do.

    It suggests a sequence of options which will normally get you
    the inputs needed for making and displaying the plot. If you
    accept these options all will go well. (You can, of course,
    choose diferent options if you wish to.)

    After this, all options are open. The program will suggest
    selecting the 'panel' option, where the options are available
    by pressing 'buttons' on a window. This is quite handy, and
    an in-screen help is displayed, as your cursor moves over the
    different buttons.

\end{description}

}\sstdiytopic{Method}{

 The program works on `sets' of tables. Each set is loaded with data
 from (up to four) tables, each list of data of the magnitudes in a
 particular colour comes from a column of data in one of the tables.
 The tables with the data for an individual set must each contain the
 same stars in the same  order. Each set can hold up to 10 000 stars.

 Up to twelve sets can be handled.

 Only the data from one set is plotted out (or written to file) at
 any one time, but the other sets can accessed at will, and added
 to the diagram. They would however, if stored, be output to different
 files.

 The extent of the diagram (in the sense of the output values) is
 under user control, and the diagram can be cleared and plotting
 started again.

 The plotting and storing is done as:-

\vspace*{2mm} \begin{tabular}{ll}
  CMD & `$Col_{2}$' vs `$Col_{3}$ - $Col_{4}$ '  \\
  Two-colour & `$Col_{1}$ - $Col_{2}$' vs `$Col_{3}$ - $Col_{4}$' \\
 \end{tabular}\vspace*{2mm}

 For example, as V vs  B-V or  R  vs  R-I  or U-B vs B-V.

 Any single character descriptors may be assigned to the colours by the
 user.

 The location of points can be found using the cursor.

 Lines can also be drawn on the diagram from keyboard, cursor or
 file table posns.


}\sstdiytopic{Options}{

 The choice of action to do next is defined by the 'option'
 chosen. These options are also available through the 'panel'
 push-button mode, on choosing the 'panel' option.

\vspace*{2mm}\begin{tabular}{|l|l|}\hline
  Option      &  Function \\ \hline
  clear       &  Clear plot \\
  close       &  Close the graphical device \\
  colour{\undersc}eqn  &  Change colour equation applied to input colours \\
  cursor      &  Get XY positions from graph with cursor \\
  dotnumber   &  Set whether numbers are plotted with points \\
  exit        &  Exit from this program \\
  getdata     &  Get the tables with the magnitudes in them \\
  line        &  Put line onto graph. \\
  mag{\undersc}limits  &  Star Magnitude ranges allowed to be plotted \\
  nearest     &  Get information on a star by putting cursor on it \\
  numgood     &  Number of good measures for plotting a star \\
  open        &  Open the plot device \\
  panel       &  Switch between panel and keyboard option selection \\
  plot        &  Plot the data as points on the graph \\
  plot{\undersc}limits &  Set the range of the graph axes in X and Y \\
  plot{\undersc}range  &  Set the range of data in X and Y to be plotted \\
  setnumber   &  Data set these setups apply to \\
  store       &  Store the present plotted data set as a table file \\
  symbol      &  Set the symbol plotted as points \\
  zero{\undersc}point  &  Change zero points applied to input colours \\
\hline\end{tabular}\vspace*{2mm}

  There is also the big 'HELP' button.

  When using the cursor to find magnitudes/colours of positions
  on the graph, place the cursor on the desired location, and
  press any keyboard key. To end, place the cursor to the left
  of the origin and press any key.

}\sstdiytopic{Colour Equation and Zero Point}{
 Each set can have its input magnitudes corrected by the following
 equation:-

$$        Col1_{n}  = Zero_{n}  + Col_{n}  + K_{n}.(C_{3}-C_{4}) $$

 Where $Col1_{n}$  is the corrected version of input colour $Col_{n}$  and the
 values $Zero_{n}$  and $K_{n}$ are input by the user. `n' runs from 2 to 4
 for a colour-magnitude type diagram, and from 1 to 4 for a colour-colour type
 diagram.

 As you can see, the colour correction is in terms of the `raw'
 magnitudes $C_{3}$  and $C_{4}$

}\sstdiytopic{Cursor}{
 The plotting software package, PGPLOT,  defines the cursor movement
 and marking of position by the appropriate method for the device being
 used. If you are uncertain about how to use the cursor, ask your
 local computer expert.

}\sstdiytopic{Input}{
 If a waveband is required twice (i.e. V in V vs B-V) the table and
 column with that waveband is only asked for once.

}\sstdiytopic{Input Controls}{
 Conditions may be imposed on which stars in a set are accepted
 for plotting. All stars are stored, but have an acceptance/rejection
 flag showing whether they would have been plotted.

 These are:-

\begin{list}{{-}}{}
  \item {\bf Raw magnitudes:} \hspace{2ex}
                       The acceptable range of input magnitudes in
                       each input waveband in a set can be specified.
                       (The default is 0.1 - 49.0.)

  \item {\bf No of good measures:} \hspace{2ex}
                        Sometimes a table containing a list of
                        magnitudes will for each stars have an entry
                        giving the number of estimates that made that
                        magnitude. (This is the case for the \starman
                        `Average' program output.) Optionally, a
                        magnitude can be rejected if this number is
                        less than a set limit for that waveband in
                        that set. (The default is no checking.)

  \item {\bf Position in Diagram:} \hspace{2ex}
                       The output (to plot or file) processed
                        magnitude/colour or colour/colour may be subject
                        to a test for location as lying in given
                        rectanglular region.
\end{list}

}\sstdiytopic{Option Input}{
  The options can be selected by responding at the keyboard to the
  `OPTION' question, or, if you are working at a workstation, using
  a panel of buttons. These options are toggled by the `panel'
  choice in the option list.

}\sstdiytopic{Plotting}{
 The symbols used to plot the data are under user control, and any of
 the standard PGPLOT symbols can be used.

 The graphical output is done using the PGPLOT package, and can
 thus be sent to any device that has a PGPLOT or GKS driver.

}\sstdiytopic{Output Table}{

 The contents of a row in the output file are:-

\vspace*{2mm}\begin{tabular}{|l|l|}\hline
Column & Content \\ \hline
  1 & Identifier \\
  2 & X \\
  3 & Y  \\
  4 & col(2) or col(1)-col(2)   (optional)  \\
  5 & col(3)-col(4)  (optional)  \\
  6 & input waveband magnitude  (optional)   \\
  7 & number of good estimates in that magnitude  (optional)  \\ \hline
\end{tabular}\vspace*{2mm}

 The first two columns (the 'x' and 'y') are optional. Their presence
 is controlled by the 'storexy' parameter.

 The last two entries are repeated for each of the input magnitudes.

 This is a \starman NDF format table.

}\sstparameters{

\sstsubsection{ALL{\undersc}SETS = LITERAL (Read)}{
 (Default - `no'     \hspace{6ex}      Choice - `yes:no')

 Apply these to all the sets (yes), or just to the present set (no).

}\sstsubsection{COLCODE = LITERAL (Read)}{
  (Default - one of `U',`B',`V'   \hspace{6ex}       Choice - any single character)

 A single character for labelling each waveband input for dialogue,
 plotting, and output.  Reply `V' or `U', etc.

 This is used for `COLCOD1', `COLCOD2', `COLCOD3', `COLCOD4'
 refering to the (up to) four input tables.

}\sstsubsection{COLCOR = {\undersc}REAL (Read)}{
 (Default - 0.0 or previous value   \hspace{6ex}      Range - -1.0e10 to 1.0e10)

 The real number in the colour equations to be applied to each input
 magnitude.

 This is the `K' in the equation:-

$$        Col1_{n}  = Zero_{n}  + Col_{n}  + K_{n} .(C_{3}-C_{4} )  $$

}\sstsubsection{COLUMN = {\undersc}INTEGER (Read)}{

 See above for more information.

3 Column
 (Default - 3       \hspace{6ex}      Range - 1 to no of columns in table)

 The number of the column in the table that contains the magnitudes.

 This is used for `COLUMN1', `COLUMN2', `COLUMN3', `COLUMN4',
 refering to the (up to) four input tables.

}\sstsubsection{DEVLIMX = {\undersc}REAL(2) (Read)}{
 (Default - the minimum and maximum of the data    \hspace{6ex}    Range - -1.0e10 to
                                                            1.0e10))

 The range of mags and cols for the plot which define the size of
 the plotted area in the X direction.

 (This does not affect the output to a table.)

}\sstsubsection{DEVLIMY = {\undersc}REAL(2) (Read)}{
 (Default - the minimum and maximum of the data      \hspace{6ex}  Range - -1.0e10 to
                                                            1.0e10))

 For the plot the range of mags and cols to define the size of
 the plotted area in the Y direction.

 (This does not affect the output to a table.)

}\sstsubsection{EASYCMD = LITERAL (Read)}{
  (Default - `yes'        \hspace{6ex}        Choice - 'yes:no')

There are two options when running 'diagram', selected by your
 answer to the 'easycmd' parameter:-

\begin{description}
 \item[1) Easycmd='yes']

    Do a standard run through to plot a CMD: -

    The program asks for the input to take two tables and put a CMD
    up on the x-windows window. The program then asks for further
    options, expecting the answer - 'exit'.

    If you put the `${\backslash}{\backslash}$` on the command line,
    the program will then end, leaving the CMD displayed in its
    window.

    If you choose to continue, you will find yourself in the middle
    of 'easycmd=no' mode, being repeatedly asked what you want to do
    through the 'option' parameter. You should choose the 'panel'
    option, and then interact with the program through the 'panel'.

\item[2) Easycmd='no']

    Do what you want: -

    The program first asks you if you want to plot a CMD or a
    colour-colour diagram. You choose, and then the program asks
    for what are the 'codes' of which colours to plot.

    After this, the program goes in the looping 'options' mode,
    repeatedly asking which option of action you want to do.

    It suggests a sequence of options which will normally get you
    the inputs needed for making and displaying the plot. If you
    accept these options all will go well. (You can, of course,
    choose diferent options if you wish to.)

    After this, all options are open. The program will suggest
    selecting the 'panel' option, where the options are available
    by pressing 'buttons' on a window. This is quite handy, and
    an in-screen help is displayed, as your cursor moves over the
    different buttons.

\end{description}


}\sstsubsection{EXIT = LITERAL (Read)}{
  (Default - `yes'        \hspace{6ex}        Choice - 'yes:no')

Do you want to exit from the program?

  This is asked for, if the program is in the 'easycmd=yes' mode,
  and has plotted the CMD.

  This is defaulted to 'yes', so that if the command line has the
  '${\backslash}{\backslash}$' input giving that defaults be taken,
  then the program ends, as it should.

  If the command line does not have this, then it is up to the
  user whether to continue.

}\sstsubsection{GTYPE = LITERAL (Read)}{
  (Default - `ask'        \hspace{6ex}        Choice - any)

  A character string giving the local name for the graphics
  display type.

  `xwindows' will put it out on the screen of your workstation,
  if you are using one.

  If `ask' is input, then the program asks a very similar question,
  in a different way. A response here of `?' will bring up a listing
  of all the possible names of graphics devices which are supported
  on your machine, and you then input the appropriate name.

}\sstsubsection{HILIM = {\undersc}REAL (Read)}{
 (Default - 49.0 or last value input    \hspace{6ex}    Range - -1.0e10 to 1.0e10)

 Stars in this file with input magnitude  fainter than this
 are not accepted.


}\sstsubsection{INTAB = NDF (Read)}{
  (Default - null)

 If `file' is chosen in `TYLINE' parameter option, then a table with
 the points defining the line is needed.  This table should have two
 columns with 'x' and 'y' values in it. The numbers of these columns
 are input with the 'PCOLUMN' parameter.

 One can use the 'offsets' parameter to shift this line an x and y.

 The table must be a standard \starman table format file. It
 is a Starman ADAM .SDF image, with `real' 32-bit real values,
 with each column having a header of up to 20 characters, and
 each row having a name of up to 20 characters.

}\sstsubsection{IN = NDF (Read)}{
  (Default - null)

 An input file containing a table with one column having magnitudes.

 This can be one of 48 input files from IN1 to IN48.
 They are used in sets of four (e.g. IN1,IN2,IN3,IN4) for a 'set'
 of (up to) four tables of input colours to make an array of points for
 the colour-magnitude or colour-colour diagram. If only two or three
 input magnitudes are needed, then not all of (IN1,IN2,IN3,IN4) will
 be used. The next set of data would then use the parameters (IN5,IN6,
 IN7,IN8), and so on. Thus 12 sets in all can be input.

 This must be in the \starman NDF table format.

 This is the help for the 'IN1', 'IN2', ... 'IN48' parameters.

}\sstsubsection{LINECOL = LITERAL (Read)}{
  (Default - `black'  \hspace{6ex}       Choice - `black:white')

 Colour of plot lines. This is determined by whether you have a
 black or white background to your plots.

}\sstsubsection{LOLIM = {\undersc}REAL (Read)}{
 (Default - 0.1 or last value input  \hspace{6ex}             Range - -1.0e10 to 1.0e10)

 Stars in this file with  input mag brighter than this
 are not accepted.

}\sstsubsection{NCOLUMN = {\undersc}INTEGER (Read)}{
 (Default - 0        \hspace{6ex}        Range - 1 to no of columns in table)

 The column in the table that contains the number of good estimates
 of the star magnitudes. If no such column exists, or use of it is
 not desired, input `0'.

 This is used for `NCOL1', `NCOL2', `NCOL3', `NCOL4'.
 refering to the (up to) four input tables in the set. (12 sets in
 all allowed.)

}\sstsubsection{NUMBUTT = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - see below   \hspace*{6ex} Range - 2 to 3)

  Number of `X-Window' buttons available on the mouse.

  Some devices have two and some have three buttons available. This
  can depend both on their actual presence, and also on the X Windows
  software that is being run.

  With three buttons, then the \starman programs use all three, with
  the right-hand button being used mainly as the `exit' button.

  With two buttons, then the third button is simulated by pressing
  both of the buttons down, with the middle one being pressed slightly
  BEFORE the left-hand one. Use of the middle button in its normal
  way has to be modified, in that one has to pause for half a second
  after using it.

  [This parameter is usally 'hidden', with the machine manager setting
   it to the appropriate value for the local set-up. Sometimes it will
   be left to the user to set, depending on his software configuartion.]

}\sstsubsection{NUMGOOD = {\undersc}INTEGER (Read)}{
 (Default - 0 or last value input     \hspace{6ex}      Range - 1 to 100000)

 If using this input control, this is the minimum no of estimates
 used in making the star mag for a star in the input file
 that is acceptable. Any star with fewer that that for the
 mag in this file is ignored.

}\sstsubsection{OFFSETS = {\undersc}REAL(2) (Read)}{
 (Default - 0.0,0.0           \hspace{6ex}      Range - -1.0e10 to 1.0e10)

 The `x' and `y' offsets to be added to the data in the `INTAB'
 table for plotting.

}\sstsubsection{OPTION = LITERAL (Read)}{
 (Default - last chosen in list below  \hspace{6ex}    Choice  - see list below)

 The choice of action to do next is defined by the 'option'
 chosen. These options are also available through the 'panel'
 push-button mode, on choosing the 'panel' option.

\vspace*{2mm}\begin{tabular}{|l|l|}\hline
  Option      &  Function \\ \hline
  clear       &  Clear plot \\
  close       &  Close the graphical device \\
  colour{\undersc}eqn  &  Change colour equation applied to input colours \\
  cursor      &  Get XY positions from graph with cursor \\
  dotnumber   &  Set whether numbers are plotted with points \\
  exit        &  Exit from this program \\
  getdata     &  Get the tables with the magnitudes in them \\
  line        &  Put line onto graph. \\
  mag{\undersc}limits  &  Star Magnitude ranges allowed to be plotted \\
  nearest     &  Get information on a star by putting cursor on it \\
  numgood     &  Number of good measures for plotting a star \\
  open        &  Open the plot device \\
  panel       &  Switch between panel and keyboard option selection \\
  plot        &  Plot the data as points on the graph \\
  plot{\undersc}limits &  Set the range of the graph axes in X and Y \\
  plot{\undersc}range  &  Set the range of data in X and Y to be plotted \\
  setnumber   &  Data set these setups apply to \\
  store       &  Store the present plotted data set as a table file \\
  symbol      &  Set the symbol plotted as points \\
  zero{\undersc}point  &  Change zero points applied to input colours \\
\hline\end{tabular}\vspace*{2mm}

  There is also the big 'HELP' button.

  When using the cursor to find magnitudes/colours of positions
  on the graph, place the cursor on the desired location, and
  press any keyboard key. To end, place the cursor to the left
  of the origin and press any key.

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

 The Output table for storing the results.

 The contents of a row in the output file are:-

\vspace*{2mm}\begin{tabular}{|l|l|}\hline
Column & Content \\ \hline
  1 & Identifier \\
  2 & X \\
  3 & Y  \\
  4 & col(2) or col(1)-col(2)   (optional)  \\
  5 & col(3)-col(4)  (optional)  \\
  6 & input waveband magnitude  (optional)   \\
  7 & number of good estimates in that magnitude  (optional)  \\ \hline
\end{tabular}\vspace*{2mm}

 The first two columns (the 'x' and 'y') are optional. Their presence
 is controlled by the 'storexy' parameter.

 The last two entries are repeated for each of the input magnitudes.

 This is a \starman NDF format table.

}\sstsubsection{PCOLUMN = {\undersc}INTEGER(2) (Read)}{
 (Default - 1,2     \hspace{6ex}    Choice - 2 integers in the range 1 to no of columns)

  If `file' is chosen in `TYLINE' option, these  are the numbers of
  the two columns in the table containing respectively the `x' and the
  `y' values which are to be plotted as a line.

}\sstsubsection{SET = {\undersc}INTEGER (Read)}{
 (Default - present value    \hspace{6ex}    Range - 1 to No of sets input)

 The number defining which of the input sets of (up to) four
 tables to deal with. Up to twelve sets can be kept.

}\sstsubsection{STOREXY = LITERAL (Read)}{
 (Default - `yes'       \hspace{6ex}    Choice - `yes:no')

  If yes, then the input file will contain in its first two columns,
  the X and Y positions of the stars, and you desire that these should
  be output to the output table.

}\sstsubsection{SYMBOL = {\undersc}INTEGER (Read)}{
 (Default - 1 or last value input    \hspace{6ex}     Range - 1 to 128)

 The PGPLOT symbol code that defines the shape of the symbol
 plotted.

}\sstsubsection{TITLE = LITERAL (Read)}{
 (Default - Input file title or `Output from Diagram'       \hspace{6ex}  Choice - any)

 The content of the 'title' header in the output table.

}\sstsubsection{TYLINE = LITERAL (Read)}{
 (Default - `return'    \hspace{6ex}
  Choice - `cursor:table:keyboard:return')

 Flag for method of putting line on diagram.

 When a method is chosen, the line is plotted, and this question is
 asked again.

 Points given by the various inputs are plotted as joined together
 with straight lines.

\vspace*{2mm}\begin{tabular}{|l|p{12cm}|}\hline
 Choice & Action \\ \hline
 cursor &   Line is drawn joining the successive locations marked
            with the cursor, until a location less than the minimum
            `x' value of the graph is chosen, when this cursor
            entry stops. \\
 table  &   An input table of x and y positions is asked for, via
            the 'intab' parameter. These are plotted. \\
 keyboard & The user types in pairs of 'x','y' positions, and these
            are plotted. This is stopped by the user inputting an 'x'
            position to the left of the graph edge. \\
 return   & Return to the 'options/'panel' mode. \\ \hline
\end{tabular}\vspace*{2mm}

}\sstsubsection{TYPE = LITERAL (Read)}{
 (Default - `hr'  \hspace{6ex}     Choice - `hr:twocol')

 Flag for choosing colour-magnitude (hr) or colour-colour (twocol)
 diagram type output.

}\sstsubsection{XRANGE = {\undersc}REAL(2) (Read)}{
 (Default - the range of the data      \hspace{6ex}   Range - -1.0e10 to 1.0e10)

 The acceptable range of the value of the output `x' colour,
 ($col1_{3}$ - $col1_{4}$ ), that a star may have. If it lies outside
 this range, then it will not be plotted, and it will be stored with
 a warning flag.

}\sstsubsection{XYKEY = {\undersc}REAL(2) (Read)}{
  (Default - X max and Y max or present values      \hspace{6ex}     Range - -1.0e10 to
                                                              1.0e10)

 `x',`y' posn to make line plot to.

 (This is only used in the `keyboard' option of the `tyline' choice
 in the 'line' option.input.

 If the `x' value input is less than the minimum value that can be
 displayed then the keyboard entry is halted, otherwise the next
 position is asked for.


}\sstsubsection{YRANGE = {\undersc}REAL(2) (Read)}{
 (Default - the range of the data    \hspace{6ex}         Range - -1.0e10 to 1.0e10)

 The acceptable range of the value of the output `y' colour,
 $col1_{2}$ or ($col1_{1}$ - $col1_{2}$ ), that a star may have.
 If it lies outside this range, then it will not be plotted, and
 it will be stored with a warning flag.

}\sstsubsection{ZEROP = {\undersc}REAL (Read)}{
 (Default - 0.0      \hspace{6ex}         Range - -1.0e10 to 1.0e10)

 The zero point corrections to be added to the input magnitude.

 This is the `Zero' in the equation:-

$$        Col1_{n}  = Zero_{n}  + Col_{n}  + K_{n}.(C_{3}-C_{4})  $$

}}}



\addcontentsline{toc}{subsection}{ Dustring}


\ajhsect{\arabic{section}}{General Programs - \hspace*{0.2in} DUSTRING}

\sstroutine{DUSTRING}{Remove `Dustring' Shadows from an Image}{

\sstdescription{
  Add and subtract the 'dustring' shadows of dust
  particles to and from an image.

  It is mainly useful for making a flat field match up to the desired flat
  field when a dust particle has blocked part of the image from complete
  illumination since the flat field was made.

  Likewise, by subtracting a ring, the flat can be corrected to before
  the particle fell.

  It is useful for combining flats with different flat field dustrings.

  It displays the image so that you can see wheat you are doing
  and uses the 'panel' push-buttons, but it also can be run without
  an image display.

}\sstdiytopic{Use}{
  The program is a looping one, where you can repeatedly choose various
  options.

  Basically, you select a dustring, and manually by trial and error
  you adjust the position and background level for a theoretical ring
  which you then add or subtract from the image.

  The ring is added/subtracted as:-

$$            (Background Level).(Profile(xo,yo))  $$

    where:-

\hspace{6ex}\begin{tabular}{lp{4in}}
 Profile(x,y) &    is a fixed profile which is a function of
                           X and Y, and is a percent of the background
                           level. \\
xo,yo    &  is the position of the ring. \\

Background Level    & is the local background level at the ring \\
\end{tabular}

  The ring profile will have previously be determined, again by trail
  and error. (See help subsection on profile.)

  When you are happy with the position, profile, and background level,
  you can also store those parameters in the working table.

  When you done all the adding/subtraction, you can store the output
  image.

  You can also note into a table any ring you wish, and this table can
  later be output to a file. It would contain the parameters of the rings
  and will only have those rings actually noted, which is NOT necessarily
  the same as those added/subtracted from the image.


}\sstdiytopic{Choosing options}{

  In the looping mode, you are faced with a menu of actions to
  choose from.

  When using the image display, the looping options request can come
  through a 'panel' displayed in the display, with buttons to 'press'
  to select options. Six lines of help are displayed as each button is
  pointed at. This mode is selected by choosing the 'panel'
  option.

  Choice of actions to do:-

 \begin{tabular}{|ll|}\hline
       Choice   &   Function \\ \hline
     add        &   Add a ring of standard profile at position set \\
     bk{\undersc}auto    &   Toggle the method of calculating the local level \\
     bk{\undersc}ground  &   Input the level for the background \\
     bk{\undersc}level   &   Measure local level - perhaps load in to default \\
     bk{\undersc}load    &   Toggle between loading background measure and not \\
     bk{\undersc}size    &   Set the size of the area used to find background \\
     clear      &   Clear screen \\
     close      &   Close the display screen \\
     cursor     &   Add or subtract a set ring at cursor position \\
     cvalues    &   Show the cursor position and image pixel value \\
     display    &   Display image \\
     exit       &   Exit from this program \\
     flash      &   Display image in standard way \\
     im{\undersc}get     &   Input new image \\
     im{\undersc}reload  &   Load original input image into present image \\
     im{\undersc}store   &   Output present image into a disk file \\
     open       &   Open the display screen \\
     panel      &   Switch between panel and keyboard option selection \\
     position   &   Set position via keyboard \\
     profile    &   Set the parameters of the ring profile \\
     reset      &   Reset zoom/pan to unity and centre \\
     show       &   Print out the ring paramaters and present controls \\
     subtract   &   Subtract a ring of set profile at position set \\
     tb{\undersc}apply   &   Add or subtract rings from the input table \\
     tb{\undersc}clear   &   Clear the table of set rings \\
     tb{\undersc}get     &   Extract a ring from the table, ready for use \\
     tb{\undersc}list    &   List the present contents of the set rings table \\
     tb{\undersc}load    &   Load a table of set rings from a file \\
     tb{\undersc}put     &   Put present ring parameters into table \\
     tb{\undersc}store   &   Store present table of rings into a disk file \\
     tb{\undersc}use     &   Set whether to use a particular ring in the table \\
     zoom       &   Zoom and pan image by using mouse location \\
\hline\end{tabular}


  For the zooming and panning, the mouse buttons have a complex
  mode of operation:-

 \begin{tabular}{|l|l|l|}\hline
    Mode                    & Choice                 & action \\ \hline
    Buttons for Zoom work:  &  Button 1 twice        & zoom /2 \\
                            &  Button 2 twice        & zoom x2 \\
                            &  Button 1 and Button 2 & pan \\
                            &  Button 3 twice        & exit \\
                            &                        & \\
  Buttons for Cvalues work: & Any button             & exit \\ \hline
 \end{tabular}

}\sstdiytopic{Dustring Profile}{

   The profile is shaped like this:-

{
 \setlength{\unitlength}{1mm}
 \begin{center}
   \begin {picture}(170,20)
     \put(0,10){xxxxxxxxxxxxx}
     \put(58,10){xxxxxxxxxxxxx}
     \put(118,10){xxxxxxxxxxxxx}

     \put(28,5){x}
     \put(54,5){x}
     \put(86,5){x}
     \put(114,5){x}

     \put(30,0){xxxxxxxxxxxx}
     \put(89,0){xxxxxxxxxxxx}
   \end {picture}
 \end{center}
}

%\hspace*{0ex}xxxxxxxxxxxxx\hspace{16ex}xxxxxxxxxxxx\hspace{17ex}xxxxxxxxxxx
%\hspace{\fill}
%\nopagebreak \\ \nopagebreak
%\hspace*{16ex}x\hspace{14ex}x\hspace{14ex}x\hspace{15ex}x\hspace{\fill}
%\nopagebreak \\ \nopagebreak
%\hspace*{17ex}xxxxxxxxxxxx\hspace{16ex}xxxxxxxxxxxx\hspace{\fill}


    Where the shape is determined by the parameters:-

\hspace*{6ex}\begin{tabular}{lp{4in}}
       PERCENT  &   Percentage drop into shadow (in terms of local
                                                 background) \\
       RIN      &   Inner radius of deep part of ring \\
       ROUT     &   Outer radius of deep part of ring \\
       SLOPEIN  &   Inwards distance from RIN to location of no shadow area \\
       SLOPEOUT  &  Outwards distance from ROUT to location of no shadow area \\
\end{tabular}

}\sstdiytopic{Output Image}{

  The output image is a copy of the input image, with rings added
  and subtracted.

}\sstdiytopic{Output Table}{

  Optionally, an output table, storing the parameters of the rings,
   can be stored.

   The contents are the parameter for each ring:-

 \begin{tabular}{|l|l|l|}\hline
      Column    & Header      &    Content \\ \hline
        1       &  'X'        &    X position of centre \\
        2       &  'Y'        &    Y position of centre \\
        3       &  'BACK'     &    Background level in image \\
        4       &  'PERCENT'  &    Percentage of background ring drops \\
        5       &  'RIN'      &    Radius of inner edge of deep ring \\
        6       &  'ROUT'     &    Radius of outer edge of deep ring \\
        8       &  'SLOPEOUT' &    Distance covered by outer penumbra \\
        9       &  'USE'      &    Flag for use this ring (0=yes:1=no) \\
  \hline
  \end{tabular}

   Only those rings actually 'noted' will be in this table. It does
   not passively record all those added or subtracted. from the image


}\sstparameters{

\sstsubsection{BACK = {\undersc}REAL (Read)}{
  (Default - 1.0   \hspace{6ex}   Range - -1.0e10 to 1.0e10)

   The local background level for the ring to use when being
   added or subtracted.

}\sstsubsection{DO{\undersc}ADD = LITERAL (Read)}{
  (Default - 'add'   \hspace{6ex}   Choice- 'add:sub')

  Add or subtract all the rings, in the list of rings, to the
  image?

}\sstsubsection{IMCOMP = {\undersc}INTEGER(2) (Read)}{
  (Default - variable, usually 1,1     -     Range - 1 to 1000)

  Factor in X and Y by which to compress the displayed image.

}\sstsubsection{IMPOSN = {\undersc}INTEGER(2) (Read)}{
  (Default - so as to centre image in screen    \hspace{6ex}
   Range -  -100000 to 100000)

  Place to put b.l.h. corner of displayed image onto the
  screen. Thus an answer of `1,1' would put the b.l.h. pixel
  of the displayed image at the b.l.h corner of the screen.

}\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The name of the input image file.

  This must be a \starman NDF 'short' integer*2 16-bit or 'real'
  real*4 32-bit image.

}\sstsubsection{INTAB = NDF (Read)}{
  (Default - null)

  The name of the input file containing the list of rings.

  This must have 9 columns and up to 1000 rows. The contents
  must be in the format of a table output from this program
  via the 'OUTTAB' parameter.

  This must be a \starman NDF table format file.

}\sstsubsection{NUMBER = {\undersc}INTEGER (Read)}{
  (Default - 1          Range - 1 to Number of rings input)

 The number in the working table of the wanted ring.

}\sstsubsection{NUMBUTT = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - see below   \hspace*{6ex} Range - 2 to 3)

  Number of `X-Window' buttons available on the mouse.

  Some devices have two and some have three buttons available. This
  can depend both on their actual presence, and also on the X Windows
  software that is being run.

  With three buttons, then the \starman programs use all three, with
  the right-hand button being used mainly as the `exit' button.

  With two buttons, then the third button is simulated by pressing
  both of the buttons down, with the middle one being pressed slightly
  BEFORE the left-hand one. Use of the middle button in its normal
  way has to be modified, in that one has to pause for half a second
  after using it.

  [This parameter is usally 'hidden', with the machine manager setting
   it to the appropriate value for the local set-up. Sometimes it will
   be left to the user to set, depending on his software configuartion.]

}\sstsubsection{OPTION = LITERAL (Read)}{
  (Default - last choice        Choices - see below)

   Choice of operations to do:-


  In the looping mode, you are faced with a menu of actions to
  choose from.

  When using the image display, the looping options request can come
  through a 'panel' displayed in the display, with buttons to 'press'
  to select options. Six lines of help are displayed as each button is
  pointed at. This mode is selected by choosing the 'panel'
  option.

  Choice of actions to do:-

 \begin{tabular}{|ll|}\hline
       Choice   &   Function \\ \hline
     add        &   Add a ring of standard profile at position set \\
     bk{\undersc}auto    &   Toggle the method of calculating the local level \\
     bk{\undersc}ground  &   Input the level for the background \\
     bk{\undersc}level   &   Measure local level - perhaps load in to default \\
     bk{\undersc}load    &   Toggle between loading background measure and not \\
     bk{\undersc}size    &   Set the size of the area used to find background \\
     clear      &   Clear screen \\
     close      &   Close the display screen \\
     cursor     &   Add or subtract a set ring at cursor position \\
     cvalues    &   Show the cursor position and image pixel value \\
     display    &   Display image \\
     exit       &   Exit from this program \\
     flash      &   Display image in standard way \\
     im{\undersc}get     &   Input new image \\
     im{\undersc}reload  &   Load original input image into present image \\
     im{\undersc}store   &   Output present image into a disk file \\
     open       &   Open the display screen \\
     panel      &   Switch between panel and keyboard option selection \\
     position   &   Set position via keyboard \\
     profile    &   Set the parameters of the ring profile \\
     reset      &   Reset zoom/pan to unity and centre \\
     show       &   Print out the ring paramaters and present controls \\
     subtract   &   Subtract a ring of set profile at position set \\
     tb{\undersc}apply   &   Add or subtract rings from the input table \\
     tb{\undersc}clear   &   Clear the table of set rings \\
     tb{\undersc}get     &   Extract a ring from the table, ready for use \\
     tb{\undersc}list    &   List the present contents of the set rings table \\
     tb{\undersc}load    &   Load a table of set rings from a file \\
     tb{\undersc}put     &   Put present ring parameters into table \\
     tb{\undersc}store   &   Store present table of rings into a disk file \\
     tb{\undersc}use     &   Set whether to use a particular ring in the table \\
     zoom       &   Zoom and pan image by using mouse location \\
\hline\end{tabular}


  For the zooming and panning, the mouse buttons have a complex
  mode of operation:-

 \begin{tabular}{|l|l|l|}\hline
    Mode                    & Choice                 & action \\ \hline
    Buttons for Zoom work:  &  Button 1 twice        & zoom /2 \\
                            &  Button 2 twice        & zoom x2 \\
                            &  Button 1 and Button 2 & pan \\
                            &  Button 3 twice        & exit \\
                            &                        & \\
  Buttons for Cvalues work: & Any button             & exit \\ \hline
 \end{tabular}

}\sstsubsection{OUT = NDF (Write)}{
 (Default - null)

  The name of the output image file. This holds the input image
  with the effect of all rings that have been added or subtracted.

  This is either a 'short' integer*2 16-bit or 'ral' real*4 32-bit
  \starman NDF format image, with BZERO, BSCALE and INVAL/RINVAL
  from the input image.

}\sstsubsection{OUTTAB = NDF (Write)}{
 (Default - null)

   The output table, storing the parameters of the rings noted.

   This is a \starman table format file.

   The contents are the parameter for each ring:-


 \begin{tabular}{|l|l|l|}\hline
      Column    & Header      &    Content \\ \hline
        1       &  'X'        &    X position of centre \\
        2       &  'Y'        &    Y position of centre \\
        3       &  'BACK'     &    Background level in image \\
        4       &  'PERCENT'  &    Percentage of background ring drops \\
        5       &  'RIN'      &    Radius of inner edge of deep ring \\
        6       &  'ROUT'     &    Radius of outer edge of deep ring \\
        8       &  'SLOPEOUT' &    Distance covered by outer penumbra \\
        9       &  'USE'      &    Flag for use this ring (0=yes:1=no) \\
  \hline
  \end{tabular}

   Only those rings actually 'noted' will be in this table. It does
   not passively record all those added or subtracted. from the image


}\sstsubsection{PERCENT = {\undersc}REAL (Read)}{
   (Default - 0.5 or last value       Range -  0 to ?)

   The percentage dip into the deep part of the ring profile,
   in terms of the defined background level

}\sstsubsection{POSN = {\undersc}REAL(2) (Read)}{
   (Default - centre or last position        Range - -1.0e10 to 1.0e10)

   The X,Y position to put the ring at.

}\sstsubsection{RIN = {\undersc}REAL (Read)}{
   (Default - 8.0 or last value          Range - 01.0 to 1.0e8)

   The radius at the inner ring edge of the deep part of the ring.

}\sstsubsection{ROUT = {\undersc}REAL (Read)}{
   (Default - 12.0 or last value          Range - 01.0 to 1.0e8)

   The radius at the outer ring edge of the deep part of the ring.

}\sstsubsection{SCREEN = {\undersc}INTEGER(2) (Read)}{
  (Default - 1, size of image      \hspace{6ex} Range - 1 to large)

  Size of screen or window to open.

  The default size is that of the image, unless the image is too large
  to fit on the screen, when the image will be binned down by an integer
  factor for display. The default size will then be this binned down size.

}\sstsubsection{SIDE = {\undersc}INTEGER (Read)}{
  (Default - 5 or last value      Range - 3 to size of image)

   The size of the side of the box, about the last defined
   position, to define the area in which to find the local level.

}\sstsubsection{SLOPEIN = {\undersc}REAL (Read)}{
  (Default - 1.0 or last value              Range - -1.0e8 to 1.0e8)

   Inwards distance from RIN to location of no shadow area.

   (The inner penumbra of the shadow.)

}\sstsubsection{SLOPEOUT = {\undersc}REAL (Read)}{
  (Default - 3.0 or last value              Range - -1.0e8 to 1.0e8)

   Outwards distance from ROUT to location of no shadow area.

   (The outer penumbra of the shadow.)

}\sstsubsection{TITLE = LITERAL (Read)}{
 (Default - Title of input image          Choice - any)

   The title to apply to the output image or table

}\sstsubsection{USE = LITERAL (Read)}{
  (Default - default        \hspace{4ex}    Choice - `yes:no')

 Is this ring to be used?

 The default is 'yes' if not used before, or the last flag for
 this ring.

}\sstsubsection{VRANGE = {\undersc}REAL(2) (Read)}{
 (Default - suggested values  \hspace{6ex}  Range - -1.0e10 to 1.0e10)

 The range of values to be displayed as black to white on image display
 display.

}\sstsubsection{WRAP = LITERAL (Read)}{
  (Default - `no'        \hspace{4ex}    Choice - `yes:no')

 When displaying image on image display, for those image pixel values that
 lie above or below the display values for white or black, do you want
 these values to be shown as white or black (`no'), or do you want them to
 be `wrapped' round - that is considered as modulo the display range
 (`yes')?

}}}




\addcontentsline{toc}{subsection}{ Interact}


\ajhsect{\arabic{section}}{General Programs - \hspace*{0.2in} INTERACT}

\sstroutine{INTERACT}{Interact with Image Display}{

\sstdescription{

  This is the main \starman program for interacting with an image or images
  displayed on a colour X-window display device.

  The Main functions are:-
  \begin{list}{{-}}{}
     \item Display of image(s)
     \item Inspection of the image
     \item Changing colour look-up tables and use of colours
     \item Inspection of pixel values in various ways
     \item Altering the image in various ways
     \item Plotting (X,Y) positions from an input table
     \item Getting (X,Y) positions for storage in an output table
     \item Aperture photometry including airmass
     \item Scrutiny of the \starman MEASURE program output
   \end{list}

 One gets into one of eight groups of options, and repeatedly
 chooses options to perform. One can move between groups of
 options

}\sstdiytopic{Use}{
As the use of Interact is interactive, there is an infinite number
of ways of using it. However, to give you some ides of its use, the following
`run-through' of one possible session is given.
It is assumed you are at a colour X-window device.

\begin{tabular}{p{5.3in}l}
$>$interact {\$}STARMAN{\undersc}DATA/measure{\undersc}in
                                                 \hspace*{\fill}  &
                                                 \hspace*{0.5em}\fbox{1} \\
EASYSTART - Use standard start sequence of operations? /YES/ $>$no
                                                                  &
                                                 \hspace*{0.5em}\fbox{2}\\
\hspace*{4em}     {\sf [information on use typed out]}            & \\
OPTION - Which action to perform? /'image'/ $>$                     &
                                                 \hspace*{0.5em}\fbox{3}\\
OPTION - Which action to perform? /'flash'/ $>$                   &
                                                 \hspace*{0.5em}\fbox{4}\\
SCREEN - XY size of window to open? /[100,100]/ $>$200,200
                                                 \hspace*{\fill}  &
                                                 \hspace*{0.5em}\fbox{5}\\
Display contrast: low =   324.9188 ; high =   -19.3838
                                                 \hspace*{\fill}  & \\
\hspace*{4em}     {\sf [display window opened and image displayed]}
                                                 \hspace*{\fill}  & \\
OPTION - Which action to perform? /'panel'/ $>$                   &
                                                 \hspace*{0.5em}\fbox{6}\\
\hspace*{4em}     {\sf [`buttons' and `help panel' windows opened]}  & \\
\hspace*{4em}     {\it Click mouse on `cvalues' button}
                                                 \hspace*{\fill}  &
                                                 \hspace*{0.5em}\fbox{7}\\
\hspace*{4em}     {\it Move cursor around image} \hspace*{\fill}  &
                                                 \hspace*{0.5em}\fbox{8}\\
\hspace*{4em}     {\it Click cursor right-hand button }
                                                 \hspace*{\fill}  &
                                                 \hspace*{0.5em}\fbox{9}\\
\hspace*{4em}     {\it Click cursor on `inspect' button}
                                               \hspace*{\fill}  & \fbox{10}\\
\hspace*{4em}     {\it Click cursor on `slice' button}
                                               \hspace*{\fill}  & \fbox{11}\\
\hspace*{4em}     {\it Position cursor inside and near b.l.h.
                    corner of image and click} \hspace*{\fill}  & \fbox{12}\\
X = 13  Y = 17                                   \hspace*{\fill}  & \\
\hspace*{4em}     {\it Position cursor inside and near t.r.h.
                    corner of image and click} \hspace*{\fill}  & \fbox{13}\\
X = 85  Y = 86                                   \hspace*{\fill}  & \\
VPRANGE - Min and Max of values to plot? /[-364,4904]/ $>$
                                               \hspace*{\fill}  & \fbox{14}\\
Input GKS name of device for graphs (-ask- if dont know)
                                                 \hspace*{\fill}  & \\
GTYPE - GKS name of plot device ? /'xwindows'/                  & \fbox{15}\\
\hspace*{4em}     {\sf [graphical window opened]}                 & \\
LINECOL - Colour of plot lines? (black:white) /'black'/ $>$
                                              \hspace*{\fill}  & \fbox{16}\\
\hspace*{4em}     {\sf [graph plotted in graphical window]}       & \\
\hspace*{4em}     {\it Click cursor on `exit' button}
                                              \hspace*{\fill}  & \fbox{17}\\
\hspace*{4em}     {\sf [display, buttons and help windows closed]}& \\
$>$xdestroy xwindows                          \hspace*{\fill}  & \fbox{18}\\
\hspace*{4em}     {\sf [graphical window closed]}                 & \\
$>$                                                               & \\
\end{tabular}

(Where a '$>$' appears, you have to type the response, followed by a
'return'. Where no response is shown, you just do the 'return'.
The parts in italics are instructions to you. and the parts in
bracketed san serif are comments on the display.)

Comments on above run-through:-

\begin{enumerate}

\item By putting the target image file name on the command line, the
      first time the name is asked for, it will be got from this
      command line. (As the image parameter, (`IN'),is the first in
      the \verb|interact| interface file, we do not have to say `IN=name'.)
\item \verb|interact| has a `default' start. However, we avoid this to
      demonstrate usage of the program
\item We are now in the `main' group of options and have available all
      the functions of this group. The choice of the option of
      getting an image is suggested. By just doing `carriage return',
      we get that option. (As we have put the image file name on the
      command line, the name is not asked for again here.)
\item We are now asked again for what option we want, and are
      offered the default of displaying the image with standard display
      settings. We take that default.
\item What size of window is to be put up? The default is the size of
      the image. We choose a window twice as large. The program opens
      the window and displays the image at a contrast suitable for
      images which are `normal' pictures of astronomical objects. It
      types out the lower and upper pixel values that cover the range
      from pure black to pure white.
\item Again, what option? We choose the default, which is
      to switch over from keyboard entry of the desired options to
      `push-button' mode. A panel of push buttons and a separate help
      window appears. The help window contents change as the
      cursor moves over the buttons.
\item We now have the options available to use in the `main' group,
      via the buttons. We choose that which will let us look at the
      pixel values.
\item Note the change in display of cursor position and pixel values
      in the panel, as the cursor is moved over the image.
\item End this option and go back to the panel option selection.
\item Leave the `main' group of functions and go to the `inspect'
      group. See how the panel display changes.
\item Select the option to get a graphical slice through the image.
\item Choose the start of the `slice'. Note the cross marking your
      position, and the typing out of the location.
\item Choose the end of the `slice'. Note that the `slice' line is
      drawn and the end location typed out.
\item The program now asks you for the `Y' range of the graph
      to display trhe results. The default is +/- 10 percent
      larger than the actual range of pixel values in the slice.
      We take the default.
\item The program now has to display the slice. It does this
      using the Starlink graphics system, GKS. It asks for the
      name of the graphics device. We give it `xwindows', the
      graphics name of one the four possible graphical windows
      on our workstation. The program opens up the window.
\item Depending on how you have set up your X-wondow device,
      the background can be any colour. We thus need to choose
      whether to have black or white lines drawn. We select
      the default.
\item We are again able to choose an `inspect' option. We select
      the one to exit from the program.
\item The graphics system leaves the graphics window displayed.
      We could leave it there, ready for its next use. We choose
      however to delete it. (See the Starlink SUN on GWM for more
      about this.)
\end{enumerate}


}\sstdiytopic{Options}{

  There are eight groups of options available. At the
  start of the program, one is in the base group, the `main'
  group. From here one can access the other seven groups,
  and also select from the simple set of options that all
  groups give access to.

  The eight groups are:-

\begin{tabular}{|l|l|}\hline
     Group     &    Type of options available \\
               &    (all do `simple set' as well) \\\hline
     main      &     --- \\
     alter     &    change image \\
     aperture  &    aperture photometry with airmass corrns \\
     colour    &    change colour of displayed image \\
     fit{\undersc}magns &    profile photometry \\
     inspect   &    inspect image \\
     positions &    plot/get positions \\
     scrutiny  &    look at MEASURE program output \\ \hline
\end{tabular}

 The `simple set' includes:- accessing the other groups and exiting;
  getting and displaying images; image zoom/pan, clearing;
  accessing pixel values; selecting image area.

 These groups can be accessed either by the keyboard, or by selecting
  the `panel' option, when a `panel' is shown on the image display,
  and the cursor can be used to push `buttons'. In this mode, a
  six-line help is displayed when the cursor is over a button.

}\sstdiytopic{Simple Set}{

  This is the `simple set' of options which are available in all
  groups of options:-

\begin{tabular}{|l|l|}\hline
 Option     &   Function \\ \hline
 alter      &   Functions for image altering in various ways \\
 aperture   &   Functions for aperture photometry \\
 colour     &   Functions for changing colour display of the image \\
 fit{\undersc}magns  &   Functions to get star magnitudes with Gaussians \\
 inspect    &   Functions for image inspection in various ways \\
 main       &   Entry point for program \\
 positions  &   Functions to get or plot a list of positions \\
 scrutiny   &   Functions to look at \starman MEASURE output \\
            &                                     \\
 image      &   Input new image \\
 im{\undersc}get{\undersc}flash&  Input new image and display (flash) it \\
            &                                    \\
 area       &   Select area of image to display \\
 clear      &   Clear screen \\
 close      &   Close the display screen \\
 compress   &   Compress image in either X or Y for display \\
 cvalues    &   Show the cursor position and image pixel value \\
 display    &   Display image \\
 flash      &   Display image in standard way \\
 open       &   Open the display screen \\
 reset      &   Reset zoom/pan to unity and centre \\
 zoom       &   Zoom and pan image by using mouse location \\
            &                                      \\
 panel      &   Switch between panel and keyboard option selection \\
 exit       &   Exit from this program \\ \hline
\end{tabular}

}\sstdiytopic{Alter Options}{


  In addition to the `simple set', see the help above, the
  following options are available:-

\begin{tabular}{|l|l|}\hline
 Option    &     Function \\ \hline
 blank\_c  &     Set areas to INVALID with cursor \\
 blank\_k  &     Set areas to INVALID with keyboar \\
 calculate &     Calculate a new image \\
 cut\_c    &     Cut out a new image with cursor \\
 cut\_k    &     Cut out a new image with keyboard \\
 compress  &     Compress image in X and Y by integer factors \\
 drange    &     Change pixel value display range \\
 flipx     &     Flip image along x direction \\
 flipy     &     Flip image along y direction \\
 magnify   &     Magnify image in X and Y by real factors \\
 rotate    &     Rotate image \\
 smooth    &     Smooth image \\
 store     &     Store present image to disk \\
 transform &     Transform image in X and Y \\
 value\_k  &     Set the value of a pixel with keyboard \\
 unsharp   &     Unsharp mask the image \\ \hline
\end{tabular}

}\sstdiytopic{Aperture Options}{

  There are two basic modes, both of which use a star aperture, moveable
  by the users with the mouse/cursor, one of which determines the sky
  value, to be subtracted from the star aperture counts, from the
  pixels in an annulus around the star aperture, and one which
  determines the sky from a seperate sky aperture (which must have
  previously been used to measure the sky).

\vspace*{1mm}
{\bf General}
\vspace*{1mm}


  In both modes, repeated measurements can be done. For the
  `non-annulus' mode, when a sky level is determined, that level is
  used for all subsequent star measures, until a new sky level
  aperture location is chosen and a sky measure made.


   The result is calculated as:-

   $$ Output{\hspace{0.3em}}magnitude = 30.0 + `Zero{\hspace{0.3em}}point'
      - 2.5*log_{10}[\frac{Star{\hspace{0.3em}}flux}{Exposure{
      \hspace{0.3em}}time}] $$

 With

$$ Star{\hspace{0.3em}}flux =
   Flux{\hspace{0.3em}}in{\hspace{0.3em}}star{\hspace{0.3em}}aperture -
   (Sky{\hspace{0.3em}}level)*(Star{\hspace{0.3em}}ap{\hspace{0.3em}}area) $$

$$ {\hspace*{-2em}}
   1) {\hspace*{3em}}   Sky{\hspace{0.3em}}flux  =
     \frac{Flux{\hspace{0.3em}}in{\hspace{0.3em}}sky{
     \hspace{0.3em}}aperture}{area{\hspace{0.3em}}of{\hspace{0.3em}}sky{
     \hspace{0.3em}}aperture} $$

$$   Or {\hspace*{2em}}   2) {\hspace*{3em}} Sky{\hspace{0.3em}}flux  =
     Median{\hspace{0.3em}}pixel{\hspace{0.3em}}value{\hspace{0.3em}}in{
     \hspace{0.3em}}sky{\hspace{0.3em}}aperture  $$

   When making a star measure, the aperture can be centered on the star.
   The default method is to have no centering, but just to take the
   cursor position. A more accurate way is to fit a Gaussian to the
   star aperture data and centre on the centre of the Gaussian.

   There is an option, ('CENTRE'), which changes the method of
   centering on a star before measuring. By toggling through `CENTRE',
   you can choose one of the four ways:-

\hspace*{4ex}\begin{tabular}{|l|l|}  \hline
    Option    &  Action \\ \hline
    None      &  No centering \\
    Max Pixel &  Centre on the pixel with maximum value in star aperture \\
    Centroid  & Centre on the centroid of the pixel values in star aperture \\
    Gauss    &   Fit a Gaussian to the star aperture pixels \\ \hline
\end{tabular}

   With the `Gauss' mode, one can set the Gauss radii to be fixed or
   floating.

\vspace*{1mm}
{\bf Photometry}
\vspace*{1mm}


   The whole subject of aperture photometry is not as simple as
   it looks at first appearence. It is recommended that the
   inexperienced user should read a book on astronomical photometry
   to understand the problems and possibilities fully.

   Some examples of the problems are:-

\begin{enumerate}

\item Is the use of the `median' mode in determining the sky level
      inside the sky aperture better than using the `mean'
      mode, as this rejects against stars better? No! The main
      problem in aperture photometry is the presence of field stars
      in the star and sky apertures. If you reject strongly against
      the faint (ones you cant see by eye) stars in the sky
      aperture by using the `median', then the similar faint stars
      in the star aperture will not be balanced by those in the
      sky aperture, and the star will be measured too bright.

\item In choosing a location for the sky aperture, one should
      choose a place that is entirely free from field star? No!
      Again, such a place might be too free, compared to the star
      aperture location, and the star might be measured too bright.

\item When measuring a very faint star on a number of exposures,
      then when the flux in the star aperture is less than the
      sky level, so that one gets a negative flux, those exposures
      should be ingnored? No! You must average everything together.

\item When comparing a bright star and a faint star, it is better
      to use a smaller aperture on the faint star to cut down the
      sky noise? No! The profile of the bright and faint stars are
      the same, and thus using a smaller aperture on the faint
      star will cut out a greater fraction of the light of the
      faint star compared to the bright one.

\item When comparing stars in different exposures, one can use
      different size apertures? No! For the same reason as for 4).

\item When comparing stars in different exposures, one can use
      the same size apertures as when doing a single exposure?
      No! As the seeing will have varied between the different
      exposures, then the apertures must be large ones, so that
      the effect of the variable seeing does not cause a
      significantly diffrent amount of light to be lost out of
      the apertures in the different exposures. Typically apertures
      less than 10 or 20 arcsec diameter will lead to bad photometry.
\end{enumerate}

\vspace*{1mm}
{\bf Aperture Options}
\vspace*{1mm}

 In addition to the `simple set', see the help above, the
  following options are available:-

\hspace*{4ex}\begin{tabular}{|l|l|}  \hline

 Option     &   Function \\ \hline
 Exptim{\undersc}im  &   Correct for exposure time from image descriptor \\
 airmass    &   Correct for Airmass from image descriptor \\
 centre     &   Toggle centre =$>$ cursor/max pixel/centroid/Gaussian \\
 exptim{\undersc}k   &   Change zeropoint by using keyboard exposure time \\
 level      &   Toggle mean/median method for sky level \\
 list       &   List the measures so far \\
 measure    &   Measure star/sky flux via cursor and buttons \\
 method     &   Sky determined from annulus or from separate area \\
 noise      &   Level of extra noise/pixel in pixel counts \\
 poisson    &   Change the Poisson scaling factor for Error \\
 recalc     &   A fresh calc for the last star and last sky \\
 remove     &   Remove a measure from memory and the display \\
 shape      &   Set via keyboard: aperture ellipticity, angle \\
 show{\undersc}ap    &   Show apertures when getting positions \\
 size{\undersc}key   &   Set via keyboard: X, Y size of the oval apertures \\
 size{\undersc}sky   &   Cursor change the size of the sky aperture(s) \\
 size{\undersc}star  &   Cursor change the size of the star aperture \\
 store      &   Store results in output file \\
 zero{\undersc}pt    &   Change the -base- magnitude zero point \\
 \hline\end{tabular}

 Mouse buttons:-

\hspace*{4ex}\begin{tabular}{|c|c|c|c|} \hline
      Buttons from left:- &   (1)    &       (2)   & (3) \\ \hline
        Aperture work:  & pick star    &   pick sky  &    return \\
          Remove work: & remove circle &   remove circle & return \\
       Ap change work:  & dec aperture  &  inc aperture  &
                                   next aperture/return \\ \hline
\end{tabular}

 In the `measure' option:- Measure star/sky flux via cursor and aperture
 size and star/sky choice. The star flux in the aperture is found (or
 sky level in the aperture), and typed. If star, then the star
 and last sky level (separate or annulus) is taken and the calc done
 for the magnitude;

  $$ Mag = 30 + Z - 2.5*log_{10}((star-sky{\hspace{0.3em}}level)/Exp) $$

}\sstdiytopic{Colour Options}{

 The standard image display uses a grey-scale display. However, by
  use of the Colour group of functions, colour displays can be made.
  There are eight standard LUT tables available, and others can be
  read in from files.

  Also the user can adjust the LUT table currently being applied. This
  can be done:-

  \begin{list}{{-}}{}
  \item   `Flip' the UT.
  \item   Change display of values above and below ends of LUT.
  \item   Interactively using a cursor:- choose a colour from the
          displayed colour bar with the cursor and `paint' this colour
          over a range of the LUT.
  \item   Horizontal movement of the cursor (with a mouse button pressed) to
          rotate the LUT
  \item   Use horizontal and vertical movement of the cursor (with a
          mouse button pressed) to shift and scale the LUT.
   \end{list}

\vspace*{1mm}
{\bf LUT Bar}
\vspace*{1mm}

  There is an option to show the form of the Look-up Table. A
  bar can be painted across the bottom of the screen, containing
  from left to right the colours associated with the displays cells
  from 1 to 150, which are used to code the image values to display
  the image.


\vspace*{1mm}
{\bf LUT Standards}
\vspace*{1mm}

  The eight standard LUT tables are:-

\begin{enumerate}
   \item Grey scale
   \item Purple with light at top
   \item Rainbow
   \item Black/blue/green/yellow/purple/white
   \item Black/blue/greeny-yellow/dark red
   \item Black/blue/greeny-yellow/light red/white
   \item Discrete steps (black/blue/green/light blue/red/purple/yellow/
                       white)
   \item Inverted grey scale
\end{enumerate}

\vspace*{1mm}
{\bf LUT Storage}
\vspace*{1mm}

  The LUTs can be output in one format, the `full' format, and input
  in two formats, the `short' and `full' formats.

  {\bf The `full' format is:-}

  This is a table containing the R,G,B fractional colour contributions
  in columns 1,2,3 of the table (ignoring the 1st 5 for table row
  names - which are not used). There are 150 rows in this table.
  Starting from the first row, there is the R,G,B set for the lowest
  location on the table, carrying onto the 150th row, where there is
  the highest LUT entry.

  There is also a scale `LUTSC', and a zero `LUTZE', in descriptors.
  These scale the LUT. A given entry point, say RV, which is
  bewteen 0.0 and 1.0, would normally go to the R,G,B set of the
  RV*150th row in the input LUT. It goes as
  the [(RV-LUTZE)/LUTSC]*150th entry, actually. If this entry is below 1 or
  above 150, then the entry is either, set at 1 or 150, or set at
  its modulo 150 value.

  {\bf The `short' format is:-}

  This is a way of making a simple table to input to the program.

  It is a table with 6 rows, and between 3 and 25 columns.

\begin{tabular}{|l|c|c|c|c|c|c|} \hline
  Each row is allocated to as:- &1      &2      &3       &4
                                &5      &6 \\ \hline
                                &  Red &  Red  & Green &  Green&   Blue
                                &  Blue \\
                               & Posn & Value &  Posn &  Value &  Posn &
                               Value \\ \hline
\end{tabular}

  The first column in a row indicated how many columns in that row are
  active, excluding itself.

  This is then converted into the LUT by:-

  Taking the proportion for each colour at a step in the LUT. This
     is done by moving along the `Colour Posn' row until one reaches
     the point that the step in the LUT table is. Thus if the step is
     number 59 out of 150 steps, then its location is 0.252. In the
     example below, this for red would be just after the 2nd (0.25)
     Posn.

   Calculating the corresponding `Colour Value'. In the example below,
     this would be between the 2nd and 3rd values, so the Red fraction
     would be :-

\begin{eqnarray}
Fraction & = & [2nd{\hspace{0.3em}}value] + \nonumber \\
         &    & [3rd-2nd{\hspace{0.3em}}values]*[fraction{
       \undersc}of{\hspace{0.3em}}step{\hspace{0.3em}}to{\hspace{0.3em}}3rd{
       \undersc}`Colour Position'] \nonumber
\end{eqnarray}

in this case:-
$$     Fraction = 0.00 + (1.0-0.0)*(\frac{0.252-0.25}{0.5-0.25}) $$

  An example of this is the `short' LUT used for the `rainbow' LUT, no 3
  above. It is:-

\begin{tabular}{ccccccc}
     4.0& 0.0& 0.25&  0.5&  1.0&  0.0& 0.0 \\
     4.0& 0.0& 0.00&  1.0&  1.0&  0.0& 0.0 \\
     6.0& 0.0& 0.125& 0.5& 0.64& 0.77& 1.0 \\
     6.0& 0.0& 0.000& 1.0& 0.50& 0.00& 0.0 \\
     5.0& 0.0& 0.25&  0.5& 0.77&  1.0& 0.0 \\
     5.0& 0.0& 1.00&  0.0& 0.00&  1.0& 0.0 \\
\end{tabular}

\vspace*{1mm}
{\bf Colour Options}
\vspace*{1mm}

  In addition to the `simple set', see the help above, the
  following options are available:-

\hspace*{4ex}\begin{tabular}{|l|p{4in}|}\hline
  Option      &   Function \\ \hline
  bar{\undersc}clear   &  Remove display of look-up table bar \\
  bar{\undersc}show    &  Display look-up table bar \\
  ends{\undersc}bw     &  Values below/above LUT as black/white \\
  ends{\undersc}cc     &  Values below/above LUT as col/col \\
  ends{\undersc}wb     &  Values below/above LUT as white/black \\
  ends{\undersc}wrap   &  Values below/above LUT as wrapped \\
  file{\undersc}get    &  Read a full look-up table \\
  file{\undersc}put    &  Write the present look-up table to file  \\
  file{\undersc}sget   &  Read a short LUT into store \\
  flip                 &  Flip LUT \\
  load                 &  Load LUT from store \\
  paint                &  Pick a colour on LUT bar and paint it
                          along the bar \\
  Rotate               &  Rotate LUT by moving cursor \\
  Scale                &  Shift and scale LUT by moving cursor \\
  Wrap                 &  Toggle between Image values above/below limits
                          displayed as:- 1) the limits (no wrap)
                          2) wrapped values (wrap) \\
 \hline\end{tabular}

 ****  This colour system uses a Look-Up Table (LUT)  ****

 The actual pixel values in the image are already displayed
 by scaling and shifting so that a range of those values lies
 between 0 and 255. To each of these 256 -values-, a colour
 is now ascribed, by means of a Look-Up Table (LUT).
 These options allow you to change the colours ascribed to
 to each -value-, in a number of ways. Actual pixel values
 which fell outside the original range, can never have a range
 of colours, as they are all set at the end value. To change
 that, redisplay the image. Likewise for fine gradations.

 How to change the colour LUT of the image display:-

\hspace*{4ex}\begin{tabular}{|c|p{3.5in}|c|} \hline
      Mouse buttons from left:- &   (1)   \hspace*{4ex} (2)   & (3) \\ \hline
       Rotate LUT    & Operate when held down; Move cursor left/right &
                        Return \\ \hline
       Scale  LUT    & Operate when held down;  Move cursor left/right
                        and up/down & Return \\
 \hline\end{tabular}

How to use the `Paint' Function:-

\begin{enumerate}
  \item              Place cursor on displayed LUT bar
  \item                Press left or centre mouse button
  \item                Release
  \item                Place cursor on displayed LUT bar
  \item                Press left or centre mouse button
  \item                Move cursor along LUT bar
  \item                Release mouse button
  \item                Repeat or press right mouse button to return
\end{enumerate}



}\sstdiytopic{Fit{\undersc}Magns Options}{

  This choice of options is the same as for `fit{\undersc}magns'. Having
  two names for this group is just for clarity, as the options
  tend to fall into two sub-groups.

  In addition to the `simple set', see the help above, the
  following options are available:-

\begin{tabular}{|l|l|}\hline
 Option    &     Function \\ \hline
 boxshow     &  Toggle showing and not the box round mag positions \\
 cross       &  Change colour/size of plot/get cross \\
 cur{\undersc}magn    &  Use cursor to get Gauss positions + magnitudes \\
 cur{\undersc}posn    &  Use cursor to get positions \\
 fit{\undersc}params  &  Set:- radii; fix/vary radii in fit; box size \\
 flush{\undersc}magn  &  Forget all star Gauss positions + magnitudes \\
 flush{\undersc}posn  &  Forget all positions \\
 list{\undersc}magn   &  Type out Gauss positions and magnitudes \\
 list{\undersc}posn   &  Type out positions and pixel values \\
 plot{\undersc}file   &  Get positions from a file and plot them \\
 review      &  Type out the present setups \\
 store{\undersc}magn  &  Put acquired Gauss magnitudes into a file \\
 store{\undersc}posn  &  Put acquired positions into a file \\
\hline\end{tabular}

  Mouse button operations when getting positions:-

\hspace*{4ex}\begin{tabular}{|c|c|c|c|}\hline
  Buttons from left:-   & (1)      &     (2)    & (3) \\ \hline
   Position work: &  pick posn &    go to zoom work & return \\
     Remove work: &remove posn &    go to zoom work & return \\ \hline
\end{tabular}


}\sstdiytopic{Inspect Options}{

 In addition to the `simple set', see the help above, the
 following options are available:-

\hspace*{4ex}\begin{tabular}{|l|l|}\hline
  Option      &   Function \\ \hline
  area{\undersc}c  &   Choose new area using cursor \\
  area{\undersc}k &    Choose new area using keyboard \\
  blink    &  Blink the presently displayed image with one underneath \\
  contour  & Contour image area to device (maybe hard) \\
  controls &  Type out present control parameters \\
  descriptor &   Type out a selected image descriptor \\
  details  &  Type out the details of the image \\
  gclose   &  Close graph window on device (maybe hardcopy) \\
  gdisplay &  Display image area to device (maybe hardcopy) \\
  histogram & Display area histogram \\
  pvalues  &  Type out the look area values as a picture \\
  radius   &  Get Gaussian radius and other details of star \\
  slice    &  Plot a slice across the image \\
  solid{\undersc}tw &  Display solid body plot - transparent \\
  solid{\undersc}t &   Display solid body plot - hidden lines \\
  stats    &  Calculate areas mean  std dev max min \\
  steps    &  Change sampling steps in areas \\
  typeform &  Change format of typing out of values in area \\
  values   &  Type out the values in the area \\
 \hline\end{tabular}

{\bf \hspace*{4ex}      Mouse buttons for Blink work:- }

\hspace*{4ex}\begin{tabular}{|c|c|c|c|}\hline
      Buttons from left:- &   (1)    &       (2)   & (3) \\ \hline
  & slow blink by x2 & speed blink by x2 & switch to hand blink \\ \hline
\end{tabular}

The hand blink is done using the keyboard.


}\sstdiytopic{Positions Options}{

  This choice of options is the same as for `Fit{\undersc}magns'. Having
  two names for this group is just for clarity, as the options
  tend to fall into two sub-groups.

  See the description under `Fit{\undersc}magns' above.

}\sstdiytopic{Scrutiny Options}{

  In addition to the `simple set', see the help above, the
  following options are available:-

\begin{tabular}{|l|l|}\hline
 Option    &     Function \\ \hline
 blink       &  Blink the displayed image \\
 box         &  Put a box in the image outside the star -Remove- area \\
 comps{\undersc}all   &  Mark posn of a star and its companions in the fit \\
 comps{\undersc}dist  &  Mark posns for next list star with distant comp \\
 list{\undersc}in     &  Load a new star list (discard the old one) \\
 list{\undersc}out    &  Write to file the -Add- used (extra,removed) list \\
 lselect     &  Select a portion of the list to look at \\
 mark{\undersc}new    &  Mark up on the display the -new- star list posns \\
 mark{\undersc}old    &  Mark up on the display the -old- star list posns \\
 nearest     &  Give nearest list star to cursor position \\
 printlist   &  Put a neat summary of the fits into an ascii file \\
 profile{\undersc}in  &  Load a new star profile (discard the old one) \\
 remove      &  Clean an area round a list star with stars removed \\
 replace     &  Replace the -Remove- box by the original image data \\
 reremove    &  Display the -Remove- box again \\
 stars{\undersc}add   &  Use cursor to add stars to star list \\
 stars{\undersc}rem   &  Use cursor to remove stars from star list \\
 type{\undersc}one    &  Type out all of a star fit (from number/name) \\
 typelist    &  Put a neat summary of the fits onto the terminal \\
\hline\end{tabular}


{\bf \hspace*{4ex}  Mouse buttons for `Stars{\undersc}Add/Rem' work:- }

\hspace*{4ex}\begin{tabular}{|c|c|c|}\hline
      Buttons from left:- &   (1)  and (2)   & (3) \\ \hline
  & Add/remove star from list & Return to Option Choice \\ \hline
\end{tabular}

{\bf \hspace*{4ex}      Mouse buttons for Blink work:- }

\hspace*{4ex}\begin{tabular}{|c|c|c|c|}\hline
      Buttons from left:- &   (1)    &       (2)   & (3) \\ \hline
  & slow blink by x2 & speed blink by x2 & switch to hand blink \\ \hline
\end{tabular}

The hand blink is done using the keyboard.


}\sstdiytopic{Panel}{

 In the menu-driven mode of this program, there is the capability
 to interact with this menu in a `windows' type mode. If you choose
 the `Panel' option in the `Option' choice, then if you have an
 X-window device a small panel appears on the screen. This has what look
 like buttons with all the available options. You select these by
 putting a cursor on the `button' and then pressing a mouse button.

 The panel has a `help' button which lists out one line
 descriptions of all the options. This button also tells you what
 the program is doing:- 'working', 'waiting', etc.


}\sstdiytopic{Mouse Buttons}{

 The mouse buttons have many uses, and which button does what is
 described in the six-line help displayed, when in the `panel'
 mode.

 The cursor must be in image window area for the mouse buttons
 to work when in -WORKING- mode. The window also must be -active-
 - that is the bar at the top must be set. Click on this bar if
 it is not, before using the buttons.

 If the cursor is outside a displayed area, often pressing the button
 will result in no actions.

 For many of the groups of functions, then when a cursor is being
 used, the X,Y position and image pixel value are continuously
 displayed on the `panel', if the panel mode is being used.

 For a more detailed exposition on mouse cursor/button use when
 in the various groups of options, see the sub-sections under
 `options' above.

 Two examples of very common uses:-

{\bf \hspace*{4ex}      Mouse buttons for Zoom/Pan work:- }

\hspace*{4ex}\begin{tabular}{|l|l|}\hline
Action                         & Effect \\ \hline
Left Button twice              & zoom /2 \\
Centre Button twice            & zoom x2 \\
Left Button then Centre Button & pan \\
Right button once              & return \\ \hline
\end{tabular}

(Zoom means zoom around present position of cursor.) \newline
(Pan means set present position of cursor to screen centre.)


The hand blink is done using the keyboard.

{\bf \hspace*{4ex}      Mouse buttons for Cvalues work:- }

The values are output continuously again on the panel, or by
request on the terminal if the panel is not being used.

\hspace*{4ex}\begin{tabular}{|c|l|} \hline
      `Panel' mode?  &  Button actions \\ \hline
           Yes       &  all give return \\
           No        &  Left, Centre give values; Right gives return \\
\hline\end{tabular}


}\sstdiytopic{Colour}{

  The standard image display uses a grey-scale display. However, by
  use of the `colour' group of functions, colour displays can
  be made. There are eight standard LUT tables available, and others
  can be read in from files.

  Colour includes grey scale.

  Also the user can adjust the LUT table currently being applied. This
  can be done directly:- `flip' the LUT;Change display of values above
  and below ends of LUT. It can also be done interactively using a
  cursor:- with the use of the display of a colour bar, pick a colour
  with the cursor and `paint' this colour over a range of the LUT; Use
  horizontal movement of the cursor (with a mouse button pressed) to rotate
  the LUT; Use horizontal and vertical movement of the cursor (with a
  mouse button pressed) to shift and scale the LUT.

}\sstdiytopic{Grey Scale}{

 See above under `colour'.

}\sstdiytopic{Cursor}{

 The cursor is used to pick up positions, change the zoom, and other
 miscellaneous purposes.

 The mouse moves the cursor.

}\sstdiytopic{Hard Copy}{

  Hard copy of an image can be made using the `gdisplay' option in
  the `inspect' group of options.

}\sstdiytopic{Display}{
  IMAGE DISPLAY

  The program puts out the images for the display on X-Window
  display devices.

  There is also the option to use PGPLOT to do one single image
  output to a device with a GKS driver. This is to output a
  grey-scale picture of an area of the image. This has the use
  that hard copies can be made, and unusal devices utilised to
  look at the image.

 GRAPHICAL DISPLAY

  In the program, there are many different types of graphical
  plotting. These are usually PGPLOT driven via GKS to any
  device that has a GKS driver.

}\sstdiytopic{Input Files}{
  The input files used by this program are:-

\begin{tabular}{|l|l|p{3in}|}\hline
   Group      & Parameter &    Contents \\ \hline
   General   &  `IN'      &   The input image \\
   Colour    &  `INLUT'   &   Table of Starman:Interact Look-Up Table -
                             either in `short' or `full' format. \\
   Interact  &  `INTAB'   &   Table of X,Y positions for plotting \\
   Scrutiny  &  `INSTARS' &   Table of the Output of Starman:Measure \\
   Scrutiny   & `PROFILE' &   Image with profile parameters and profile
                               map in the normal \starman `Profile'
                               image \\ \hline
\end{tabular}

   Images are in the normal \starman 'short' 16-bit integer or 'real'
   32-bit real NDF format

   Tables are in the normal \starman `real' 32-bit real NDF format.

   For more information on:-

\begin{tabular}{ll}
      `INLUT'   &  - see the output:colour for Starman:Interact \\
      `INSTARS' &  - see the output for Starman:Measure \\
      `PROFILE' &  - see the output for Starman:Profile \\
\end{tabular}


}\sstdiytopic{Output Files}{
  There can be output from this program. If there is, it is in the
  form of one or more tables:-

\hspace*{4ex}\begin{tabular}{|l|l|p{3in}|}\hline
  Function &   Parameter  &  Table Contents \\ \hline
  Aperture &  `OUTMAGS'    &  Results of aperture photometry \\
  Colour   &  `OUTLUT'   &  New colour Look-up Table \\
  Fit{\undersc}Magns & `OUTTAB'   &  Magnitude measures \\
  Positions & `OUTTAB'   &  X,Y Pixel value tables from cursor \\
  Scrutiny & `OUTFILE' &   Text file with a formatted selection of input
                           Starman:Measure table \\
  Scrutiny & `OUTSTARS' &  Starman:Measure results table with `extra'
                           stars \\ \hline
\end{tabular}

   The tables are in the normal \starman `real' real 32-bit
   real image NDF file format.

  And one image:-

\hspace*{4ex}\begin{tabular}{|l|l|l|}\hline
  Function &   Parameter  &  Image Contents \\ \hline
  Alter    &  `OUTIM'     &  New image - an altered version of the input \\
\hline\end{tabular}


}\sstdiytopic{Alter Output}{

 The `Alter' output, `OUTIM', is an image which is an altered version
 of the input image. The alteration depends on which of the `alter'
 options have been performed on the input image.

 By default, it is a `real' real 32-bit \starman NDF image, but
 optionally, it can also be a `short' 16-bit integer image. In this
 latter case, the values can be scaled by the BSCALE, BZERO values
 if the values are outside the range -32767 to +32767.

}\sstdiytopic{Aperture Output}{

  The `Aperture' output, `OUTMAGS', is a table of the aperture photometry
  results.

  It is has contents:-  (it may only have the name,X,Y,Magnitude
  columns)

\begin{tabular}{|l|p{3in}|}\hline
   Table Column Header & Contents \\ \hline
   Name               &	Star name \\
   X 			& Star X position \\
   Y			& Star Y position \\
   Magnitude		& Star magnitude (see below) \\
   Error		& Estimate of std dev error in star magnitude \\
   Flux			& Flux (above sky) in star aperture \\
   Flux error		& Estimate of std dev error in star flux \\
   Max Value 		& Maximum pixel value in star aperture area \\
   Area 		& Area of star aperture (Straddles pixels) \\
   No Bad Pixels 	& No of `bad' pixels in star aperture \\
   Total Flux		& Total flux in star aperture \\
   Sky level 		& Sky level used for star magnitude \\
   Sky flux 		& Total flux in sky aperture used for sky level \\
   No sky bad pixels	& Number of `bad' pixels in sky aperture area \\
   Sky area 		& Area of sky aperture (Straddles pixels) \\
   Sky X 		& X position of sky aperture \\
   Sky Y  		& Y position of sky aperture \\
   Star ap dia 		& Star aperture diameter \\
   Sky ap dia 		& Sky aperture diameter \\
   Sky inner annulus diameter   & If sky area is annulus, inner diameter
                                  of annulus \\
   Sky outer annulus diameter  &  If sky area is annulus, outer diameter
                                  of annulus \\
   Annulus flag 	& Sky area circle (0.0), or annulus around
                          star(1.0)? \\
   Centering flag 	& Star position been:- `none' `max' `pixel'
                          `centroid' `Gauss' method -- (1/2/3/4) --
                           centered \\
   Median flag 		& Sky level taken as mean (0.0), or median (1.0)? \\
   Extra noise 		& Extra noise level assumed per pixel \\
   Events/pixel values 	& Square root[Flux*(this)] = effective Poisson
                          noise \\
   Exp time 		& Exposure time \\
   Zero point		& Zero point applied to output mag \\ \hline
\end{tabular}


   Where:-

   $$ Output{\hspace{0.3em}}magnitude = 30.0 +
                                        `Zero{\hspace{0.3em}}point' -
      2.5*log_{10}[\frac{Star{\hspace{0.3em}}flux}{Exposure{
      \hspace{0.3em}}time}] $$

$$   Star{\hspace{0.3em}}flux = Flux{\hspace{0.3em}}in{
         \hspace{0.3em}}star{\hspace{0.3em}}aperture -
         (Sky{\hspace{0.3em}}level)*(Star{\hspace{0.3em}}ap{
         \hspace{0.3em}}area) $$

$$ {\hspace*{-2em}}     1) {\hspace*{3em}}   Sky{\hspace{0.3em}}flux  =
         \frac{Flux{\hspace{0.3em}}in{\hspace{0.3em}}sky{
         \hspace{0.3em}}aperture}{area{\hspace{0.3em}}of{
         \hspace{0.3em}}sky{\hspace{0.3em}}aperture} $$

$$   Or {\hspace*{2em}}   2) {\hspace*{3em}} Sky{\hspace{0.3em}}flux  =
     Median{\hspace{0.3em}}pixel{\hspace{0.3em}}value{
     \hspace{0.3em}}in{\hspace{0.3em}}sky{\hspace{0.3em}}aperture  $$

   In the annulus work, the sky area is taken as that between the
   sky annulus inner ring and the sky annulus outer ring.
   In non-annulus work, the sky aperture is a simple circle, placed
   as specified.

   `Bad pixels' are ignored. Thus in the sky estimates this should
   not make much trouble, but in the Star estimates it will if the
   relevant pixel has a value above the sky level.

   The apertures have `smooth' edges. The circle that gives the
   edge of the aperture will fall `through' the body of some of the
   pixels at the edge of the aperture. What happens then is that these
   `edge' pixels are subdivided into a 5x5 subarray, and each sub-pixel
   is looked at to see if it is in or out of the aperture. The area of
   the pixel, for the program purposes, is then (number/25.0). The
   flux in the pixel is then scaled down to the same extent.

   Errors:-

   The errors are calculated assuming that the pixel values are due
   to a source with Poisson noise (which has suffered scaling) and
   an extra `magic' source of noise (with zero effect on the mean
   pixel value).

   Thus the pixel variance = Flux*(`Poiss' value) +
                          (no of pixels)*(`Noise' value)*(`Noise' value)

   [Std dev = square root(variance)]

   The star error is then calculated assuming that noise in the star
   flux, and noise due to the error in calculating the sky level.

}\sstdiytopic{Colour Output}{
  The output of the Interact:Colour group, `OUTLUT', is a file
  containing a table describing the Colour Look-Up Table made in the
  group.

  This is a table containing the R,G,B fractional colour contributions
  in columns 1,2,3 of the table (ignoring the 1st 5 for table row
  names - which are not used). There are 150 rows in this table.
  Starting from the first row, there is the R,G,B set for the lowest
  location on the table, carrying onto the 150th row, where there is
  the highest LUT entry.

  There is also a scale `LUTSC', and a zero `LUTZE', in descriptors.
  These scale the LUT. A given entry point, say RV, which is
  bewteen 0.0 and 1.0, would normally go to the R,G,B set of the
  RV*150th row in the input LUT. It goes as
  the [(RV-LUTZE)/LUTSC]*150th entry, actually. If this entry is below 1 or
  above 150, then the entry is either, set at 1 or 150, or set at
  its modulo 150 value.

}\sstdiytopic{Fit{\undersc}Magns Output}{
  The output of the Interact:fit{\undersc}magns group, `OUTTAB', is a file
  containing a table of the magnitude measures.

  The headers are:  `X', `Y', `Magnitude', `Dx', `Dy', `Iterations',
                    `Rms', `Numinval', `Height', `Base', `Max pixel',
                    `Rx', `Ry', `Xbox', `Ybox'

}\sstdiytopic{Positions Output}{
  The output of the Interact:positions group, `OUTTAB', is a file
  containing a table of either the X,Y positions and pixel values of the
  locations chosen by the cursor. The headers are `X', `Y', and `VALUE'.


}\sstdiytopic{Scrutiny Output}{
  One output of the Interact:Scrutiny group, `OUTSTARS', is a file
  containing a table in the format of the Starman:Measure program,
  of that input Starman:measure table, but with (optionally) some stars
  removed, and (optionally) some extra stars added. These extra stars
  are picked up in the Interact:Scrutiny group of functions

  The other output, `OUTFILE', is a text file containing a selection
  of the input Starman:Measure table of fitted results. The user
  selects the option to `print' the table in a defined format to
  this file. The file is a normal ASCII text file

}\sstparameters{

\vspace*{3mm}

\sstsubsection{\large \bf Introduction:- }{

  The parameters are split into groups in this manual - a general one for
  parameters which are used by more than one of the program
  groups, and then a group for each of the eight program groups themselves.

\begin{tabular}{|l|l|}\hline
     Group     &    Function \\ \hline
     General   &    Disparate functions \\
     Main      &    Entry level functions \\
     Alter     &    Alter the image \\
     Aperture  &    Aperture photometry in an interactive way \\
     Colour    &    Changing the colour LUT of the image display \\
     Fit{\undersc}magns &    Magnitudes with simple profile fitting \\
     Inspect   &    Look at pixel values in different ways \\
     Positions &    Get/plot table of XY positions \\
     Scrutiny  &    Look at the output of Starman:Measure \\ \hline
\end{tabular}

\hspace*{3mm}

}\sstsubsection{\large \bf General:-}{

  The parameters that are used by more than one program group.


}\sstsubsection{BLINK{\undersc}CH = LITERAL (Read)}{
  (Default - last, start `under' \hspace{6ex}
   Choice -'under:over:auto:exit')

  Where to put the window for a `blink'. The blink is achieved by
  putting the display window `under' or `over' any other window
  that is in the same place. [Thus you should have used another
  window to open up another display window with the image, and placed
  it in the same position as the display window of this program.]

\begin{tabular}{|l|l|}\hline
 Choice  &   Function \\ \hline
  auto   &    Blink by alternatively putting it on top then under \\
  exit   &    Return from this option \\
  over   &    Place window on top of any other \\
  under  &    Place window under any other \\
 \hline\end{tabular}

  In automatic blinking, then the displayed image is alternately
  `popped' and `pushed'. The time interval starts of at 1/2 second,
  and is lengthed or shortened by pressing keys on the mouse.

  The keys have the functions:-

\hspace*{4ex}\begin{tabular}{|l|l|}\hline
    Action   & Effect \\ \hline
    Left Button   & slow blink by x2 \\
    Centre Button & speed blink by x2 \\
    Right Button  & switch to hand blink \\
 \hline\end{tabular}

}\sstsubsection{EASYSTART = LITERAL (Read)}{
  (Default - `yes'    \hspace{6ex}    Choice - `yes:no')

   Use the standard start sequence of operations?

   This quickly gets an image, displays it in the standard way, sets
   up the panel buttons, and gets you going.

   The alternative is simply to go into the normal `OPTION'
   method of the program asking you for instructions. You would want
   to use this if you wished not to display the image at first, or
   not use the panel buttons, or display the image in a non-standard
   way.

}\sstsubsection{GTYPE = LITERAL (Read)}{
  (Default - `ask'    \hspace{6ex}    Choice - any)

  A character string giving the local name for the graphics
  display type.

  `xwindows' will put it out on the screen of your display.
  if you are using one.

  If `ask' is input, then the program asks a very similar question,
  in a different way. A response here of `?' will bring up a listing
  of all the possible names of graphics devices which are supported
  on your machine, and you then input the appropriate name.

}\sstsubsection{IN = NDF (Read)}{
  (Default - null)

 The name of the file containing the input 2-D image.

 A null `return' entry is not allowed at the very start of the
 program. Later on, it may be, in which case the program
 will continue. Sometimes four repeated `null' entries will be
 needed to get to this continue.

 This image can be either the `real' 32-bit real or the `short'
 16-bit integer' NDF format.

}\sstsubsection{IMCOMP = {\undersc}INTEGER(2) (Read)}{
  (Default - variable, usually 1,1        \hspace{6ex}
  Range - 1 to 1000)

  Factor in X and Y by which to compress the displayed image.

}\sstsubsection{IMPOSN = {\undersc}INTEGER(2) (Read)}{
  (Default - so as to centre image in screen
   Range -  -100000 to 100000)

  Place to put b.l.h. corner of displayed image onto the
  screen. Thus an answer of `1,1' would put the b.l.h. pixel
  of the displayed image at the b.l.h corner of the screen.


}\sstsubsection{LINECOL = LITERAL (Read)}{
  (Default - `black'  \hspace{6ex}       Choice - `black:white')

 Colour of plot lines. This is determined by whether you have a
 black or white background to your plots.

}\sstsubsection{NUMBUTT = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - see below   \hspace*{6ex} Range - 2 to 3)

  Number of `X-Window' buttons available on the mouse.

  Some devices have two and some have three buttons available. This
  can depend both on their actual presence, and also on the X Windows
  software that is being run.

  With three buttons, then the \starman programs use all three, with
  the right-hand button being used mainly as the `exit' button.

  With two buttons, then the third button is simulated by pressing
  both of the buttons down, with the middle one being pressed slightly
  BEFORE the left-hand one. Use of the middle button in its normal
  way has to be modified, in that one has to pause for half a second
  after using it.

  [This parameter is usally `hidden', with the machine manager setting
   it to the appropriate value for the local set-up. Sometimes it will
   be left to the user to set, depending on his software configuartion.]

}\sstsubsection{SCREEN = {\undersc}INTEGER(2) (Read)}{
  (Default - 1, size of image      \hspace{6ex} Range - 1 to large)

  Size of screen or window to open.

  The default size is that of the image, unless the image is too large
  to fit on the screen, when the image will be binned down by an integer
  factor for display. The default size will then be this binned down size.


}\sstsubsection{TITLE = (Read)}{
  (Default - various            \hspace{6ex}    Choice - any character string)

  The title to put into the `TITLE' descriptor of the output
  file you are making at the moment. This deals with the output files
  accessed through the `OUTMAGS', `OUTLUT', `OUTTAB', `OUTSTARS' parameters
  (see the `Output' sections above).

}\sstsubsection{VRANGE = {\undersc}REAL(2) (Read)}{
 (Default - suggested values  \hspace{6ex}  Range - -1.0e10 to 1.0e10)

 The range of values to be displayed as black to white on image display
 display.


  The display of pixel values above and below these limits is
  controlled by the value of the `wrap' parameter. They are shown
  as either:-

  \begin{list}{{-}}{}
     \item Black below and white above
     \item Modulo the `Vrange' display range
\end{list}

}\sstsubsection{WRAP = LITERAL (Read)}{
  (Default - `no'        \hspace{4ex}    Choice - `yes/no')

 When displaying image on image display, for those image pixel values that
 lie above or below the display values for white or black, do you want
 these values to be shown as white or black (`no'), or do you want them to
 be `wrapped' round - that is considered as modulo the display range
 (`yes')?

\vspace*{3mm}

}\sstsubsection{ \large \bf Main:-}{

  The parameters that are used by the `Main' program group.

}\sstsubsection{OPTION = LITERAL (Read)}{
  (Default - present value, start=see below       \hspace{6ex}
   Choices - see below)

 What operation, from a menu of possible choices, to do next?

 (Accessed in the `Main' group of options.)

 It is the entry option choice. You repeatedly get asked for options.
 You select one of the menu operations.  A number of these - the
 `functions' are themselves list of options.

 When you started the program, you were asked for the input image and
 input star table. Then you started on this option choice. Generally the
 default option is a repeat of the last option. However at the start,
 a standard set of options is given as the default.

 The list of functions is given at the start of this section.

 The cursor must be in image window area for the cursor buttons to
 work when in `WORKING' mode. The window also must be `active' - that
 is the bar at the top must be set. Click on this bar if it is not
 before using the buttons.

 The options and use of the buttons are described earlier.

\hspace*{3mm}

}\sstsubsection{\large \bf Alter:-}{

  The parameters that are used by the `alter' program group.

}\sstsubsection{ALOPTION = LITERAL (Read)}{
  (Default - present value   \hspace{6ex}    Choices - see below)

 What operation, from a menu of possible choices, to do next?

 It is the Alter choice, which you repeatedly come back to, after
 performing operations. You select one of the menu  operations.

 Generally the default option is a repeat of the last option.

 The list of options and button usage has been described earlier.

}\sstsubsection{BIN = {\undersc}INTEGER (Read)}{
  (Default - 1,1   \hspace{6ex}    Range - 1 to max size of image)

  The two integer values for the X and Y compressions.


}\sstsubsection{BLANK = {\undersc}INTEGER (Read)}{
  (Default - 1,1,1,1 or last   \hspace{6ex}    Range - 1 to max size of image)

  The four integer values for the X and Y coords of the b.l.h.
  corner and t.r.h. corner of the area of the image to
  be set to INVALID. (input as xs,ys,xe,ye)

}\sstsubsection{BOX = {\undersc}INTEGER(2) (Read)}{
  (Default - 3,3    \hspace{6ex}    Range - 1 to max size of image)

  The two integer values for the X and Y sides of the box
  to be used for the `top-hat' box averaging or the `median'
  box averaging.

}\sstsubsection{CHECK = LITERAL (Read)}{
  (Default - 'no'  \hspace{6ex}    Choice - `yes:no')

  When using the `top-hat' averaging, do we check for `bad'
  (INVALID) pixels, and set the output average value for the box
  that contains any such pixels as `bad'? In this case, the
  answer is 'yes'.

  Or do we just ignore such pixels, and make the average the
  average of all the `good' pixels?  In this case, the
  answer is 'no'.

  (In both cases, a box that contains only `bad' pixels will be
   set to `INVALID'.)

}\sstsubsection{DOIT = LITERAL (Read)}{
  (Default - 'no'  \hspace{6ex}    Choice - `yes:no')

  Perform, or not, a second smoothing in the unsharp masking.

  This is often done so that signal can be removed at both long
  and short scales. In this case, then in one of the smoothings,
  a box with a small side is used, and in the other, one with a
  large side.

}\sstsubsection{EQN = LITERAL (Read)}{
  (Default - null          \hspace{6ex}    Choice - as defined below)

  The FORTRAN-style expression that gives the elements in the
  pixels of the output image.

  Its style is given the `equation' section of this help.


}\sstsubsection{FRACTION = {\undersc}REAL (Read)}{
  (Default - 0.8    \hspace{6ex}    Range - 0.0 to 1.0e20)

 The fraction of the values of the smoothed image that are
 to be subtracted from the original image.

 A value of 0.8 often gives a nice removal of most of the unwanted
 signal, whilst leaving enough to keep all values positive, and
 also some indication of the original signal.

 It will be a matter of experimentation what value is appropriate
 to the actual image being unsharp-masked.

 Thus after the subtraction is done and displayed, the user is
 asked, via the `MORE' parameter, if a new value is to be tried.

}\sstsubsection{GBOX = {\undersc}INTEGER(2) (Read)}{
  (Default - 10 x X,Y star radii \hspace{6ex}
   Range - 1 to max size of image)

  The two integer values for the X and Y sides of the box
  to be used for the `gaussian' box averaging.

  Each value must be an odd number.

}\sstsubsection{GRADIUS = {\undersc}REAL (Read)}{
  (Default - 2.0  \hspace{6ex}   Range - 1.0e-5 to 1.0e10)

  The radius of the circular Gaussian profile to be used in
  doing theGaussian smoothing.


  The profile is taken as:- $ e^{-1.0*(d/r)**2} $

  where          d = distance from profile centre in pixels \newline
 \phantom{where} r = GRADIUS

}\sstsubsection{INIM = NDF (Read)}{
  (Default - null)

 The input image corresponding to one of the `IB' to `IZ' to be used
 in the arithmetic expression.

 The `IB', 1IC', ..., `IZ' in the equation pick up the images from
 the parameters `INB', `INC', ..., `INZ'.

 (`IA' is reserved to mean the presently displayed image.)

 The input images must be standard Starman ADAM .SDF images, with
 either `real' 32-bit real values, or `short' 16-bit integer values.
 They can have the `BSCALE' and `BZERO' values, and `magic pixel values'
 indicating `bad' pixels.

 The `help' for all these is kept here, for `inim'.

}\sstsubsection{INVAR = {\undersc}REAL (Read)}{
  (Default - 0.0    \hspace{6ex}       Range -1.0e37 to 1.0e37)

  The value to be used in the equation for the value of
  the desired variable, from the range `A', `B', ..., `Z'.

  The `help' for all these is kept here, for `invar'.

}\sstsubsection{MORE = LITERAL (Read)}{
  (Default - 'yes'  \hspace{6ex}    Choice - `yes:no')

 In doing the unsharp masking, do you want to have another
 go at subtracting the smoothed image from the original image?

 This enables you to input a new value of the factor by which
 the smoothed image is multiplied before being subtracted.

 See the comments on the `FRACTION' parameter above for why
 this is useful.

}\sstsubsection{NXY = {\undersc}INTEGER (Read)}{
  (Default - 1,1 \hspace*{6ex}       Range - 1 to 100000)

  If there are no input images, the user has the choice of the size of
  the output image.

  This parameter defines the `X' and 'Y' sizes of the output image.

}\sstsubsection{OUTIM = NDF (Write)}{
  (Default - null)

  The name of the output file to contain the `Alter' output
  image.

  This is in the format of the \starman `short' 16-bit integer or
  `real' real 32-bit NDF image.

  A description is given above, in the `Alter Output' section.

}\sstsubsection{ROTATE = {\undersc}REAL (Read)}{
  (Default - 0.0  \hspace{6ex}   Range - 1.0e-20 to 1.0e20)

 The angle in degrees through which to rotate the image in a
 counter-clockwise direction.

 After rotation, if the image is not orthogonal to the X and Y axes,
 it is placed within a larger image, so that the new `bottom' corner
 is at the bottom of the image, and the new `left-hand' corner is
 at the left of the image.


}\sstsubsection{SAMPLE = LITERAL (Read)}{
  (Default - 'highest'  \hspace{6ex}
   Choice - 'sample:highest:average' )

  Method of extracting output value from binning box:-

\begin{tabular}{|l|l|}\hline
  Option  &  Choice \\ \hline
  Average & Take average of all pixels \\
  Highest & Take highest pixel \\
  Sample  & Take value of bottom left hand pixel in box \\ \hline
\end{tabular}

}\sstsubsection{SEED = {\undersc}INTEGER (Read)}{
  (Default - 1234567891    \hspace{6ex} Range - 1200000001 to 1400000001)

  The seed number to be used in any random number generators.
  This is used in the `GAUSS()' and `RAN()' operators. These
  will provide the same pattern of numbers in the same
  seed number is input.

  It has to be a large positive odd number.

}\sstsubsection{SMETHOD = LITERAL (Read)}{
  (Default - 'box' or `median' \hspace{6ex}
   Choice - 'gauss:box:median')

  Which smoothing method to use.

\vspace*{2mm}\begin{tabular}{|l|p{5in}|}\hline
  Option  &  Choice \\ \hline
  Gauss   & Run a rectangular box over the whole image, taking the
            average of the pixels using a weight given by the value of a
            circular Gaussian profile centered at the box centre. \\
  Box     & Run a rectangular box over the whole image, taking the
            average of the pixels within the box. \\
  Median  & Run a rectangular box over the whole image, taking the
            median of the pixels within the box. \\
\hline\end{tabular}\vspace*{2mm}

  For all three methods, the result is normalised, so that a flat
  image would result in an identical output.

  When the box overlaps the edges of the image, only the pixels
  inside the image are taken.

}\sstsubsection{TITLEIM = LITERAL (Read)}{
  (Default - ' '  \hspace{6ex}    Choice - any)

  Title to add as a descriptor of the output image of the `Alter'
  group of options. The default is the title of the input image,
  or ' ', if it has no title.

}\sstsubsection{XCOEFF = {\undersc}REAL(3) (Read)}{
  (Default - 0.0,1.0,0.0 \hspace{6ex}    Range - -1.0e8 to 1.0e8)

  The coefficients used to calculate, for a pixel in the new image,
  its X position in the old image.

    $$ X_n  =  C(1) + C(2)*X_o  +  C(3)*Y_o $$

}\sstsubsection{XMAGNIFY = {\undersc}REAL (Read)}{
  (Default - 1.0   \hspace{6ex}    Range - 1.0 to 1.0e20)

 The factor by which to stretch the image in the X direction.

 The magnification is done by using this and the `YMAGNIFY'
 parameter to load the coefficients of the transform values.

 If one wishes to compress the image by integer steps, it is
 better to use the `compress' option.

}\sstsubsection{YCOEFF = {\undersc}REAL(3) (Read)}{
  (Default - 0.0,0.0,1.0 \hspace{6ex}    Range - -1.0e8 to 1.0e8)

  The coefficients used to calculate, for a pixel in the new image,
  its X position in the old image.

    $$ Y_n  =  C(1) + C(2)*X_o  +  C(3)*Y_o $$

}\sstsubsection{YMAGNIFY = {\undersc}REAL (Read)}{
  (Default - 1.0   \hspace{6ex}    Range - 1.0 to 1.0e20)

 The factor by which to stretch the image in the Y direction.

 The magnification is done by using this and the `YMAGNIFY'
 parameter to load the coefficients of the transform values.

 If one wishes to compress the image by integer steps, it is
 better to use the `compress' option.


\vspace*{3mm}

}\sstsubsection{\large \bf Aperture:-}{

  The parameters that are used by the `Aperture' program group.

}\sstsubsection{AIRNAME = LITERAL (Read)}{
  (Default - 'null')

  Name of descriptor in the image which holds the airmass.

}\sstsubsection{AOPTION = LITERAL (Read)}{
  (Default - present value, start='size{\undersc}c'       \hspace{6ex}
   Choices - see below)

 What operation, from a menu of possible choices, to do next?

 It is the Aperture Photometry option choice, which you repeatedly come
 back to, after performing operations. You select one of the menu
 operations.

 Generally the default option is a repeat of the last option. However
 at the start of doing `Aperture', the default is `Size{\undersc}c'.

 The list of options and button usage has been described earlier.

}\sstsubsection{APANG = {\undersc}REAL (Read)}{
  (Default - present value, start=0.0          \hspace{6ex}
   Range - -90.0 to +90.0)

 Angle to X-axis, working counter-clockwise, that the major
  axis makes, in degrees.

}\sstsubsection{APDIAM = {\undersc}REAL (Read)}{
  (Default - present value, start=see below          \hspace{6ex}
   Range - 0.0 to 1.0e8)

  The diameter in pixels of the apertures used in the measuring.

  These are :-

  \begin{list}{{-}}{}
  \item        the star aperture diameter     (start=20.0)
  \item        the sky aperture diameter for non-annulus work
                                              (start=20.0)
  \item        the sky aperture inner diameter for annulus work
                                              (start=30.0)
  \item        the sky aperture outer diameter for annulus work
                                              (start=40.0)
  \end{list}

  In the annulus work, the sky area is taken as that between the sky
  inner annulus ring and the sky outer annulus ring.
  In non-annulus work, the sky aperture is a simple circle, placed
  as specified.

}\sstsubsection{APELL = {\undersc}REAL (Read)}{
  (Default - present value, start=0.0              \hspace{6ex}
   Range - 0.0 to 1.0)

  The ellipticity of the aperture.

  The ellipticity is ((a-b)/a) where a = major axis diameter and
  b = minor axis. a is the diameter you input for aperture size.
  Thus a round aperture has ellipticity = 0.0, a line has = 1.0.

}\sstsubsection{COORDTYPE = LITERAL (Read)}{
  (Default - 'radians'               \hspace{6ex}
   Choice - `degrees:radians:string')

 Method by which the RA and Dec are stored in the descriptors.

 \begin{tabular}{|l|l|}\hline
   Method  &  Example \\ \hline
   degrees &   +40.234 \\
   radians &   -0.445678 \\
   string  &   +12 34 45 \\ \hline
  \end{tabular}

}\sstsubsection{DECNAME= LITERAL (Read)}{
  (Default - 'null')

  Name of descriptor in the image which holds the object Dec.

}\sstsubsection{DESCRAIR= LITERAL (Read)}{
  (Default - 'airmass') \hspace{6ex}    Choice - `none:airmas:position')

 Method of getting airmss of observation.

 \begin{tabular}{|l|l|}\hline
   Choice   &   Method \\ \hline
   airmass  &  Get it from a descriptor in the image \\
   none     & Do not calculate airmass \\
   position &  Use the RA and Dec of the object, with the Sid T and
             site latitude \\ \hline
  \end{tabular}

}\sstsubsection{DESCRFILT= LITERAL (Read)}{
  (Default - last (start='no') \hspace{6ex}    Choice - `yes:no')

  Use image descriptor to get filters from? If there is one
  this is nice to use. If there isnt, you cant.

}\sstsubsection{DESCRTIME= LITERAL (Read)}{
  (Default - last (start='no') \hspace{6ex}    Choice - `yes:no')

  Use image descriptor to get the exposure time from? If there is one
  this is nice to use. If there isnt, you cant.

}\sstsubsection{EXPNAME= LITERAL (Read)}{
  (Default - 'null')

  Name of descriptor in the image which holds the exposure time.

}\sstsubsection{EXPTIM = {\undersc}REAL (Read)}{
  (Default - present value, start=1.0              \hspace{6ex}
   Range - 1.0e-8 to 1.0e8)

  The exposure time of the image. This is applied to the output
  magnitude. It applies a correction of $-2.5*log_{10}(Exptim)$,
  and thus the starting exposure time of 1 second applies a zero
  correction.

}\sstsubsection{EXTINC = {\undersc}REAL (Read)}{
  (Default - see below               \hspace{6ex}
   Range - 0.0 to 1.0e8)

  The extinction values to use with this filter.

  The defaults assume that the filters are U,B,V,R,I,J,H,K,L and are
  0.68, 0.28, 0.15, 0.10, 0.07, 0.10, 0.04, 0.06, 0.06 for the nine
  possible filters.


}\sstsubsection{FILTLOC = {\undersc}REAL (Read)}{
  (Default - 1,79      \hspace{6ex}       Range - 1 to 256)

  Start and end location in the filter name descriptor of the
  characters that have the filter name.

}\sstsubsection{FILTNAME = LITERAL (Read)}{
  (Default - `null'      \hspace{6ex}

  Name of descriptor in the image which holds the filter name.


}\sstsubsection{FIXGRAD = LITERAL (Read)}{
  (Default - `no'      \hspace{6ex}       Choice - `yes:no')

  Use fixed radii when doing Gauss centering with fixed radii ('Yes').
  If floating radii are desired, use `No'.

}\sstsubsection{FNAME= LITERAL (Read)}{
  (Default - 'null')

  Name of filter that can be looked for in the filter name descriptor.

  Up to nine names can be input, via the `FNAME1', `FNAME1', ....,
  `FNAME9' input.

  Input is stopped by inputting a `null' entry (hit `return' key).

}\sstsubsection{GRADII = {\undersc}REAL (Read)}{
  (Default - present value, start=2.0,2.0     \hspace{6ex}
     Range - 0.1 to 100.0)

  Gaussian radii to use when doing Gauss centering with fixed radii.

}\sstsubsection{KEEP = LITERAL (Read)}{
  (Default - `no'      \hspace{6ex}       Choice - `yes:no')

  If some aperture measures done have been `removed', then this
  gives the user a chance to resurrect all such removed ones
  when loading the output results table file.

}\sstsubsection{KEYTIME = LITERAL (Read)}{
  (Default - `no'      \hspace{6ex}       Choice - `yes:no')

  Do you want to correct the magnitudes by an `exposure time',
  entered via the keyboard?

}\sstsubsection{LATITUDE = LITERAL (Read)}{
  (Default - `+00 00 00'

  Latitude of site.

  This is input as a character string in the format `+00 00 00'

}\sstsubsection{LIST = LITERAL (Read)}{
  (Default - `no'      \hspace{6ex}       Choice - `yes:no')

  If some aperture measures done have been `removed', then this
  gives the user a chance to have them all output when doing the
  the type-out of the results table.

}\sstsubsection{METHOD = LITERAL (Read)}{
  (Default - present value, starting `annulus'    \hspace{6ex}
   Choice - `annulus:separate')

  Method to determine the area used to get the sky level.

  There are two ways of selecting areas the area to be used for
  determining the sky level. These are an annulus round the star,
  and a separate circular area elsewhere in the image.

  The advantage of using an annulus is that this gives a good
  estimate of the mean level at the star itself. The disadvantage
  is that a significantly bright star may be present in that
  annulus. With the use of a separate area, an area free of
  significant stars can be chosen.

  If the `separate' mode is used, then the sky level adopted
  for each star is that determined from the last sky level
  determination. Such determinations can be made as frequently as
  desired.

  In the `annulus' mode, the inner and outer radii of the annulus
  can be set separately.

  For a fuller discussion on the problems of determining sky levels,
  see the `Options' - `Aperture options' section.

}\sstsubsection{NOISE = {\undersc}REAL (Read)}{
  (Default - present value, start=0.0              \hspace{6ex}
   Range - 0.0 to 1.0e16)

  The amount of extra noise that is actually present in each pixel,
  above the amount the program can find.

  The program thinks that the only source of noise is the Poisson
  noise of the counts (scaled by the `Poiss' parameter input factor).
  This `Noise' parameter allows you to put in another source of
  noise. An example could be the `read-out' noise of a CCD.

  The `Noise' is the standard deviation ofsuch an extra source of
  noise.

}\sstsubsection{OUTMAGS = NDF (Write)}{
  (Default - null)

  The name of the output file to contain the `Aperture' output results
  table.

  This is in the format of the \starman 'real' real 32-bit NDF file.

  The contents are described in the 'Output' section.

}\sstsubsection{OUTTYPE = LITERAL (Read)}{
  (Default - `full'              \hspace{6ex}    Choice - `Short/Full')

  Do you want the output `Aperture' results table file to contain
  all the information, or just a shortened subset? The shortened
  subset just has the X,Y positions and the measured magnitudes.

}\sstsubsection{POISS = {\undersc}REAL (Read)}{
  (Default - present value, start=1.0          \hspace{6ex}
   Range - 1.0e-8 to 1.0e16)

 The scaling that would have to be applied to pixel values so that
 their values would have a Poissonian distribution.

 This is used to calculate the error on a flux level.

\begin{eqnarray}
 The{\hspace{0.3em}}error{\hspace{0.3em}}used{\hspace{0.3em}}(squared)
   & = & Flux*(`Poiss'{\hspace{0.3em}}value) + \nonumber \\
   &   & (no{\hspace{0.3em}}of{\hspace{0.3em}}pixels)*(`Noise'{
         \hspace{0.3em}}value)*(`Noise'{\hspace{0.3em}}value) \nonumber
\end{eqnarray}

 This enables the output error estimates to be reasonably correct.

}\sstsubsection{RANAME= LITERAL (Read)}{
  (Default - 'null')

  Name of descriptor in the image which holds the object RA.

}\sstsubsection{SIDTNAME= LITERAL (Read)}{
  (Default - 'null')

  Name of descriptor in the image which holds the Sidereal Time of the
  exposure.

}\sstsubsection{ZEROP = {\undersc}REAL (Read)}{
  (Default - present value, start=0.0             \hspace{6ex}
   Range - -1.0e8 to 1.0e8)

  The zero point to be added to the output star magnitudes.

\vspace*{3mm}

}\sstsubsection{\large \bf Colour:-}{

  The parameters that are used by the `Colour' program group.

}\sstsubsection{COPTION = LITERAL (Read)}{
  (Default - present value,start='load'        \hspace{6ex}
   Choices - see below)

  What operation, from a menu of possible choices, to do next?

  The menu selection of options for changing the colour Look-up Table
  of the image display.

  You repeatedly come back to this parameter after performing `Colour'
  operations. You select one of the menu operations. You return to the
  main `Interact' group by entering the `return' option.

  The functions and button uses are listed above in the `Options' section.

  The cursor must be in image window area for the cursor buttons to
  work when in `WORKING' mode. The window also must be `active' - that
  is the bar at the top must be set. Click on this bar if it is not
  before using the buttons.

}\sstsubsection{INLUT = NDF (Read)}{
  (Default = null)

  The name of a file containing a LUT Table in the `full' format of the
  Interact:Colour output `OUTLUT', or as a `short' LUT in a brief
  form. In the later case the file is read into the internal program
  storage, but not loaded to the display LUT. It may, of course, be
  later read from the storage to be applied to the display LUT.

  The formats are more fully described in the `colour' section.

  This enables you to input a new LUT.

}\sstsubsection{LUTNUM = {\undersc}INTEGER (Read)}{
  (Default - 1             \hspace{6ex}    Range - 1-15)

  Choose the number of the stored LUT table you want to apply to the
  display.

  The program has eight standard LUT tables, numbered as 1-8. You
  can input others, or store modified ones, and store them in numbers
  9-15. These are then available for use. However these are not
  kept when you exit from the program.

  The eight standard LUT tables are described above in the section
  on `colour option'.

}\sstsubsection{NUM{\undersc}LUT = {\undersc}INTEGER (Read)}{
  (Default - 1st number not yet used                  \hspace{6ex}
  Range - 9 to 15)

  When reading in a file containing a `short' Look-up Table, this
  is the storage number inside the program where it is kept.

  You can put it in any of the 9 - 15 slots, but you may overwrite a
  previously stored short LURT.

}\sstsubsection{OUTLUT = NDF (Write)}{
  (Default - null)

  The name of the new file, into which you wish to load the LUT
  presently in use. This is stored as a `full' LUT, in a standard
  format:-

  This is a table containing the R,G,B fractional colour contributions
  in columns 1,2,3 of the table (ignoring the 1st 5 for table row
  names - which are not used). There are 150 rows in this table.
  Starting from the first row, there is the R,G,B set for the lowest
  location on the table, carrying onto the 150th row, where there is
  the highest LUT entry.

  There is also a scale `LUTSC', and a zero `LUTZE', in descriptors.
  These scale the LUT. A given entry point, say RV, which is
  bewteen 0.0 and 1.0, would normally go to the R,G,B set of the
  RV*150th row in the input LUT. It goes as
  the [(RV-LUTZE)/LUTSC]*150th entry, actually. If this entry is below 1 or
  above 150, then the entry is either, set at 1 or 150, or set at
  its modulo 150 value.


\vspace*{3mm}

}\sstsubsection{ \large \bf Fit{\undersc}Magns:-}{

  The parameters that are used by the `Fit{\undersc}Magns' program group.

  (They are also used by the `Positions' group, which access the same
   options.)

}\sstsubsection{BOXSHOW = LITERAL (Read)}{
  (Default - last (start='yes')   \hspace{6ex}    Choice - `yes:no')

  After a star has been fitted, paint a rectangle round the
  fitted area?

}\sstsubsection{BOXSIZE = {\undersc}INTEGER(2) (Read)}{
  (Default - last (start=10,10)          \hspace{6ex}
   Range - 3 to 200)

  Size of box around star input position that defines area to
  be fitted for star posn and magnitude.
  It should be some 3 to 5 times the star profile FWHM.

}\sstsubsection{CRCOL = LITERAL (Read)}{
  (Default - `Blue'           \hspace{6ex}    Choices - see below)

  Colour of crosses to paint up either when marking new or old
  X,Y positions, or when marking up positions from the input
  `INTAB' table.

  Choice is:- red:green:blue:cyan:magenta:yellow:coral:palegreen

}\sstsubsection{CROSSL = {\undersc}REAL (Read)}{
  (Default - Present value, start=3.0           \hspace{6ex}
   Range - 1.0 to 1.0e8)

  Length in pixels, of cross arms (from side to side) of the
  crosses written up marking old or new X,Y positions.

}\sstsubsection{GOPTION = LITERAL (Read)}{
  (Default - present value, start=''       \hspace{6ex}
   Choices - see below)

  What operation, from a menu of possible choices, to do next?

 (Accessed in the `Fit{\undersc}magns' and `Positions' groups of options.)

  The menu selection of options for getting magns and positions from the
  display. You repeatedly come back to this parameter after
  performing `Getting Position' operations. You select one of the
  menu operations.

  The functions and button usgae are as described earlier
  in this description.

}\sstsubsection{INTAB = NDF (Read)}{
  (Default = null)

  Name of the existing file with the input table of X,Y positions to
  plot on the display.

}\sstsubsection{RADFIX = LITERAL (Read)}{
  (Default - last, start='no'       \hspace{6ex}  Choice - `yes:no')

   Fix the star X and Y radii, or not?

   In the Gaussian fitting, keep the star radii fixed?

}\sstsubsection{RADSIZE = {\undersc}REAL(2) (Read)}{
  (Default - last (start=2.0,2.0)         \hspace{6ex}
   Range - 0.2 to 100.0)

   What X and Y radii to give to the star Gaussian profile?

   These are the radii out at which the profile is 1/e of the
   peak value. The profile is elliptical, but orthogonal to the
   X and Y axes. If the radii are kept fixed (set through the RADFIX
   parameter), then these are the radii used. If they are not
   fixed, then these are the start values for the fitting, and they
   get refined through the fitting to produce the best fit. In this
   case, it is hepful to the fitting if these start values are close
   to the actual values.

}\sstsubsection{XRANGE = {\undersc}INTEGER(2) (Read)}{
  (Default - 1, X size if image         \hspace{6ex}
   Range - 1 to X size of image)

  X limits of area of input image to use.

}\sstsubsection{YRANGE = {\undersc}INTEGER(2) (Read)}{
  (Default - 1, Y size if image         \hspace{6ex}
   Range - 1 to Y size of image)

  Y limits of area of input image to use.

}\sstsubsection{OUTTAB = NDF (Write)}{
  (Default - null)

  Name of the new file to load with the output table of X,Y positions
  or measured magnitudes that have been obtained from the display.

  Fit{\undersc}magns group of options:-

  The output of the Interact:fit{\undersc}magns group, `OUTTAB', is a file
  containing a table of the magnitude measures.

  The headers are:  `X' \hspace{1em} `Y' \hspace{1em}
                    `Magnitude' \hspace{1em}
                     `Dx' \hspace{1em} `Dy' \hspace{1em}
                    `Iterations' \hspace{1em} `Rms' \hspace{1em}
                    `Numinval' \hspace{1em} `Height' \hspace{1em}
                    `Base' \hspace{1em} `Max pixel' \hspace{1em}
                    `Rx' \hspace{1em} `Ry' \hspace{1em}
                    `Xbox' \hspace{1em} `Ybox'


  Positions group of options:-

  The output of the Interact:positions group, `OUTTAB', is a file
  containing a table of either the X,Y positions and pixel values of the
  locations chosen by the cursor. The headers are `X', `Y', and `VALUE'.

\vspace*{3mm}

}\sstsubsection{\large \bf Inspect:-}{

  The parameters that are used by the `Inspect' program group.

}\sstsubsection{BASE = {\undersc}REAL (Read)}{
  (Default - present value, start=0.0           \hspace{6ex}
   Range - -1.0e20 to 1.0e20)

  The base level that is applied to the values in the typing out of
  pixel values.

  A pixel value of(say) RV, is typed out as  (RV-BASE)/SCALE.

  SCALE is the typing out scale, input by the user via the
  `SCALE' parameter, and whose default is 1.0

}\sstsubsection{CONTOUR = {\undersc}REAL(2) (Read)}{
  (Default - see below             \hspace{6ex}    Range - -1.0e20 to 1.0e20)

  The lower and upper limits of values that are plotted out
  in the contour map, and the step between the contour levels.

  Thus an input of `10.0,100.0,20.0' would put out contour
  levels of (10.0,30.0,50.0,70.0,90.0).

  The default is `(minimum of data),(maximum of data),(1/10th of range)'

}\sstsubsection{DECPL = {\undersc}INTEGER (Read)}{
  (Default - present value, start=0           \hspace{6ex}
   Range - 0 to 10000)

  No of decimal places to show in the typing out of pixel values.

  If = 0, then the decimal point is suppressed.

}\sstsubsection{DESNAME = LITERAL (Read)}{
  (Default - null)

  The name of the descriptor that you want to get the value of.

}\sstsubsection{EXTNAME = LITERAL (Read)}{
  (Default - `starman'      \hspace{6ex}

  Descriptors are held in separate groups (extensions) in
  the image.

  The name of the extension in the image that the descriptors that you
  want to get the value of are stored in. This is usually the `STARMAN'
  extension, but others include `FITS', `FIGARO'.

  `starman' is the one that holds all the ones accepted by the
  \starman programs. `fits' is an extension that often contains
  relevant descriptors.

}\sstsubsection{HRANGE = {\undersc}REAL(3) (Read)}{
  (Default - see below             \hspace{6ex}    Range - -1.0e20 to 1.0e20)

  The lower and upper limits of values whose number of pixels
  having those values are plotted out in a histogram. Also the
  width of the bins in the histogram.

  Thus an input of `10.0,70.0,20.0' would put out a histogram
  with bins of [(10.0-30.00,(30.0-50.0),(50.0-70.0)].

  The default is `(minimum of data),(maximum of data),(1/10th of range)'

}\sstsubsection{IGBOX = {\undersc}INTEGER(2) (Read)}{
  (Default - 20,20                 \hspace{6ex}    Range - 5 to 100)

  X and Y size of box round the cursor position to be used
  in measuring the Gaussian radius of a star.

}\sstsubsection{IGRADII = {\undersc}REAL(2) (Read)}{
  (Default - 3.0,3.0              \hspace{6ex}    Range - 0.2 to 60.0)

  When using fixed Gaussian radii in measuring the Gaussian
  radius of a star, these are the values to fit.

}\sstsubsection{IOPTION = LITERAL (Read)}{
  (Default - present value,start='area{\undersc}c'        \hspace{6ex}
   Choices - see below)

  What operation, from a menu of possible choices, to do next?

  The menu selection of options for inspecting the pixel values of
  the image in various ways.

  You repeatedly come back to this parameter after performing `Inspect'
  operations. You select one of the menu operations. You return to the
  main `Interact' group by entering the `return' option.

  The functions and the uses of buttons are described above in the
  section on Inspect Options.

  The cursor must be in image window area for the cursor buttons to
  work when in `WORKING' mode. The window also must be `active' - that
  is the bar at the top must be set. Click on this bar if it is not
  before using the buttons.

}\sstsubsection{ORIENT = {\undersc}REAL (Read)}{
  (Default - present value, start=1.0     \hspace{6ex}
   Range - 0.0 to 360.0)

  Azimuth in degrees from which to view displyed `solid' plot of image
  area.

  The value input is internally used as though it was in steps of
  30 degrees. Thus 330, 0, and 30 show three different views of the
  `solid' looking at the XZ plane from the direction of -Y, but
  from the left, straight on, and from the right respectively.

  It is not a true viewpoint, but is pretty good.

}\sstsubsection{SCALE = {\undersc}REAL (Read)}{
  (Default - present value, start=1.0       \hspace{6ex}
   Range - -1.0e20 to 1.0e20)

  The scale that is applied to the values in the typing out of
  pixel values.

  A pixel value of(say) RV, is typed out as  (RV-BASE)/SCALE.

  BASE is the typing out base, input by the user via the
  `BASE' parameter, and whose default is 0.0.

}\sstsubsection{STEPS = {\undersc}INTEGER(2) (Read)}{
  (Default - present value, start=1,1         \hspace{6ex}
   Range - 1 to [max(nx,ny)-1])

  The X and Y step between pixels that are selected to have their pixel
  values output in the typing out of values.

  The upper limit of the steps is the largest side of the image - 1.

}\sstsubsection{VPRANGE = {\undersc}REAL(2) (Read)}{
  (Default - 10\% below/above data range      \hspace{6ex}
   Range - -1.0e20 to 1.0e20)

  The minimum and maximum pixel values that are plotted. (PGPLOT is
  used in this option.)

  This can be asked for for:-

  \begin{list}{{-}}{}
  \item      3-D plot
  \item      3-D celled plot (solid or transparent)
  \item      Slice of pixel values along a pre-defined line
  \item      A grey-scale plot of the image.
  \end{list}

  The default is large enough to cover the actual range.

  This can be a hard copy device.

}\sstsubsection{WIDTH = {\undersc}INTEGER (Read)}{
  (Default - present value, start=8          \hspace{6ex}
   Range - 1 to 10000)

  Width of the character string shown for a value in the typing out of
  pixel values. This include any `-' sign and any decimal point. If
  this width is wider than the number of charactes actually in the
  number, then blanks are shown before.

}\sstsubsection{WINDOW = {\undersc}REAL(2) (Read)}{
  (Default - present values, start=-1.0e20,1.0e20    \hspace{6ex}
   Range - -1.0e20 to 1.0e20)

  The `window' that controls the values in the typing out of values.
  Numbers that are above this value are typed out as `****' and
  those below as `   `.

}\sstsubsection{XAREA = {\undersc}REAL(3) (Read)}{
  (Default - last (Start=1,X size,1) \hspace{6ex}
   Range - 1 to X size of image)

  Three numbers that define the area inspected by the other
  options of the `INSPECT' function.

  The number s are the X start of the area; the X end of the area;
  the step between pixels that sampling is to be done at.

}\sstsubsection{XYPPLOT = {\undersc}REAL(2) (Read)}{
  (Default - 0.8,0.8 scaled         \hspace{6ex}      Range - 0.101 to 0.9)

  X, Y fraction of graphical display physical window that will be
  used in writing graph or image. The default sizes will result
  in a correct shape being written out. (PGPLOT is used in this
  output.)

  The actual area covered will be:- (0.1 to X, 0.1 to Y) where
  0.0-1.0 is the entire range in each direction.

  This can be a hard copy device.

}\sstsubsection{YAREA = {\undersc}REAL(3) (Read)}{
  (Default - last (Start=1,Y size,1) \hspace{6ex}
   Range - 1 to Y size of image)

  Three numbers that define the area inspected by the other
  options of the `INSPECT' function.

  The numbers are the Y start of the area; the Y end of the area;
  the step between pixels that sampling is to be done at.

\vspace*{3mm}

}\sstsubsection{ \large \bf Positions:-}{

  The parameters that are used by the `Positions' program group.

  They are also used by the `Fit{\undersc}Magns' group, which access
  the same options. They are described above.

\vspace*{3mm}

}\sstsubsection{\large \bf Scrutiny:-}{

  The parameters that are used by the `Scrutiny' program group.

}\sstsubsection{BYLIST = LITERAL (Read)}{
  (Default - present value, start='Yes'         \hspace{6ex}
   Choice - `Yes/No')

  In selecting stars from the input table to deal with, do you want
  to select choosing only those stars that lie in a defined section
  of the table? If not, then the selection will be only those stars
  that lie in a defined rectangle in the image.


}\sstsubsection{COL{\undersc}BAD = LITERAL (Read)}{
  (Default - `Green'         \hspace{6ex}      Choices - see below)

  Colour of spots or crosses to use when painting up stars which have
  `bad' fits, that is fits that have failed in the Starman:Measure.

  Choice is:- red:green:blue:cyan:magenta:yellow:coral:palegreen

}\sstsubsection{COL{\undersc}OK = LITERAL (Read)}{
  (Default - `Red'       \hspace{6ex}        Choices - see below)

  Colour of spots or crosses to use when painting up stars which have
  `ok' fits, that is fits that have been done ok in the Starman:Measure.

  Choice is:- red:green:blue:cyan:magenta:yellow:coral:palegreen

}\sstsubsection{COL{\undersc}STAR = LITERAL (Read)}{
  (Default - `Red'      \hspace{6ex}         Choices - see below)

  Colour of spots or crosses to use when painting up stars which have
  been added or removed from the star list.

  Choice is:- red:green:blue:cyan:magenta:yellow:coral:palegreen

}\sstsubsection{CONTRAST = LITERAL (Read)}{
  (Default - present value, start='No'       \hspace{6ex}
   Choice - `Yes/No')

  When displaying the removal of a fitted star from the image, is
  the effect to be shown at a `high' contrast, that is the contrast
  suitable for the small area that is removed? If not, then it is
  displayed at the contrast used in the display of the whole image.

  For the `Yes' option, one can often see good detail about the
  fit itself, whilst for the `No' option one sees best the quality
  of the fit in relation to the whole image.

}\sstsubsection{DOFORM = LITERAL (Read)}{
  (Default - present value, start='No'        \hspace{6ex}
   Choice - `Yes/No')

  In typing out, to terminal or file, of the Starman:Measure table,
  format the numbers in the way you want? If not, then the standard
  format is used.

  If you choose to format, you control which columns of the table
  are output and the width of the field for each column, and the
  number of decimal places of the number in the field.

  The standard format is, depending on whether the X,Y positions are
  out, :-

   Star   \hspace{1em} Mag   \hspace{1em} Height   \hspace{1em} Dx
   \hspace{1em} Dy  \hspace{1em} Rms  \hspace{1em} Its \hspace{1em}
   Inval \hspace{1em} Comps \hspace{1em} Imp  \hspace{1em} Diff-2

  or:-

   Star   \hspace{1em} X      \hspace{1em} Y      \hspace{1em} Mag
   \hspace{1em} Height   \hspace{1em} Dx    \hspace{1em} Dy
   \hspace{1em} Rms  \hspace{1em} Its \hspace{1em} Inval \hspace{1em} Imp


}\sstsubsection{DOPREF = LITERAL (Read)}{
  (Default - present value, start `Yes'        \hspace{6ex}
  Choice - `Yes/No')

  When writing the output table of Interact:Scrutiny, this controls
  how the names of the `new' stars are to be made.

  If there have been no new stars input by the user then this
  parameter is not asked for.

\begin{tabular}{lp{4.5in}}
  If `Yes', & then the input stars are output with their same names.
              The new stars are output with names \#'X'1, \#'X'2, , ... ,
              where `X' is a character string, input via the parameter
              `Prefix'. `X' has a default of `A', and it is recommended
              that only a short character string be used, since the
              total name length is only 20. \\
            & \\
  If `No',  & then all the output stars are renamed as \#1, \#2, ... \\
\end{tabular}

  The names are the `identifiers', placed in the first 5 columns of
  each row of the output table. They are 20 characters long, and
  usually are in the form `\#1', `\#2', ...

}\sstsubsection{DOMAP = LITERAL (Read)}{
  (Default - `yes'      \hspace{6ex}       Choice - `yes:no')

  The profile map is non-zero. Do you want to use it in
  Interact:Scrutiny?

}\sstsubsection{DONEW = LITERAL (Read)}{
  (Default - `yes'      \hspace{6ex}       Choice - `yes:no')

  In marking up the positions of stars around the subject star
  that were fitted along with it, should the starting positions
  be used, or the `new' fitted ones?

}\sstsubsection{DOSLOPE = LITERAL (Read)}{
  (Default - present value, start='Yes'       \hspace{6ex}
   Choice - `Yes/No')

  When subtracting fitted star from display, subtract the sloping
  background as well. This is not the overall backgound but the
  sloping component above (or below) the background value at the
  b/l/h corner of the fitting box.

}\sstsubsection{DOSPOT = LITERAL (Read)}{
  (Default - present value, start='Yes'      \hspace{6ex}
   Choice - `Yes/No')

  In marking up the positions of stars in the Starman:Measure input
  file table, should the positions be marked with a single pixel
  spot? If not, then they will be marked with a cross of adjustable
  length.

}\sstsubsection{INSTARS = NDF (Read)}{
  (Default - null)

  Name of file containing the output of a run of the Starman:Measure
  program.

  This is a table in the format of a  \starman table file.

}\sstsubsection{LENGTH = {\undersc}REAL (Read)}{
  (Default - 2.0             \hspace{6ex}         Range - 0.5 to 100.0 )

  Length, in pixels,  across arms of the crosses that are to be
  painted up.

}\sstsubsection{LISTXY = LITERAL (Read)}{
  (Default - present value, start='Yes'  \hspace{6ex}     Choice - `Yes/No')

  In typing out, to terminal or file, the table of the Starman:Measure
  table input file in the standard format, do you want the X,Y
  position of each star to be output?

  The standard format is, depending on whether the X,Y positions are
  out, :-

   Star   \hspace{1em} Mag   \hspace{1em} Height   \hspace{1em} Dx
   \hspace{1em} Dy  \hspace{1em} Rms  \hspace{1em} Its \hspace{1em}
   Inval \hspace{1em} Comps \hspace{1em} Imp  \hspace{1em} Diff-2

  or:-

   Star   \hspace{1em} X      \hspace{1em} Y      \hspace{1em} Mag
   \hspace{1em} Height    \hspace{1em} Dx    \hspace{1em} Dy
   \hspace{1em} Rms  \hspace{1em} Its \hspace{1em} Inval \hspace{1em} Imp

}\sstsubsection{LRANGE = {\undersc}INTEGER(2) (Read)}{
  (Default - present values, start=1,no of rows   \hspace{6ex}
   Range - 1 to no of rows)

  This parameter is accessed when selecting which stars in the
  input MEASURE table to use. It defines which ones by taking those
  in the table  in the defined range of rows in the table

  This parameter defines the start and end row numbers to define that
  range.

}\sstsubsection{LXRANGE = {\undersc}REAL(2) (Read)}{
  (Default - present values, start=-1.0e6,1.0e6     \hspace{6ex}
   Range - -1.0e10 to 1.0e10)

  This parameter is accessed when selecting which stars in the
  input MEASURE table to use. It defines which ones by taking those
  in the table  which lie in a defined range of X positions.

  This parameter defines the start and end of that X range.

}\sstsubsection{LYRANGE = {\undersc}REAL(2) (Read)}{
  (Default - present values, start=-1.0e6,1.0e6    \hspace{6ex}
   Range - -1.0e10 to 1.0e10)

  This parameter is accessed when selecting which stars in the
  input MEASURE table to use. It defines which ones by taking those
  in the table  which lie in a defined range of Y positions.

  This parameter defines the start and end of that Y range.

}\sstsubsection{NAME = LITERAL (Read)}{
  (Default - null)

  Name of star in input Starman:Measure table to put out all its
  details for.

}\sstsubsection{NUMAFT = {\undersc}INTEGER (Read)}{
  (Default - 2       \hspace{6ex}           Range - 0 to 130)

  When setting up format for typing out, to terminal or file, details
  of fit of star, this is the number of decimal places to show in a
  number. If `0' is replied, the decimal point itself is suppressed.

}\sstsubsection{NUMBEF = {\undersc}INTEGER (Read)}{
  (Default - 4      \hspace{6ex}            Range - 0 to 130)

  When setting up format for typing out, to terminal or file, details
  of fit of star, this is the number of characters to show before the
  decimal point.

}\sstsubsection{NUMBER = {\undersc}INTEGER (Read)}{
 (Default -  see below \hspace{6ex}   Range - see below)

  A general request for a number. The possible occasions this can
  be asked for are:-

\begin{tabular}{|c|l|p{3in}|}\hline
  Default    & Range         &  Remarks \\ \hline
  1   &       1-no of rows & Star in input Starman:Measure table to
                             display the residuals to fit, in the
                             displayed image. \\
  1    &      1-no of rows & Star in input Starman:Measure table to type
                             out to terminal all details for. \\
  next not removed &  0-no of rows &  When choosing stars to mark with their
                             companions in their fits, this is the
                             number of the star to select. Replying
                             `0' will stop the looping asking for next
                             star. \\
  next not removed &  0-no of rows & When choosing stars to mark with distant
                             companions, the program will search
                             through the list, from this star on, for
                             such a star and output the details and
                             mark up the star. Replying `0' will stop
                             the looping asking for next star. \\ \hline
\end{tabular}

}\sstsubsection{NUMCHAR = {\undersc}INTEGER (Read)}{
  (Default - 12   \hspace{6ex}       Range - 1 to 20)

  Number of characters in the star's name (identifier) to output in the
  typing out, to terminal or file, of star details from the input
  Starman:Measure table.

}\sstsubsection{NUMCOL = {\undersc}INTEGER (Read)}{
  (Default - present value, start=1   \hspace{6ex}
   Range - 0 to No of columns)

  The number of the column in the input Starman:Measure table that
  is to be put in this typing out, to terminal or file, column.

}\sstsubsection{OUTFILE = NDF (Write)}{
  (Default - null)

  The name of the new file to contain the formatted version of a
  selection of the input Starman:Measure table of fitted results. The
  file is a normal ASCII text file

}\sstsubsection{OUTSTARS = NDF (Write)}{
  (Default - null)

  The name of the new file to contain a table, in the format of the
  Starman:Measure program, of that input Starman:measure table,
  but with (optionally) some stars removed, and (optionally) some
  extra stars added. These extra stars are picked up in the
  Interact:Scrutiny group of functions

}\sstsubsection{PREFIX = LITERAL (Read)}{
  (Default - `A'       \hspace{6ex}  Choice - any character string)

  The character string to add to the names of new stars in the
  `Outstars' output table file.

  This is asked for if there have been new stars made for the
  output in the `Outstars' table of the Interact:Scrutiny, and it
  is desired (via the `Dopref' parameter) that the names of these new
  stars are distinguished by having a character string between the `\#'
  that usually starts a star name and the number that ends it.

  The new stars are output with names \#'X'1, \#'X'2, , ... ,
  where `X' is a character string, input via this parameter.
  `X' has a default of `A', and it is recommended that only a short
  character string be used, since the total name length is only 20.

  The names are the `identifiers', placed in the first 5 columns of
  each row of the output table. They are 20 characters long, and
  usually are in the form `\#1', `\#2', ...

}\sstsubsection{PROFILE = NDF (Read)}{
  (Default - null)

  The name of the existing file containing the `profile' of the stars
  to be used in Interact:Scrutiny.

  It is an image with the profile parameters and profile map in the
  normal \starman `Profile' format, in a \starman NDF file.

}\sstsubsection{SEEK = LITERAL (Read)}{
  (Default - `Number'                \hspace{6ex}  Choice - `Number/Name')

  When typing out the full details of the fit for a star in the input
  Starman:Measure table, select that star by name or number in the
  table.

}\sstsubsection{SOPTION = LITERAL (Read)}{
  (Default - present value,start='list'      \hspace{6ex}
   Choice - see below)

  What operation, from a menu of possible choices, to do next?

  The menu selection of options for looking and adding to, the output
  results table of the Starman:Measure program.

  You repeatedly come back to this parameter after performing
  `Scrutiny' operations. You select one of the menu operations. You
  return to the main `Interact' group by entering the `return' option.

  The functions and the uses of the buttons are described above in the
  `Scrutiny Option' section.

  The cursor must be in image window area for the cursor buttons to
  work when in `WORKING' mode. The window also must be `active' - that
  is the bar at the top must be set. Click on this bar if it is not
  before using the buttons.


}\sstsubsection{WLIST = LITERAL (Read)}{
  (Default - `New'    \hspace{6ex}        Choice - `Old/New')

  This deals with the removal of stars from the input Starman:Measure
  star list.

  The removal is done by the user using the cursor to mark a position
  in the image and the program thens removes the `nearest' star in the
  list to that position. This choice is whether the nearest star is
  defined from the output positions of the Starman:Measure table (the
  normal positions) or the positions that the Starman:Measure program
  run had, as input, before it was run.

}}}


\addcontentsline{toc}{subsection}{ Measure}


\ajhsect{\arabic{section}}{General Programs - \hspace*{0.2in} MEASURE}

\sstroutine{MEASURE}{Perform Crowded-Field Stellar Photometry}{

\sstdescription{
   This performs photometry of the stars in a crowded star field.

   A 2D Lorentz-Gaussian-empirical profile is fitted to the stars near the
   positions given by an input position table. The magnitudes and positions
   of the stars are found, and the fit details typed out and stored.

   The profile is a full 2-D one and is a good match to typical star
   images, so the program has a good S/N performance. It can also deal
   with severe crowding and severe pixel under-sampling.


}\sstdiytopic{Algorithm}{
\hspace*{4ex}{\bf What the program actually does}

\begin{enumerate}
 \item A rough estimate of the magnitude, height and position of each star in
       the input list is made, looking for the peak pixel value within one
       radius of the input position.

 \item These estimates are looked at for each star, to see if any of the
       other stars (that is the stars in the input list) will
       (given their distance in terms of the star profile and distance
       and relative magnitude) affect the star. This is done as :-

   Go through the input star position table and find for each star its
   importance according to the formula

       $$ Imp = mag(star) - mag(main star) - 6 + d/(star radius) $$

   Thus the more important the star is the more -ve Imp is. If the
   star is important enough to worry about (Imp less than 0) then the star
   is noted with the more important stars first. Stars inside the
   measuring box (width of about 10 radii) are also included.

   If more than fourteen stars are important enough to be noted, only
   the fourteen most important are noted.

 \item This gives, for each star, a group of stars. A rectangular box is
    drawn round the target star, large enough to take all of it in -
    about 10 times the half height radius in X and Y, allowing for
    the possible rotation of the star profile from the X-Y axes.
    The group of stars are solved together (stars whose centres are
    outside the box are fitted all the same, but their positions are not
    allowed to vary).

   The result for the target star is typed out and also stored.

   Thus this is the stage at which the actual measurement occurs.

   It will be noted that stars, if any,  which are not in the input list
   are neither fitted, nor taken into account when fitting other stars.

 \item At the end, there is an option to clean the image by subtracting all
   the stars that have had successful fits.

 \item Optionally it can then go over the cleaned image, trying to fit the
    stars that it failed on before.

 \item Optionally, it can then look at close undone pairs and try to fit
    one star between them.

 \item Optionally, it can repeat the entire process, using the new
    estimates of posns and heights to deal better with large stars adjacent
    to each target star. If on this redoing, an isolated star has been
    previously fitted on the first loop, and its calculated position was
    within 0.1 pixels of its input position, it is assumed that the fit was
    good, and it is not recalculated.

 \item It types out each fit as it does it, as well as storing to file.
\end{enumerate}

}\sstdiytopic{Profile Variations}{

   The program can deal with stars of different profiles. For each star
   you can feed in a separate profile. ( If they all have the same profile,
   as usual for many ground-based observations, this is done automatically
   when inputting the standard profile.) This enables you to deal with
   position and/or colour dependent profiles. Whilst this option is fully
   functional, some helpful ancillary programs are still being documented,
   so in the future dealing with differing profiles will be easier than
   it is now.


}\sstdiytopic{Fitting}{
 The fit is done applying, to single stars or groups of stars, a proper
 iterative least squares fitting proceedure with a function of a sloping
 plane background and up to fourteen identical fully 2D star profiles.

 The profile that is fitted is one that has been found to give a good fit
 to typical star images. It is an elliptical rotated Lorentzian sitting
 on top of a wide low circular modified Gaussian, with an empirical
 residuals map. The actual fitting is a scaling of this profile, added
 onto a linear sloping background, which is fitted at the same time as
 the star.  The mathematical expression of this is:-




 The parameters X0,Y0,A,B,C, and D are not parts of the profile, as
 they can be different for each star.

 The fitting is done by starting with trial values of the star heights
 and positions and of the background, and then improving these by the
 iterative linearised least squares method until an acceptable fit is
 made, or until too many iterations have been done.

 Features of the fit are:-

\begin{list}{{-}}{}
\item It can deal with close companions.
\item It can deal with areas of 'bad' pixels, in that such areas are
     ignored in the fits. Again you have to define these areas. (Such
     pixels can also be so flagged before entering the program - see
     the \starman package help for the method of flagging invalid
     pixels.)
\end{list}

  The fitting takes account of pixel averaging, that is what happens
  when the star radius is small, and there is significant change in
  the profile across one pixel. As the profile is not a straight line,
  the normal practice of taking the profile value at the centre of the
  pixel will be wrong. The program subdivides the profile over the
  pixel and calculates a more accurate average. So the bad effects of
  a narrow profile and star centres being at different distances from
  the pixel sides are minimised.

  The 'volume' of this profile, that is the numerical integration under
  the 2-D profile out to a defined distance, can be calculated. (The
  calculation is done with a fine mesh, so there is no effect from the
  pixel averaging for small radii.) This enables the magnitudes of
  stars with different profiles to be estimated.


   So each star has a height, A, and a position X0, Y0.


   The program also calculates a magnitude from the star height. This
   is :-

$$   Mag  =  30  -  2.5*log_{10}(star{\hspace{0.3em}}height*profile volume) $$

   The profile volume is the numerical integration (on a fine grid)
   over the standard profile for a star of unit height out to a large
   distance. So (star height*profile volume) is an estimator of the
   total flux in the target star.
   The value 30 is an arbitrary constant to give magnitudes of a
   comfortable level.

   The relative magnitudes of the stars in the image will be measured
   correctly, and the absolute level will be roughly right (apart from
   the arbitrary zero point), but for the best comparision with stars
   in other images with different profiles, the zero point is best
   determined by aperture photometry on the bright stars.


}\sstdiytopic{Input }{

   The input consists of an image, a table of star positions and
   a profile. Optionally other star tables can be input for ease
   of use

}\sstdiytopic{Input Image }{

  The input image can be any \starman .sdf image, without constraints.

  Input via the parameter `IN'.

}\sstdiytopic{Input Star Positions}{

  The star positions are fed in through a \starman table.

  Input via the parameter `INSTARS'.

  This must contain at least two columns for the X,Y positions. The
  positions will be taken from those columns with headers `X' and `Y'.
  If these headers are not present, then the X position will be taken
  from the first column and/or the Y position forom the second column.

  It should be noted that the program cannot find stars for itself, or
  decide if a star is actually a multiple one. It takes the stars in the
  input position table as all the stars it has to know about. A consequence
  of this is that the input positions have to be rather good, for two
  reasons. First the program only looks a short way round each input
  position for a star (this is to avoid trouble in crowded areas). Second
  if stars are really crowded, the fitting tends to fail unless the
  input positions are good. For the first case, the positions have to
  be within a radius, and for the second even better.

  There may also be a `HEIGHT' column, which contains a value of
  an estimate of the star height. Again this is in either the column with
  the `HEIGHT' header or in column 3. This parameter is optional.

  This file may also contain the information for the profile to be
  used for each star. As MEASURE can apply a different profile for
  each star, this information has to be supplied to the program. In the
  INSTARS file, each star may have the profile parameters given for
  each star as columns in this input table. These parameters are taken
  from columns with the appropriate header, or if that is not present, then
  a default column. These headers are:-

\vspace*{2mm}\begin{tabular}{|l|l|l|l|}\hline
    Parameter   &    Header     &  Default        &  Mandatory \\
                &               &  Column         & \\   \hline
    X posn      &    `X'        &     1           &     Y \\
    Y posn      &    `Y'        &     2           &     Y \\
    Height      &    `HEIGHT'   &     3           &     N \\
    Maj Rad     &    `RX'       &     4           &     N \\
    Min Rad     &    `RY'       &     5           &     N \\
    Power       &    `P'        &     6           &     N \\
    Pow Maj Rad &    `PRX'      &     7           &     N \\
    Pow Min Rad &    `PRY'      &     8           &     N \\
    Angle       &    `THETA'    &     9           &     N \\
    Gauss Power &    `QP'       &    10           &     N \\
    Gauss Height&    `QH'       &    11           &     N \\
    Gauss Rad   &    `QR'       &    12           &     N \\
    Map Number  &    `MAPNUM'   &    13           &     N \\
    Map X Size  &    `MX'       &    14           &     N \\
    Map Y Size  &    `MY'       &    15           &     N \\
    Map Magnif  &    `MAGNIF'   &    16           &     N \\
\hline\end{tabular}\vspace*{2mm}

   The `Map Number' gives the number of the empirical profile map
   to use in the input file `PROFILE', with the MX and MY showing
   the XY size of that particular map to use, and the `MAGNIF' showing the
   `magnification' of that particular map. For a fuller explanation see
   the help on `PROFILE'.

   If any of the non-mandatory columns are absent (i.e. there are less
   than 16 columns in the input table, than the profile parameters
   given in the input `PROFILE' file will be used for the missing
   parameters.

   The parameters in the `PROFILE' file will override ALL profile
   parameters (if any) in the `INSTARS' file, if the `PYES' parameter is
   given as `yes' (its default value). Also in this case, the map number
   is defined as `1'.

}\sstdiytopic{Input Profile}{

  The star profile is fed in through an image, usually made by the
  PROFILE (qv)  program.

  Input via the parameter `PROFILE'.

  This can be just one profile or it can be the store of many profiles
  empirical maps for when stars have differing profiles. In this
  latter case, then the profiles parameters are input in the INSTARS
  table in a manner explained elsewhere.

  This file is a 2-D image. It contains the parameters for one
  profile as descriptors, and the image pixels contain the empirical
  profile map for either one, or more than one profile.

  The descriptors are:-

\vspace*{2mm}\begin{tabular}{|l|l|l|}\hline
   Parameter    &   Descriptor & \\ \hline
    Maj Rad     &    `RX'  & \\
    Min Rad      &   `RY' & \\
    Power        &   `P' & \\
    Pow Maj Rad  &   `PRX' & \\
    Pow Min Rad  &   `PRY' & \\
    Angle        &   `THETA' & \\
    Gauss Power  &   `QP' & \\
    Gauss Height &   `QH' & \\
    Gauss Rad    &   `QR' & \\
    Map Magnif   &   `MAGNIF' & \\
    Profile Volume &  `VOL' & \\
    Radius for Vol & `VOLRAD' & \\
    Gauss Base     & `QBASE' & \\
    No of maps     & `MAPMAX'       & \\
    Map X space    & `MAPX'    &  (optional) \\
    Map Y space    & `MAPY'    &  (optional) \\
\hline\end{tabular}\vspace*{2mm}

  An empirical map covers a certain number of image pixels, with
  a defined sub-division of the pixels (the `magnification'). Thus
  a pixel map that covers a 10x10 image pixel area will have a
  size of 20x20 if its `magnification' is 2.

  The pixel values are the values that that pixel (or sub-division of
  a pixel) is scaled down from the Lorentzian profile. Thus if a
  pixel should have 1/10th the value of the Lorentzian peak value,
  then it will have a value of 0.1 (since the Lorentz central peak
  has a value of 1.0).

  Often the image will have a `BSCALE' and `BZERO', so the pixel
  values used are  that of (BS*[disk value] + BZ).

  (This `single' profile image is the one put out as the output of the
  PROFILE programme.)

  If more than one empirical map is to be held in the image, then
  this has to be made by the user, by making an image with the `MAPMAX'
  parameter being more than one. In this case the maps are stored in
  the image in a series of `boxes', of size MAPX by MAPY, stacked one
  `above' in the other in the `Y' direction, with their `left-hand' sides
  along the `left' of the image. Each map is kept with its
  b.l.h. corner at the b.l.h corner of its `box'. If the MAPX and
  MAPY parameters are missing, then the program assumes that MAPX is
  the same as the X size of the image, and that MAPY is the Y size
  of the image, divided by MAPMAX, the number of maps in the image.

  When a map is used, the program gets the map number, and actual
  X,Y size of the map from the INSTARS input star position table,
  finds the map location from the image as the `nth' box up, and
  reads the map out of the box.


}\sstdiytopic{Other Inputs}{

  Optionally, two further tables of stars of stars can be input.

 {\bf \hspace*{1em} `BEFORE' table}

   A table which was the 'OUT' measures from a previous run of MEASURE.

   Input via the parameter `BEFORE'.

   This table must contain the same stars with the same positions as
   the main input star position table 'IN'. The purpose of this
   is that if a run was interrupted, and only some stars solved, the
   run can be repeated, but the stars done dont have to be redone.
   If there is not such a file, just press 'return'.

 {\bf \hspace*{1em} `EXTRA' table}

   Is there another table of stars, additional to the input table,
   which should be solved for?

   Input via the parameter `EXTRA'.

   The is for use when you have solved for a lot of stars in an image,
   but you want to do a few more and these new stars could be crowded
   by the old stars, as well as by themselves. Rather than redoing the
   combined tables together, when all the stars would have to be
   redone, the new ones are input here and the program works out which
   stars of the old table have to be redone since stars of the new
   table affect them and which stars of the new table are affected by
   stars in the old table. The output table has the stars from the old
   table and then those from the new table in it.

}\sstdiytopic{Output }{

 The output consists of a table of star measures, and optionally
  a copy of the input image, with the measured stars `removed'.

}\sstdiytopic{Output Star Measures }{
  The output star measures are put into a file in the \starman table format.

  Output via the parameter `OUT'.

  The table has the entries in the order:-

\begin{tabular}{|c|c|p{2.8in}|}\hline
   Column & Identifier &   Content \\ \hline
     1    &   X        &   fitted X position \\
     2    &   Y        &   fitted Y position  \\
     3    &   MAG      &   magnitude \\
     4    &   DX       &   difference in fitted X posn from input posn \\
     5    &   DY        &  difference in fitted Y posn from input posn \\
     6    &   ITERATIONS&  no of iterations done in the fitting \\
     7    &   CHI       &  calculated Chi-squared value of the fit \\
     8    &   NUMINVAL  &  number of INVALID points in the Chi-squared
                         error estimating area \\
     9    &   HEIGHT    &  height of the fitted star above the sky \\
    10    &   BASE      &  sky (or background) level \\
    11    &   MAPNUM    &  number of profile map used \\
    12-20 &   as contents & profile parameters:-  RX, RY, P, PRX, PRY, THETA,
        QR, QH, QP \\
    21    &   NUMCOMPS  &  no of companion stars that have been fitted with the
                         target star \\
    22-28 &   COMP1, etc & numbers (as ranks in the input table) of the
                         first block of companion stars, in order of
                         importance (as defined above) to the target star \\
    29    &   XBOX    &    X size of the box used for the fitting \\
    30    &   YBOX     &   Y size of the box used for the fitting \\
    31    &   IMPORTANCE OF COMPS & total importance of all the companion stars used \\
    32    &   XSLOPE    &  X sky slope fitted \\
    33    &   YSLOPE    &  Y sky slope fitted  \\
    34    &   FLAG1     &  Flag 1 for internal program use \\
    35    &   FLAG2     &  Flag 2 for internal program use \\
    36    &   VOLUME    &  'volume' of a star, with this profile, of unit height \\
    37    &   ORDER     &  order this star was done in the fit  \\
    38    &   MAPX      &  empirical map X size \\
    39    &   MAPY      &  empirical map Y size \\
    40    &   MAGNIF    &  empirical map magnification \\
    41-47 &   COMP8, etc & 22-28 for second block of stars \\
    48    &   DIFF LAST ITS &  change in the magnitude estimate between the final
                               fit and the iteration two before it \\
    49    &   GUESS HEIGHT   &   temporary internal height estimates \\
    50    &   ERROR     &  Estimate of the star magnitude error \\
    51    &   DAMPING   &  final value of the damping factor used in the star fit \\ \hline
\end{tabular}

    The program stores output as it goes along, so a crash is not
   fatal. You can also rerun the program using the part completed output as
   input so it doesnt have to do those stars again, by use of the
   BEFORE option.

  The output table may be inspected, plotted on the image, and
  formatted for printing by using the program INTERACT, in the
  `scrutiny' mode.

}\sstdiytopic{Output Cleaned Image  }{

  Optionally, the input image can be copied to the output, with the
  stars that have had actual fits `removed' from the image. This
  enables you to see how good the fits were.

  Output via the parameter `OUTIM'.

  There are a number of ways in the INTERACT program with the `scrutiny'
  mode that this cleaned image can be looked at, especially in
  conjunction with the table of star measures.

}\sstdiytopic{Fitting Order}{
   The actual order of fitting is to start with the brightest star, solve
   it, and go onto the next brightest. This is so that in fitting the
   difficult faint stars, the any nearby bright stars will already have
   more accurate psoitions and heights for use in setting up the starting
   conditions of the fit, and thus make the fit willbe both more
   accurate and faster. Doing the stars in this way also means that the
   bright easy stars are done first, and so monitoring of the process at
   the beginning of running the program is more rewarding in that
   the results come more quickly than later on, and also the results for
   the most prominent stars become available first.


}\sstdiytopic{Errors}{
   The program calculates two error parameters for each star. There
   are:-

\begin{enumerate}
\item    The Chi-squared value from the difference between the fitted
         (maybe multiple) profile and the actual data over a small
         area around the fitted star position. The area is an
         orthogonal rectangle of X size (2*Rmaj+1) and Y size (2*Rmin+1),
         and so no account here is taken of any rotation of the star
         from the X-Y axes. The Rmaj, Rmin are as defined in the profile
         equation above.
\item    An estimate of the error of the star magnitude itself. This is
         calculated from the goodness of the fit itself, made during
         the least-squares fitting, falling out of the error matrix.
\end{enumerate}


}\sstdiytopic{Tips}{
  The main decision is do you want to do the two refining options,
  REDO and DOTWOS, and do you want to do the RECYCLE.

  The simplist and fastest, is NO to all of the above. Some
  more difficult stars are done with the REDO and DOTWOS options,
  and slightly more accurate results are given by RECYCLE. It depends
  a lot on what your interest in the image is, and how much
  computer time you want to spend.

  The default choice is a reasonable choice.

  The secondary decision is the OUTFIX1 and OUTFIX2 details about the
  fits. See the help on them for more details, but again the default
  is a reasonable choice.

  On both these matters, some experimentation by you will give you
  an idea on the best combination to suit you.

}\sstdiytopic{Display}{

  There is a very pretty option. It shows how the fitting is getting on.

  The whole image is displayed and then a little square dots round removing
  the stars.

  It paints up a blue rectangle of the place where it is going to remove
  the next star. Then it removes it, and paints a green rectangle where
  the fit has used data from the image to make the fit. There is also a
  red rectangle which shows the area out to where the subtraction of the
  wings of the fitted star have had an effect, that is at a level of
  0.2 pixel value.


}\sstdiytopic{Hidden Parameters}{
  A number of input control parameters that the user can set to control
  the way the program works are 'hidden' from the user. That is, the
  default values are used unless overridden on the Command Line, or
  in a local '.ifl' interface file.

  This is done because the parameters need only be changed for special
  needs. The parameters are:-

\begin{tabular}{|l|p{3.5in}|l|}\hline
  Name   &   Function& Default\\ \hline
  BOX    &   Set size of box round stars to be fitted       & Appropriate Size \\
  DOTWOS &   Fit close undone pairs as single star on
            cleaned image                                & Yes \\
  FIX    &   Fix all star positions at input values         & No \\
  INFORM &   Type of information output.                    & Simplest \\
  NUMBER &   Number of stars to fit (brightest first)       & All \\
  OFIX1  &   Fix posns and hts of stars some distance from
            box at rough values, in first cycle            &Yes \\
  OFIX2  &   Fix posns and hts of stars some distance from
            box at 1st cycle values, in second cycle &      Yes \\
  RADIUS &   Radius out to which 'volume' under profile is
            to be found to add to mag zero point. &         30.0 \\
  RECYCLE &   After the fits, repeat the entire process,
            to get better estimates. &                       Yes \\
  REDOCL &   After the first fit, image cleaned and the
            failed stars fitted on the cleaned image. &      Yes \\
  SCREEN  &  Size of screen to open up if displaying image. &  Image size \\ \hline
\end{tabular}

  Further information is available in the individual sections on the
  parameters.



}\sstparameters{

\sstsubsection{BEFORE = NDF (Read)}{
   (Default - null)

   The name of a file containing the table which was the 'OUT' measures
   from a previous run of MEASURE. if no such file is to be input,
   enter the 'null' response.

   This table must contain the same stars with the same positions as the
   main input star position table 'IN'. The purpose of this
   is that if a run was interrupted, and only some stars solved, the
   run can be repeated, but the stars done dont have to be redone.
   If there is not such a file, just press 'return'.

}\sstsubsection{BOX = {\undersc}INTEGER(2) [HIDDEN] (Read)}{
  (Default - 0,0   \hspace{4ex}   Range for each - 0 to 200)

  The X,Y size of the box round each star that is to be used in the
  fitting. If either size is set at 0 (which is the default), then the
  program calculates for each star what it thinks the best box size is.
  This is done from the width of the profile for that star.

  (Hidden parameter - not asked for, has to be set if default not wanted)

}\sstsubsection{DODISP = LITERAL (Read)}{
  (Default - `no'    \hspace{4ex}   Choice - `yes:no')

  Display the results as they are calculated?

  This is a very pretty option. It shows how the fitting is getting on,
  but slows the program down

  The whole image is displayed and then a little square dots round
  removing the stars.

  It paints up a blue rectangle of the place where it is going to remove
  the next star. Then it removes it, and paints a green rectangle where
  the fit has used data from the image to make the fit. There is also a
  red rectangle which shows the area out to where the subtraction of the
  wings of the fitted star have had an effect, that is at a level of
  0.2 pixel value.

}\sstsubsection{DOMAP = LITERAL (Read)}{
  (Default - `yes'    \hspace{4ex}   Choice - `yes:no')

   If you have an empirical map in your profile file, do you want it used?

}\sstsubsection{DOTWOS = LITERAL [HIDDEN] (Read)}{
  (Default - `yes'    \hspace{4ex}   Choice - `yes:no')

  After the first fit (and any redo -see 'Redocl' parameter), do you
  want the image cleaned and an attempt made to fit close undone
  pairs as a single star.

  (Hidden parameter - not asked for, has to be set if default not wanted)

}\sstsubsection{EXTRA = NDF (Read)}{
   (Default - null)

   The name of a file with a table of extra star positions. If no
   extra file is to be input, enter the 'null' response.

   Is there another table of stars, additional to the input table, which
   should be solved for?

   The is for use when you have solved for a lot of stars in an image, but
   you want to do a few more and these new stars could be crowded by the
   old stars, as well as by themselves. Rather than redoing the combined
   tables together, when all the stars would have to be redone, the new
   ones are input here and the program works out which stars of the old
   table have to be redone since stars of the new table affect them and
   which stars of the new table are affected by stars in the old table.
   The output table has the stars from the old table and then those from
   the new table in it.

}\sstsubsection{FIX = LITERAL [HIDDEN] (Read)}{
  (Default - `no'    \hspace{4ex}   Choice - `yes:no')

  Option to fix the positions of all the stars at the input positions. This
  can enable more accurate magnitudes to be calculated. Use of this option
  should be done with care, as even a small inaccuracy in the input
  position (say a 1/10th of the seeing diameter will result in very poor
  fits.

  (Hidden parameter - not asked for, has to be set if default not wanted)

}\sstsubsection{GAIN = {\undersc}REAL (Read)}{
  (Default - 1.0          \hspace{4ex}  Range - 1.0e-8 to 1.0e8)

  The gain of the original detector. in terms of counts stored in
  a pixel for each independent event detected. Thus something like
  counts/photon.

}\sstsubsection{HEIGHTS = LITERAL (Read)}{
  (Default - `yes'    \hspace{4ex}   Choice - `yes:no')

   If the input table of stars has a column called 'HEIGHTS', then this
   is the choice for using the fitted heights in that file for the
   program to use as first estimators of the star heights when looking
   for important neighbours to allow for in the fitting. Say no only
   when the numbers in the 'HEIGHTS' column are not the heights.

   Remember that the case of the letters matters.

}\sstsubsection{IN = NDF (Read)}{
   (Default - null)

  The name of the input image.

  The image must be a standard \starman ADAM .SDF image, with
  either `real' 32-bit real values, or `short' 16-bit integer values.
  It can have the `BSCALE' and `BZERO' values, and `magic pixel values'
  indicating `bad' pixels.

}\sstsubsection{INFORM = LITERAL (Read)}{
   (Default - `standard' \hspace{4ex}  Choice - 'none:standard:more:full')

   Flag for outputting via the terminal to the user informative measures.

\begin{tabular}{|c|p{4.5in}|}\hline
   Flag      &  Terminal Output \\ \hline
    none     &  Results only \\
    standard &  Results + stage reached \\
    more     &  Results + stage reached + times at various
                subroutine entries \\
    full     &  Results + companion fits + stage reached + times at various
                subroutine entries \\ \hline
\end{tabular}

  (Hidden parameter - not asked for, has to be set if default not wanted)

}\sstsubsection{INSTARS = NDF (Read)}{
   (Default - null)

  The name of the file with the table of the star positions. This
  must be the name of a \starman table format file, with two
  columns containing the X,Y positions.

  This can be very complex. See the help in the `Input Star Positions'
  section above.

}\sstsubsection{NOISE = {\undersc}REAL (Read)}{
  (Default - 0.0   \hspace{4ex}  Range - -1.0e8 to 1.0e8)

  The additional noise per pixel present in a pixel if there was no
  signal noise. An example of this is the read-out noise in a CCD.

  This should be in the std dev of the numbers in the image pixels.

  This is used when calculating the error in a measure.

}\sstsubsection{NUMBER = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - All of them.    \hspace{4ex}  Range - 0 to all)

  The number of stars to be analysed. Remember that the stars are
  done in rough order of brightness, so 'number' does not mean do
  the first 'number' in the input table, but 'number' of the bright
  stars, though not necessarily the brightest ones.

  (Hidden parameter - not asked for, has to be set if default not wanted)

}\sstsubsection{OFIX1 = LITERAL [HIDDEN] (Read)}{
  (Default - `yes'    \hspace{4ex}   Choice - `yes:no')

  In the first loop, fix, for each star fit, the positions and heights of
  those stars some distance outside the fitting  box at roughly found
  values (or the input heights)?

  The advantage in fixing is that if you already have the right heights,
  then the fit will be better. The danger is that if the heights are
  wrong, then the fit might be inaccurate. If you are only doing one
  loop, you have to let the stars vary as the input geusses are
  just rough estimates. If doing two loops, then the error will not
  be too large, and fixing them will speed things up.

  If you are doing once (RECYCLE=NO) then
  say NO, otherwise the common answer is YES, but you might
  to try otherwise and see what difference it makes to the results.

  (Hidden parameter - not asked for, has to be set if default not wanted)

}\sstsubsection{OFIX2 = LITERAL [HIDDEN] (Read)}{
  (Default - `yes'    \hspace{4ex}   Choice - `yes:no')

  In the second loop (if doing one), fix, for each star fit, the positions
  and heights of those stars some distance outside the fitting  box at the
  values found in the first loop?

  The advantage in fixing is that if you already have the right heights,
  then the fit will be better. The danger is that if the heights are
  wrong, then the fit might be inaccurate. By the second loop, the
  fits from the first loop should be reasonable.

  The common answer is YES, but you might
  try NO and see what difference it makes to the results.

  (Hidden parameter - not asked for, has to be set if default not wanted)

}\sstsubsection{OIMTIT = LITERAL (Read)}{
  (Default-  'Output from MEASURE'    \hspace{4ex}  Choice - any)

  The title to be attached to the output cleaned OUTIM image.

}\sstsubsection{OUT = NDF (Write)}{
   (Default - null)

  The name of the file to contain the output table of measurements.

  Its contents are described in the 'Misc' section of the help.

  This table can be looked at, and formatted for listing, by the program
  'INTERACT' in its 'SCRUTINY' section.

}\sstsubsection{OUTIM = NDF (Write)}{
   (Default - null)

  If you want a copy of the input image, cleaned of the fitted stars,
  then input here the name of a file to hold the cleaned image.

  If you do not want to have this stored, then just press return.

  This has no bearing on the option for fitting unfitted stars on a
  cleaned image. The calculations are entirely separate.

}\sstsubsection{OUTTIT = LITERAL (Read)}{
   (Default - 'Output from MEASURE'   \hspace{4ex}   Choice - any))

  The title to be added as a descriptor to the 'Outstars' file.

}\sstsubsection{PROFILE = NDF (Read)}{
   (Default - null)

  Input the name of the image, usually made by PROFILE (qv), which has the
  image parameters.

  This can be very complex. For a full help, see the `Input Profile'
  section above.

}\sstsubsection{PYES = LITERAL (Read)}{
  (Default - `yes'    \hspace{4ex}   Choice - `yes:no')

  If you have profiles in the star table, do you want the profile
  parameters in the profile file to override the profiles in the table?

}\sstsubsection{RADIUS = {\undersc}REAL [HIDDEN] (Read)}{
   (Default - 30.0.     \hspace{4ex}   Range - 1.0 to 1.0e8 )

  When calculating the magnitude, the volume under the profile has
  to be calculated. How far out from the star (in pixels) shall this
  be carried out? This is only important if you want to compare with
  aperture photometry, or have stars with differing profiles in the
  image.

  (Hidden parameter - not asked for, has to be set if default not wanted)

}\sstsubsection{RECYCLE = LITERAL [HIDDEN] (Read)}{
  (Default - `yes'    \hspace{4ex}   Choice - `yes:no')

  After the fits has been done, repeat the entire process, to use the
  better estimates of star heights and positions for starting input,
  and for better fits where a star is affected by stars some distance
  away.

  (Hidden parameter - not asked for, has to be set if default not wanted)

}\sstsubsection{REDOCL = LITERAL [HIDDEN] (Read)}{
  (Default - `yes'    \hspace{4ex}   Choice - `yes:no')

  After the first fit, do you want the image cleaned and an attempt
  made to fit the failed stars on the cleaned image.

  (Hidden parameter - not asked for, has to be set if default not wanted)


}\sstsubsection{XCOEFF = {\undersc}REAL(3) (Read)}{
  (Default - 0.0,1.0,0.0 \hspace{6ex}    Range  -1.0e20 to 1.0e20)

  The coefficients used to transform the XY positions in the input table
  of star positions to a new set of X positions.

    $$ X  =  C(1) + C(2)*X_{in}  +  C(3)*Y_{in} $$

}\sstsubsection{YCOEFF = {\undersc}REAL(3) (Read)}{
  (Default - 0.0,0.0,1.0 \hspace{6ex}    Range  -1.0e20 to 1.0e20)

  The coefficients used to transform the XY positions in the input table
  of star positions to a new set of Y positions.

    $$ Y  =  C(1) + C(2)*X_{in}  +  C(3)*Y_{in} $$

}}}





\addcontentsline{toc}{subsection}{ Profile}


\ajhsect{\arabic{section}}{General Programs - \hspace*{0.2in} PROFILE}

\sstroutine{PROFILE}{Determine Profile of Stars in an Image}{

\sstdescription{
 This program determines the mean stellar profile (the shape) of
 stars in an image. It uses a number of stars to determine this mean.

 The user inputs the locations of a number of bright stars in an
 image, and the program then (either automatically or interactively with
 the user) determines the mean profile. It estimates the parameters of an
 analytic profile and estimates a subsidary empirical map that
 together give the best  mean fit for the profiles of these stars.

 The analytical profile is one which combines a Lorentz type profile
 with a wide Gaussian type profile added. Usually, the
 Lorentz component of the profile plus the empirical map gives an
 adequate fit. This is what the program fits in its automatic mode.


}\sstdiytopic{Method}{

 The user inputs in the image which the stars are in, and a table
 of (X,Y) star positions. The program
 takes a small area round each of those stars, and fits the data in
 the boxes with a sloping sky and a star profile. The sky and the
 profile are adjusted until there is a good fit. The parameters of
 the profiles for each of the stars are then averaged together to
 make a mean profile.

 At first, only the Lorentz part of the profile is used. Then, if it
 is necessary, the empirical map of any remaining residuals may be
 fitted, and then, for the rare occassions when suitable, the wide
 Gaussian wing can be fitted.

 The resultant profile is then stored in a file (as an image with
 the profile parameters as descriptors). This profile can then be used
 as the input to MEASURE, ADDSTARS, or INTERACT.

 The program works by first asking you for the input image and the
 table of star positions. It then goes either into the `automatic' mode,
 or into the `interactive' mode.


 {\bf \hspace*{2em} Automatic Mode:-}

 The program goes through these steps:-


\begin{enumerate}

\item  Lists the input stars and default profile.

\item  Asks for any table of companions to stars or bad areas near them.
       In you wish to input such a table, look for further help in
       the `Inputs' section.

\item  Asks for any shift to be applied to all the X,Y coordinates.

\item  Gets positions and very rough profiles.

\item  Determines the size of the `box' around each star to do the
       fits in.

\item  Fits each star in full detail.

\item  Calculates the mean profile, by rejecting discordant stars, and
       taking the means of the parameters of the profile.

\item  Recalculate fits with mean profile.

\item  Calculate the residuals for each star from the fits.

\item  Use residuals to make profile map.

\item  Store profile (with its empirical map).

\item  Optionally, store table of fitted stars.

\item  Optionally, store any table of fitted companion stars and bad areas.

\end{enumerate}


 {\bf \hspace*{2em} Interactive Mode:-}

 The program loops round, offering the repeated option
 of performing functions. One can leave the `Main' section and
 go into subsidary sections -- this is indeed needed for removing
 stars and bad areas near to the target stars, for making the
 empirical map, and for making the Gaussian wing.

 There are many other operations that can be done here.

 For further information, see the `Fitting Details', `Options',
 `Run-through', `Tips', and `Use' sections.


}\sstdiytopic{Run-through}{

 This section describes the interactive use of Profile, with its
 (nearly) infinite number of ways of using it. To give you some ides of
 its use, the following `run-through' of one possible session is given.

 [For the `automatic' mode, see the `Method' section.]

This run-through does not deal with the major features:- rejection of companion
stars; rejection of bad areas; fitting the empirical map. There are also
many minor features that are not explored.

Explanations and commentary associated with each annotation are given
afterwards. The parts in san serif are abbreviated versions of typed output
or are comments on the display. The parts in italics are instructions to
you.

It is assumed the user is at a colour X-windows display.


\vspace*{1mm}
\hspace*{13mm}\rule{5in}{0.25mm}
\vspace*{3mm}

\begin{tabular}{p{5.3in}l}
$>$ profile          & \hspace*{0.5em}\fbox{1} \\
IN - Input image name /!/ $>$
     {\$}STARMAN{\undersc}DATA/profile{\undersc}in
                     & \hspace*{0.5em}\fbox{2} \\
INSTARS - Input star list (posns,details) name /!/ $>$
          {\$}STARMAN{\undersc}DATA/profile{\undersc}instar
                     & \hspace*{0.5em}\fbox{3} \\
    {\sf \hspace*{4em} [Star list typed out with default profile] }
                                               \hspace*{\fill}  & \\
USE - Do automatically or interactively (auto:inter)? /'inter'/ $>$
                     & \hspace*{0.5em}\fbox{4} \\
    {\sf \hspace*{4em} [Information on how to use typed out] }
                                               \hspace*{\fill}  & \\
OPTION - Which option to perform? /'fit{\undersc}rough'/ $>$
                     & \hspace*{0.5em}\fbox{5} \\
    {\sf \hspace*{4em} [Information on rough fits typed out]}
                                               \hspace*{\fill}  & \\
OPTION - Which option to perform? /'box{\undersc}size'/ $>$
                     & \hspace*{0.5em}\fbox{6} \\
 \hspace*{1ex} {\sf Old X Y sides of box 20 20} \hspace*{\fill}  & \\
 \hspace*{1ex} {\sf Suggested X Y sides of box 22 20}
                                                \hspace*{\fill}  & \\
SIZE - XY Lengths of sides of box /[22,20]/ $>$
                     & \hspace*{0.5em}\fbox{7} \\
 \hspace*{1ex} {\sf Old X Y sides of Profile Map 20 20}
                                                \hspace*{\fill}  & \\
 \hspace*{1ex} {\sf Suggested X Y sides of Profile Map 20 20}
                                                \hspace*{\fill}  & \\
SIZE - XY Lengths of sides of box /[22,20]/ $>$
                     & \hspace*{0.5em}\fbox{8} \\
 \hspace*{1ex} {\sf Residuals zeroed}                            & \\
 \hspace*{1ex} {\sf }                                            & \\
 \hspace*{1ex} {\sf You may also wish to change the size of the box}  & \\
 \hspace*{1ex} {\sf for the profile map to match the measuring box}   & \\
 \hspace*{1ex} {\sf   Old X Y sides of Profile Map   20   20}    & \\
 \hspace*{1ex} {\sf   Suggested new sides of Profile Map    22   20}  & \\
SIZE - XY Lengths of sides of box /[22,20]/ $>$
                     & \hspace*{0.5em}\fbox{9} \\
 \hspace*{1ex} {\sf Profile Map copied to new Map }              & \\
OPTION - Which option to perform? /'fit{\undersc}all'/ $>$
                                   & \fbox{10} \\
FITTYPE - Start values, fix:float -- fit type? /'old'/ $>$
                                   & \fbox{11} \\
 \hspace*{1ex} {\sf  }                                           & \\
 \hspace*{1ex} {\sf  Box  X length =   22  Y length =   20  }    & \\
 \hspace*{1ex} {\sf \begin{tabular}{lllllllll}
   No &  Height & Its &    Rmaj &   Rmin &   P   &  PRmaj &  PRmin&  Theta \\
    1 &  8978.2 &  8  &   2.151 &  1.855 & 2.199 &  10.00 &  17.80&   26.21 \\
    2 &  3237.4 & 11  &   2.124 &  1.873 & 2.011 &  5.92  &  6.23 &  17.80 \\
    3 &  6114.1 & 17  &   2.223 &  1.893 & 2.320 &  7.56  & 18.47 &  20.31 \\
    4 & 31302.2 &  6  &   2.464 &  2.215 & 2.224 &  9.98  & 10.36 &  80.69 \\
\end{tabular} }                    & \fbox{12} \\
OPTION - Which option to perform? /'disp{\undersc}fit{\undersc}all'/ $>$
                                   & \fbox{13} \\
SCREEN - XY size of window to open for display /[420,496]/ $>$
                                   & \fbox{14} \\
\hspace*{4em} {\sf The raw and cleaned areas round each star are
                        displayed }              \hspace*{\fill}  & \\
OPTION - Which option to perform? /'panel'/ $>$
                                   & \fbox{15} \\
\hspace*{4em} {\sf The `push-buttons' and `help' are displayed }
                                               \hspace*{\fill}  & \\
\end{tabular}


\vspace*{\fill}

Comments on above run-through:-

\begin{enumerate}

\item Start the program.
\item The input image.
\item The input table of a list of four star positions.
\item We want to use the interactive mode.
\item We have now entered the looping part of the program. We are at
      present in the `Main' section. For the first few questions the
      program offers suggestions and we accept them. Later on we go into
      the `panel' mode to choose options. Here we are offered the default
      of making a rough fit to the stars. (This gives us a check on
      their quality). We accept this choice.
\item We are offered the default of changing the size of the box
      round each star which is used in the fitting. We accept this choice.
\item We set the size of the box to be fitted round each star.
\item We set the size of the empirical map of the profile.
\item We reset the size of the empirical map of the profile.
\item We fit the Lorentz analytical profile for each star.
\item We choose as the starting values of the parameters, the last
      values they had.
\item The program types out the results of the fits as it goes
      along.
\item We want to look at the data. We will see the original areas
      and the areas after the central star has been removed with the
      parameters of its own fit. If the fit is good, the star should
      have disappeared cleanly.
\item The program wants to know how large a window to open. We take the
      suggested size.
\item The program suggest entering the `push-button' mode of option
      choosing. We take the suggestion.
\end{enumerate}

\vspace*{\fill}

\begin{tabular}{p{5.3in}l}
\hspace*{4em} {\it Click cursor on 'mean' button in `Profile' section}
                  \hspace*{\fill}  & \fbox{16}\\
\hspace*{4em} {\sf Information on mean typed out}  \hspace*{\fill}   & \\
FLIP - Star number to flip angle (0=none;- = flip -ve) /0/ $>$
                                   & \fbox{17} \\
\hspace*{1ex} {\sf  Reject or accept nth star (n,-n,0) ? }      & \\
REJECT - Star number to not use (0=none;- = accept) /0/ $>$
                                   & \fbox{18} \\
\hspace*{1ex} {\sf  Had to zero residuals - profile changed }   & \\
\hspace*{1ex} {\sf  Present box size =   22  20 }               & \\
\hspace*{1ex} {\sf  Suggested new box size =   21  22 }         & \\
\hspace*{4em} {\it Click cursor on 'res{\undersc}calc' button in
                  `Residuals' section}
                  \hspace*{\fill}  & \fbox{19} \\
\hspace*{4em} {\it Click cursor on 'res{\undersc}interact' button in
                  `Residuals' section}
                  \hspace*{\fill}  & \fbox{20} \\
\hspace*{4em} {\it Click cursor on 'clear' button in
                  `Display' section}
                  \hspace*{\fill}  & \fbox{21} \\
\hspace*{4em} {\it Click cursor on 'display' button in
                  `Display' section}
                  \hspace*{\fill}  & \fbox{22} \\
\hspace*{4em} {\it Click cursor on 'fill' button in
                  `Load' section}
                  \hspace*{\fill}  & \fbox{23} \\
\hspace*{4em} {\it Click cursor on 'smooth' button in
                  `Smooth' section}
                  \hspace*{\fill}  & \fbox{24} \\
SMSIZE - XY size of smoothing box /[3,3]/ $>$
                                   & \fbox{25} \\
\hspace*{4em} {\it Click cursor on 'return' button in
                  `Control' section}
                  \hspace*{\fill}  & \fbox{26}\\
\hspace*{4em} {\it Click cursor on 'map{\undersc}add' button in
                  `Map' section}
              \hspace*{\fill}      & \fbox{27} \\
\hspace*{4em} {\it Click cursor on 'store' button in
                  `Files' section}
              \hspace*{\fill}      & \fbox{28} \\
\hspace*{1ex} {\sf  Image to put profile parameters into }      & \\
OUT - Output file for profile (an image) /!/ $>$ fred
                                   & \fbox{29} \\
TITLE - Text to add as a title to file /'Profile from PROFILE'/ $>$
                                   & \fbox{30} \\
\hspace*{1ex} {\sf  File to put stars details into }            & \\
OUTSTARS - Output file for details of fit stars /!/ $>$
                                   & \fbox{31} \\
\hspace*{4em} {\it Click cursor on 'exit' button in
                  `Control' section}
                  \hspace*{\fill}  & \fbox{32} \\
\hspace*{1ex} {\sf  !! Null NDF structure specified for the 'OUTSTARS'
                    parameter. }
                                   & \fbox{33} \\
$>$               \hspace*{\fill}  & \fbox{34} \\
\end{tabular}


\vspace*{3mm}
\hspace*{13mm}\rule{5in}{0.25mm}
\vspace*{1mm}

\begin{enumerate}
\setcounter{enumi}{15}
\item We like the fits, so we make a mean fit.
\item We do not see any orientations of the fitted elliptical profiles
      that have to be flipped by 180 degrees.
\item We do not see any stars that have to be rejected.
\item We now want to look at the average of the residuals from the
      mean profile. So we calculate them.
\item We now go into the group of options for dealing with the
      residuals.
\item We clear the screen.
\item We display the residuals. On the left are the rsiduals. On the
      right is the `fill-factor' map. This shows not the pixels, but the
      sub-pixels.

      As the pixels are sub-divided, not all the sub-divisions have to
      have a residual. The `fill-factor' map shows the sub-pixels which
      have at least one residual, and which have none.

      If we had more stars, then probably their random off-pixel centre
      centres would rsult in a full coverage of the sub-pixel plane, but
      that is not the case now.
\item As some sub-pixels are empty, we `fill' them by interpolation.
\item We smooth the residuals.
\item We take the suggested size of the `top-hat' box to smooth with.
\item We are happy with this, and do not wish to zero any part of it.
      (In practice, we would avoid some of these.) So we return to
      the `main' group of options.
\item We load the `residuals' into the `empirical map'
\item We now have the Lorentz analytical parameters, and the empirical
      map. We decide we do not want to look at any wide Gaussian wings,
      and we know that they were set to zero on starting the program.
      So we now wish to store the profile to a file.
\item We call the file `fred'.
\item We accept the suggested title for the file.
\item We enter a `null' response to the request for a file to put
      the details of the fits for the stars. So these are not stored.
\item We decide to exit the program.
\item The program insists on telling us that we put a `null' name
      when asked for the `OUTSTARS' parameter. This does no harm.
\item The program returns us to the command line.
\end{enumerate}

}\sstdiytopic{Use}{
  WARNING -- Use only bright stars as the fit will blow up and/or give a poor
   fit if used on noisy data.

   {\bf An explanation of the use of the program}

\begin{enumerate}

 \item {\bf Input of image and list of positions of stars to define the
        profile}
   The image and an table of (X,Y) positions of the stars are fed in by you.
   It is recommended that the stars should be as isolated as possible,
   bright, but not so bright that their peaks are saturated. About 5
   to 10 stars are enough.

   After this stage, you then enter the interactive part of the program.
   A recommended course of action is to do the following (and then repeat
   as needed some stages):-

 \item {\bf First rough profile derivation}
   You can use the 'rough' option to make a rough profile estimate. Other
   options are:- If you do know the rough stellar radius, input it.
   If you don't, then choose a good (isolated) star, and make a fit on
   that, and make the mean (of one!). If you don't know which are the
   good stars, display them and look.

 \item {\bf Rough box size}
   You can now set the fitting box size roughly right. In the course of
   the program, each time you calculate the Mean profile, the proper
   fitting box size is recalculated. If it differs from the size, you
   are using, then it is advisable to change to the recommended size
   and redo the fits.

 \item {\bf Fitting of the lorentzian and calculation of mean}
   Then fit a Lorentzian at each star. The program types out the fits.
   You can display the fits and look at them, then estimate the mean
   profile, rejecting bad fits.

 \item {\bf Dealing with companions, faint companions,and bad areas}
   You can then look at the stars and see if there are companions that
   need dealing with or if there are bad areas. These things are dealt
   with in three stages :-

   \begin{list}{{-}}{}
   \item   Faint companions on the wings of the main star. These are
        iteratively subtracted during the fitting process. Thus they are
        allowed for, but do not really define the profile. Their posit-
        ions are fed in by lists or by your using the cursor to point
        them out.

   \item  Bright companions or companions close to the main star. These are
        fitted in the same process as the main star. Thus they are fully
        used to define the profile, along with the target star. Their
        positions are fed in by lists or by your using the cursor to
        point them out.

   \item Bad areas. These are ignored during the fit. Their
        positions are fed in by lists or by your using the cursor to
        point them out.
   \end{list}

   In this stage, the area displayed round each star is roughly twice the
   linear size of the area actually used in the fit, so you need not
   worry about bad areas or faint stars near the edge, but stars whose
   profiles get near the central region should be marked.
   You can also mark and remove mistaken points using the cursor in the
   same way.

   You can then re-estimate the fit.

 \item {\bf Making the empirical profile map}
   If on inspection of the fits, you have a suspicion there is a system-
   atic pattern to the residuals, you can confirm this by making a map
   of the mean residuals. If on smoothing (or not) you remain convinced,
   then the empirical profile map can be loaded from this residual map.
   At this stage it is best to go back and refit the Lorentz, to see if
   the residuals map has really gone away, as it should.

   If no pronounced pattern  can be seen it is safest  not to make these
   residuals, or if made, not to copy them over to the profile map. To do
   otherwise is merely to introduce noise.

   It is also wise only to make the profile map where there is good
   signal to noise (usally at the centre of the image). Set the profile
   map to zero in the middle and outer regions where it is just sky
   noise.

 \item {\bf Fitting the modified gaussian wings}
   If on inspection of the fits, you have a suspicion there is a system-
   atic tendency for the profiles to have wide unfitted wings, then you
   can fit the wide low modified Gaussian wings of the profile. This is
   done by the program taking the current mean Lorentz/empirical fit, and
   fitting it to the accepted stars out to a distance of twice the box
   size previously used.
   You may have to add more companion stars and/or bad areas for the
   larger boxes.
   The mean radial plot and radial fit around the star centre is then
   shown. You can then refine this by using the cursor to define a fid-
   ucial set of points giving the proper profile as you see it, and the
   program will fit to them, rather than the data points.

   At this stage, it may be necessary to refit the empirical map.

   It is important to note that if no definite trend in the residuals
   can be seen, or it looks as though the wings are so wide that they do
   not go to zero within the plot, it is best to set the wings to zero.
   This avoids bright stars producing unrealistic wide wings in MEASURE
   (qv).

 \item {\bf Invalid pixels}
   If any of the pixels used are flagged as INVALID, they are ignored.

 \item {\bf Storage of the results}
   The profile is stored as an image containing the empirical map with
   the profile parameters as descriptors. The information of the fits to
   the stars and of the companions and bad areas is also stored in tables.
\end{enumerate}


}\sstdiytopic{Tips}{
   Getting a good fit is still an art, although I am working on
   making it a science, so it can be automated. But for now you
   will have to suck it and see. It is a good idea to play around
   for a while, trying the effects of various things on the fit
   and displaying the fit residuals ( not the residuals map ).

   Various points:-

\begin{list}{{-}}{}
\item   Use bright stars (ESPECIALLY if making a profile map).

\item   Repeat the fit using `old' in the `fittype' parameter in
        the `fit{\undersc}all' option, to see if the fit has converged.
        This can be checked that only a few iterations are done.
        (not the 30 allowed).

\item   The fit carries on till none of the parameters are changing
        fractionally by more than 0.001. This can be changed with the
        `controls{\undersc}fit' option - both for the normal fits and the wing fits.
        This also enables you to change the damping factor to speed up
        the fits, AT THE COST OF A RISK of edging AWAY from the right
        answer, rather than towards it.

\item   Choose which stars you are going to use by the rejection in
        the `mean' and `reject' options.

\item   It is often good to fix the angle once you have some idea what
        it is.

\item   After you have decided on a fit, run the `fit{\undersc}all' option
        with `fixmean' for the `fittype' parameter in the `fit{\undersc}all'
        option, and look at the results with the `disp{\undersc}fit{\undersc}all'
        option. Are you still happy?

\item   Remember, if you have rejected some stars, and then do the
        `fit{\undersc}all' and `disp{\undersc}fit{\undersc}all' options, the display for the stars
        not done shows the old fits.
\end{list}


}\sstdiytopic{Options}{

 In the interactive mode, the program works in an `option' mode, where
 you repeatedly select operations to do, until you are satisfied.

 On starting the program, you first have to input the image and
 the table of star positions. Then you are asked whether to proceed
 in the `automatic' or `interactive' modes.

 {\bf \hspace*{2em} Automatic mode:-}

 If you select the `automatic' mode, no further input is needed,
 apart from the names of the file to put the output into.

 {\bf \hspace*{2em} Interactive mode:-}

 You now have the `main' list of options available to you. The program
 suggests the first five selections, and then suggests going into to
 the `panel' mode, where the options are available as buttons in a
 `panel' window in the display.

 You can now select any sequence of otpions to determine the mean
 profile in the best way from the actual image you are working on.

 From this `main' group four other groups of options are available:-

\begin{tabular}{|l|l|p{3.2in}|}\hline
   Group    &  Panel Button to press  & Type of options available \\ \hline
   main     &    -                    & Main options \\
   fit      &  interact{\undersc}fit  & Interaction with display of the fits \\
   map      &  map{\undersc}interact  & Interaction with display of
                                        the profile map \\
   residual &   res{\undersc}interact & Interaction with display of
                                        the residuals to mean fit \\
   wing     &  wing                   & Calculation of wide Gaussian wing \\
  \hline\end{tabular}

 {\bf \hspace*{2em} Main options:-}

 \begin{tabular}{|l|p{4.5in}|}\hline
 Option & Function \\ \hline
 angle                  &  Change Fix/Vary angle and/or angle \\
 box{\undersc}size      &  Change size of box round stars used for fitting \\
 clear                  &  Clear the display window \\
 close                  &  Close the display screen \\
 comp{\undersc}zero     &  Delete all comp/faint comp/bad area list entries \\
 controls{\undersc}fit  &  Change internal controls of fit calculating \\
 disp{\undersc}fit{\undersc}all  &  Display the areas + residuals to the
                                    fits \\
 disp{\undersc}fit{\undersc}one  &  Display the areas + residuals to a single
                                    fit \\
 display                &  Display image \\
 exit                   &  Exit from this program \\
 fit{\undersc}all       &  Fit all the accepted stars \\
 fit{\undersc}changed   &  Fit only stars with changed circumstances \\
 fit{\undersc}one       &  Fit a certain star \\
 fit{\undersc}rough     &  Make rough estimate of posns, heights, radii \\
 fit{\undersc}trial     &  Calculate the mean profile from one star \\
 fix{\undersc}set{\undersc}xy    &  Set fixed/varying positions and/or the
                                    posns \\
 flip                   &  Rotate profile ellipse of stars by 180 degrees \\
 info{\undersc}fits     &  List the present fits \\
 info{\undersc}fitting  &  Type intermediate step results in the fitting \\
 info{\undersc}star     &  List the fit, comps, bads of a star \\
 interact{\undersc}fit  &  Interact with the display of fits \\
 map{\undersc}add       &  Add the Residuals array onto the Profile Map \\
 map{\undersc}disp      &  Display the profile map \\
 map{\undersc}interact  &  Interact with the display of Profile Map \\
 map{\undersc}scale     &  Change Profile Map scale (mult/div its values) \\
 map{\undersc}size      &  Change Profile Map size \\
 map{\undersc}use       &  Change whether to apply the Profile Map or not \\
 map{\undersc}zero      &  Zero the Profile Map \\
 mean                   &  Decide which stars to use; find mean weighted
                           profile \\
 new{\undersc}cm{\undersc}pr     &  Load some previous stuff (Comps,
                                    Bad areas, Fit) \\
 new{\undersc}image     &  Input new image to replace the present one \\
 new{\undersc}stars     &  Input list of star posns to replace present ones \\
 panel                  &  Switch between panel and keyboard option
                           selection \\
 prof{\undersc}change   &  Change the mean profile parameters \\
 prof{\undersc}fix      &  Change fixed/variable control on profile params \\
 radial{\undersc}plot   &  Put a radial plot of profile and fit into file \\
 reject                 &  Change which stars are accepted/rejected \\
 res{\undersc}calc      &  Calculate the array of residuals \\
 res{\undersc}disp      &  Display the mean fit residuals array \\
 res{\undersc}fill      &  Fill any -empty- pixels in the residuals array \\
 res{\undersc}interact  &  Interact with the display of residuals array \\
 shift{\undersc}all     &  Shift XY positions of all the stars and comps \\
 show{\undersc}reject   &  Put red border for rejected stars on display \\
 store                  &  Save the profile and fits \\
 volume                 &  Calculate the profile volume \\
 wing                   &  Fit a broad Gaussian wing - zero broad wing start \\
 \hline\end{tabular}

 The `shift{\undersc}all' option shifts the X,Y positions of all the stars
 and companions and faint companions. It leaves the bad areas unmoved.
 This enables you to use the lists from one exposure on another where
 the field centre is different, but where the detector bad areas are
 at the same positions.

 Further information on these options is given in the six line help
 window that appears in the `panel' mode, and contains relevant help
 when the cursor is placed on a button.

 {\bf \hspace*{2em} Fit options:-}

 These options enable you to pan and zoom the display of
 the stars and the residuals of the fits. You can also insert
 and remove companion stars, faint companions, and bad areas;
 get the values in the images or residuals; remove/replace the
 coloured lines.

 \begin{tabular}{|l|p{4.5in}|}\hline
 Option & Function \\ \hline
 blank         &  Remove an area from the calculations \\
 box           &  Paint fitting box when displaying fits \\
 clear         &  Clear the display window \\
 close         &  Close the display screen \\
 comp{\undersc}br       &  Add a bright or close companion \\
 comp{\undersc}fa       &  Add a faint or distant companion \\
 disp{\undersc}all      &  Display the areas + residuals to the fits \\
 disp{\undersc}one      &  Display the areas + residuals to a single fit \\
 im{\undersc}values     &  Type values in main image in cursor given area \\
 info{\undersc}star     &  List the fit, comps, bads of a star \\
 paint{\undersc}box     &  Paint up fitting boxes \\
 paint{\undersc}comp    &  Paint up companions and bad areas \\
 posntype      &  Change posn markers between spot and crosses \\
 res{\undersc}values    &  Type out residual values in cursor defined area \\
 reset         &  Reset zoom/pan to unity and centre \\
 return        &  Return to main program option list \\
 shift         &  Reposition a main star \\
 unblank       &  Restore an area to the calculations \\
 uncomp{\undersc}br     &  Remove a bright or close companion \\
 uncomp{\undersc}fa     &  Remove a faint or distant companion \\
 zoom          &  Zoom and pan image by using mouse location \\
 \hline\end{tabular}

Zoom/pan work:- \hspace*{4ex}\begin{tabular}{|c|l|}\hline
Action                         & Effect \\ \hline
Left Button twice              & zoom /2 \\
Centre Button twice            & zoom x2 \\
Left Button then Centre Button & pan \\
Right button once              & return \\ \hline
\end{tabular}


 Further information on these options is given in the six line help
 window that appears in the `panel' mode, and contains relevant help
 when the cursor is placed on a button.


 {\bf \hspace*{2em} Map options:-}

 These options enable you to look at the profile map closely and to
 change it to some extent.

 \begin{tabular}{|l|p{4.5in}|}\hline
 Option & Function \\ \hline
 clear         &  Clear the display window \\
 display       &  Display the profile empirical map array \\
 original      &  Load map as before entering this MAP option \\
 reset         &  Reset zoom/pan to unity and centre \\
 return        &  Return to main OPTION choice \\
 smooth        &  Smooth profile map by -top hat- NxM box \\
 spolyin       &  Define a polygon with cursor, smooth area inside \\
 spolyout      &  Define a polygon with cursor, smooth area outside \\
 values        &  Type out values for an area of the profile map \\
 zero          &  Zero all profile map \\
 zoom          &  Zoom and pan image by using mouse location \\
 zpolyin       &  Define a polygon with cursor, zero area inside \\
 zpolyout      &  Define a polygon with cursor, zero area outside \\
 zrect         &  Define a rectangle with cursor, zero area inside \\
 \hline\end{tabular}


 When defining the polygons, you use the cursor and the
 buttons. Place the cursor at consecutive vertices of the
 desired polygon, and press any button. To end the input of
 vertices, do a repeat press, without moving the cursor, on
 the last vertex. A line showing where the polygon lies is
 output whilst you are doing this.

 Further information on these options is given in the six line help
 window that appears in the `panel' mode, and contains relevant help
 when the cursor is placed on a button.


 {\bf \hspace*{2em} Residual options:-}

 These options enable you to look at the residuals map
 closely and to change it to some extent.

 \begin{tabular}{|l|p{4.5in}|}\hline
 Option & Function \\ \hline
 calculate     &  Calculate the array of residuals \\
 clear         &  Clear the display window \\
 display       &  Display the mean fit residuals array \\
 fill          &  Fill any -empty- pixels in the residuals array \\
 original      &  Load original values from last fit calculations \\
 reset         &  Reset zoom/pan to unity and centre \\
 return        &  Return to main OPTION choice \\
 smooth        &  Smooth profile map by -top hat- NxM box \\
 spolyin       &  Define a polygon with cursor, smooth area inside \\
 spolyout      &  Define a polygon with cursor, smooth area outside \\
 values        &  Type out values for an area of the residual array \\
 zero          &  Zero all residual array \\
 zoom          &  Zoom and pan image by using mouse location \\
 zpolyin       &  Define a polygon with cursor, zero area inside \\
 \hline\end{tabular}

 When defining the polygons, you use the cursor and the
 buttons. Place the cursor at consecutive vertices of the
 desired polygon, and press any button. To end the input of
 vertices, do a repeat press, without moving the cursor, on
 the last vertex. A line showing where the polygon lies is
 output whilst you are doing this.

 Further information on these options is given in the six line help
 window that appears in the `panel' mode, and contains relevant help
 when the cursor is placed on a button.

 {\bf \hspace*{2em} Wing options:-}

 These options enable you to estimate the parameters of the wide
 Gaussian wing:-

 The `wing' options fits a low wide Gaussian wings to the profile.

 \begin{tabular}{|l|p{4.5in}|}\hline
 Option & Function \\ \hline
 display       &  Display the areas + residuals to the fits \\
 fit{\undersc}gcursor   &  Fit to wing points input by cursor \\
 fit{\undersc}graw      &  Fit to raw wing points as calculated \\
 fit{\undersc}stars     &  Fit stars in the large areas round each star \\
 gclose        &  Close the graphics device \\
 gcursor       &  Put -better- wing points in by cursor \\
 gplot         &  Plot the wing points graphically \\
 gshowfit      &  Plot fitted line \\
 interact      &  Interact with the display of fits \\
 return        &  Return to main option \\
 set{\undersc}param     &  Insert your own wing profile values \\
 type{\undersc}Param    &  Type present wing parameters \\
 \hline\end{tabular}

 The program sums up all the accepted stars, subtracts the fitted fixed
 Lorentzian profiles, folds the data round the centre and fits the
 modified Gaussian. The program then plots
 the data and draws the Gaussian it has fitted. If you have
 chosen an interactive terminal, you can then modify the fit by marking
 (via the cursor) points which you think best show the actual profile
 and the program then fits the Gaussian to these points and draws the
 fitted curve on the device. You can then redefine a new set of points
 as often as you like until you are satisfied with the fit.

 You can:-

   -  Look at a larger area round each star to see if there are areas
      to be blanked off, or stars to be marked so that the fits can
      be redone.
   -  Fit the stars. This does a fit, and calculates the residual
      radial distribution of data that is left.
   -  Look at the 1-D distribution of residual data on a graph,
      and if it looks corrupted input your own residual distribution.
   -  Fit the wing profile parameters to the 1-D residual profile,
      either by fitting to calculated points, or fitting to the
      hand input points.
   -  Look at the wing profile parameter fit to the 1-D distribution.
   -  Put in your own estimates of the wing profile parameters, and
      say if they should be fixed or not.

 The point about the option for hand inputting is that sometimes
 the raw points are disturbed by miscellaneous things in the large
 areas used in determining the wing profile. You can thus use
 some judgement and put the radial distribution where you think it
 should be.

 In putting your own set of points of the radial distribution, be sure
 to put in enough that the fit can make a good fit to them.

   A normal course might be to:-

\begin{list}{{-}}{}

\item {\bf Display \hspace*{2ex}} Display the x2 area and blank
                                  off or mark up the extra stars
                                  in the large wing area
\item {\bf Interact \hspace*{2ex}}   Blank off or mark up the extra
                                  stars in the large wing areas
\item {\bf Fit{\undersc}stars \hspace*{2ex}}    Fit the stars in
                                  the large wing area and calc
                                  the distribution of wing data points
\item {\bf Gplot \hspace*{2ex}}   Look at the wing data points
\item {\bf Gcursor \hspace*{2ex}} Put your own smoothly distributed
                                  wing data points by using the
                                  graphics cursor
\item {\bf Fit{\undersc}gcursor \hspace*{2ex}}    Fit the wing
                                  parameters to your cursor input
\end{list}

   After this you can loop round changing the cursor positions
   and/or refining the fit. The fit is usally very delicate
   and it is common to adjust the profile parameters by hand
   before a number of fits to get a good fit

    Then:-

\begin{tabular}{lp{4in}}
      -Return-       Back to the main option.
\end{tabular}

 Further information on these options is given in the six line help
 window that appears in the `panel' mode, and contains relevant help
 when the cursor is placed on a button.

}\sstdiytopic{Fitting Details}{

 The elliptical rotated Lorentz profile that is fitted is one that has
 been found to give a good fit to typical star images.

 The actual fitting of a star in an image is a scaled (according to the
 height of the star) version of this total profile, added onto a
 linear sloping sky background. The fitting for the background is done
 at the same time as the fitting for the star.

 The fitting is done by starting with trial values of the star heights
 and positions and of the background, and then improving these by the
 iterative linearised least squares method until an acceptable fit is
 made, or until too many iterations have been done.


 \begin{list}{{-}}{}
 \item It can deal with close companions. You have to tell it where
     these stars are.
  \item It can deal with areas of 'bad' pixels, in that such areas are
     ignored in the fits. Again you have to define these areas. (Such
     pixels can also be so flagged before entering the program - see
     other Starman programs for the method of flagging invalid
     pixels.)
\end{list}

 The fitting takes account of pixel averaging, that is what happens
 when the star radius gets small, and there is significant change in
 the profile across one pixel. As the profile is not a straight line,
 the normal practice of taking the profile value at the centre of the
 pixel will be wrong. The program subdivides the profile over the
 pixel and calculates a more accurate average. So the bad effects of
 a narrow profile and star centres being at different distances from
 the pixel sides are minimised.

 The 'volume' of this profile, that is the numerical integration under
 the 2-D profile out to a defined distance, can be calculated. (The
 calculation is done with a fine mesh, so there is no effect from the
 pixel averaging for small radii.) This enables the magnitudes of
 stars with different profiles to be estimated.

 At the program start, the values of the profile parameters are:-
      RX=2.0, RY=2.0, P=2.2, PRX=10.0, PRY=10.0, THETA=0.0
      QH=0.0, QR=10.0, QP=2.0

 (A note for people looking inside the program source)

 Inside the program, the parameters have slightly different names:-

\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}\hline
 Here     &RX    &RY     &P     &PRX    &PRY   &THETA
& QH           & QR           & QP \\ \hline
 Inside  &{\small Rmaj}  &{\small Rmin}  &{\small Power}  &{\small PRmaj}
  &{\small PRmin}  &{\small Angle}
&{\small Wing} &{\small Wing} & {\small Wing } \\
 & & & & & & & {\small Height} & {\small Radius}  & {\small Power} \\ \hline
\end{tabular}


}\sstdiytopic{Profile details}{

 The profile that is fitted is one that has been found to give a good fit
 to typical star images. It is an elliptical rotated Lorentzian sitting
 on top of a wide low circular modified Gaussian, with an empirical
 residuals map. The actual fitting is a scaling of this profile, added
 onto a linear sloping background, which is fitted at the same time as
 the star.

 {\bf The mathematical expression of this is:-}



 {\bf \hspace*{2em} Nomencluture:-}

\begin{tabular}{|l|p{4in}|}\hline
    Word        &     Meaning \\ \hline
   The profile   &  Usally the nine profile parameters and the profile
                   map. Sometimes just the nine parameters. \\
   Residuals map &  The map of differences of the data from the fits
                   using the mean profile at the time the `res{\undersc}calc'
                   option was run. \\
   Profile Map   &  The empirical array,  F(x,y), described in the
                   method section. This can only be loaded by
                   adding in a processed residuals map. \\ \hline
\end{tabular}

}\sstdiytopic{Input Files}{

 The input is done by files containing images and tables.

 These are described in the parameter lists.


\begin{tabular}{|l|p{4in}|} \hline
  Parameter &  Contents \\ \hline
  IN        &  Input image \\
  INSTARS   &  Input table of star positions \\
  INCOMPS   &  Input table of companion stars and bad areas (optional) \\
  INPROF    &  Input profile (optional - for use as default start) \\
\hline\end{tabular}

}\sstdiytopic{Output Files}{

 The output is done by files containing images and tables.

 These are described in the parameter lists.

\begin{tabular}{|l|p{4in}|} \hline
  Parameter &  Contents \\ \hline
  OUT       &  Output profile (stored as image) \\
  OUTSTARS  &  Output table of fitted stars (optional) \\
  OUTCOMPS  &  Output table of companion stars and bad areas (optional) \\
  OUTRADIAL &  Output table of wing fit and its residuals (optional) \\
\hline\end{tabular}


}\sstdiytopic{Display}{

  In the interactive mode, you can display on an image display the
  three types of data the program deals with. You are in fact encouraged
  to do so, so as to understand the profile.

  In each case you can inspect and interact with the data displayed.

\begin{tabular}{|l|p{4in}|}\hline
  Types of data   &   Description \\ \hline
  Fits            &  Display of     a) the image round each star \newline
                     \hspace*{7ex}  b) the image minus the stars fitted \\
  Residuals       &  Display of     a) the residuals to the mean fit \newline
                     \hspace*{7ex}  b) the filling of the residuals array \\
  Profile map     &  Display of the profile map array \\ \hline
\end{tabular}

  A fuller description of the types of data is given in the `Data'
  section.

{\bf \hspace*{2em} Fits Display:-}

  When the fits are displayed on the image display, the display
  consists of two parts. The top half contains the actual pictures round
  each target star. The bottom half contains the residuals when the fits
  are subtracted from the actual image.

  The displayed boxes have sides that are twice the actual fitting
  boxes. (The edges of the fitting boxes are indicated by the purple
  dots at the sides of the displays.) The reason for this is to help
  you in marking the positions of stars just outside the fitting boxes
  which are bright enough that they affect the data inside the fitting
  boxes.

  The intensity scaling in the top half is uniform. In the bottom half,
  each box has its own scaling to bring up the residuals as well as
  possible. An idea of the relative scaling may be gained by looking at
  the intensity variations in the sky background.

  You can inspect and interact with this data (see the OPTION parameter).

{\bf \hspace*{2em} Residuals Display:-}

  When the residuals are displayed, there is also shown the filling map
  of the residuals. This filling map shows which pixels in the
  residuals array actually have data.

  The residuals are displayed at the right size. The intensity scaling is
  such as to show the residuals up as much as possible.

  The residuals map covers the same number of image pixels as the
  fitting box. But the residuals map may well contain more pixels, and
  thus be `larger', by an integral number factor, than the fitting box.
  This happens when the profile is so small that pixel averaging
  becomes important. In this case the residuals map is subdived, with
  each pixel becoming a nxn box (where n=1+int[2.9/(min radius)] ).

  Then for each star, the residual from the profile at each pixel is
  calculated and stored in the nearest subdivision. For example, if a
  star with radius 1.5 had its centre at [100.2,100.8], the residual of
  pixel [105,105] at distance (4.8,4.2), would be stored at the (1,3)
  subdivision of the (4,4) pixel.

  Alongside the residuals, in a red box, are displayed the
  filling factors, that is, which pixels (shown as white) have data,
  and those that do not (shown as black).

  You can inspect and interact with this data (see the ROPTION parameter).

{\bf \hspace*{2em} Profile Map Display:-}

  The display of the profile map shows the current state of the
  profile map.

  This is much like the residuals map, except that there is no filling
  factor display, as the profile map can only be filled from a full
  residuals map (one either naturally full, or smoothed full, or boxed
  or polygoned so, or zeroed so).

  You can inspect and interact with this data (see the OPTION parameter).

  The profile map does not have to be the same size as the fitting
  area.

  Its size is the number of pixels of the image that the profile map
  covers. This can be different than the computer storage size and the
  size of the profile file image, since the profile map may map to
  sub-divided image pixels, and thus contain more data points.

}\sstdiytopic{Panel}{
 In the menu-driven mode of this program, there is the capability
 to interact with this menu in a `windows' type mode. If you choose
 the `Panel' option in the `Option' choice, then if you have a
 workstation (at present only a Vaxstation with VWS windows and
 Decwindows) a small panel appears on the screen. This has what look
 like buttons with all the available options. You select these by
 putting a cursor on the `button' and then pressing a cursor button.

 The panel has a `help' button which lists out one line
 descriptions of the options. It also has a `command' button which
 gives you access to no useful command in itself, but you can
 then enter the full program help system.

}\sstdiytopic{Cursor}{

 In the interactive mode, a cursor is used to pick up positions, change
 the zoom, and other miscellaneous purposes.

 The mouse moves the cursor. It is assumed that a 3 button
 mouse is used. The mouse buttons are worked like this:-

   General position marking:-   Press any button

Zoom/pan work:- \hspace*{4ex}\begin{tabular}{|c|l|}\hline
Action                         & Effect \\ \hline
Left Button twice              & zoom /2 \\
Centre Button twice            & zoom x2 \\
Left Button then Centre Button & pan \\
Right button once              & return \\ \hline
\end{tabular}

  If the cursor is outside a displayed area, often pressing the button
  will result in no actions.

}\sstdiytopic{Graphics}{

  Graphics are done under the control of the Starlink
  use of `GKS'. This opens a separate graphical window. This window
  can only be removed outside the program by use of the `xdestroy'
  program.

}\sstparameters{

\sstsubsection{ANGLE = {\undersc}REAL (Read)}{
 (Default - the present calculated value   \hspace*{6ex}
  Range - 90.0 to 90.0)

 Input the angle, in degrees, of the major axis of the profile,
 anti-clockwise from +ve X direction.

 At the program start, the value is 0.0

 The first use is to change if needed the angle found by the preliminary
 fit. Thereafter it is used only if the angle is to be fixed.

 By inputting a suitable angle, you can speed the fit up, as it starts
 from a value near its proper one. Also if you have said, via the
 `FIXANGLE' parameter in the `angle' option, that the want the angle
 fixed, then you need to say what you want it fixed at. Then both the
 fit will go faster, and the angle will stay at a good value.

 This should be used in practice if you:-

\begin{list}{{-}}{}
\item Want to start the fit near the proper angle.
\item Are sure of the angle.
\item Are sure the stars are round (in which case set the angle to zero).
\item Want to speed the fit up and do not care what the angle is.
\end{list}

}\sstsubsection{BASE = {\undersc}REAL (Read)}{
  (Default - present value    \hspace*{6ex}    Range - -1.0e10 to 1.0e10)

  The value of the base level that underlies the Gaussian wing fit.
  Sometimes the fit does not do a very good fit to the base, and
  this enables you to set (and perhaps fix with the `set{\undersc}param' option
  in the `wing' options) this base level.

}\sstsubsection{CWIDTH = {\undersc}REAL (Read)}{
  (Default - present value    \hspace*{6ex}    Range - 1.0 to 1.0e10)

  The width in pixels of the crosses to be painted up to mark the
  positions of the stars. The starting value is 3 pixels.

}\sstsubsection{DAMP = {\undersc}REAL (Read)}{
  (Default - present value   \hspace*{6ex}     Range - 0.0 to 100.0)

  The damping factor in the fitting least squares method, whilst
  doing the main Lorentz profile fitting.

  This controls the spize of the adjustments in the fitting. The
  smaller the number, the less the internal damping, and so the
  bigger the steps, the faster the fitting, and also the risk of
  shooting out of the best `least squares' path and so mis-fitting.
  In general, values are such that:-

        0.0 = no damping, 0.5 = normal, 1.0 = a lot of damping.


}\sstsubsection{DOPTION = LITERAL (Read)}{
  (Default - last choice   \hspace*{6ex}     Choices - see below)

 Which of the following options, to do with looking at the fits
 and modifying them, do you want to do?

  This is the interaction with the display of the raw images round
  each star and those images after the fit made has been subtracted
  from the image.

 Enables you to pan and zoom at the display of the stars and the
 residuals of the fits. You can also insert and remove companion
 stars, faint companions, and bad areas; get the values in the
 images or residuals; remove/replace the coloured lines; display
 star positions as spots or crosses.

 [The options are listed in the `options' section.]

Buttons for Zoom/pan work:-

\hspace*{4ex}\begin{tabular}{|c|l|}\hline
Action                         & Effect \\ \hline
Left Button twice              & zoom /2 \\
Centre Button twice            & zoom x2 \\
Left Button then Centre Button & pan \\
Right button once              & return \\ \hline
\end{tabular}


}\sstsubsection{FITLIM = {\undersc}REAL (Read)}{
  (Default - present value       \hspace*{6ex} Range - 0.0 to 100.0)

  The `limit' in the profile parameter changes when the fit is thought to
  have settled, while doing the main Lorentz profile fit.

  It is the fractional change, at an iteration step in the least squares
  fit, in each of the profile parameter values that are changing. Their
  changes must be less than this before the least squares iterations
  stop. Normal value = 0.001.

  See the 'Htlim' parameter for the limit on the fractional change
  in the star height.

}\sstsubsection{FITTYPE = LITERAL (Read)}{
   (Default - 'old'    \hspace*{6ex}
    Choice - 'fixmean:fixold:mean:none:old:update')

   Method of inputting starting values to the profile parameters
   in the fit iterations

   This is done either to speed things up, or get better values out of
   the fit. This can also provide a temporary override on the `fixing'of
   the profile parameters, by fixing them for this go.

   Choices:-

\begin{tabular}{|c|p{4in}|}\hline
   Option   &   Function \\ \hline
   Fixold   &   Fix profile at last fit of each star (no profile
                fitting) \\
   Fixmean  &   Fix at the last calculated mean profile (no profile
                fitting) \\
   Mean     &   Take last calculated mean profile \\
   None     &   Do not do fit \\
   Old      &   Take last fit for each star \\
   Update   &   Take mean of fits made of previous stars in this
                list \\ \hline
\end{tabular}

}\sstsubsection{FIXANGLE = LITERAL (Read)}{
 (Default - `no'     \hspace*{6ex}    Choice - `yes:no')

 Option for fixing the angle to the X axis of the major axis of the
 Lorentzian component of the profile. (THETA in the profile equation.)
 This is measured in an anti-clockwise direction, starting from the
 +ve X axis direction.

 At the program start, it is not fixed.

 This should only be used if you are either certain of the angle, or
 sure the stars are round (in which case set the angle to zero).

}\sstsubsection{FIXEM = {\undersc}INTEGER(4) (Read)}{
  (Default - present values    \hspace*{6ex}    Choices - 0 or 1)

  This inputs four integer values, each either 0 or 1. These are input
  as (say) `1,0,1,0'. These values are then switches as to whether the
  wing parameters are fixed or varying when doing the wing fit.

  0 = Fix ;    1 = Free (varying)


}\sstsubsection{FIXPROF = LITERAL (Read)}{
 (Default - present value     \hspace*{6ex}    Choice - `yes:no')

 Option for whether to have the main profile parameter, that you are
 being asked about, fixed or not.

 At the program start, none are fixed.

 You are asked about five of the parameters in the main profile
 (Rmaj, Rmin, Power, PRmaj, PRmin) in turn. (The angle parameter is
 then asked for with the control `FIXANGLE', but that is separate
 to this particular bit of help.)

 The usual reason for fixing these parameters is that you are sure
 of what they are, and/or you do not want them to change, and/or
 you want to speed the fit up.

 The values of the profile can be input via the OPTION:PROFCHANGE
 and then the 'VALUE' input. But in this case, all the profile
 parameters are asked for, the 6 of the Lorentzian and the 3 of the
 Gaussian.

}\sstsubsection{FLIP = {\undersc}INTEGER (Read)}{
 (Default - 0    \hspace*{6ex}  Choices -  -n to +n, n being the number of stars in list)

 The number of the star to have its fitted angle flipped by 180 degs.
 If +n, then the nth star has its angle increased by 180deg, if -n
 then the nth star has it decreased by 180. This sometimes helps
 in the calculation of the mean.

 For no more changes, type 0.


}\sstsubsection{GTYPE = LITERAL (Read)}{
  (Default - `ask'    \hspace{6ex}    Choice - any)

  A character string giving the local name for the graphics
  display type.

  `xwindows' will put it out on the screen of your display.
  if you are using one.

  If `ask' is input, then the program asks a very similar question,
  in a different way. A response here of `?' will bring up a listing
  of all the possible names of graphics devices which are supported
  on your machine, and you then input the appropriate name.

}\sstsubsection{HEIGHT = {\undersc}REAL (Read)}{
  (Default - present value       \hspace*{6ex} Range - -1.0e10 to 1.0e10)

 Set the value of the `Wing height' parameter in the modified
 Gaussian profile. This is the fractional height of the Gaussian
 wing compared to the main Lorentz profile.

 It is usual to set this to more than 0.0. If it is less than
 zero, then if the wing fit to determine the wing profile is done,
 the result is unpredictable.


}\sstsubsection{HTLIM = {\undersc}REAL (Read)}{
  (Default - present value       \hspace*{6ex} Range - 0.0 to 100.0)

  The `limit' in the height changes when the fit is thought to
  have settled, while doing the main Lorentz profile fitting.

  It is the fractional change, at an iteration step in the least squares
  fit, in the height of the main star that is  changing. Its changes must
  be less than this before the least squares iterations stop.
  Normal value = 0.001.

  See the 'Fitlim' parameter for the limit on the fractional change
  in the profile values.

}\sstsubsection{IN = NDF (Read)}{
  (Default - null)

 The name of the file containing a 2-D image which has the stars
 in it whose profile it is desired to measure.

 A null `return' entry is not allowed.

 This image must be in either the `short' 16-bit integer or `real'
 32-bit real standard Starman NDF format.

}\sstsubsection{INCOMPS = NDF (Read)}{
  (Default - null)

 Input an existing table with the companions, faint companions and
 bad areas in it.

 A `blank' entry of just typing `return' will result in no table being
 input.

 The table must be in the format of the `OUTCOMPS' output of PROFILE, and
 will almost certainly have been made from a previous run of PROFILE.

 A 'Companion' is a star that is close and comparably bright
 to the target star. A faint star in the fitting box is not a companion,
 neither is a bright star on the edge of the box. (These are the faint
 companions.) In the fitting, companion stars are fitted along with
 the target stars, with their profiles being varied with the target stars
 to minimise the total residuals of the joint fit. Up to seven
 companion stars are allowed for each target star, and eight faint
 companions. Up to sixteen bad areas can be marked near each target star.

}\sstsubsection{INPROF = NDF (Read)}{
  (Default - null)

 Input an existing image containing the profile.

 This image, contained in a file, holds the profile in the standard
 Starman way, that is the profile parameters are the descriptors
 of the image and the profile empirical map, if any, is contained
 in the image itself.

 A `blank' entry of just typing `return' will result in no image being
 input.

 The image must be in the standard format. It may have been produced via
 the `OUT' output of PROFILE during this or a previous run, or
 may have been generated by another means.

}\sstsubsection{INSTARS = NDF (Read)}{
  (Default - null)

 The name of the file containg the table of the positions of the stars
 to be fitted.

 A null `return' entry is not allowed.

 This can be  either a simple (X,Y list), or it could contain more
 information. For example, the output star table of the `OUTSTARS' parameter
 of PROFILE can be fed in here, and all the PROFILE information on the
 fitting to the stars would be available.

 Thus a run on PROFILE could take off from where it stopped.
 (If other information on companion stars and bad areas is needed that
 can also be input with the OPTION:FILELOAD command.) Also the output
 table from MEASURE could be used as this input, and the profile and
 height information would be taken as wellas the X,Y positions. Indeed,
 for any table with 'HEIGHT' as one ofthe descriptors, the heights would
 be input. This kind of preliminary information is useful in speeding up
 the fitting.


}\sstsubsection{LINECOL = LITERAL (Read)}{
  (Default - `black'  \hspace{6ex}       Choice - `black:white')

 Colour of plot lines. This is determined by whether you have a
 black or white background to your plots.

}\sstsubsection{MOPTION = LITERAL (Read)}{
 (Default - last option     \hspace*{6ex}   Choice - see below)

 Which of the following options, to do with
 looking at the empirical map closely and modifying it, do you want to do?

 This enables you to look at the empirical profile map closely and to
 modify it.

 [Further details are given above the `options' section.]

 When defining the polygons, you use the cursor and the buttons. Place
 the cursor at consecutive vertices of the desired polygon, and press
 any button. To end the input of vertices, do a repeat press, without
 moving the cursor, on the last vertex. A line showing where the
 polygon lies is output whilst you are doing this

}\sstsubsection{NUMBER = {\undersc}INTEGER (Read)}{
  (Default - see below   \hspace*{6ex}     Choice - se below)

  This is asked for in a number of different contexts. It thus has
  a number of various uses, depending on option in the `OPTION'
  parameter that you have selected:-

\begin{tabular}{|c|p{4in}|}\hline
  Option   &   Use \\ \hline
  Info{\undersc}star &   Number of star you want the
                         complete fit details for. \\
  Fix{\undersc}set{\undersc}xy    &  Number of star you whose position
                         you want fixed (Minus that number frees the
                         position; 0 exits from this option). \\
  Fit{\undersc}one  & Number of the star you want fitted. \\
  Disp{\undersc}fit{\undersc}one & Number of the star you want
                                   displayed. \\ \hline
\end{tabular}

}\sstsubsection{NUMBUTT = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - see below   \hspace*{6ex} Range - 2 to 3)

  Number of `X-Window' buttons available on the mouse.

  Some devices have two and some have three buttons available. This
  can depend both on their actual presence, and also on the X Windows
  software that is being run.

  With three buttons, then the Starman programs use all three, with
  the right-hand button being used mainly as the `exit' button.

  With two buttons, then the third button is simulated by pressing
  both of the buttons down, with the middle one being pressed slightly
  BEFORE the left-hand one. Use of the middle button in its normal
  way has to be modified, in that one has to pause for half a second
  after using it.

  [This parameter is usally 'hidden', with the machine manager setting
   it to the appropriate value for the local set-up. Sometimes it will
   be left to the user to set, depending on his software configuartion.]

}\sstsubsection{OK = LITERAL (Read)}{
  (Default - `various'    \hspace*{6ex} Choice - `yes:no')

 This can be demanded at various stages in the program,

 What is wanted here will be clear from the previous operation, or
 information line just typed out. It generally gives you
 a chance to agree or disagree with some question that the program
 wants answering.

 Often the program will suggest the 'usual' answer. For example, you
 may have chosen to calculate the residuals map before you have
 calculated a mean profile, which would be a silly thing to do.
 The program checks if you really mean this. Then by typing NO, you
 can escape back to the OPTION choice. (Of course, you may want to do
 this for some reason, perhaps the default profile is usable, in which
 case just type YES.)

}\sstsubsection{OPTION = LITERAL (Read)}{
  (Default - see below     \hspace*{6ex}   Choice - see below)

 What operation, from a menu of possible choices, to do next?

 It is the general option choice, which you repeatedly come back to after
 performing operations. You select one of the menu operations.

 When you started the program, you were asked for the input image and
 input star list. Then you started on this option choice. Generally the
 default option is a repeat of the last option. However at the start,
 a standard set of options is given as the default

 [The list of options is given in the `options' section above.]


}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

 The name of the new output file containing the image into which the
 present profile parameters and empirical profile map are to be written
 into.

 A `blank' entry of just typing `return' will result in no file being
 made.

 The parameters of the profile (RX,RY,P,PRX,PRY,THETA,QH,QR,QP,VOL)
 are written as descriptors of this file, together with the
 XMAG and YMAG descriptors which show the subdivision of the image
 pixels into a finer spaced grid in which the profile mean residuals
 are calculated. The size of this image is about 7*max(YMAG,XMAG)*RX,RY
 with the precise factor depending on the angle of the
 profile to the X-Y directions.

 The file is an Integer*2 (16bit) file and the residuals are stored
 as the residuals that a star of peak height 10 000 would have (but
 this is noted by the BSCALE factor, so other programs get the right
 values.)

 This file can be used as input to MEASURE (qv), and can be re-input
 into PROFILE, via (INPROF) at any time.


}\sstsubsection{OUTCOMPS = NDF (Write)}{
  (Default - null)

 The name of the new output file containing the table with the positions
 and fitted heights of the companions and faint companions, and the
 positions of the boxes containing the bad areas near the stars.

 This file can be re-input into PROFILE, via (INCOMPS) at any time.

\begin{tabular}{|l|l|p{2.8in}|}\hline
 Column  &   Header    &          Contents \\ \hline
   1   &   X OR XS             &  X posn of comp or X start of bad area \\
   2   &   Y OR YS             &  Y posn of comp or Y start of bad area \\
   3   &   HT OR XE            &  Height or X end of bad area \\
   4   &   NULL OR YE          &  Null   or Y end of bad area \\
   5   &   NULL                &  Empty \\
   6   &   1:2:3=COMP:FC:BAREA &  Code for line (1:2:3=Comp:faint comp:
                                                     bad area) \\ \hline
\end{tabular}

}\sstsubsection{OUTRADIAL = NDF (Write)}{
  (Default - null)

  Name of file to put 1-D profile Gaussian wing plot into.

  This is output as a table, with rows given the values at
  different radial distances from the centre. The columns
  contain the data as:-

\begin{tabular}{|c|c|l|}\hline
 Column &    Header           &Contents \\ \hline
  1 &    DISTANCE    & Distance from centre \\
  2 &    FIT         & Value of fitted Gaussian profile \\
  3 &    DATA        & Actual data values fitted to \\
  4 &    RESIDUALS    & Data - fit \\ \hline
\end{tabular}

}\sstsubsection{OUTSTARS = NDF (Write)}{
  (Default - null)

 The name of the new output file containing the table with the details
 of the present individual fits to the stars.

 This table can be re-input (via INSTARS) into PROFILE to carry on the
 analysis when starting again.


}\sstsubsection{POSN = {\undersc}REAL(2) (Read)}{
  (Default - present position.     \hspace*{6ex}   Range - -1.0e10 to 1.0e10)

  Position in image to fix star at.

}\sstsubsection{POSTYPE = LITERAL (Read)}{
 (Default - see below     \hspace*{6ex}    Choice - `spot:cross')

  Mark the positions of the stars with spots (`spot') or crosses
  (`cross'). The default is the opposite to what is being used at
  the moment. At the start of the program the 'cross' option is
  set.

  If the `cross' option is chosen, then the length of the crosses
  in pixels is asked for, via the `CWIDTH' parameter.

}\sstsubsection{POWER = {\undersc}REAL (Read)}{
 (Default - Present value       \hspace*{6ex}  Range - 0.1 to 100.0)

 Set the value of the `Wing power' parameter in the modified
 Gaussian profile.

 It is usual to have it fixed, as this prevents low values of it being
 found which give unrealistically high values of the profile at great
 distances (which are not shown in the display of the fitting.)

}\sstsubsection{RADIUS = {\undersc}REAL (Read)}{
  (Default - `Present Value'   \hspace*{6ex} Range - 1.0e-20 to 1.0e20.0)

  The Radius, QR, in the modified Gaussian wing part of the profile.

 For more details on the profile, see the section on it above.

}\sstsubsection{REJECT = {\undersc}INTEGER (Read)}{
 (Default - 0   \hspace*{6ex}  Choice - -n to +n, n
  being the number of stars in list)

 The number of the star to be rejected (+n), or to be accepted in spite
 of having been rejected (-n). If any star has been rejected or accepted,
 the mean fit is recalculated and another chance given for the fit.

 If there are no more changes to be made, type 0.

}\sstsubsection{ROPTION = LITERAL (Read)}{
 (Default - last option    \hspace*{6ex}    Choice - see below)

 Which of the following options, to do with
 looking at the residuals map closely and modifying it, do you want to do?

 [The list of options is given above in the `options' section.]

 When defining the polygons, you use the cursor and the buttons. Place
 the cursor at consecutive vertices of the desired polygon, and press
 any button. To end the input of vertices, do a repeat press, without
 moving the cursor, on the last vertex. A line showing where the
 polygon lies is output whilst you are doing this

}\sstsubsection{SCALE = {\undersc}REAL (Read)}{
  (Default - last   \hspace*{6ex}    Range - 1.0e-8 to 1.0e8)

  Value to scale the standard empirical profile map by. (Not the
  factor to multiply the last scaled map, but the absolute scale, i.e.
  `scale=10, and then `scale=2' has the same effect as scale=2).

  This is not really useful.

}\sstsubsection{SCREEN = {\undersc}INTEGER(2) (Read)}{
  (Default - 1, size of image      \hspace{6ex} Range - 1 to large)

  Size of screen or window to open.

  The default size is that of the image, unless the image is too large
  to fit on the screen, when the image will be binned down by an integer
  factor for display. The default size will then be this binned down size.

}\sstsubsection{SHIFTXY = {\undersc}REAL(2) (Read)}{
  (Default - 0.0,0.0        \hspace*{6ex}   Ranges - -1.0e20 to 1.0e20)

  Input as two real numbers as (say)  1.5,20.2

  The shift in X and Y on the input image to be applied to all the
  star positions, with their companions, but not to the bad areas.

  This is useful when you are doing an image, and you have an input
  list of star positions, which is displaced for this image.

}\sstsubsection{SIZE = {\undersc}INTEGER(2) (Read)}{
  (Default - present values.   \hspace*{6ex}     Range - 1 to 200)

  Input two numbers as (say) 10,12.

  Input the X and Y size of the area of either of:-

\begin{list}{{-}}{}
\item The fitting box (the area that the fits are done in, and
      which is displayed on the image display).
\item The profile map. This does not have to be the same size
      as the fitting area. The size is the number of pixels of
      the image that the profile map covers. This can be
      different than the computer storage size and the size
      of the profile file image, since the profile map may
      map to sub-divided image pixels, and thus contain more
      data points.
\end{list}

}\sstsubsection{SMSIZE = {\undersc}INTEGER(2) (Read)}{
 (Default - 3   \hspace*{6ex}  Choices - all +ve odd integers 3 to 32767)

  Input two number as (say)  `5,5'.

 These are the sizes of the sides of the box to be used in the
 smoothing of the residuals or profile maps.

 The smoothing is done by replacing each pixel with the average
 value of the pixels in the box surrounding that pixel. ('Top hat'
 smoothing.) This is why the sides must have an odd number of
 pixels.

 If the sides of the box are larger than the map to be smoothed
 or if the area of the box is more than 32767 pixels, the
 input wont work, and you are asked again.

}\sstsubsection{TITLE = LITERAL (Read)}{
   (Default - various   \hspace*{6ex}    Choice -any)

  Title to add as a descriptor to the output file.

  The output file in question is the one you are opening and
  writing to. It can be:-

 \hspace*{3ex} - \hspace*{2ex} the profile image file \newline
 \hspace*{3ex} - \hspace*{2ex} the stars table file \newline
 \hspace*{3ex} - \hspace*{2ex} the companions/bad areas table file \newline
 \hspace*{3ex} - \hspace*{2ex} the Gaussian wing profile table file

}\sstsubsection{USE = LITERAL (Read)}{
 (Default - `inter'  \hspace*{6ex}   Choice - `auto:inter')

  Do the fitting interactively with the user, or do an automatic
  fit, where a profile is derived without much sophistication?

}\sstsubsection{USEMAP = LITERAL (Read)}{
 (Default - present state    \hspace*{6ex}    Choice - `yes:no')

 A choice as to whether to use whatever Profile Map exists in the
 fitting or residuals display. Generally any action that zeroes the
 Profile Map, sets this option to no, and any that loads a non-zero
 one sets it to yes.

}\sstsubsection{VALUE = {\undersc}REAL (Read)}{
  (Default - present value  \hspace*{6ex} Range  -1.0e20 to 1.0e20)

  After the OPTION:PROFCHANGE choice, you are then asked for the values
  of the 9 parameters of the entire profile. The 6 of the Lorentx profile
  (Rmaj, Rmin, Power, PRmaj, PRmin, Angle) and the 3 of the Gaussian
  wing (Fractional height, Radius, Power). The angle should be input
  in degrees.

  At the program start, the values are:-

     (2.0, 2.0, 2.2, 10.0, 10.0, 0.0; 0.0, 10.0, 2.0).

  (These can be changed as a result of doing the OPTION:ROUGH choice.)

  Depending on which of the parameters you have/have not fixed (at the
  start none are fixed), these cannot/can vary during a fit.

}\sstsubsection{VOLRAD = {\undersc}REAL (Read)}{
  (Default - present value  \hspace*{6ex}   Range - 1.0 to 1.0e6)

  If calculating profile volume, how many pixels out to carry calculations.

  This is a rather minor parameter. The program will normally start with
  a value of 30 pixels. This may be changed when a `profile' image file is
  read in, as that file contains its own 'volrad' parameter.

}\sstsubsection{WDAMP = {\undersc}REAL (Read)}{
  (Default - present value      \hspace*{6ex}   Range - 0.0 to 100.0 )

  The damping factor in the fitting least squares method, whilst
  doing the 1-D Gaussian wing profile fitting.

  This controls the spize of the adjustments in the fitting. The
  smaller the number, the less the internal damping, and so the
  bigger the steps, the faster the fitting, and also the risk of
  shooting out of the best `least squares' path and so mis-fitting.
  In general, values are such that:-

        0.0 = no damping, 0.5 = normal, 1.0 = a lot of damping.


}\sstsubsection{WFITLIM = {\undersc}REAL (Read)}{
  (Default - present value     \hspace*{6ex}   Range - 0.0 to 100.0)

  The `limit' in the profile parameter changes when the fit is thought to
  have settled, while doing the 1-D Gaussian wing profile fitting.

  It is the fractional change, at an iteration step in the least squares
  fit, in each of the profile parameter values that are changing. Their
  changes must be less than this before the least squares iterations
  stop. Normal value = 0.001.

  See the 'Whtlim' parameter for the limit on the fractional change
  in the star height.

}\sstsubsection{WFITOK = LITERAL (Read)}{
 (Default - `no'     \hspace*{6ex}    Choice - `yes:no')

  Have the good stars been fitted with a fixed profile to the present
  data with the present companions and blank areas? By the present
  data is meant the data in the normal 'small' boxes, not that in the
  'large', 'wing' boxes round each star.

  If not, a fit will be done to the 'small' boxes.

}\sstsubsection{WHTLIM = {\undersc}REAL (Read)}{
  (Default - present value     \hspace*{6ex}   Range - 0.0 to 100.0)

  The `limit' in the height parameter changes when the fit is thought to
  have settled, while doing the 1-D Gaussian wing profile fitting.

  It is the fractional change, at an iteration step in the least squares
  fit, in the star fractional height parameter value that is changing.
  Its changes must be less than this before the least squares iterations
  stop. Normal value = 0.001.

  See the 'Wfitlim' parameter for the limit on the fractional change
  in the profile values.

}\sstsubsection{WOPTION = LITERAL (Read)}{
  (Default - last choice     \hspace*{6ex}  Choices - see below)

  These are the options to determine the wide Gaussian wing part of the
  profile.

 [A full discussion of the options is given in the `options' section above.]

}\sstsubsection{XAREA = {\undersc}INTEGER(2) (Read)}{
 (Default - 1,X size.     \hspace*{6ex} Range - 1 to X size, 1 to X size)

 The X region of the profile or residuals map you want to type out.


}\sstsubsection{YAREA = {\undersc}INTEGER(2) (Read)}{
 (Default - 1,Y size.   \hspace*{6ex}   Range -  1 to Y size, 1 to Y size)

 The Y region of the profile or residuals map you want to type out.

}}}



\addcontentsline{toc}{subsection}{ Simplemag}


\ajhsect{\arabic{section}}{General Programs - \hspace*{0.2in} SIMPLEMAG}

\sstroutine{SIMPLEMAG}{Simple Aperture or Profile Photometry }{

\sstdescription{
  This program does three kinds of simple photometry. They are:-

  \begin{list}{{-}}{}
   \item Aperture photometry on isolated stars.

   \item Gaussian profile photometry on isolated stars.

   \item Determination of mean Gaussian radii from isolated
     stars.

   \end{list}

 The three kinds are executed by entirely different sections of
 the program. These sections can be thought of as separate
 programs, one of which is chosen after entering SIMPLEMAG.

 In all cases, an image and a list of star positions is input and
 the work done using those inputs.

}\sstdiytopic{Aperture Photometry}{

 Does aperture photometry on stars in an image.

 For each star in the input table of positions, the program does:-

\begin{enumerate}

 \item Optionally, refine position before use by centering on the star
    that near the table position.

 \item Place an aperture of specified size at the position.

 \item Calculate flux in an aperture at the position.

 \item Calculate mean `sky' level with a circular annulus around the
    position, with specified inner and outer radii,

 \item Subtract sky level from the flux in the aperture.

 \item Calculate star magnitude as:-

       $$   Mag = 30 -
       2.5*log_{10}(star-(sky{\hspace*{0.2em}}level)*area) $$

      where area = star aperture area


 \item Store result in output table.

 \item Optionally, type out result to user.

\end{enumerate}

 The error in the star magnitude and sky level are also calculated
 from the pixel values. The pixels are presumed to be Poisson noised,
 with a scale level put in by the user. This is a number such that
 if the pixel values are multiplied by this number, then the pixels
 would have proper Poisson noise. There is also a user input value
 for an extra noise level that is added to each pixel. This noise can
 be thought of as the noise that would be there if the pixel values
 had a mean level of zero.

}\sstdiytopic{Aperture Output}{

 The file output by this program uses the `OUT' parameter, and
 is a table of results. The contents of the table are the parameters
 measured for each star:-

 \begin{tabular}{|l|l|p{3in}|}\hline
  Column Number   & Header       & Contents \\ \hline
    1  &    X          &  X position used (optionally centered) \\
    2  &    Y          &  Y position used (optionally centered) \\
    3  &    Magnitude  &  Magnitude \\
    4  &    Error      &  Error (std dev) in magnitude \\
    5  &    Peak       &  Maximum pixel value in star aperture \\
    6  &    Dx         &  X distance from input to measured position \\
    7  &    Dy         &  Y distance from input to measured position \\
    8  &    Flux       &  Sum of pixel values in star aperture \\
    9  &    Number     &  Number of valid pixels in star aperture \\
   10  &    Invalid    &  Number of invalid pixels in star aperture \\
   11  &    Sky        &  Sky level (mean) \\
   12  &    Sky Error  &  Error (std dev) in sky level \\
   13  &    Sky Number &  Number of valid pixels in sky annulus \\
   14  &    Sky Invalid & Number of invalid pixels in sky annulus \\ \hline
   \end{tabular}

  The magnitudes are calculated as:-

      $$   Mag = 30 -
           2.5*log_{10}(star-(sky{\hspace*{0.2em}}level)*area) $$

      \hspace*{\fill}  where area = star aperture area

 If the star flux is negative, the magnitude is set to 50. It is
 also set at that level if there are no good pixels in the star aperture
 and/or none in the sky annulus.

}\sstdiytopic{Gaussian Photometry}{

  Does photometry on isolated stars in an image, fitting a 2-D
  Gaussian to stars whose positions are given in an input list.

  It estimates the flux of stars in an image, by taking a small area
  around the star position and fitting a background and a 2-D Gaussian
  profile to the data in that area. The star positions are taken from
  an input table, and the results are (optionally) typed out and
  stored in an output table.

  The Gaussian profile is an ellipse, orthogonal to the X and Y
  axes.

  This program takes no account of sub-pixel variations. Thus a
  profile whose value changes significantly inside a pixel will
  be assumed to have the mean value as the value at the centre of
  that pixel. For narrow profiles, this will introduce errors.

}\sstdiytopic{Gaussian Method}{
   The star profile is of the form:-



  $$ I = exp^{-1.0.d^2} $$

  Where d = sqrt((X/RX)**2+(Y/RY)**2)


  Beware that, as stars are not exactly Gaussian, the fitted profile
  will vary with box size.

  This program takes no account of sub-pixel variations. Thus a
  profile whose value changes significantly inside a pixel will
  be assumed to have the mean value as the value at the centre of
  that pixel. For narrow profiles, this will introduce errors.

  Star profiles are not strictly Gaussian, so for stars with whose
  profiles differ, there will be a small, systematic, error in their
  relative magnitudes. That is the magnitude is not a `correct'
  estimate from the `volume' of a star. However for stars with the
  same profile, for example in many cases, stars in one image, this
  error has the same fractional size, and so the relative magnitudes
  are correct.

  For very faint stars, letting the profile radii vary can cause
  significant errors.

}\sstdiytopic{Gaussian Output}{

 The file output by this program uses the `OUT' parameter, and
 is a table of results. The contents of the table are the parameters
 measured for each star:-


 \begin{tabular}{|l|l|p{3in}|}\hline
  Column Number & Header & Contents \\ \hline
    1 & X         & X position \\
    2 & Y         & Y position \\
    3 & Magnitude & Magnitude \\
    4 & Dx        & X distance from input to measured position \\
    5 & Dy        & Y distance from input to measured position \\
    6 & Iterations & Number of iterations taken in the fitting
                     (the maximum allowed is 20) \\
    7 & Rms       & The RMS of the residuals between the fit and the
                    data, in an area around the star centre \\
    8 & Numinval  & Number of `invalid' pixels in the area used
                    in the fit\\
    9 & Height    & The height of the Gaussian fitted \\
   10 & Base      & The `sky' level on which the star sits \\
   11 & Rx        & The fitted X radius of the elliptical profile \\
   12 & Ry        & The fitted Y radius of the elliptical profile \\
                    \hline
 \end{tabular}

  The magnitudes are calculated as:-

     $$   Mag = 30.0 - 2.5.log_{10}(pi.height.rx.ry) $$

  where (pi.height.rx.ry) is the `volume' of a Gaussian.



}\sstdiytopic{Gaussian Radius}{

  Estimates the mean Gaussian Radii of stars in a table of
  star positionss in an uncrowded image.

  It makes three estimates, by using three methods:-

\begin{list}{{-}}{}
\item Fit each star individually and average the measured radii

\item (Optional) Take the pixels round each star and add them together to
      make one star, and then measure its radii. The adding is
      done assuming that each star centre is at the b.l.h. corner of the
      pixel in which it actually falls.

\item (Optional) Take the pixels round each star and add them together to
      make one star and then measure its radii. The adding is
      done by taking the star centres to be at their calculated
      positions and using an interpolation method to put the best
      pixel values into the summed star.
\end{list}

  This program takes no account of sub-pixel variations. Thus a
  profile whose value changes significantly inside a pixel will
  be assumed to have the mean value as the value at the centre of
  that pixel. For narrow profiles, this will introduce errors.

  The profile is an ellipse, orthogonal to the X and Y axes.

}\sstdiytopic{Radius Method}{
   The position, radii, and height of each of the stars in the table
   are found by taking a small box round each star in the image, and
   fitting a single 2-D Gaussian (with different X and Y radii), but
   no rotation. No allowance is made for the fact that there may be
   contamination by nearby stars. The results may be typed out.

   Bad stars are then rejected, on the basis of `invalid' pixels
   in the fitting boxes, radii too large or small, heights too small.

   The mean of the fits is then calculated and typed out.

   The program then makes a `grand' star by taking the data around
   each individual good star centre and adding each pixel value into
   a total array at its appropriate position. The radii of this mean
   star are then calculated, typed, and stored as parameters of the
   program.

   An even better radii is then calculated by doing the summing in a
   better way, in which the program allows for the fact that the
   stars are not centred at integral pixel values by interpolating
   between pixels before adding into the mean array. The radii of
   this mean star are then calculated, typed, and stored as parameters
   of the program.

   The star profile is of the form:-


  $$ I = exp^{-1.0.d^2} $$

  Where d = sqrt((X/RX)**2+(Y/RY)**2)


    Beware that, as stars are not exactly Gaussian, the fitted profile
    will vary with box size.

  This program takes no account of sub-pixel variations.

}\sstdiytopic{Radius Output}{
 The files output by this program are:-

\begin{tabular}{|l|p{4.5in}|}\hline
   Parameter    &     Content \\ \hline
    OUT1IM     &    An image with the residuals after a fit has been to
                   done to the array made by summing up all the areas
                   round each star in the input table. \\

    OUT2IM      &   An image with the residuals after a fit has been to
                   done to the array made by summing up all the areas
                   round each star in the input table, with the
                   summing done using pixel interpolation when adding
                   the data from an individual star into the array. \\

    OUT1TB      &  A table with the radial plot of the fit and the data
                   after a fit has been to done to the array made by
                   summing up all the areas round each star in the
                   input table. The table contains three columns, the
                   first the distance from the centre of the fitted
                   star, the second the summed data values, and the
                   third the value of the fit at that point. \\

    OUT2TB      &  A table with the radial plot of the fit and the data
                   after a fit has been to done to the array made by
                   summing up all the areas round each star in the
                   input table, with the summing done using pixel
                   interpolation when adding the data from an
                   individual star into the array. The table contains
                   three columns, the first the distance from the
                   centre of the fitted star, the second the summed
                   data values, and the third the value of the fit at
                   that point. \\ \hline
\end{tabular}


}\sstparameters{

\sstsubsection{ \large \bf General:- }{

  The following parameters are used in more than one of the
  three types of photometry done in this program.

}\sstsubsection{BOX = {\undersc}REAL(2) (Read)}{
  (Default - 20,20       \hspace*{6ex}     Range - 2 to 200)

  The X and Y size of the box round each star to take when
  making the individual fits.

}\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The input image.

  This can be either a `short' 16-bit integer of a `real' 32-bit
  real \starman NDF image.

}\sstsubsection{INSTARS = NDF (Read)}{
  (Default - null)

  The input list of star positions.

  This must be a \starman table format file.

}\sstsubsection{OPTION = LITERAL (Read)}{
  (Default - `aperture'   \hspace*{6ex} Choice - `aperture:gaussian:radius' )

  Which of the three types of fit do you want to do?

 \begin{tabular}{|l|l|}\hline
  Choice     & Function \\ \hline
  Aperture   & Aperture Photometry \\
  Gaussian   & Gaussian profile fitting photometry \\
  Radius     & Determine mean Gaussian radii \\ \hline
 \end{tabular}


}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

  The output table of results.

  This can be either from the aperture measuring or from the
  profile measuring. For the contents of the table, see the
  sections on the functions.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - title of input table     \hspace*{6ex}  Choice - any)

  The title to add into the output table.

}\sstsubsection{TYPING = LITERAL (Read)}{
  (Default - `yes'   \hspace*{6ex}    Choice - `yes:no' )

  Do you want to have typed out the individual fits to each star?

}\sstsubsection{\large \bf Aperture Measure:- }{

  The following parameters are for the Aperture Photometry.

}\sstsubsection{APDIA = {\undersc}REAL (Read)}{
  (Default - 20.0       \hspace*{6ex}     Range - 0.1 to 200.0)

  The diameter of the star aperture.

}\sstsubsection{CENTRE = LITERAL (Read)}{
  (Default - `no'     \hspace*{6ex}      Choice - `yes:no')

  Do you want the input positions corrected before the measuring is
  done?

  If so, then the program will fit a Gaussian to the data near the
  input position, and take the fit centre as the new position.

}\sstsubsection{NOISE = {\undersc}REAL (Read)}{
  (Default - 0.0      \hspace*{6ex}     Range - 0.0 to 1.0e10)

  In calculating the errors, is there a hidden source of noise, and
  if so what is its level?

  If an image had a mean level of zero, what would be the std dev of the
  pixel values? There might be such a source of noise from say the
  removal, before the use of this program, of a mean level.

  A knowledge of such a hidden noise is necessary for the correct
  estimate of the error in the calculated magnitudes.

}\sstsubsection{POISV = {\undersc}REAL (Read)}{
  (Default - 1.0    \hspace*{6ex}        Range - 1.0e-10 to 1.0e10)

  In calculating the errors, it is necessary to know if the pixel
  values have a Poisson noise. Sometimes, the pixel values are
  scaled values

}\sstsubsection{SKYDIAS = {\undersc}REAL(2) (Read)}{
  (Default - 30.0,40.0         \hspace*{6ex}     Range - 0.1 to 200.0)

  The inner and outer diameters of the sky annulus.


}\sstsubsection{\large \bf Gaussian Photometry:- }{

  The following parameters are for the Gaussian Profile Photometry.

}\sstsubsection{PARFIX = (Read)}{
  (Default - `no'        \hspace*{6ex}      Choice - `yes:no')

  Are fixed radii to be used in the fitting?

  Either the program can determine the best values of the
  profile radii for each star, or it can keep those radii
  fixed throughout the program with user-determined values.

  If they are allowed to vary, then the starting values, of the
  iterative process in the fitting, are taken as 2.0,2.0.

}\sstsubsection{RADII = {\undersc}REAL(2) (Read)}{
  (Default - 3.0,3.0    \hspace*{6ex}     Range - 0.1 to 200.0)

  X and Y radii of the star profile to be used in fitting the
  stars. If the profile is fixed, then these are used. If it is
  allowed to vary, then these are used as the starting points
  of the iterative fitting.

}\sstsubsection{\large \bf Gaussian Radius:-}{

  The following parameters are for the Determination of the
  Mean Gaussian profile.

}\sstsubsection{DOINT = LITERAL (Read)}{
  (Default - `yes'     \hspace*{6ex}      Choice - `yes:no' )

  Do you want the make the grand star, amde  by summing the data round
  the individual stars (using interpolation), for fiting?

}\sstsubsection{DOSUM = LITERAL (Read)}{
  (Default - `yes'     \hspace*{6ex}      Choice - `yes:no' )

  Do you want the make the grand star, amde  by summing the data round
  the individual stars, for fiting?


}\sstsubsection{OUT1IM = NDF (Write)}{
  (Default - null)

  The name of the image to contain the summed star.

  The image is the residuals after a fit has been to done to the
  array made by summing up all the areas round each star in the
  input table.

  If a null repsonse is made, this image is not made.

  This is a `short' 16-bit integer \starman NDF image.

}\sstsubsection{OUT2IM = NDF (Write)}{
  (Default - null)

  The name of the image to contain the summed star, with the
  summing done using interpolation.

  The image is the residuals after a fit has been to done to the
  array made by summing up all the areas round each star in the
  input table, with the summing done using pixel interpolation
  when adding the data from an individual star into the array.

  If a null repsonse is made, this image is not made.

  This is a `short' 16-bit integer \starman NDF image.

}\sstsubsection{OUT1TB = NDF (Write)}{
  (Default - null)

  The name of the table to contain radial profile fitted and a
  radial plot of the data of the data for the summed star. The fit
  and the data are folded around the centre of the fit.

  No account is made of sub-pixel variations.

  The table contains three columns, the first the distance from
  the centre of the fitted star, the second the summed data values,
  and the third the value of the fit at that point.

  This is a table with the radial plot of the fit and the data
  after a fit has been to done to the array made by summing up all
  the areas round each star in the input table.

  If a null repsonse is made, this table is not made.

 This is a `real' 32-bit real \starman table format NDF file.

}\sstsubsection{OUT2TB = NDF (Write)}{
  (Default - null)

  The name of the table to contain radial profile fitted and a
  radial plot of the data of the data for the summed star, using
  interpolation. The fit and the data are folded around the centre of
  the fit.

  No account is made of sub-pixel variations.

  The table contains three columns, the first the distance from
  the centre of the fitted star, the second the summed data values,
  and the third the value of the fit at that point.

  This is a table with the radial plot of the fit and the data
  after a fit has been to done to the array made by summing up all
  the areas round each star in the input table, with the summing
  done using pixel interpolation when adding the data from an
  individual star into the array.

  If a null repsonse is made, this table is not made.

 This is a `real' 32-bit real \starman table format NDF file.

}\sstsubsection{RADLIMS = {\undersc}REAL(2) (Read)}{
  (Default - 0.5*fitted radius,1.5*fitted radius or 1.0,10.0 \hspace*{6ex}
   Range - 0.1 to 100.0)

  The lower and upper limits to the range of acceptable radius
  (average of the X and Y radii) for a star.

  If an individual star has a fitted radius outside these limits,
  it will not be used in making the mean radius, nor will the box
  round it be used in making the grand summed star which is later
  fitted.

}\sstsubsection{RX1 = {\undersc}REAL (Write)}{
  (Output parameter)

  The mean X radius, calculated from the mean of the individual
  radii.

}\sstsubsection{RX2 = {\undersc}REAL (Write)}{
  (Output parameter)

  The mean X radius, calculated from fitting to the summed data of
  the boxes round the indivual stars.

}\sstsubsection{RX3 = {\undersc}REAL (Write)}{
  (Output parameter)

  The mean X radius, calculated from fitting to the summed data of
  the boxes round the indivual stars, with the summing done using
  interpolation.

}\sstsubsection{RY1 = {\undersc}REAL (Write)}{
  (Output parameter)

  The mean Y radius, calculated from the mean of the individual
  radii.

}\sstsubsection{RY2 = {\undersc}REAL (Write)}{
  (Output parameter)

  The mean Y radius, calculated from fitting to the summed data of
  the boxes round the indivual stars.

}\sstsubsection{RY3 = {\undersc}REAL (Write)}{
  (Output parameter)

  The mean Y radius, calculated from fitting to the summed data of
  the boxes round the indivual stars, with the summing done using
  interpolation.

}\sstsubsection{SUMBOX = {\undersc}REAL(2) (Read)}{
  (Default - 6*X radius, 6*Y radius  \hspace*{6ex}   Range - 2 to 200)

  The X and Y size of the box round each star to take when
  making summing up the data to make a grand star.
}}}



\addcontentsline{toc}{subsection}{ Sprinkle}


\ajhsect{\arabic{section}}{General Programs - \hspace*{0.2in} SPRINKLE}

\sstroutine{SPRINKLE}{Make a Table of Random Stars}{

\sstdescription{
  Makes a table of stars with random positions, magnitudes, colours and
  heights. This table represents the stars in a star field. It can be
  used with ADDSTARS to make an image of a `random' star field, either
  as a uniform distribution, or as a cluster. The colours and magnitudes
  can be set in a number of diverse ways.

  It thus outputs two types of stars, cluster stars and field stars.

  The cluster stars are distributed in position to mimic a cluster with
  a King profile and in magnitude and colour to follow either an
  input colour-magnitude diagram (specified by an input file designed to
  model a cluster CMD) or one of randomly scattered magnitudes.

  The field stars have a random x,y distribution and a cmd of again
  either an input CMD (designed in a different way to model a field
  star distribution) or a random scatter in colour and magnitude.

  The range in position, colour and magnitude allowed can be specified.

}\sstdiytopic{Use}{

 \begin{enumerate}
\item Make a table of the cluster CMD and field star CMD. (See the help
      on 'Cluster' and 'Field' on how to do this.) Or you can (for
      either) decide to have a CMD with random magnitudes and colours
      evenly scattered over a chosen mag and colour range.

\item Decide:- \newline \begin{list}{{-}}{}
      \item What reddening and distance modulus you want them both to have.
      \item Where in the field you want the cluster centre to be.
      \item How large the field is (for both field and cluster stars).
      \item What region of the CMD you want filled (for field/cluster stars).
      \item On the cluster King core and tidal radii.
      \item On the number of cluster and field stars to make.
      \item On the random seed numbers.
      \end{list}

\item Run the program.

\item The output is a table of star positions, heights, magnitudes,
      and colours.
\end{enumerate}

}\sstdiytopic{Method}{

}\sstdiytopic{Cluster stars}{

  {\bf The selection of a random magnitude and colour}

  The colour-magnitude diagram is input as lines in the CMD. Each line
  is specified by [a start mag,col; an end mag,col; the number of stars
  in that line]. The program then sums the total number of stars in all
  the lines. To choose a random (mag,col), it selects a random number in
  the range 0.0 to 1.0, and finds in which line segment the ratio of
  (sum of stars in lines so far)/(total no of stars) is first greater
  than the number chosen. Thus the lines are selected in proportion to
  the number of stars in them. Then a (mag,col) is chosen from a uniform
  random distribution along the chosen line.

  Thus the line segments do not have to be contiguous in the CMD, but
  no smoothing in the number distribution from one line to the next is
  made (which if they are not touching would be incorrect). Thus to
  insure no falsely rapid changes in the number distribution are made,
  the line segments must be short enough that in each one, a uniform
  number distribution is suitable.

  After this the input distance modulus and reddening are applied (after
  the table (m-M) and Eb-v (say) have been removed).

  Then the input limits on magnitude and colour are checked. If the
  chosen mag,col lies within the limits, they are accepted; if not,
  then the process is repeated.

  {\bf Alternative}

  No table is input, and the mag,cols are uniformly distributed within
  the mag,col limits.


  {\bf The selection of a random X,Y Position}

  The King core and tidal radii are used to make a random selection
  of distance from the cluster centre, which results in the King
  radial distribution. These are then uniformily distributed in
  position angle around the cluster. They are accepted if they fall
  within the input position limits.

  The core and tidal radii have thus to be input as 'pixel' values.

  The King distribution is that defined by Ivan King in:- AJ 67,471;
  AJ 70,376; AJ 71,64

}\sstdiytopic{Field stars}{

  {\bf The selection of a random magnitude and colour}

  The colour-magnitude diagram is input as numbers of stars in uniform
  areas in a grid in the CMD.

  The table specifying the CMD gives the location of the top left hand
  area and the area size. The table then contains the number of stars
  in each area. The program then sums the total number of stars in all
  the areas. To choose a random (mag,col), it selects a random number in
  the range 0.0 to 1.0, and finds in which area the ratio of
  (sum of stars in areas so far)/(total no of stars) is first greater
  than the number chosen. Thus the areas are selected in proportion to
  the number of stars in them. Then a (mag,col) is chosen from a uniform
  random distribution within the chosen area.

  Thus no smoothing in the number distribution from one area to the
  next is made. So to insure no falsely rapid changes in the number
  distribution are made, the areas must be small enough that in each
  one, a uniform number distribution is suitable.

  After this the input distance modulus and reddening are applied (after
  the table (m-M) and Eb-v (say) have been removed).

  Then the input limits on magnitude and colour are checked. If the
  chosen mag,col lies within the limits, they are accepted; if not,
  then the process is repeated.

  {\bf Alternative}

  No table is input, and the mag,cols are uniformly distributed within
  the mag,col limits.


  {\bf The selection of a random X,Y Position}

  A uniform random distribution within the input limits is made.


}\sstdiytopic{Input CMDs}{

 The star positions are selected from random field or cluster
 positions. The magnitudes and colours of the stars can be
 selected from a uniform distribution, or from a `CMD'.


}\sstdiytopic{Cluster CMD}{

  Input table giving cluster CMD. It contains rows describing line
  segements of the cluster.

\begin{list}{{-}}{}
\item Each row of the table contains a description of a line segment of
      the cluster CMD. It has, in order,:-

      Mag start, Col start, Mag end, Col end, Number of stars


\item See the section on 'Method' as to how this is used.


\item The table also has, as descriptors, the reddening and distance modulus
      of the CMD. Thus when the user inputs the desired reddening and
      distance modulus, the table descriptor values are first subtracted.

      Thus, for example, if the user puts in the same reddening and distance
      modulus as the value in the cluster file, the values in the cluster
      table for the stars are used unaltered.

      The table descriptors are:-

\begin{tabular}{|c|l|}\hline
      Name   &  Content \\ \hline
      RED    &  The reddening \\
      DISMOD &  The distance modulus \\ \hline
\end{tabular}

\item The table can be made at the keyboard by the program `tbkey'.
      and the decriptors added with the program `tbdes'.
\end{list}

}\sstdiytopic{Field CMD}{


  The input table giving the field star CMD. It contains rows which
  have the number of stars in areas in a CMD.

\begin{enumerate}

\item The CMD (magnitude increasing down, colour increasing to right) may
      be thought of being divided up into a rectangular grid of areas of
      equal size. The CMD is then described by the number of stars in each
      area. Each row of the input table then contains the numbers of stars
      in the areas in one horizontal row of the grid, and the rows in toto
      make up the whole CMD. The number of columns in a row gives the
      horizontal number of areas in the grid and the number of rows gives
      the vertical number. The size of each area is described in the table
      descriptors, and the location of the grid in the CMD is also described
      there.

\item See the section on 'Method' for further description.

\item The table also has, as descriptors, the reddening and distance moculus
      of the CMD. Thus when the user inputs the desired reddening and
      distance modulus, the table ones are first subtracted.

      Thus, for example, if the user puts in the same reddening and distance
      modulus as the value in the field file, the values in the field
      table for the stars are used unaltered.

      The table has descriptors:-

\begin{tabular}{|c|p{4.0in}|}\hline
      Name   &  Content \\ \hline
      RED    &  The reddening \\
      DISMOD &  The distance modulus \\
      MSTART &  The magnitude of tlh corner of the tlh area in the CMD grid \\
      MSTEP  &  The vertical (magnitude) size of the areas \\
      CSTART &  The colour of tlh corner of the tlh area in the CMD grid \\
      CSTEP  &  The horizontal (colour) size of the areas \\ \hline
\end{tabular}

      MSTEP and CSTEP must be positive

\item The table can be made at the keyboard by the program TBKEY, and the
      decriptors added with the program TBWRDES.

\end{enumerate}


}\sstdiytopic{Random seeds}{

  The choosing of the random values is done with the a simple
  algorithm, which starts from an input seed and creates a pseudo-random
  number form 0 to 1 from that and updates the seed.

  This seed number is fed in by the user.

  So if you feed in the same seed, you will get the same distribution
  of star mag,col and positions. A different seed will give a different
  pattern. These seeds have to be large (over a billion) to ensure
  good randomising. There are separate seeds for the cluster and field
  stars, so one pattern can be repeated, whilst holding the other
  constant.

}\sstdiytopic{Output}{

   The table contains seven columns. For each star, the entry is:-

\begin{tabular}{|c|c|p{4in}|}\hline
    Column  & Header    & Content \\ \hline
     1  &    X       &  X posn \\
     2  &    Y       &  Y posn \\
     3  &    HEIGHT1 &  height of star in the 1st colour band (e.g. 'V') \\
     4  &    HEIGHT2 &  height of star in the 2nd colour band (e.g. 'B') \\
     5  &    MAG1    &  1st colour band magnitude (e.g. 'V') \\
     6   &   COL     &  colour (e.g. 'B-V') \\
     7   &   MAG2    &  2nd colour band magnitude (e.g. 'B') \\ \hline
\end{tabular}

     Thus from the input table(s) of (say) 'V' and 'B-V', an output
     table of X, Y, V height, B height, V, B-V, and B is made.

     The stars are named as \#1, \#2, \#3, etc.

 It is also possible, through the LOG parameter, to get a typing out as
 the program goes.

}\sstdiytopic{Hidden Parameters}{
  The parameter LOG is `hidden', that is only
  accessible by putting `SPRINKLE LOG=yes' on the command line or a
  previous LET command.


}\sstparameters{

\sstsubsection{CCRANGE = {\undersc}REAL(2) (Read)}{
  (If there is a cluster file:- \newline
     Default - bluest to reddest colour in cluster file \hspace*{6ex}
     Range - bluest to reddest colour in cluster file \newline
   If the cluster is to have a uniform magnitude distribution:- \newline
     Default - -20, 20 \hspace*{6ex}
     Range - -20 to +20)

  Colour range that cluster stars can have.

}\sstsubsection{CDISMOD = {\undersc}REAL (Read)}{
  (Default - Value in cluster file, if any, or 0.0 \hspace*{6ex}
   Range - -1.0e8 to 1.0e8)

  Cluster distance modulus. If there has been the input of a cluster file
  with its own distance modulus, that distance modulus is first subtracted.

}\sstsubsection{CEVEN = LITERAL (Read)}{
  (Default - `yes'  \hspace*{6ex}   Choice - `yes:no')

  Use a uniform cmd distribution instead of the cluster cmd for the
  cluster stars.

}\sstsubsection{CLUSTER = NDF (Read)}{
  (Default - null)

  Input table giving cluster CMD. It contains rows describing line
  segements of the cluster.

\begin{list}{{-}}{}
\item Each row of the table contains a description of a line segment of
      the cluster CMD. It has, in order,:-

      Mag start, Col start, Mag end, Col end, Number of stars


\item See the section on 'Method' as to how this is used.


\item The table also has, as descriptors, the reddening and distance modulus
      of the CMD. Thus when the user inputs the desired reddening and
      distance modulus, the table descriptor values are first subtracted.

      Thus, for example, if the user puts in the same reddening and distance
      modulus as the value in the cluster file, the values in the cluster
      table for the stars are used unaltered.

      The table descriptors are:-

\begin{tabular}{|c|l|}\hline
      Name   &  Content \\ \hline
      RED    &  The reddening \\
      DISMOD &  The distance modulus \\ \hline
\end{tabular}

\item The table can be made at the keyboard by the program `tbkey'.
      and the decriptors added with the program `tbdes'.
\end{list}

}\sstsubsection{CMRANGE = {\undersc}REAL(2) (Read)}{
  (If there is a cluster file:- \newline
     Default - brightest to faintest magnitude in cluster file \hspace*{6ex}
     Range -  brightest to faintest magnitude in cluster file \newline
   If the cluster is to have a uniform magnitude distribution:- \newline
     Default -  -50,50  \hspace*{6ex}  Range-  -50 to +50)

  Magnitude range that cluster stars can have.

}\sstsubsection{CNUMBER = {\undersc}INTEGER (Read)}{
  (Default - 1  \hspace*{6ex}  Range - 0 to 100000000)

  Number of cluster stars to make

}\sstsubsection{CREDDEN = {\undersc}REAL (Read)}{
  (Default - Value in cluster file, if any, or 0.0 \hspace*{6ex}
   Range -   -1.0e8 to 1.0e8)

  Cluster reddening. If there has been the input of a cluster file
  with its own reddening, that reddening is first subtracted.

}\sstsubsection{CSEED = {\undersc}INTEGER (Read)}{
  (Default - 1234567891  \hspace*{6ex}  Range - 1200000001 to 1400000001)

  Random number to seed making of random cluster stars. Should
  be an odd number

}\sstsubsection{CXRANGE = {\undersc}REAL(2) (Read)}{
  (Default - 1.0,100.0  \hspace*{6ex}  Range - -1.0e8 to 1.0e8)

  X start and end of acceptable area for cluster stars to lie in

}\sstsubsection{CXYPOSN = {\undersc}REAL(2) (Read)}{
  (Default - 50.0,50.0  \hspace*{6ex}  Range - -1.0e8 to 1.0e8)

  X,Y position of the cluster.

}\sstsubsection{CYRANGE = {\undersc}REAL(2) (Read)}{
  (Default - 1.0,100.0  \hspace*{6ex}  Range - -1.0e8 to 1.0e8)

  Y start and end of acceptable area for cluster stars to lie in

}\sstsubsection{DOCLUST = LITERAL (Read)}{
  (Default - `yes'  \hspace*{6ex}   Choice - `yes:no')

  Do the cluster stars?

}\sstsubsection{DOFIELD = LITERAL (Read)}{
  (Default - `yes'  \hspace*{6ex}   Choice - `yes:no')

  Do the field stars?

}\sstsubsection{FCRANGE = {\undersc}REAL (Read)}{
  (If there is a field file:- \newline
     Default - bluest to reddest colour in field file \hspace*{6ex}
     Range - bluest to reddest colour in field file \newline
   If the field is to have a uniform magnitude distribution:- \newline
     Default - -20,20 \hspace*{6ex}
     Range - -20 to +20)

  Range in colour that field stars can have.

}\sstsubsection{FDISMOD = {\undersc}REAL (Read)}{
  (Default - Value in field file, if any, or 0.0  \hspace*{6ex}
   Range -  -1.0e8 to 1.0e8)

  Field distance modulus. If there has been the input of a field file
  with its own distance modulus, that distance modulus is first subtracted.

}\sstsubsection{FEVEN = LITERAL (Read)}{
  (Default - `yes'  \hspace*{6ex}   Choice - `yes:no')

  Use a uniform cmd distribution instead of the field cmd for the
  field stars.

}\sstsubsection{FIELD = NDF (Read)}{
  (Default - null)

  The input table giving the field star CMD. It contains rows which
  have the number of stars in areas in a CMD.

\begin{enumerate}

\item The CMD (magnitude increasing down, colour increasing to right) may
      be thought of being divided up into a rectangular grid of areas of
      equal size. The CMD is then described by the number of stars in each
      area. Each row of the input table then contains the numbers of stars
      in the areas in one horizontal row of the grid, and the rows in toto
      make up the whole CMD. The number of columns in a row gives the
      horizontal number of areas in the grid and the number of rows gives
      the vertical number. The size of each area is described in the table
      descriptors, and the location of the grid in the CMD is also described
      there.

\item See the section on 'Method' for further description.

\item The table also has, as descriptors, the reddening and distance moculus
      of the CMD. Thus when the user inputs the desired reddening and
      distance modulus, the table ones are first subtracted.

      Thus, for example, if the user puts in the same reddening and distance
      modulus as the value in the field file, the values in the field
      table for the stars are used unaltered.

      The table has descriptors:-

\begin{tabular}{|c|p{4.0in}|}\hline
      Name   &  Content \\ \hline
      RED    &  The reddening \\
      DISMOD &  The distance modulus \\
      MSTART &  The magnitude of tlh corner of the tlh area in the CMD grid \\
      MSTEP  &  The vertical (magnitude) size of the areas \\
      CSTART &  The colour of tlh corner of the tlh area in the CMD grid \\
      CSTEP  &  The horizontal (colour) size of the areas \\ \hline
\end{tabular}

      MSTEP and CSTEP must be positive

\item The table can be made at the keyboard by the program TBKEY, and the
      decriptors added with the program TBWRDES.

\end{enumerate}


}\sstsubsection{FMRANGE = {\undersc}REAL(2) (Read)}{
  (If there is a field file:- \newline
     Default - brightest to faintest magnitude in field file  \hspace*{6ex}
     Range - brightest to faintest magnitude in field file \newline
   If the field is to have a uniform magnitude distribution:- \newline
     Default - -50 \hspace*{6ex}
     Range - -50 to +50)

  Range in magnitude that field stars can have.

}\sstsubsection{FNUMBER = {\undersc}INTEGER (Read)}{
  (Default - 1   \hspace*{6ex}  Range - 0 to 100000000)

  Number of field stars to make

}\sstsubsection{FREDDEN = {\undersc}REAL (Read)}{
  (Default - Value in field file, if any, or 0.0 \hspace*{6ex}
   Range - -1.0e8 to 1.0e8)

  Field reddening. If there has been the input of a field file
  with its own reddening, that reddening is first subtracted.

}\sstsubsection{FSEED = {\undersc}INTEGER (Read)}{
  (Default - 1234567891  \hspace*{6ex}  Range - 1200000001 to 1400000001)

  Random number to seed making of random field stars.

}\sstsubsection{FXRANGE = {\undersc}REAL (Read)}{
  (Default - 1.0,100.0   \hspace*{6ex}  Range - -1.0e8 to 1.0e8)

  X start and end of acceptable area for field stars to lie in.

}\sstsubsection{FYRANGE = {\undersc}REAL (Read)}{
  (Default - 1.0,100.0   \hspace*{6ex}  Range - -1.0e8 to 1.0e8)

  Y start and end of acceptable area for field stars to lie in.

}\sstsubsection{LOG = LITERAL [HIDDEN] (Read)}{
  (Default - `no'  \hspace*{6ex}   Choice - `yes:no')

  This is a 'hidden' parameter, only accessable through the
  command line or the interface file.

  Put out a log as the program goes?

}\sstsubsection{M1FACT = {\undersc}REAL (Read)}{
  (Default - 1000.0   \hspace*{6ex}  Range - 1.0e-8 to 1.0e8)

  This is the scale conversion from magnitude to height for the first
  colour band. You input the height  (linear flux equivalent) a star
  of magnitude 20.0 in the input magnitude (e.g. 'V') should have.

  This is used in the conversion in the output table between the
  magnitudes in column 5 (MAG1) and the heights of column 3 (HEIGHT1).

}\sstsubsection{M2FACT = {\undersc}REAL (Read)}{
  (Default - M1fact  \hspace*{6ex}   Range - 1.0e-8 to 1.0e8)

  This is the scale conversion from magnitude to height for the second
  colour band. You input the height  (linear flux equivalent) a star
  of magnitude 20.0 in 'Mag' + 'Col' = 2nd magnitude band
  (e.g. 'V' + 'B-V' = 'B') should have.

  This is used in the conversion in the output table between the
  magnitudes in column 7 (MAG2) and the heights of column 4 (HEIGHT2).

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

  The name of the file to conatin the output table.

}\sstsubsection{RADCORE = {\undersc}REAL (Read)}{
  (Default - 10.0  \hspace*{6ex}  Range - -1.0e8 to 1.0e8)

  King core radius of cluster ( in pixels )

}\sstsubsection{RADTIDE = {\undersc}REAL (Read)}{
  (Default - 100.0  \hspace*{6ex}  Range - -1.0e8 to 1.0e8)

  King tidal radius of cluster ( in pixels )

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - `Output from SPRINKLE')

  The Title to add to the output table


}}}



\addcontentsline{toc}{subsection}{ Starfind}

\ajhsect{\arabic{section}}{General Programs - \hspace*{0.2in} STARFIND}

\sstroutine{STARFIND}{Find Stars in an Image}{

\sstdescription{
  This program finds stars in an image.

  It works by looking for boxes of roughly the seeing size which are
  above (in a significant way) their surroundings. It is a good
  searcher, but slow, although it can be sped up by setting the search
  limits so it does not look for very improbable stars.

  It can deal with variations in the background level, but gets
  thrown by very large galaxies. If it encounters small galaxies, it
  gives them the benefit of the doubt and marks up a double star.

  It is not perfect, and the eye can do better in some cases. It is
  very good on very faint isolated stars, finding (real) things you
  wouldnt believe, but in very crowded fields or very overlapping
  stars, it is good to run STARFIND and then delete and add the few
  corrections to the star list produced. This can be done by INTERACT.

  The output file is not asked for until the very end of the program,
  after it has found the stars. If you want to input the file name at
  the beginning of the program, do so in the command line when running
  the program, with OUT=`name of file' and TITLE=`title to add to file'.
  This will then permit the program to access these when it needs them

  The program will not work on images smaller than 10x10.

}\sstdiytopic{Use}{

 First you must know very roughly the radius of the star images.

\begin{enumerate}
  \item Start the program.
  \item Input the control parameters
  \item A list of star positions comes out.
  \item Er - that's it.
\end{enumerate}

  There are two options to omit two parts of the searching to speed
  things up. Use of these options will result in not finding a few of
  the tricky stars.

  There are also two input paramaters to select the range of stars
  found to differing probability limits.

  There is also a not very critical parameter, the size of the large
  sky box the program uses. I suggest you adopt the computer suggested
  size.

  If you are interested in the progress of the program you can set
  the parameter INFORM to different levels to get different levels of
  output on the terminal as you go along.

}\sstdiytopic{Method}{

 The finding is done by:-

\begin{list}{{---}}{}

 \item Making a `U-map' image of the input image. This is a map of the
     probability that a pixel is significantly higher than its
     surroundings, and so is likely to be near the peak of a star.
     Thus a `sharpened' image is made of star-sized objects above the
     local levels.

 \item Looking in the U-map image for:-

   \begin{list}{{-}}{}

     \item Star peaks and plateaus
     \item Elliptical stars, and saying that is actually two stars
     \item Shoulders running off from stars, and saying they are actually
        stars
  \end{list}

 \item Weeding the stars found for spurious ones

 \end{list}

 This process has been deliberately tuned to be reasonably generous
 in finding stars, so it should find more than there are. The output
 of this should be put into a proper star measuring program to
 sort out the (small number of) false alarms.

 There is a limit on the number of stars that can be found.

 These matters are described more fully in the sub-headings below.


 \vspace*{1mm}
 \hspace*{2em}{\bf U-Map}
 \vspace*{1mm}

  The U-map is made by:-

 Running a non-parametric test (one tailed mann-whitney U test)
 over every point in the image. At each point it takes a box
 (roughly a seeing size) round that point and compares it with
 an equal area around that box. It looks at the ranks of points
 when all put together, and assigns a probability
 (0-1 1=certain) to the chance that the ranks are NOT scattered
 at random, and thus that the data in the box is different
 AND higher from that in the annulus round it. This is then
 repeated with the comparision area separated by 1 pixel from
 the central box, and then with slices on each side,and then
 with slice on top and bottom. The comparision which indicates
 the most difference is taken.

 The U-map image of probabilities is a sharpened (on the scale
 of the box used) copy of the input. Thus the background (sky,
 large-scale effects such as galaxies, fringes, etc) is
 automatically allowed for. The box size is 3x3 for radius less
 than 1.75, 5x5 for radius less than 2.5 and then 7x7 up to 5.5,
 and therafter  ( nbox = 1 + 2*int(1.0+(radius-1.5)/2.0) )

 \vspace*{1mm}
 \hspace*{2em}{\bf Peaks}
 \vspace*{1mm}

 The peaks are found by searching the U-map for isolated images.

 This is done
    by lowering a threshold and looking for isolated patches
    above those thresholds. The mean position of the largest size
    patch before it merges in the lowering with another is taken
    as the star position. The lowering continues until the U-map
    probability level of `x' is reached (i.e. their is a `x' chance
    that the values are not different from the surrounds). `x' is
    is a user input number. An `x' value of 0.001 will result in
    about 100 false detections in a 320 by 512 image. Thus
    normally, a value of 0.01 is used.

    The lowering then continues down to the `y' probablity level,
    but only those patches which have values in the corresponding
    real image significantly (2.25 std devs) above the local sky
    level are found. This finds faint stars on the wings of bright
    ones. `y' is normally 0.05, but to speed the process up, can
    be set to the `x' level of step 3).

 \vspace*{1mm}
 \hspace*{2em}{\bf Sky}
 \vspace*{1mm}

 The local sky level referred to above has previously been
 determined by the program.

 This is done by making a `sky map', that is a temporary image the
 same size as the input image, with its pixel values set to what the
 program thinks is the value of the background sky at that pixel.

 It also determines another sky map, which have the local values of
 (sky+scatter), where `scatter' is the largest reasonable value the
 sky noise could add to the sky level in a pixel.

 These are determined in one of three ways:-

 \begin{enumerate}
  \item Subdividing the image into largeish (set by you, but suggested
    at 64x64) boxes, finding local modes and scatters, and then
    interpolating between these local modes by linear interpolation
    between the box centres. The scatter about the
    mode of the lowest mode is taken as the sky scatter.

  \item Taking the input image as having uniform background. The mode of
        the image is found, and the std dev about this mode found.

        This is the default way.

  \item Looking for the minimum pixel value and taking that as the sky
    level. The noise is taken as the std dev around the mode of the whole
    image.

\end{enumerate}

 The default should be chosen unless there is smooth and
 significant change in the sky background (say from an elliptical
 galaxy which covers most of the image). If the
 change in the sky background is sharp, say from a globular cluster
 manifesting itself over 50 pixels, choose the default anyway.

 \vspace*{1mm}
 \hspace*{2em}{\bf Ellipticity}
 \vspace*{1mm}


 The found images are searched for ellipticity, an indication of 2
 stars close together, merging to make one.

 The program looks at stars and sees if the U-test image shape of the
 star is elliptical. For a star to qualify as elliptical, the
 group of flagged pixels that make up the star (that is the number
 of contiguous pixels flagged as being below the present
 significance level) have to satisfy certain criteria:-

\begin{list}{{-}}{}

    \item  the ellipticity has to be greater than a given limit, 0.35
    \item  the semi-major axis has to be larger than a given limit
              (0.67 times the star image profile radius)
    \item  the area of the star has to be more than seven pixels
    \item  the area of the star must not touch the image edge
    \item  the area of the star does not contain other stars
\end{list}

 This searching is only done when new stars are found in the main
 program. On these occasions, all the stars are checked for
 ellipticity. Now some of these will have already been found
 to be elliptical when working at a higher contour level
 significance. Such stars are rechecked regardless, as the lower
 significance, larger, image may show up a better ellipticity. This
 rechecking of `existing' doubles is however only done five times.

 \vspace*{1mm}
 \hspace*{2em}{\bf Shoulders}
 \vspace*{1mm}

  Stars on the wings of brighter ones are searched for. These show up
  in the U-map image as long, narrow projections from the patches. At
  each lowering level, each image is searched for these projections.
  These projections are allowed down to a 9.5\% probability level.

 \vspace*{1mm}
 \hspace*{2em}{\bf Weeding}
 \vspace*{1mm}

 The stars found are weeded before output to remove spurious
 detections.

 This is done by:-

\begin{list}{{-}}{}

 \item The final list is searched for stars which are too close
    to each other (separation less than 0.66*star radius). These
    are replaced by one star at the mean position.

 \item For CCD images, bright stars have linearity problems and/or
    saturated centres, and these centres should be marked by
    INVALID flag levels for all pixels above some level. These
    stars are then found to have a number of isolated patches
    in the U-map (since the centre itself has all the same values),
    and so a test is made for these saturated centres, and the
    possibly more than 1 stars found there are reduced to one.

 \item If an image was trailed or by some other cause has elongated
    images, then this program will tend to regard each image
    as a double and mark it as so. If desired, the star list
    is looked at for an excess of close doubles at the same
    angle and separation, and these are reset to be single stars.
\end{list}

 \vspace*{1mm}
 \hspace*{2em}{\bf Maximum Number}
 \vspace*{1mm}

 There is a user defined computer found star storage work space.
 This limits the number of stars that may be found. The default is
 10,000 stars. If more than this are found, the program stops.
 If more than this are found, the program stops. The resulting star
 list will have a non-complete and non-uniformly found content and
 should not be used as an reliable list. Although all the stars
 actually in it will be good ones, the found/not found distinction
 may vary with position, brightness, ellipticity, sky background,
 and presence of nearby stars in an unprdicatble way. If the
 max number of stars is found, then because of the weeding of close
 pairs and of multiple hits on large invalid areas, less than the
 maximum may be put out. Beware of thus thinking that all was ok
 just because of the fact that less than the maximum number were
 output.


}\sstdiytopic{Output}{
   The output table contains six columns. For each star, the entry is:-

\begin{tabular}{|l|p{4in}|}\hline
Column Number & Content \\ \hline
       1 & X posn \\
       2 & Y posn \\
       3 & Height above sky \\
       4 & utest value as 100000.0*(1.0 - [u-test probablity]) \\
       5 & flag for `STARFIND' type 1:single 2:nipple 3:ellipse
                              11:single-inval 12:nip-inval 13:ell-inval
                              4:weeded ellipse centre \\
       6 & elliptical companion number (=0 if none) \\ \hline
\end{tabular}

}\sstdiytopic{Hidden Parameters}{
  The parameters MAXNUM, PLIMIT and WLIMIT are `hidden', that is only
  accessible by putting `STARFIND MAXNUM=value PLIMIT=value WLIMIT=value'
  on the command line or a previous LET command.

}\sstdiytopic{Inform}{
  The program can output progress information as it goes along.
  What is output to the terminal device by the program is set by
  the INFORM parameter. Thus:-

\begin{tabular}{|l|p{4in}|}\hline
     INFORM  value &   Output information \\ \hline
      none    &        None \\
      some    &   Stages in the finding started and ended \\
      lots    &   As for `some', but also more detailed information, such
                  as the U-map level being looked at, and stars found \\ \hline
\end{tabular}

  In the typed-out information when INFORM = `lots', those lines relating to
  star finds are similar to the rows in the output table. The
  star number is however not the same as in the output, as there is a
  sequence of finding which may affect earlier finds, and so disrupt the
  star numbering. Thus a found star may later in the program be decided
  to be:-

 \begin{list}{{-}}{}
    \item replaced by two stars since the found star is too elliptical
    \item removed as one of a number of false finds in an `invalid' peak
    \item removed as being too close to another star
\end{list}

  These last two removal processes also have their process informed to
  the terminal.

}\sstparameters{

\sstsubsection{ELLIPSE = LITERAL (Read)}{
  (Default - `yes'   \hspace{6ex} Choice - `yes/no')

  After the first search, repeat, trying to see if any of the objects
  were elliptical and thus maybe double stars. YES/NO will enable/
  suppress this extra search.

}\sstsubsection{FAINT = LITERAL (Read)}{
  (Default - `yes'   \hspace{6ex} Choice - `yes/no')

  After the first search, repeat, trying to see if any of the objects
  were had faint companions that were missed. YES/NO will enable/suppress
  this extra search.

}\sstsubsection{IN = NDF (Read)}{
 (Default - null)

  The name of the file containing the input image

  This can be either a `short' 16-bit integer or a `real' 32-bit real
  \starman NDF image.

}\sstsubsection{INFORM = {\undersc}INTEGER (Read)}{
  (Default - 'none'      \hspace{6ex}   Choice - `none:some:lots')

  Switch to enable monitoring of the progress.

  [See the section on `Inform']

}\sstsubsection{MAXNUM = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - 10000      \hspace{6ex}   Range - 1 to 1 000 000)

  [Hidden variable, only accessible from command line.]

  The maximum number of stars that can be found.

  If more than this are found, the program stops. The resulting star
  list will have a non-complete and non-uniformly found content and
  should not be used as an reliable list. Although all the stars
  actually in it will be good ones, the found/not found distinction
  may vary with position, brightness, ellipticity, sky background, and
  presence of nearby stars in an unprdicatble way. If the
  max number of stars is found, then because of the weeding of close
  pairs and of multiple hits on large invalid areas, less than the
  maximum may be put out. Beware of thus thinking that all was ok
  just because of the fact that less than the maximum number were
  output.

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

  The name of the file to contain the output table of star positions.

  The output file is not asked for until the very end of the program,
  after it has found the stars. If you want to input the file name at
  the beginning of the program, do so in the command line when running
  the program, with OUT=`name of file' and TITLE=`title to add to file'.
  This will then permit the program to access these when it needs them

}\sstsubsection{OUTIM = NDF [HIDDEN] (Write)}{
  (Default - null)

  The name of the file to contain output U-test image.

  This is only output, if `YES' has been responded to `Usave'.

  [Hidden variable, only accessible from command line.]

}\sstsubsection{PLIMIT = {\undersc}REAL   [HIDDEN] (Read)}{
  (Default - 0.001   \hspace{6ex}  Range - 0.00001 to 1.0)

  [Hidden variable, only accessible from command line.]

  The limit of probability that the difference between the area inside
  the search box and the area around it has arisen by chance and that
  there is not really a star at this position. A value of 0.001 gives
  roughly 10 false detections in a 100x100 pixel area.

}\sstsubsection{RADIUS = LITERAL (Read)}{
  (Default - 2.0  \hspace{6ex}   Range  - 0.2 to 20.0)

  The approximate Half Power Half Width of the star images. This is what
  `profile' (qv) and `simplemag' (qv) find and what `measure' (qv) uses

}\sstsubsection{SKYTYPE = {\undersc}INTEGER (Read)}{
  (Default - `local' \hspace{6ex}    Choice - `local:mean:minimum')

 Method of making the sky map.

 This is done by making a `sky map', that is a temporary image the
 same size as the input image, with its pixel values set to what the
 program thinks is the value of the background sky at that pixel.

 It also determines another sky map, which have the local values of
 (sky+scatter), where `'scatter' is the largest reasonable value the
 sky noise could add to the sky level in a pixel.

 These are determined in one of three ways:-

\begin{tabular}{|l|p{4in}|}\hline

 Code & Method \\ \hline
 local &
  Subdividing the image into largeish (set by you, but suggested
    at 64x64) boxes, finding local modes and scatters, and then
    interpolating between these local modes by linear interpolation
    between the box centres. The scatter about the
    mode of the lowest mode is taken as the sky scatter.

        This is the default way.  \\

mean & Taking the input image as having uniform background. The mode of
        the image is found, and the std dev about this mode found. \\

minimum &
    Looking for the minimum pixel value and taking that as the sky
    level. The noise is taken as the std dev around the mode in the whole
    image. \\ \hline
\end{tabular}

 The default should be chosen unless there is smooth and
 significant change in the sky background (say from an elliptical
 galaxy which covers most of the image). If the
 change in the sky background is sharp, say from a globular cluster
 manifesting itself over 50 pixels, choose the default anyway.

}\sstsubsection{SMEAR = LITERAL (Read)}{
  (Default - `yes'   \hspace{6ex} Choice - `yes/no')

   If an image was trailed or by some other cause has elongated
   images, then this program will tend to regard each image
   as a double and mark it as so. If desired (YES), the star list
   is looked at for an excess of close doubles at the same
   angle and separation, and these are reset to be single stars.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - input image title, or `Output from STARFIND'  \hspace{6ex} Choice
   - any)

  The Title to add to file ( named with `OUT') containing the output
  star position table.

}\sstsubsection{USAVE = LITERAL [HIDDEN] (Read)}{
  (Default - `no'   \hspace{6ex} Choice - `yes/no')

  Flag for saving the U-test image made in the calculations.

  [Hidden variable, only accessible from command line.]

}\sstsubsection{WLIMIT = {\undersc}REAL [HIDDEN] (Read)}{
  (Default - 0.05   \hspace{6ex}    Range - 0.0001 to 1.0)

  [Hidden variable, only accessible from command line.]

  The limit of probability that the difference between the area inside
  the search box and the area around it has arisen by chance and that
  there is not really a star at this position, FOR A POSITION WHICH HAS
  A SIGNAL VALUE of 2.5 std dev above the local sky. This is used for
  looking for stars on the wings of bright stars.

}\sstsubsection{XSKYBOX = {\undersc}INTEGER(2) (Read)}{
  (Default - 64 (or half X size, if less)    \hspace{6ex}        Range - 10 to half X size of image)

  Suggested X size of the box the program uses to average the sky
  values. Should be small compared to the scale of the sky variations.

  (This is only asked for if the `SKYTYPE' parameter is set to 'local'.)

}\sstsubsection{YSKYBOX = {\undersc}INTEGER(2) (Read)}{
  (Default - 64 (or half X size, if less)           \hspace{6ex}    Range - 10 to half Y size of image)

  Suggested Y size of the box the program uses to average the sky
  values. Should be small compared to the scale of the sky variations.

  (This is only asked for if the 'SKYTYPE' parameter is set to `local'.)


}}}



\addcontentsline{toc}{subsection}{ Unccd}


\ajhsect{\arabic{section}}{General Programs - \hspace*{0.2in} UNCCD}

\sstroutine{UNCCD}{Calibrate raw CCD images}{

\sstdescription{
  This takes the raw image from a CCD and turns it into a clean image,
  corrected for many of the CCD characteristics such as Bias, Flat
  Field, etc.

  In effect it takes the CCD image which is a picture of the sky, with
  CCD artifacts imposed, and undoes the effects of these artifacts to
  restore the sky picture. It thus un-ccds the image, thus its name.

}\sstdiytopic{Use}{
  This is used for removing the CCD characteristics as far as possible
  from the image and turning it into nice image.

  The program can do any or all of the following actions:-

\begin{list}{{-}}{}
\item select an area in the image to be the output area
\item estimate a mean bias level from a bias area and subtract it
\item subtract a bias image
\item correct for non-linearity
\item subtract a dark image (scaled to the exposure time)
\item subtract a preflash image (scaled to the preflash time)
\item divide by a flat field image
\item subtract a night sky fringe pattern (scaled to the exposure time)
\item flag areas as `bad'
\item flag pixel values outside a given range as `bad'
\item normalise the output
\item display the output
\end{list}

}\sstdiytopic{Guide}{
 This is a brief guide on how to use `unccd' in calibrating CCD images.

{\hspace*{4ex} \bf  Background Knowledge }

 You must have a general background in CCDs and Photometry:-
 read the section on 'Knowledge'.


{\hspace*{4ex} \bf  Make the Master Calibration frames }

 See the help on this in the `Calibration Frames' section.


{\hspace*{4ex} \bf  Use `unccd' to make the processed exposures}


\begin{list}{{-}}{}
\item Strip out the overscan area, and subtract its mean level
\item Subtract any useful BIAS frame
\item Subtract any useful PREFLASH frame
\item Subtract any useful DARK frame
\item Divide by the FLAT frame
\item Subtract any useful FRINGE frame
\item Flag bad areas with the bad pixel list
\end{list}

{\hspace*{4ex} \bf   Comments }

 The end result should be inspected to see if the FRINGE exposure
 (if used) is appropriate in strength and pattern to the target
 expoure

 The user should consider Why `unccd' does it so that step 5 is done
 AFTER steps 1 to 4, why it would be wrong to do step 5 before any of
 the steps 1 to 4, and why is step 6 done after step 5?

}\sstdiytopic{Knowledge}{

 Before using this program, it will prove well worth your while to
 have a general background knowledge of CCDs and Photometry. This
 section will point to some areas worth learning about.

{\hspace*{4ex} \bf   Understand the way a CCD works}

 You can read all about the mechanics, the problems and the
 possibilities CCDs in many books. Two good examples are:-

   1) Chapter 2 of The University of Leeds thesis of John Buttress

   2) McClean's book on Electronic Astronomy.

{\hspace*{4ex} \bf   Learn about Photometry in general}

 See, for example, the University of Leeds thesis of Richard Noble.
 There are also many other books and articles are general photometry,
 such as Andrew Young's articles in `Methods in Experimental Physics',
 or Welch in the JRAS Canada.


{\hspace*{4ex} \bf   Learn about `unccd'}

 Read this help

{\hspace*{4ex} \bf   Learn about the \starman program `imcalc'}

 This enables you to add images together, divide by constants,
 etc. (Useful in scaling to 1 second equivalents or to
 mean levels of 1.0)

{\hspace*{4ex} \bf   Learn about the \starman program `imstat' }

 This enables you to measure the mean and std dev in an area. It is
 useful in determining levels so that `imcalc' can be used to make
 1.0 level mean exposures.

{\hspace*{4ex} \bf   Learn about the range of programs available}

 Use the Help to browse through the \starman package
 of programs, seeing the range of tools available.

{\hspace*{4ex} \bf   Be methodical in your work}

 Make a record of what you do, so you can go back over it later if you
 think that will be useful. Be prepared to justify on scientific grounds
 any decision you take (or fail to take).

{\hspace*{4ex} \bf   Make a list of the various categories of the exposures}

 I.e., Bias; dark; preflash; flat field (called `sky', `dark sky',
 `flat', etc); the different star fields; the E-region standard
 exposures

{\hspace*{4ex} \bf   Look at all the images}

 Use the \starman program `imflash' to display the images.

 Are they what you expect?

 Make a note of the mean and std dev. The display range is typed
 out by `imflash', as (mean+3.std dev) to (mean-2.std dev). Or use
 `imstat'. Are the mean and std dev what other similar images have?

 Make a rough note of the seeing on the star field exposures
 (bad, average, good).

 Are there any funny effects in any exposure?

}\sstdiytopic{Details}{

  There are various details as to the use of the program which
  the sub-helps here will tell you about.

{\hspace*{4ex} \bf  Bad Areas}

  A 'magic value' bad pixel flagging scheme is used. This may result in
  pixels being flagged as bad by the input of a 'bad pixel list' (qv),
  or by any of the input calibration images containing 'bad' pixels. Any
  pixel which is bad in the bad pixel list or any of the calibration
  images is flagged as 'bad'

{\hspace*{4ex} \bf  Bad Pixel Lists}

  In the input image (both in the area that will be output and in the
  bias level area), pixels may be flagged as bad by a 'bad pixel list'.
  These pixels will be set to 'invalid' in the output image.

  The list is a table which consists of rows of data, each of
  which describe a rectangular 'bad' area. Each row has 4 integers
  giving x,y ranges. Thus if the first 'bad' area to be described has a
  blh corner at x1,y1, and a trh corner at x2,y2, then the first row
  in the table will be x1,x2,y1,y2. Then the second entry will have
  the ranges for the second area, and so on.

  The coordinates are relative to the entire input image.

{\hspace*{4ex} \bf  Bias Level}

  Whether or not the subtraction of the mean bias level of the exposure
  is done is controlled by the 'BIAS' parameter. If it is done, then an
  area of the input image is selected (defined in the 'NBIAS'
  parameter) and its mean calculated, with the non-use of pixels
  defined by the, optional, bad pixel list file given via the
  'BIASBAD' parameter.

  This mean value is then selected, and subtracted from the input.

{\hspace*{4ex} \bf  Fringe Exposures}

 Sometimes on astronomical CCD exposures which have been flat fielded,
 one can see a residual `fringe' pattern, looking like distorted
 Newton's rings. This effect comes from emission lines in the night
 sky interacting with the thickness of the CCD chip.

 What happens is that as chip are quite thin, a few light wavelengths
 from the top surface to the base, any incident light can suffer an
 interference effect. Thus the intensity of the light that falls on
 the silicon detector gets affected by this interference. So the total
 response of the chip depends not only on the response of the silicon
 for an individual pixel, but also how much interference has taken
 place. Normally, these two effects are not separated, and a `flat-field'
 exposure will measure the combination of the two. However, as the
 interference effect is a strong function of wavelength, the `flat'
 will vary markedly with wavelength, giving a `fringe' effect in the
 `flat', tracing out the variations in thickness of the chip over its
 surface area. This effect is normally washed out over the wavelength
 width of the filter response, and the fringing gets lost.

 If the night sky has emission lines in the part of its spectrum which
 falls with the filter response, then that additional light, having
 a narrow wavelength range, will have its own `flat', different from
 the total `flat' with (possibly, depending on the pattern of chip
 thickness variations) a `fringe' pattern. Thus using a normal
 `flat-field' will not `flatten' the sky contribution correctly.

 This is got round by seeing what this difference is, and allowing for
 it. One takes a long exposure of an area of sky where there are few
 or no  stars or other objects. (Such areas are usually in front
 of dark clouds.) Then after the standard processing, including
 using the normal `flat-field', the mean level is subtracted. What
 is left can be considered as the additional signal from the night
 sky emission lines. It can now be subtracted, scaled appropriately
 for exposure times, from other normal frames, after they have been
 processed.

 There are a number of additional effects to consider:-

\begin{list}{{-}}{}
\item The mean level was used to subtract the other night-sky light,
    as we wish to make the output sky level a correct match to the
    total incoming flux.
\item Often, the night sky emission line spectrum will vary. A simple
    scaling in strength may be allowed for by having a number of
    fringe frames, scaled by varying amounts, and seeing which does
    the best job in removing the fringe effect. A variation in the
    relative strength of a number of emission lines in the filter
    response wavelength coverage, will however mean making a totally
    new `fringe' frame.
\item `Fringe' frames may also be made from normal exposures. A
    large number of exposures, each containing a large proportion
    of blank sky with the astronomical objects in them occupying
    different positions, are taken. Then by averaging them with a
    technique that throws away divergent pixels (say modal averaging),
    the mean underlying night-sky `fringe' pattern may be seen.
\end{list}



}\sstdiytopic{General}{

\begin{enumerate}
\item A non-linearity in the input can be dealt with.

\item Special corrections can be done. At present, these are:-

       - AAT 1988 RCA CCD band correction

\item The image can be normalised, either scaled so that the average
      value in a selected area to be unity, or scaled by the exposure
      time to an exposure time of 1 second, or having a mean value
      subtracted.

\item The final image can be displayed on a image display.

\item The exposure time of the image is needed if an input calibration
      'dark' image or 'fringe' image is used. This exposure time is
      picked up from a descriptor, whose name is input by the user
      with the 'EXPNAME' parameter.
\end{enumerate}

}\sstdiytopic{Calibration Frames}{

 This section describes how to make the master calibration frames which
 `unccd' uses to calibrate the program exposures.

 (In these descriptions, refeerence is often made to averaging frames.
  You should be aware of these various methods of averaging, their
  strengths and weaknesses, and especially how they deal with
  discordant pixels.)

{\hspace*{4ex} \bf  Determine the bad pixel list}

 Look at a variety of types of exposures - bias; flat field; star field;
 standards. Are then any areas that look 'bad', i.e. the signal
 is clearly wrong. Too high, too low, etc. (A common fault
 is a part of a column can be significantly low.)

 Use `interact', with:- zoom, cvalues, area, inspect, etc, to determine
 the location of such areas. Make a bad pixel list (use `tbkey'),
 as described in the `unccd' help for the `bad' parameter.


{\hspace*{4ex} \bf   Determine the bias frame}

\begin{enumerate}
 \item Have a look

 \item Smooth a bias image with `imsmooth', on scales of
    10x10, 50x50, and 100x100 to see if there is any overall pattern.
\end{enumerate}

 If there is no pattern, ignore the bias frames. If there is one, then
 make a mean bias frame with as little noise as possible consistent
 with preserving any detectable pattern.

 Make the bias frame. First, strip out the overscan area, and then
 subtract its mean level. Then average with other bias exposures
 to make a mean bias frame.

 Then consider the output bias frame. Is it worthwhile using? Will
 it actually correct the exposures to any significant degree, or
 will it just add noise?



{\hspace*{4ex} \bf   Determine the 1 sec preflash frame}

 Use `unccd' to make each individual preflash frame.

\begin{enumerate}
\item Strip out the overscan area, and subtract its mean level
\item Subtract any useful bias frame
\item Flag bad areas with the bad pixel list
\end{enumerate}

 Then average with other preflash exposures, each  scaled to 1 sec,
 to make a mean frame,

 Is the output preflash frame worthwile? For the exposures will
 it actually correct the exposures to any significant degree, or
 will it just add noise?

 Why do we need to make a `1 second' master frame?

{\hspace*{4ex} \bf  Determine the 1 sec Dark current frame}

 Use `unccd' to make each individual DARK frame:-

\begin{enumerate}
\item Strip out the overscan area, and subtract its mean level
\item Subtract any useful BIAS frame
\item Flag bad areas with the bad pixel list
\end{enumerate}

 Then average with other dark exposures to make a mean dark frame,
 each scaled to 1 sec.

 Is the output Dark frame worthwhile? For the Star field exposures will
 it actually correct the exposures to any significant degree, or
 will it just add noise?

 Why do we need to make a `1 second' master frame?


{\hspace*{4ex} \bf  Determine the Master Flat Field frames}

 Use `unccd' to make each individual flat frame.

\begin{enumerate}
\item Strip out the overscan area, and subtract its mean level
\item Subtract any useful bias frame
\item Subtract any useful preflash frame
\item Flag bad areas with the bad pixel list
\end{enumerate}

 Then take the individual ones and average them together to make
 a mean.

{\hspace*{4ex} \bf  Determine the 1sec Fringe frame}

 Use `unccd' to make each individual fringe frame:-

\begin{enumerate}
\item Strip out the overscan area, and subtract its mean level
\item Subtract any useful bias frame
\item Flag bad areas with the bad pixel list
\item Flag any areas contaminated by stars
\item Divide by the flat field for the filter
\item Subtract the mean level
\item Divide by the exposure time in seconds
\end{enumerate}

Then average a number of these individual fringe frames to make a mean
fringe frame, This is now scaled to 1 sec. The averaging technique
should be one that rejects pixels in individual frames which are
contaminated by stars or cosmic rays.

Is the output Fringe frame worthwhile? For the Star field exposures will
it actually correct the exposures to any significant degree, or
will it just add noise?

Why do we need to make a `1 second' master frame?


}\sstdiytopic{Input/output}{
\begin{enumerate}

\item  The input image can be in one of a number of formats.

    The formats and the value of the 'DTYPE' parameter to select them
    are:-

\begin{tabular}{|c|p{4in}|}\hline
 `DTYPE' value & Format \\ \hline
 `SIGNED' & Signed 16-bit integer (-32768 to 32767)  \\
 'UNSIGNED' &  Unsigned 16-bit integer (0-65535)  \\
 'BADSIGNED' & Which is flagged as signed but actually
       contains unsigned numbers (0-65535) \\
 'REAL' & Real 32-bit numbers  \\ \hline
\end{tabular}

\item The input calibration images are either `real' or `short'
      images.

\item All calculations inside the program are done in REAL*4 (32-bit)
      precision.

\item The final image can be output to file. This output is either
      a `real' image, or a `short' image with
      user-chosen BSCALE and BZERO  to deal with the 16-bit
      resolution of the output pixel values.
\end{enumerate}

}\sstdiytopic{How To Normalise}{
  The output image may be normalised (that is its mean level set to
  1.0), before the final output if desired.

  Whether this is done, and if it is then how, is controlled by the
  'NORM' parameter. The options are:-

\begin{tabular}{|c|p{4.2in}|}\hline
     'NORM' value    &      Method \\ \hline
      Flux      &  Normalise average val to 1.0 (divide by mean) \\
      Time      &  Norm values to what they would have been if the
                  exposure time had been 1.0 seconds \\
      None      &  No normalisations \\
      Sub       &  Subtract mean \\ \hline
\end{tabular}

  If normalisation is done, and 'Flux' or 'Sub' is chosen, then the
  the mean has to calculated. The area of the image used to calculate
  the  mean can be set by the 'NNORM' parameter.

  The 'NNORM' parameter defines the (X start, X end, Y start, Y end) of
  the chosen area.

  The default is the whole of the area that will be stored as the
  output image.

}\sstdiytopic{Display}{
  The output image may be displayed. This is controlled by the 'DISP'
  parameter.

  If the display has been chosen, then the 'NDISP' parameter is used
  to select an area of the image to display. The area is input as
  (X start, X end, Y start, Y end of the input image area).

  The default is the entire output area.

  After the display the user is ask, via the 'ENOUGH' parameter, for
  when the program should continue, as some displays remove the
  picture when the program ends.

  The display is done with a pixel value contrast of +/- 3 std dev
  about the mean, with high pixels values set as black, and low as
  white.

}\sstparameters{

\sstsubsection{BAD = NDF (Read)}{
  (Default - null)

  The table containing the bad pixel list of 'bad' areas (if none,
  press 'return').

  These will be set to 'invalid' in the output image.

  The list is a table which consists of rows of data, each of
  which describe a rectangular 'bad' area. Each row has 4 integers
  giving x,y ranges. Thus if the first 'bad' area to be described has a
  blh corner at x1,y1, and a trh corner at x2,y2, then the first row
  in the table will be x1,x2,y1,y2. Then the second entry will have
  the ranges for the second area, and so on.

  The coordinates are relative to the entire input image.

  The table is in the \starman table format of a real NDF file.

}\sstsubsection{BIAS = LITERAL (Read)}{
  (Default - 'no'  \hspace*{6ex}         Choice - 'yes:no')

  Do you want to find a mean bias level from an `overscan' area?

  This mean will be subtracted from the image.

  The area is defined by the `NBIAS' input.

}\sstsubsection{BIASBAD = NDF (Read)}{
  (Default - null)

  The table containing the bad pixel list for the bias 'overscan'
  area (if none, press `return').

  These will define the areas of the bias 'overscan' area not to use in
  calculating the mean bias.

  The table consists of rows of data, each of
  which describe a rectangular 'bad' area. Each row has 4 integers
  giving x,y ranges. Thus if the first 'bad' area to be described has a
  blh corner at x1,y1, and a trh corner at x2,y2, then the first row
  in the table will be x1,x2,y1,y2. Then the second entry will have
  the ranges for the second area, and so on.

  The coordinates are relative to the entire input image.

  The table is in the \starman table format of a real NDF file.

}\sstsubsection{CORRECT = LITERAL (Read)}{
  (Default - 'none'    \hspace*{6ex}         Choice - 'none:mode1')

  Do you want to correct the image for some type of fault?

\begin{tabular}{|c|p{4in}|}\hline
  Choice  &  Result \\ \hline
  None   &   No correction \\
  Mode1  &   The AAT type row/column fault. In this, at present the
            high/low adjacent rows are just averaged. \\ \hline
\end{tabular}

}\sstsubsection{DISP = LITERAL (Read)}{
  (Default - 'no'         \hspace*{6ex}   Choice - 'yes:no')


  Do you want the output image displayed on the screen?

}\sstsubsection{DOLIMS = LITERAL (Read)}{
  (Default - 'no'         \hspace*{6ex}   Choice - 'yes:no')

  Do you want to flag values above and below certain values as `bad'?

  If you do, then you will be asked in the `lims' parameter what
  limits to acceptable values you want to input.

}\sstsubsection{DTYPE = LITERAL (Read)}{
  (Default - 'signed'   \hspace*{6ex}        Choice  - 'unsigned:signed:badsigned:real')

  The input image is taken as made of Integer*2 16-bit numbers, or
  as real 32-bit numbers. (The calculations inside the program use
  real numbers.)


  The formats and the value of the 'DTYPE' parameter to select them
  are:-

\begin{tabular}{|c|p{4in}|}\hline
 `DTYPE' value & Format \\ \hline
 `SIGNED' & Signed 16-bit integer (-32768 to 32767)  \\
 'UNSIGNED' &  Unsigned 16-bit integer (0-65535)  \\
 'BADSIGNED' & Which is flagged as signed but actually
       contains unsigned numbers (0-65535) \\
 'REAL' & Real 32-bit numbers  \\ \hline
\end{tabular}

  The data is read in in the proper way. The input image may have
  BSCALE and BZERO parameters, and these are applied, but any
  magic value INVAL parameter is ignored.

}\sstsubsection{ENOUGH = LITERAL (Read)}{
  (Default - 'yes'       \hspace*{6ex}     Choice - 'yes:no')

  Finished looking at screen?

}\sstsubsection{EXPNAME = LITERAL (Read)}{
  (Default - 'exposed'    \hspace*{6ex}            Choice - any)

  The name of the descriptor in the input image giving the exposure
  time. A choice of 'None' indicates there is no such descriptor.

}\sstsubsection{EXPTIME = {\undersc}REAL (Read)}{
  (Default - 1.0      \hspace*{6ex}      Range - 0.0 to 1.0e8 )

  Length of exposure in seconds.

  This is only used if the exposure time cannot be found from the
  input image header which the user has said contains the
  exposure time.

}\sstsubsection{GAIN = {\undersc}REAL (Read)}{
  (Default - 0.0      \hspace*{6ex}    Range  -1.0e8 to 1.0e8)

  The gain of the chip, in terms of electrons per adu. This is added
  as information to the output image descriptors. If 0.0 (the default)
  is input, then this is not added.

}\sstsubsection{IM\_B = NDF (Read)}{
  (Default - null)

  The name of the file with the bias frame to subtract from
  the input image.

  This should be a standard Adam .NDF file.

  A null response means that no bias is to be input.

}\sstsubsection{IM\_D = NDF (Read)}{
  (Default - null)

  The name of the file with the dark frame to subtract from
  the input image.

  This should be a standard Adam .NDF file.

  A null response means that no dark is to be input.

  It should be a dark frame scaled so as to be that which would
  result from a 1 second dark exposure.

  This is scaled in the program to the actual exposure time of the
  exposure.

}\sstsubsection{IM\_FL = NDF (Read)}{
  (Default - null)

  The name of the file with the flat field frame to divide into the
  processed (bias, preflash, dark) input image.

  This should be a standard Adam .NDF file.

  A null response means that no flat field is to be input.

  This should be the sensitivity function of the chip, thus a pixel
  of high sensitivity will have a high value, and one with low
  sensitivity will have a low value. It should have a mean level of
  1.0.

}\sstsubsection{IM\_FR = NDF (Read)}{
  (Default - null)

  The name of the file with the fringe frame to subtract from
  the input image.

  This should be a standard Adam .NDF file.

  A null response means that no fringe is to be input.

  It should be a fringe frame scaled so as to be that which would
  result from a 1 second exposure.

  This is scaled in the program to the actual exposure time of the
  exposure.

}\sstsubsection{IM\_P = NDF (Read)}{
  (Default - null)

  The name of the file with the preflash frame to subtract from
  the input image.

  This should be a standard Adam .NDF file.

  A null response means that no preflash is to be input.

  It should be a Preflash frame scaled so as to be that which would
  result from a 1 second preflash exposure.

  This is scaled in the program to the actual preflash time of the
  exposure.

}\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The name of the input image file.

  This should be a standard Adam .NDF file, but can be in a number of
  formats (real, signed 16-bit, unsigned 16-bit, badsigned 16-bit).

}\sstsubsection{LIMS = {\undersc}REAL(2) (Read)}{
  (Defaults -  0.0,32767.0 or 0.0,65535.0  \hspace*{6ex}
   Range - -1.0e10 to 1.0e10)

  The low and high limits to acceptable values in the input image.

  If you have answered 'YES' to the `dolims' query, then you are
  asked this.

  The values wanted are those after scaling for BSIZE and BZERO of
  the input image. Thus they are not the file storage 16-bit values,
  but the true, proper values they should be if it were not for the
  need to work with 16-bit images.

}\sstsubsection{LIN = LITERAL (Read)}{
  (Default - 'none'   \hspace*{6ex}         Choice - 'none:mode1')

  Do you want to correct the input data for non-linearity?

\begin{list}{{-}}{}
\item {\bf None: \hspace*{3ex}} No linearity correction
\item {\bf Mode1:  \hspace*{3ex}}    This correction is of the form:- \newline
           Raw-bias = (Corrected-bias)*[1.0 + factor*(Corrected-bias)]
\end{list}

}\sstsubsection{LINF = {\undersc}REAL (Read)}{
  (Default - 3.2*10-6   \hspace*{6ex}         Range - -1.0e8 to 1.0e8 )

  The factor 'factor' in the linearisation equation to use in correcting
  for the non-linearity of the CCD. (see paramater 'lin'.)

}\sstsubsection{NAREA = {\undersc}INTEGER(4) (Read)}{
  (Default - 1,nx,1,ny   \hspace*{6ex}      Range - 1 to 100000)

  This is the X start, X end, Y start, Y end of the image area to be
  taken, processed and output.

  This is input as four integers, separated by commas.

}\sstsubsection{NBIAS = {\undersc}INTEGER(4) (Read)}{
  (Default - 1,1,1,1     \hspace*{6ex}   Range - 1 to 100000)

  This is the X start, X end, Y start, Y end of the bias `overscan'
  area to be used.

  This is input as four integers, separated by commas.

}\sstsubsection{NDISP = {\undersc}INTEGER(4) (Read)}{
  (Default  -  Output area {\undersc}REAL   Range - 1 to 100000)

  This is X start, X end, Y start, Y end of the input image area to be
  displayed.

  This is only asked for if the query `disp' has been answered `YES'.

  This is input as four integers, separated by commas.

}\sstsubsection{NNORM = {\undersc}INTEGER(4) (Read)}{
  (Default  -  Output area {\undersc}REAL   Range - 1 to 100000)

  This is the X start, X end, Y start, Y end of the image area to be
  used in calculating the normalising value for the scaling.

  This is only asked for if the query `norm' has been answered `FLUX,
  or `SUB'.

  This is input as four integers, separated by commas.

}\sstsubsection{NOISE = {\undersc}REAL (Read)}{
  (Default - 0.0        \hspace*{6ex}      Range - --1.0e8 to 1.0e8)

  The read-out noise of the chip. This is added as information to the
  output image descriptors. If 0.0 (the default) is input, then this
  is not added.

}\sstsubsection{NORM = LITERAL (Read)}{
  (Default - 'none'    \hspace*{6ex}      Choice - see below)

  The method of normalising the image.

\begin{tabular}{|c|p{4.2in}|}\hline
     'NORM' value    &      Method \\ \hline
      flux      &  Normalise average val to 1.0 (divide by mean) \\
      time      &  Norm values to what they would have been if the
                  exposure time had been 1.0 seconds \\
      none      &  No normalisations \\
      sub       &  Subtract mean \\ \hline
\end{tabular}

}\sstsubsection{OBJNAME = LITERAL (Read)}{
  (Default - 'OBJECT'     \hspace*{6ex}      Choice - any)

  The name of the descriptor in the input image giving the object
  name. A choice of 'None' indicates there is no such descriptor.

}\sstsubsection{OFFSET = {\undersc}REAL (Read)}{
  (Default - 0,0       \hspace*{6ex}    Range - -10000 to 10000)

  The (X,Y) offset, relative to the entire raw input image, of the
  pixels of the reference (dark, flat field, etc.) images and bad
  pixel lists.

  Thus if the reference images were made in such a way that the (1,1)
  pixel of the reference images should be applied to the (11,11) pixel
  of the ENTIRE input image (not, that is, to the location of the
  pixel in the area in the input image that will become the output
  image), then the `offset' would be (10,10).

  The non-default option is mainly used for two cases:-

 \begin{enumerate}

 \item When a window of the normal CCD image has been used, so that only
     a part of the CCD image is read out. In this case, then the
     reference images will have normally been made for the `normal'
     entire CCD area - a bigger area. In these cases, the `offset'
     will always be two positive numbers, being the shift of the start
     of the windowed small image from the start of the normal large
     CCD image.

 \item When an `overscan' bias area is at the left of the image, so that
     the reference images and the bad pixel lists, while refering,
     normally, to the de-biased image, thus start not at the (1,1)
     pixel of the raw input image, even if it is a whole CCD image.

 \end{enumerate}

  If, further, the output image blh has an offset from the (1,1) pixel
  of the input image, then this does NOT affect the `offset'.

}\sstsubsection{OUT = NDF (Write)}{
  (Defaulty - null)

  The output file.

  This is a 'real' image or a 'short' integer*2 image with
  BZERO, BSCALE as chosen by the user. The default BZERO and BSCALE are
  taken from the first input frame.

  It is a standard \starman ADAM NDF image.

  If you put a null response in, then the output image is not stored.

}\sstsubsection{OUTTYPE = LITERAL (Read)}{
  (Default - same as input \hspace*{6ex}   Choice - `real:short')


  Should the output image be:-

\begin{tabular}{lp{4in}}
  'real'  &  This is a 32-bit real image with a precision of about
            1 in 10 million, nad values between +/- 10**38 \\

  'short' &  This is a 16-bit integer image, with a precision of about
            1 in 60000. The numbers are stored on disk as integers
            between -32768 and +32767. They are used in the \starman
            programs as real numbers, by the use of BSCALE and BZERO,
            such that:-

                'used value' = BSACLE*'disk value' + BZERO

            The advantage of this is that if this precision is adequate
            then the files are half the size of 'real' files. The
            problem is that one has to be constantly aware of the
            'digitisation' of the images when being stored on disk.
            Also, many other program packages do not use the
            BSCALE and BZERO, so cannot get the 'true' values. \\
 \end{tabular}


}\sstsubsection{PREFNAME = LITERAL (Read)}{
  (Default - 'PREFLASH'    \hspace*{6ex}         Choice - any)

  The name of the header in the input image which holds the
  length of the preflash exposure in seconds.

  If 'None' is entered, the user is asked for the preflash
  time.

  This parameter is only asked for if a preflash frame is used.

}\sstsubsection{PREFTIME = {\undersc}REAL (Read)}{
  (Default - 1.0       \hspace*{6ex}     Range - 0.0 to 1.0e8 )

  Length of preflash in seconds.

  This is only used if the user inputs that there is a prflash frame
  and that the preflash time cannot be found from the input image
  header.

}\sstsubsection{SCALE = {\undersc}REAL(2) (Read)}{
  (Default - as described below  \hspace*{6ex}     Range - -1.0e20 to 1.0e20)

   The two output image constants of BSCALE and BZERO.

   The output image is Integer*2, and has BSCALE and BZERO headers so
   that

       Real pixel value = BSCALE*(file pixel value)  + BZERO

   The BSCALE parameter:-

   Thus normally this is 1.0, or that of the input image.

   If the output image has been scaled for averaging, then a
   different scale may be appropriate.

   Thus for the flat field output, the pixels would all contain 1!
   So in these cases the default scale is 0.0001, and so in the case
   of the flat field the values would be about 10000, allowing for a
   reasonable dynamic range. For the averaging of preflash, and bias,
   a scale of 1.0 would be ok, but for dark and fringe, a scale of
   0.0001 might be ok, as these are scaled to 1 second exposure times.
   Anyway for these, have a look at the output, to see if the dynamic
   range has been chosen ok.

   The BZERO parameter:-

   Normally this is 0.0 or the input value.

   However for UNSIGNED or BADSIGNED input (16-bit unsigned numbers),
   the default is put at 32766, so the full range of numbers can be
   dealt with in the output. The value is 32766, not 32767, and thus
   a number of 65536 is put out as invalid (flagged with INVAL value).
   The reason for so chopping the highest unsigned number, is that
   -32768 is reserved as the INVAL number, and it was thought better
   to loose the 65536s than the 0s.

}\sstsubsection{TIT = LITERAL (Read)}{
  (Default - see below                   Choice - any)

  The Title to add to the output image. Default is the name in the
  image 'objname' descriptor.


}}}

\end{small}


\newpage
\section{Image Programs}
\ajhsect{\arabic{section}}{IMAGE PROGRAMS}
\label{se:progim}
\newpage
\begin{small}

\addcontentsline{toc}{subsection}{ Imcalc}


\ajhsect{\arabic{section}}{Image Programs - \hspace*{0.2in} IMCALC}

\sstroutine{IMCALC}{ Does mathematics on input images }{

\sstdescription{
 Does mathematics on input images.

 Arithmetic and mathematical functions are applied to input images
 and constants, by means of a FORTRAN-like equation.

 In addition to the standard FORTRAN facilities, a number of special
 functions are available (e.g. for adding noise).

  A simple example would be:-


\hspace*{4em} imcalc \hspace*{0.1em} (fred+george)/2.2   \hspace*{0.1em}
arthur  \hspace*{0.1em} 'new sums'


  This would add the images in the files `fred.sdf' and `george.sdf',
  divide the result by 2.2, and store the output in file `arthur.sdf',
  with the added title `new sums'.

}\sstdiytopic{Method}{


 The user inputs a Fortran-like equation (through the parameter EQN).
 The equation can contain references to:-

\begin{list}{{-}}{}
\item specified images
\item variables
\item constants
\item Fortran operators on these (e.g. `+', or `cos()', ... )
\item extra operators
\end{list}

 (For more details on the structure of the equation see the
 `equation' sub-help.)

 The equation is analysed and the operations are performed. Each
 pixel of the output image contains the results of the equation,
 with the data for the input images coming from the matching pixel
 of those input images.


 More specifically, the equation is analysed to identify the names
 of images and variables and to evaluate constants and isthen
 converted into reverse-Polish notation. The images and variables are
 prompted for in alphabetical order and the program then performs
 simple `stack-arithmetic' to evaluate the expression for each output
 image pixel.

 The output image is made by:-

 Making a new image from scratch - whose X and Y sizes are either
 equal to the minimum X and Y sizes in the set of the input images
 of, if there are no input images, defined by the user.


}\sstdiytopic{Equation}{

 An arithmetic expression of up to 132 characters which gives the
 function to be evaluated for each output image pixel. The syntax
 is similar to Fortran (same operator precedence, etc.) but with the
 some differences, described in the lower help levels here.

{\hspace*{4ex} \bf Input images }

  Input images can be represented in three ways:-

\begin{tabular}{|l|l|p{2.7in}|}\hline
  Method &  Example       &             Use \\ \hline
  Name   &  fred            &           Simple, easy \\

  Marked Name &  {$\backslash$}!../dirname/fred-back{$\backslash$}!
                                  &  For when a file name contains
                                  characters that would be confused
                                      with operators. The `{$\backslash$}!'
                                      denote
                                      the start and end of the name. \\

  Code    & IA  or IB  ... IZ    &      These special symbols are taken
                                      as asking for images. The input
                                      parameters `INA', `INB', etc.
                                      will then be used to ask for the
                                      images. (Must be capitals, i.e.
                                      `ia' will be thought of as the
                                      file `ia.sdf'. \\
\hline\end{tabular}

 The input images must be standard \starman ADAM .SDF images, with
  either `real' 32-bit real values, or `short' 16-bit integer values.
  They can have the `BSCALE' and `BZERO' values, and `magic pixel values'
  indicating `bad' pixels.

{\hspace*{4ex} \bf  Numerical parameters}

  Numerical parameters by any of the variables variables A to Z

{\hspace*{4ex} \bf  Constants}

  Constants by any numerical Fortran constant (real or integer,
  including exponent if required).

{\hspace*{4ex} \bf  Real typing}

  Arithmetic is performed as though all values were real, The
  input images are scaled by their (BSCALE and BZERO) scale/zero
  images before use. The actual calculations are performed in
  double precision, and the results translated back to the
  real or integer*2 format of \starman NDF images.

{\hspace*{4ex} \bf  Fortran functions}

   The standard Fortran functions are available and identified
    by their generic names, i.e.

\begin{tabular}{llllllllll}
        -     &    +      &   **     &   *     &  /     & NEG   &
        SQRT  &    EXP    &   LOG10  &   LOG   \\
        SIN   &    COS    &   TAN    &   ASIN  &  ACOS  & ATAN  &
        ATAN2 &    SINH   &   COSH   &   TANH  \\
        ABS   &    AINT   &   ANINT  &    MOD  &  SIGN  & DIM   &
        MIN   &    MAX    &          &        \\
\end{tabular}

    Note, however, that MIN and MAX may take only 2 arguments.

    To avoid problems with the way the Starlink environment
    handles character parameters, the comma `,' must be replaced with
    the colon `:' for separating function arguments. Similarly, the
    division sign `/' may be replaced by the percent sign `\%', although
    this latter substitution is not necessary for simple constructs or
    when replying to a prompt at the terminal.

{\hspace*{4ex} \bf  Extra functions}

 There are five extra functions available:-

\begin{tabular}{|l|p{4.5in}|}\hline
    XX          & The `X' value of the pixel. \\
    YY          & The `Y' value of the pixel. \\
    CLIP(A,B,C) & This gives the value B so long as it lies in the
                  interval A to C (inclusive). Otherwise it gives a
                  zero result. It may be used to remove output values
                  outside a certain range (e.g. if a division operation
                  has resulted in very large output values). \\
    GAUSS(X)    & Gives gaussian noise with zero mean and standard
                  deviation X (the value returned is different at each
                  pixel and for each call of GAUSS). \\
    RAN(X)      & Gives uniform noise with a value between zero and X
                  (the value returned is different at each pixel and
                  for each call of RAN). \\
\hline\end{tabular}

{\hspace*{4ex} \bf  Example}


  For example, an equation of the form:-

        $$  IA*3.3 + 0.5 + COS(IB) + A + MOD(YY:10) + XX\%3.0 $$

  will fill each pixel with:- \newline

( 3.3 times the pixel in the corresponding pixel of the input image
        given through parameter `INA' ) \newline

+ ( 0.5 ) \newline

+ ( cosine of pixel in the corresponding pixel of the input image
        specified through parameter `INB' ) \newline

+ ( the user defined value of the variable `A' ) \newline

+ ( the `Y' value (not its actual value) of the pixel, modulo 10 ) \newline

+ ( the `X' value (not its actual value) of the pixel divied by 3 ) \newline

  whilst

 $$  fred*3.3+ 0.5 + COS({\backslash}!a1-b1{\backslash}!) + A + MOD(YY:10)
     + XX\%3.0 $$


  will do the same for the images in the files `fred.sdf' and
  `a1-b1.sdf'.


}\sstdiytopic{Input}{

 Only images and variables used in the expressions are prompted for and
 these are requested in alphabetical order, and only once each.

}\sstparameters{


\sstsubsection{BCHOICE = LITERAL (Read)}{
  (Default - `yes'          \hspace*{6ex}       Choice - `yes:no')

 Choose BSCALE and BZERO for the output `real' image to be 1.0, 0.0
 rather than the values inherited from the input images.
 For a `real' image, a value of 1.0,0.0 allows the image to be
 properly processed by other packages.

}\sstsubsection{BSCALE = {\undersc}REAL (Read)}{
  (Default - 1.0 or input image value \hspace*{6ex}
   Range -  -1.0e10 to 1.0e10

  The output image has a (BSCALE/BZERO) scale and zero such that:-

    the `true' value of a pixel = BSCALE*'value' + BZERO.

  These scale and zero are defined by the user, with suggested values
  of 1.0/0.0, or as those of the first input image, if any. This
  parameter defines the `BSCALE' value.

}\sstsubsection{BZERO = {\undersc}REAL (Read)}{
  (Default - 0.0 or input image value \hspace*{6ex}
   Range -  -1.0e10 to 1.0e10

  The output image has a (BSCALE/BZERO) scale and zero such that:-

    the `true' value of a pixel = BSCALE*'value' + BZERO.

  These scale and zero are defined by the user, with suggested values
  of 1.0/0.0, or as those of the first input image, if any. This
  parameter defines the `BZERO' value.


}\sstsubsection{EQN = LITERAL (Read)}{
  (Default - ` '          \hspace*{6ex}       Choice - as defined below)

  The FORTRAN-style expression that gives the elements in the
  pixels of the output image.

  Its style is given the `equation' section above.

}\sstsubsection{INIM = NDF (Read)}{
  (Default - null)

 The input image corresponding to one of the `IA' to `IZ' to be used
 in the arithmetic expression.

 The `IA', `IB', ..., `IZ' in the equation pick up the images from
 the parameters `INA', `INB', ..., `INZ'.

 The input images must be standard \starman ADAM .SDF images, with
 either `real' 32-bit real values, or `short' 16-bit integer values.
 They can have the `BSCALE' and `BZERO' values, and `magic pixel values'
 indicating `bad' pixels.

}\sstsubsection{INVAR = {\undersc}REAL (Read)}{
  (Default - 0.0       \hspace*{6ex}        Range -1.0e37 to 1.0e37)

 The value to be used in the equation for the value of
  the desired variable, from the range `A', `B', ..., `Z'.

 The `help' for all these is kept here, for `invar'.

}\sstsubsection{NXY = {\undersc}INTEGER (Read)}{
  (Default - 1,1 \hspace*{6ex}       Range - 1 to 100000)

  If there are no input images, the user has the choice of the size of
  the output image.

  This parameter defines the `X' and 'Y' sizes of the output image.

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

The name of the file to contain the output image.

 The size of the output image is:-

\begin{list}{{-}}{}
\item That of the `template' image, plus (optionally) some columns.
\item Or has a user defined number of columns with the number of rows
    being the same as the number of rows in the input images.
\item Or, if there are no input images, the number or columns and rows
    are user defined.
\end{list}

  This is a `real' 32-bit image or a `short' 16-bit integer image.

  It has a (BSCALE/BZERO) scale and zero such that:-

  the `true' value of a pixel = BSCALE*'value' + BZERO.

  These scale and zero are defined by the user, with suggested values
  of 1.0/0.0, or as those of the first input image, if any.

  There is also a `magic value' to flag `bad' pixels. This is
  either -32767 (for `short') or a v large number (for `real') or that
  of the first input image, if any. or will be `{\#}1', `{\#}2', etc..

}\sstsubsection{OUTTYPE = LITERAL (Read)}{
  (Default - same as input    \hspace*{6ex}   Choice - `real:short')

  Should the output image be:-

\begin{tabular}{lp{4.5in}}
  `real'  &  This is a 32-bit real image with a precision of about
            1 in 10 million, nad values between +/- 10**38. \\

  `short' &  This is a 16-bit integer image, with a precision of about
            1 in 60000. The numbers are stored on disk as integers
            between -32768 and +32767. They are used in the \starman
            programs as real numbers, by the use of BSCALE and BZERO,
            such that:-

                `used value' = BSACLE*'disk value' + BZERO

            The advantage of this is that if this precision is adequate
            then the files are half the size of `real' files. The
            problem is that one has to be constantly aware of the
            `digitisation' of the images when being stored on disk.
            Also, many other program packages do not use the
            BSCALE and BZERO, so cannot get the `true' values. \\
\end{tabular}

}\sstsubsection{SEED = {\undersc}INTEGER (Read)}{
  (Default - 1234567891    \hspace*{6ex}
   Range - 1200000001 to 1400000001)

  The seed number to be used in any random number generators.
  This is used in the `GAUSS()' and `RAN()' operators. These
  will provide the same pattern of numbers in the same
  seed number is input.

  It has to be a large positive odd number.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - input image title or null, 'Output from Imcalc'
    \hspace*{6ex}   Choice  - any)

  The title for the output image.

}}}



\addcontentsline{toc}{subsection}{ Imcube}


\ajhsect{\arabic{section}}{General Programs - \hspace*{0.2in} IMCUBE}

\sstroutine{IMCUBE}{ Cut 2-D image from 3-D or 4-D image }{

\sstdescription{
  This program cuts a 2-D image out of a 3-D or 4-D image.

  It can squeeze down (add together) a range of planes in the
  other directions.

  If in squeezing down, any of the 3-d or 4-d pixels, added in
  to make the output 2-d pixel, is INVALID, then the output pixel
  is INVALID.

  The input image types it can deal with are:-

   \begin{tabular}{|l|l|}\hline
     Type       &       Name \\ \hline
     32-bit real &      Real \\
     32-bit integer &   Integer \\
     16-bit integer  &  Short \\ \hline
   \end{tabular}


}\sstparameters{

\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The name of the input image.

  The input image must be a standard ADAM .SDF images, with
  either `real' 32-bit real values, `integer' 32-bit integer,
  or `short' 16-bit integer values.

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

  The name of the output image.

  The output image will be a standard ADAM .SDF images, with
  the pixel types of the input image, with either `real' 32-bit
  real values, `integer' 32-bit integer, or `short' 16-bit integer values.

}\sstsubsection{PLANE3 = LITERAL (Read)}{
  (Default - 'xy'      \hspace*{6ex}      Choice - 'xy:xz:yz')

  The plane to cut out of a 3-D cube. The cube is considered
  to have axes XYZ.

}\sstsubsection{PLANE4 = LITERAL (Read)}{
  (Default - 'xy'        \hspace*{6ex}    Choice - 'xy:xz:xt:yz:yt:zt')

  The plane to cut out of a 4-D cube. The cube is considered
  to have axes XYZT.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - input image title    Choice - any)

  The title to be attached as a header to the output image.

}\sstsubsection{XPLANE = {\undersc}INTEGER (Read)}{
  (Default - 1, X size  \hspace*{6ex}     Range - 1 to size of X plane)

  The range, along the X direction, of planes to squeeze down
  (add together) to produce the plane to be cut out. A range of
  1 (say 5,5) cuts out a single plane

  For this to be asked for, the cube has to be either a 3-D one
 (XYZ), or a 4-D one (XYZT).

}\sstsubsection{YPLANE = {\undersc}INTEGER (Read)}{
  (Default - 1, Y size \hspace*{6ex}    Range - 1 to size of Y plane)


  The range, along the Y direction, of planes to squeeze down
  (add together) to produce the plane to be cut out. A range of
  1 (say 5,5) cuts out a single plane

  For this to be asked for, the cube has to be either a 3-D one
 (XYZ), or a 4-D one (XYZT).

}\sstsubsection{ZPLANE = {\undersc}INTEGER (Read)}{
  (Default - 1, Z size \hspace*{6ex}    Range - 1 to size of Z plane)

  The range, along the Z direction, of planes to squeeze down
  (add together) to produce the plane to be cut out. A range of
  1 (say 5,5) cuts out a single plane

  For this to be asked for, the cube has to be either a 3-D one
  (XYZ), or a 4-D one (XYZT).

}\sstsubsection{TPLANE = {\undersc}INTEGER (Read)}{
  (Default - 1, T size  \hspace*{6ex}     Range - 1 to size of T plane)

 The range, along the T direction, of planes to squeeze down
  (add together) to produce the plane to be cut out. A range of
  1 (say 5,5) cuts out a single plane

  For this to be asked for, the cube has to be either a 3-D one
 (XYZ), or a 4-D one (XYZT).

}}}



\addcontentsline{toc}{subsection}{ Imcut}


\ajhsect{\arabic{section}}{Image Programs - \hspace*{0.2in} IMCUT}

\sstroutine{IMCUT}{Cut out, Bin, Flip an Area of an Image }{

\sstdescription{
  Copies one image to another, with the options of:-

\begin{list}{{-}}{}
\item Copying only a section of the input image
\item Binning that section down
\item Inverting the section in X and/or Y
\end{list}

}\sstdiytopic{Binning}{
  It can take rectangular groups of pixels (bins) in the input image
  and output them as a single pixel to the output image. This is
  known as 'binning'. The reduction of a group can be done either
  by taking the bottom left hand pixel of the group and outputting
  that value, or taking the mean of all the pixels in the group.
  If the average is taken, there is the choice of:-


\begin{list}{{-}}{}
\item Ignore any INVALID points in the bin
\item Set the output to INVALID
\end{list}

  If this binning is used, and the chosen area of the input image cannot
  be exactly sub-divided into an integral number of bins, then those
  pixels at the right and top edges of the chosen area that fall
  outside the binned area are ignored.

}\sstdiytopic{Inverting}{

  The inverting is done by defining the section with the start and
  stop locations inverted.

  Thus for example, if one wanted to take all the bottom half of
  an image of size NX by NY, and invert in X, one would define the
  section as:-

          (NX, 1) and (1, NY/2)

}\sstparameters{

\sstsubsection{BIN = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,1   \hspace*{6ex}   Range - 1 to max size of image)

  The size of the groups of pixels that are to binned to make
  the output image. If the default is taken, no binning is done.

  If the sampling step in both X and Y is not one, then either the 1st
  (blh) pixel of the bin is output ('yes'), or the average of the bin
  is output ('no').

  If the average is taken, there is the option to either ignore any
  INVALID points in the bin, or to set the output to INVALID.

}\sstsubsection{CHECK = LITERAL (Read)}{
  (Default - 'no'      \hspace*{6ex}      Choice - 'no:yes')

  In taking the average, ignore any INVALID points in the input bin
  ('yes'), or to set the output to INVALID ('no').

}\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The name of the input image file.

  The input image must be a standard \starman ADAM .SDF image, with
  either `real' 32-bit real values, or `short' 16-bit integer values.
  It can have the `BSCALE' and `BZERO' values, and `magic pixel values'
  indicating `bad' pixels.

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

  The name of the new file containing the output image.

  The output image will be a standard \starman ADAM .SDF image. It
  will have th same type as the input image, with either `real'
  32-bit real values, or `short' 16-bit integer values.
  It can have the `BSCALE' and `BZERO' values, and `magic pixel values'
  indicating `bad' pixels.

}\sstsubsection{SAMPLE = LITERAL (Read)}{
  (Default - 'highest'     \hspace*{6ex}
   Choice - 'sample:highest:average')

  If the binning step in both X and Y is not one, then either the 1st
  (blh) pixel of the bin is output ('sample'), or the highest pixel of
  the bin (`highest'), or the average of the bin is output ('no').

  If the average is taken, there is the option to either ignore any
  INVALID points in the bin, or to set the output to INVALID.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - input image title, or if null, 'Output from IMCUT'
    \hspace*{6ex}   Choice  - any)

  Title to add to output image

}\sstsubsection{XRANGE = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,input image X size    \hspace*{6ex}     Range - 1 to input image X size)

  X start and X end of the area of image to cut out and put in new image.

  If the X end is smaller than the X start, then the output image is
  inverted in X.

}\sstsubsection{YRANGE = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,input image Y size   \hspace*{6ex}      Range - 1 to input image Y size)

  Y start and Y end of the area of image to cut out and put in new image.

  If the Y end is smaller than the Y start, then the output image is
  inverted in Y.


}}}



\addcontentsline{toc}{subsection}{ Imdes}


\ajhsect{\arabic{section}}{Image Programs - \hspace*{0.2in} IMDES}

\sstroutine{IMDES}{List, Write, Delete, Copy Image Descriptors }{

\sstdescription{
  List, write, delete or copy the descriptors of an image.

  Choose which one of the four options you wish to do, with
  the `OPTION' parameter. Then do that option.

}\sstdiytopic{Copy Option}{


  Copy all descriptors from `IN' image to `OUT' image.

  There are two options:-

\begin{list}{{-}}{}
\item If a descriptor to be copied from the input image exist in
    the output image, should the descriptor from the input image
    overwrite that already in the output image?

\item    If this overwriting is to take place, should multi-line
    descriptors which are overwritten be entirely deleted?
\end{list}

}\sstdiytopic{Delete Option}{

  Allows all or some descriptor items to be deleted from an image.

  If only some are to be deleted, then the `LOOP' parameter is
  set to `yes', then the program loops, asking for new descriptor
  names until a `null' response is input. If it is set to `no',

}\sstdiytopic{List Option}{

  Types out the descriptors of an image.

  It types the size; pixel value scale and zero; title.

  Then it asks whether you want all descriptors output or just specificied
  ones. If you want all, it outputs them. If you want specific ones, it
  asks for the name of a specific descriptor. You give it, and it types
  out the descriptors value. It then repeats asking for names until you
  reply with a null (' ` or $<$carriage return$>$).

  You can specify that the program looks at only one descriptor before
  exiting. This mode is chosen with the `ALL{\undersc}LIST=no' and
  `ONLYONE=yes' setting of the parameters.

}\sstdiytopic{Write Option}{

  Allows descriptor items to be overwritten with new information, or
  inserted if they were not present, into an image.

  If the `LOOP' parameter is set to `yes', then the program loops,
  asking for new descriptor names until a `null' response is input.
  If it is set to `no', then only one descriptor is asked for.

}\sstparameters{

\sstsubsection{ALL{\undersc}DEL = LITERAL (Read)}{
  (Default - `all'   \hspace*{6ex}         Choice - `all:some')

  In deleting descriptors, delete them all, or just some?

}\sstsubsection{ALL{\undersc}LIST = LITERAL (Read)}{
  (Default - `all'   \hspace*{6ex}         Choice - `all:some')

  In the listing, do you want all the descriptors output (`all'),
  or just specified one or ones (`some')?

}\sstsubsection{DELETE = LITERAL (Read)}{
  (Default - `yes'   \hspace*{6ex}         Choice - `yes:no')

 In copying descriptors from input image to output image, and
 if a descriptor to be copied from the input image exists in
 the output image, the descriptor from the input image is to
 overwrite that already in the output image, then:-

 Should multi-line descriptors which are overwritten be
 entirely deleted?

}\sstsubsection{FORMAT = LITERAL (Read)}{
  (Default - `char'   \hspace*{6ex}  Choice - `char:int:real')

 In writing a descriptor, what format should it be in?
 A text string; an integer value; a real value?

}\sstsubsection{IN = NDF (Read)}{
 (Default - null)

  The name of the input image file.

  The input image must be a standard \starman ADAM .SDF image, with
  either `real' 32-bit real values, or `short' 16-bit integer values.

}\sstsubsection{LOOP = LITERAL (Read)}{
  (Default - `yes'       \hspace*{6ex}       Choice - `yes:no')

  If `yes', then the program loops, asking for new descriptor names
  until a `null' response is input. If `no', then only one
  descriptor is asked for.

}\sstsubsection{MORE = LITERAL (Read)}{
  (Default - `yes'       \hspace*{6ex}       Choice - `yes:no')

  Used listing descriptors, and splitting the listing into pages.

  Do you want any more output of these descriptors (if doing all of
  them)or of this descriptor (if doing single specific descriptors)?

}\sstsubsection{NAME = LITERAL (Read)}{
  (Default - ` `       \hspace*{6ex}        Choice - any)

  Name of descriptor you want to use (list;write;delete).

  If you reply with a null (' ` or $<$carriage return$>$), it ceases
  asking for descriptor names.

}\sstsubsection{ONLYONE = LITERAL (Read)}{
  (Default - `no'     \hspace*{6ex}         Choice - `yes:no')

  Do you want the program to look at only one descriptor before
  exiting?

  This option is only asked for if you are listing descriptors, and
  only listing some.

}\sstsubsection{OPTION = LITERAL (Read)}{
  (Default - `list'     \hspace*{6ex}  Choice - `copy:delete:list:write')


  Choose one of the options.

\begin{tabular}{|l|l|}\hline
  Option  &    Function \\ \hline
  Copy    &    Copy descriptors from one image to another \\
  Delete  &    Delete a descriptor(s) from an image \\
  List    &    List descriptor(s) in an image \\
  Write   &    Write descriptors from the keyboard into an image \\
\hline\end{tabular}


}\sstsubsection{OUT = NDF (Read/Write)}{
 (Default - null)

  Output image for `copy' option. This image is actually both
  input and output.

  The image must be a standard \starman ADAM .SDF image, with
  either `real' 32-bit real values, or `short' 16-bit integer values.


}\sstsubsection{OVER = LITERAL (Read)}{
  (Default - `yes'     \hspace*{6ex}         Choice - `yes:no')

  In copying descriptors, overwrite existing values where there
  is an existing descriptor of the same name.

}\sstsubsection{PAGING = LITERAL (Read)}{
  (Default - `no'     \hspace*{6ex}         Choice - `yes:no')

  When listing out descriptors, should the listing halt every 20
  descriptors to give you a chance to read them.? (You then
  carry on with the `MORE' parameter.)

}\sstsubsection{VALUE = LITERAL (Read)}{
  (Default - null     \hspace*{6ex}         Choice - any)

  The character string containing the descriptor, when `writing'
  descriptors.

  If you have input, via the `FORMAT' parameter, that the descriptor
  is to have a character string, then this is put there.
  If it is `real', then it is turned into a real number before
  being put, and if an `integer', turned into an integer.

}}}



\addcontentsline{toc}{subsection}{ Imfits{\undersc}dr}


\ajhsect{\arabic{section}}{Image Programs - \hspace*{0.2in}
IMFITS{\undersc}DR}

\sstroutine{IMFITS{\undersc}DR}{Read simple FITS image from a disk file }{

\sstdescription{
  Reads a disk file with a simple FITS image in it, and produces
  a \starman Adam SDF (NDF) format image, which the other \starman
  programs can read.

  If the input is 16-bit, a 16-bit integer output image is suggested.
  If it is 32-bit (integer or real), a 32-bit real output image is.

  A simple line of information about the image is typed out.

  A further line of reference may be typed out with entries for:-

  `File', `object name', `filter', `ra', `dec', `date',  `time', `exposure'.

}\sstdiytopic{Fits format}{
  The file must be a 16-bit integer or a 32-bit integer or real image.

  It wants a 2-D image.
  If it has one dimension, it is treated as though the other is NY=1.
  If it has more than two dimensions, only the first XY plane is taken.

  That is one that starts with a series of sets of 36 lines of `headers',
  with the last set containing the `END'.

  The headers must start:-

\vspace*{2mm}\begin{tabular}{lp{2in}ll}
  SIMPLE  &= \hspace*{40mm}     T & / & FITS STANDARD \\
  BITPIX  &= \hspace*{40mm}     ? & / & FITS BITS/PIXEL \\
  NAXIS   &= \hspace*{40mm}     2 & / & NUMBER OF AXES \\
  NAXIS1  &= \hspace*{40mm}     ? & / & \\
  NAXIS2  &= \hspace*{40mm}     ? & / & \\
\end{tabular}

    where `?' must be 16, 32, or -32 for BITPIX, and the size of the image
    must be in NAXIS1 and NAXIS2. (The -32 is the FITS code for a 32-bit
    real image.)

  The file must have consist of the FITS standard complete 2880 byte blocks.

}\sstdiytopic{Optional line}{
  In addition to the information about the size of the image typed out,
  the program optionally can type out a line of astronomical information.

  This contains:-

  `File', `object name', `filter', `ra', `dec', `date',  `time', `exposure'.

  As the information for all except the first can be in arbitrarily
  named descriptors, the user has to input the names of those descriptors.

}\sstparameters{

\sstsubsection{DATE = LITERAL (Read)}{
  (Default - `DATE'   \hspace*{6ex}         Choice - any)

  The name of the descriptor holding the date that the exposure
  was made on.

  This is only asked for if the second optional information line is
  being put out.

}\sstsubsection{DEC = LITERAL (Read)}{
  (Default - `DEC'   \hspace*{6ex}         Choice - any)

  The name of the descriptor holding the Declination of the exposure.

  This is only asked for if the second optional information line is
  being put out.

}\sstsubsection{DO{\undersc}INFO = LITERAL (Read)}{
  (Default - `no'   \hspace*{6ex}     Choice - `yes:no')

  Type out the optional information line, giving information on the
  exposure.

  This line contains:-

  `File', `object name', `filter', `ra', `dec', `date',  `time', `exposure'.

}\sstsubsection{FILTER = LITERAL (Read)}{
  (Default - `FILTER'   \hspace*{6ex}         Choice - any)

  The name of the descriptor holding the Filter of the exposure.

  This is only asked for if the second optional information line is
  being put out.

}\sstsubsection{IN = LITERAL (Read)}{
 (Default - null)

  The name of the input FITS file.

  Include the qualifier, if there is one. That is `R001.fits', for
  example.

}\sstsubsection{OBJECT = LITERAL (Read)}{
  (Default - `OBJECT'   \hspace*{6ex}         Choice - any)

 The name of the descriptor holding the name of the Object of the exposure.

  This is asked for, to get what to put in the `title' of the output
  image. It is also used for the second optional information line, if that
  is being put out.

}\sstsubsection{OUT = NDF (Write)}{
 (Default - null)

  The name of the output NDF file.

  If the input is 16-bit, a 16-bit integer output image is suggested.
  If it is 32-bit (integer or real), a 32-bit real output image is.

  The image will be a standard \starman ADAM .SDF image.
  It will have the `BSCALE' and `BZERO' values, and `magic pixel values'
  indicating `bad' pixels.

}\sstsubsection{OUTTYPE = LITERAL (Read)}{
  (Default - see below     \hspace*{6ex}         Choice - `real:short')

  Is the output image to be a 16-bit integer image ('short'), or
  a 32-bit real image ('real')?

  The program takes as default the number of bits per pixel in the
  input FITS file (the BITPIX header).

}\sstsubsection{RA = LITERAL (Read)}{
  (Default - `RA'   \hspace*{6ex}         Choice - any)

  The name of the descriptor holding the Right Ascension of the exposure.

  This is only asked for if the second optional information line is
  being put out.

}\sstsubsection{TIME = LITERAL (Read)}{
  (Default - `TIME'   \hspace*{6ex}         Choice - any)

  The name of the descriptor holding the Time (UT, Sid T, etc) of the
  exposure.

  This is only asked for if the second optional information line is
  being put out.

}}}



\addcontentsline{toc}{subsection}{ Imflash}


\ajhsect{\arabic{section}}{Image Programs - \hspace*{0.2in} IMFLASH}

\sstroutine{IMFLASH}{Display Image}{

\sstdescription{
  IMFLASH displays an image on an image display with a minimum
  of interaction with the user. It `flashes' an image up on the
  screen.

  The program calculates the `best' contrast to display the image
  at. This assumes that much of the image is sky with some noise.
  The display is -2/+5 std dev about the mean. This brings up
  faint features.

  The image is displayed in black and white, with black denoting
  high values. `Invalid' pixels are displyed as white.

  If the image is too large to be displayed on the image, it is binned
  down (with square bins), so that it does fit into the display.

  The image disappears when the user ends the program. Thus if you
  want to have an image displayed, while you do something else, then
  leave the image displayed, and start another window, start \starman
  there, and do what you want to do there.

}\sstparameters{

\sstsubsection{ENOUGH = LITERAL (Read)}{
  (Default - `yes'     \hspace{6ex}      Choice - `yes:no')

  Have you had enough of looking at the image?

  If you have, then the program will exit, and if you are using a
  workstation the image will vaish from the screen.

}\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The name of the file containing the input image.

  The input image must be a standard \starman ADAM .SDF image, with
  either `real' 32-bit real values, or `short' 16-bit integer values.
  It can have the `BSCALE' and `BZERO' values, and `magic pixel values'
  indicating `bad' pixels.


}}}



\addcontentsline{toc}{subsection}{ Imjoin}


\ajhsect{\arabic{section}}{Image Programs - \hspace*{0.2in} IMJOIN}

\sstroutine{IMJOIN}{Mosaic Several Images into One Image}{

\sstdescription{
 This program is used to merge several images into one new image.

 The key features are:-

\begin{list}{{-}}{}
\item The addition of each image is done in such a way that the
      each pixel in the output image has the `weighted' contribution
      from each input image.

\item The input images can be `transformed', that is given a
      displacement, rotation, and stretch in the XY plane.

\item For each image, the pixel values can have a zero level
      subtracted and can be scaled before being added into the output
      image.
\end{list}

 The program can, less usually, combine two `reference' images.

 The output can be an `real' 32-bit image or a `short' 16-bit integer image,
 or a real 32-bit `reference' image.

 The reference image can contain more information than the simple
 output image, and is accompanied by a `load' image, which means it
 can be input into IMJOIN again without loosing any information.

}\sstdiytopic{Method}{
 This program is intended for the purpose of making a large image from
 a number of images.

 The input images can be placed in a normal output image or as an
 output `reference' image. The reference image can either then be used
 as a normal image (but see the comment in the `Details' help section),
 or used as a further input to another run of IMJOIN.

{\hspace*{4ex} \bf A Simple Point}

 If the input images were simply added in, then when images overlapped
 the output pixels would have double inputs and be too high. This
 problem is solved by some simple arithmetic.

 It works by adding image(s) into a `reference' image.

 The reference image has an accompanying `load' image which records for
 each pixel how many input images have contributed to that pixel. Thus
 a new input pixel value gets added in to give the output value as:-


$$    OUT\_VAL =  \frac{OUT\_VAL.(Present~number~of~inputs) + IN\_VAL}{
                     Present~number~of~inputs + 1} $$


{\hspace*{4ex} \bf Scaling the Input Images}

 There is a further facility, in that the input images may have
 different `scales'. Thus if there are two images which have different
 exposure times, then simply adding them in together will result in
 mismatched pixels.

 This is solved by applying a `scale' to each input image.

 When the new image is added in, each pixel that gets a value from the
 new image is scaled by a factor. Each pixel is multiplied by this
 scale factor. Then at the end the output pixel is divided by the sum
 of the `scales'. Thus if the scaling were due, in fact, to different
 exposure times, the `scale' could be inversely proportional to the
 exposure times.

 Since the scale is multiplied into the pixel values, it is recommended
 that the longest exposure have a `scale' of 1.0, and the others in
 proportion. This avoids loosing accuracy when the output image (which
 is real) is later converted back to a short integer one.

 Thus a pixel, from an input image of the `SCALE' parameter of IN\_SCALE,
 with a pixel value of IN\_VAL will be added to a reference image pixel
 of scale SCALE\_VAL and value REF\_VAL so that the output pixel value
 will be:-

 $$ OUT\_VAL = \frac{REF\_VAL.SCALE\_VAL + IN\_VAL}{SCALE\_REF + IN\_SCALE}$$

 and the output `scale' image will be:-

 $$ OUT\_SCALE = SCALE\_VAL + IN\_SCALE $$


{\hspace*{4ex} \bf Subtracting a Zero from the Images}

 There is a facility for subtracting a mean `zero' level from each input
 image before the process of scaling, transforming and inputting starts.

 This is useful when the input images have been taken under different
 conditions of sky brightness and each has an extra, uniform,
 contribution from the sky background. This level can be automatically
 estimated and subtracted from the image.

 This is not a good idea when there is large scale structure truly
 present in the imagea, as a mean level from this in each image will
 also be subtracted, leading to strange effects.

}\sstdiytopic{Pixel Interpolation}{
  As the transformation coefficents do not necessarily result in
  each pixel in an input image corresponding exactly to the pixel
  locations in the output image, it is necessary to interpolate
  between the input pixels to see what value to put into the
  output pixel.

  This interpolating from the grid of input image pixels onto the
  output image can be done in one of three ways:-

\begin{tabular}{|c|p{4in}|}\hline
  Method & Action \\ \hline
  NEAREST  &  Take the nearest input image pixel. \\
  LINEAR   &  Make a linear combination of the four input image
              pixels around the output image pixel. \\
  UNIFORM  &  Make a weighted mean of the nine adjacent input image
              pixels (linearly combined), so that the ouput image pixels
              have a constant noise value.  \\ \hline
\end{tabular}

  The default is LINEAR.

 The NEAREST method is the simplest, and actually no interpolation is
 done.

 All interpolation methods have the drawback that they will miss high
 and low points `between' the pixels. Thus if there is structure on a
 scale commensurate with the pixel sizes, there will tend to be a
 smoothing of the high and low points. Thus, an image with stars in it
 runs the risk that the star peaks will be smoothed down.

 A drawback with `LINEAR' is that an output pixel in the centre of four
 input pixels will be the mean of those, and thus have a lower noise
 than an output pixel on an input pixel, in which case it would only
 have the mean of that single pixel. Thus the provision of the `UNIFORM'
 mode.

}\sstdiytopic{Reference Image Adding}{
 It sometimes happens that one has run IMJOIN twice, and one wants to
 combine the two resultant `reference' and `load' images. This can be
 done.

 The combining is done assuming that the images are already exactly
 aligned. The output `reference' and `load' images are made, dealing
 with the `weights' in the proper manner.

}\sstdiytopic{Transformation}{
 The `transformation' of the input image pixel locations into the
 output images pixel locations is done with a linear transformation.

 Thus:-

$$     x1 = c1 + c2.x + c3.y $$
$$     y1 = c4 + c5.x + c6.y  $$

 where: (x,y) are the coordinates in the input image.
        (x1,y1) are the coordinates in the output `reference' image,

  The default is no translation, rotation or stretching:-

$$     x1 = 0.0 + 1.0*x + 0.0*y $$
$$     y2 = 0.0 + 0.0*x + 1.0*y $$

}\sstdiytopic{Details}{
 The input reference, input load, output reference, and output load
 images are all real (32 bit). The input image, and the output image are
 integer*2.

 If there is no input reference image, then a default null one is
 assumed, with a default null load image.

 `Invalid' pixels in an input image are not transferred over to the
 corresponding pixel in the output image, unless that pixel has had no
 valid input data yet. If an output image pixel has had only `invalid'
 input image pixels, and then a new input image delivers a valid
 pixel value, that overwrites the `invalid' flag in the output pixel.

 Up to ten input images can be used. If it is desired to load more
 than ten, then run the program again.

}\sstdiytopic{Warnings}{
  This program can seem very slow or inoperative, because of the
  number and sizes of the files used/made. Also the size of the
  output files may be larger than you expect.

}\sstparameters{

\sstsubsection{DOOUT = LITERAL (Read)}{
  (Default - `yes'      \hspace*{6ex}          Choice - `yes:no')

  An output 'reference' image will be made. Do you want the normal
  output image as well?

}\sstsubsection{IN = NDF (Read)}{
 (Default - null)

 The name of the input image. This can be for the parameters:-
  IN1, IN2, .... IN10.

 A null entry means that there are no more input images

 The input image must be a standard \starman ADAM .SDF image, with
 either `real' 32-bit real values, or `short' 16-bit integer values.
 It can have the `BSCALE' and `BZERO' values, and `magic pixel values'
 indicating `bad' pixels.


}\sstsubsection{INLOAD = NDF (Read)}{
 (Default - null)

 The name of the input `load' image.

 This is the image which contains for each pixel the `weight' of
 the pixels values already added into the corresponding `reference'
 image  pixel.

 - This must be a `Real*4' image.

 - This is only asked for if a `reference' image has been input.

 - A null  response is invalid.

  The image must be a standard \starman ADAM .SDF image, `real' 32-bit
  real values. It can have the `BSCALE' and `BZERO' values, and
  `magic pixel values' indicating `bad' pixels.

}\sstsubsection{INLOAD1 = NDF (Read)}{
 (Default - null)

 The name of the first input `load' image.

 This is the image which contains for each pixel the `weight' of
 the pixels values already added into the corresponding first
 `reference' image  pixel.

 - This must be a `Real*4' image.

 - A null  response is invalid.

  The image must be a standard \starman ADAM .SDF image, `real' 32-bit
  real values. It can have the `BSCALE' and `BZERO' values, and
  `magic pixel values' indicating `bad' pixels.

}\sstsubsection{INLOAD2 = NDF (Read)}{
 (Default - null)

 The name of the second input `load' image.

 This is the image which contains for each pixel the `weight' of
 the pixels values already added into the corresponding second
 `reference' image  pixel.

 - This must be a `Real*4' image.

 - A null  response is invalid.

  The image must be a standard \starman ADAM .SDF image, `real' 32-bit
  real values. It can have the `BSCALE' and `BZERO' values, and
  `magic pixel values' indicating `bad' pixels.

}\sstsubsection{INREF = NDF (Read)}{
 (Default - null)

 The name of the input `reference' image.

 A null response indicates that the  user says that one does
 not exist. If one does not exist, the program creates one with
 all pixels set at the `BLANK' parameter value.

 This must be a `Real*4' image.

  The image must be a standard \starman ADAM .SDF image, `real' 32-bit
  real values. It can have the `BSCALE' and `BZERO' values, and
  `magic pixel values' indicating `bad' pixels.

}\sstsubsection{INREF1 = NDF (Read)}{
 (Default - null)

 The name of the first input `reference' image.

 - A null response is invalid.

 - This must be a `Real*4' image.

  The image must be a standard \starman ADAM .SDF image, `real' 32-bit
  real values. It can have the `BSCALE' and `BZERO' values, and
  `magic pixel values' indicating `bad' pixels.

}\sstsubsection{INREF2 = NDF (Read)}{
  (Default - null)

 The name of the second input `reference' image.

 - A null response is invalid.

 - This must be a `Real*4' image.

  The image must be a standard \starman ADAM .SDF image, `real' 32-bit
  real values. It can have the `BSCALE' and `BZERO' values, and
  `magic pixel values' indicating `bad' pixels.

}\sstsubsection{METHOD = LITERAL (Read)}{
  (Default - `'linear'     \hspace*{6ex}
   Choices - `linear:nearest:uniform')

  This interpolating from the grid of input image pixels onto the
  output image can be done in one of three ways:-


\begin{tabular}{|c|p{4in}|}\hline
  Method & Action \\ \hline
  NEAREST  &  Take the nearest input image pixel. \\
  LINEAR   &  Make a linear combination of the four input image
              pixels around the output image pixel. \\
  UNIFORM  &  Make a weighted mean of the nine adjacent input image
              pixels (linearly combined), so that the ouput image pixels
              have a constant noise value.  \\ \hline
\end{tabular}

 For more information, see the `Pixel Interpolation' help at a higher
 level in the IMJOIN help.

}\sstsubsection{OUT = NDF (Read)}{
  (Default - null)

  The name of the file to contain the output image. If this
  is null, then no output image will be made.

  The image will be a standard \starman ADAM .SDF image, with
  either `real' 32-bit real values, or `short' 16-bit integer values.
  It will have the `BSCALE' and `BZERO' values, and `magic pixel values'
  indicating `bad' pixels.

}\sstsubsection{OUTLOAD = NDF (Write)}{
  (Default - null)

  The name of the output reference `scale' image. This is only
  asked for if an output reference image is made.

  This will be created as a `real' 32-bit image.

}\sstsubsection{OUTMODE = LITERAL (Read)}{
  (Default - `new'      \hspace*{6ex}      Choices - `new:reference')

 The program can do two things:-

   - The usual mosaicing in of new input images.

   - The less usual adding together of two `reference' images.

 The two modes are described in the higher levels of the IMJOIN help.

 The program is usally used in the `New' mode.

}\sstsubsection{OUTREF = NDF (Write)}{
  (Default - null)

  The name of the output reference image. If this
  is null, then no output image will be made.

  This will be created as a `real' 32-bit image.

}\sstsubsection{OUTSCALE = {\undersc}REAL(2) (Read)}{
  (Default - input scale, zero      \hspace*{6ex}
   Range - 2 real numbers in the range -1.0e20 to 1.0e20)

  Input the BSCALE and BZERO of the output image.

  The `true value'' of a pixel = BSSCALE*`stored value' + BZERO

}\sstsubsection{OUTTYPE = LITERAL (Read)}{
  (Default - same as input  \hspace*{6ex}   Choices - `real:short')

 Should the output image be:-

\begin{tabular}{lp{4.5in}}
  `real' &   This is a 32-bit real image with a precision of about
            1 in 10 million, nad values between +/- 10**38 \\

  `short' &  This is a 16-bit integer image, with a precision of about
            1 in 60000. The numbers are stored on disk as integers
            between -32768 and +32767. They are used in the \starman
            programs as real numbers, by the use of BSCALE and BZERO,
            such that:-
                `used value' = BSACLE*'disk value' + BZERO

            The advantage of this is that if this precision is adequate
            then the files are half the size of `real' files. The
            problem is that one has to be constantly aware of the
            `digitisation' of the images when being stored on disk.
            Also, many other program packages do not use the
            BSCALE and BZERO, so cannot get the `true' values. \\
\end{tabular}


}\sstsubsection{SCALE = {\undersc}REAL (Read)}{
  (Default - 1.0            \hspace*{6ex}        Range - 0.0 to 1.0e8)

 The scale you want the first image to be put at. The image is
 multiplied by this before adding into the output (after
 subtracting any zero level).

 This is the help for `SCALE1', `SCALE2', ... `SCALE10',
 the scales for the input images.

 This could, for a series of images of different exposure times,
 be inversely proportional to the exposure times. Since the scale is
 multiplied into the pixel values, it is recommended that the longest
 exposure have a `scale' of 1.0, and the others in proportion. This
 avoids loosing accuracy when the output image (which is real) is
 later converted back to a short integer one.

}\sstsubsection{SHIFT = LITERAL (Read)}{
  (Default - `xyshift'      \hspace*{6ex}    Choice - `full:xyshift')

 What shift to apply to the input images?

\begin{tabular}{ll}
   Option &   Action \\ \hline
   Full   &   Do a full shift with shift, rotation, stretch \\
   Shift  &   Do a shift with just an XY shift \\
\end{tabular}

  Of course, if no shift is to be applied, respond `xyshift' and
  put `0,0' as the shift.

}\sstsubsection{SIZE = {\undersc}INTEGER(2) (Read)}{
  (Default - 100,100 or largest needed  \hspace*{6ex} Range - 1 to 100000)

  If no reference image is input, then this is the size of
  the one to make. The default will be just large enough to take
  all the input images.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - null             \hspace*{6ex}       Choice - any)

  The title to add to the output image.

}\sstsubsection{TITLEL = LITERAL (Read)}{
  (Default - null            \hspace*{6ex}        Choice - any)

  The title to add to the output reference load image.

}\sstsubsection{TITLER = LITERAL (Read)}{
  (Default - null            \hspace*{6ex}        Choice - any)

  The title to add to the output reference image.

}\sstsubsection{XCOEFF = {\undersc}REAL(3) (Read)}{
  (Defaults - 0.0,1.0,0.0       \hspace*{6ex}    Range -1.0e8 to 1.0e8)

 This is the help for `XCOEFF1', `XCOEFF2', ... `XCOEFF10',
 the X coefficents for the input images.

 The X transformation coefficents of the set to transform the
 first input image coordinates to the reference image. These
 are in the form:-

  $$   x1 = c1 + c2.x + c3.y $$
  $$   y1 = c4 + c5.x + c6.y $$

 where: (x,y) are the coordinates in the input image.
        (x1,y1) are the coordinates in the reference image,

  The default is no translation, rotation or stretching:-

  $$   x1 = 0.0 + 1.0*x + 0.0*y $$
  $$   y2 = 0.0 + 0.0*x + 1.0*y $$


}\sstsubsection{YCOEFF = {\undersc}REAL(3) (Read)}{
  (Defaults - 0.0,0.0,1.0      \hspace*{6ex} Range -1.0e8 to 1.0e8)

 This is the help for `YCOEFF1', `YCOEFF2', ... `YCOEFF10',
 the Y coefficents for the input images.

 The Y transformation coefficents of the set to transform the
 first input image coordinates to the reference image. These
 are in the form:-

  $$   x1 = c1 + c2.x + c3.y $$
  $$   y1 = c4 + c5.x + c6.y $$

 where: (x,y) are the coordinates in the input image.
        (x1,y1) are the coordinates in the reference image,

  The default is no translation, rotation or stretching:-

  $$   x1 = 0.0 + 1.0*x + 0.0*y $$
  $$     y2 = 0.0 + 0.0*x + 1.0*y $$


}\sstsubsection{ZERO = LITERAL (Read)}{
  (Default - `no'      \hspace*{6ex}          Choice - `yes:no')

  Do you want a `zero' level removed from the input image before
  scaling and adding to the output image?

}}}



\addcontentsline{toc}{subsection}{ Imkey}


\ajhsect{\arabic{section}}{Image Programs - \hspace*{0.2in} IMKEY}

\sstroutine{IMKEY}{ Keyboard Entry of Pixel Values}{

\sstdescription{
  This program inputs pixel values into an image from the keyboard.

  The user inputs the following information on the keyboard:-

  Whether there is an input image to put data into, or whether an
  entirely new image is to be made.

  The user then inputs the pixel values.

}\sstparameters{


\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The name of the file containing the input image. A null
  response will mean that a new image is to be made.

  The input image must be a standard \starman ADAM .SDF image, with
  either `real' 32-bit real values, or `short' 16-bit integer values.
  It can have the `BSCALE' and `BZERO' values, and `magic pixel values'
  indicating `bad' pixels.

}\sstsubsection{INVALXY = {\undersc}INTEGER(2) (Read)}{
  (Default - last (start 1,1)  \hspace*{6ex} Range - 1 to max image size)

  Pixel XY position to put 'invaid' pixel magic value.

}\sstsubsection{LEVEL = {\undersc}REAL (Read)}{
  (Default - 0.0    \hspace*{6ex}    Range - -1.0e10 to 1.0e10)

  Level to add to all pixels in the new output image.

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

  The name of the new file containing the output image.

  The image will be a standard \starman ADAM .SDF image, with
  either `real' 32-bit real values, or `short' 16-bit integer values.
  It will have the `BSCALE' and `BZERO' values, and `magic pixel values'
  indicating `bad' pixels.

}\sstsubsection{OUTSCALE = {\undersc}REAL(2) (Read)}{
  (Default - 1.0,0.0 or input scale, zero      \hspace*{6ex}
   Range - 2 real numbers in the range -1.0e20 to 1.0e20)

  Input the BSCALE and BZERO of the output image.

  The `true value'' of a pixel = BSSCALE*`stored value' + BZERO

}\sstsubsection{OUTTYPE = LITERAL (Read)}{
  (Default - same as input image  \hspace*{6ex}   Choice  - `real:short')


  Should the output image be:-

\vspace*{2mm}\begin{tabular}{lp{4in}}
  'real'  &  This is a 32-bit real image with a precision of about
            1 in 10 million, nad values between +/- 10**38 \\

  'short' &  This is a 16-bit integer image, with a precision of about
            1 in 60000. The numbers are stored on disk as integers
            between -32768 and +32767. They are used in the \starman
            programs as real numbers, by the use of BSCALE and BZERO,
            such that:-
                'used value' = BSACLE*'disk value' + BZERO

            The advantage of this is that if this precision is adequate
            then the files are half the size of 'real' files. The
            problem is that one has to be constantly aware of the
            'digitisation' of the images when being stored on disk.
            Also, many other program packages do not use the
            BSCALE and BZERO, so cannot get the 'true' values. \\
\end{tabular}

}\sstsubsection{SIZE = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,1  \hspace*{6ex} Range - 1 to 100000)

  As there is no input image, you have to tell the program
  how big an image you want.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - input image title, or if null, 'Output from IMKEY'
    \hspace*{6ex}   Choice  - any)

  A character string (up to 50 characters) to be added to the output
  file as its 'title'.

}\sstsubsection{VALUE = {\undersc}REAL (Read)}{
  (Default - present value  \hspace*{6ex} Range - -1e10 to 1.0e10)

  Pixel value to insert at this position?

}\sstsubsection{XY = {\undersc}INTEGER(2) (Read)}{
  (Default - last (1,1)  \hspace*{6ex} Range - 0 tp max image size)

  Pixel XY position to put a value into?

  Respond 1,0 to input INVALID pixel, 0,1 to end.


}}}



\addcontentsline{toc}{subsection}{ Import}


\ajhsect{\arabic{section}}{Image Programs - \hspace*{0.2in} IMPORT}

\sstroutine{IMPORT}{ Copies descriptors between extensions }{

\sstdescription{
  In the ADAM system, the image descriptors are kept in
  separate sections, called `extensions'. \starman programs
  access only the `Starman extension'.

  If you are using Adam NDF images which have not been made by
  {\it Starman}, then if there are image descriptors in the one of the
  other ADAM extensions, then you will need to copy the descriptors
  into the Starman extension, where the \starman programs look for
  them.

  An example of this would be CCD FITS images read in with the
  KAPPA FITSIN program, when the descriptors would be in the FITS
  extension. This is, in fact, set as the default, a copy from the
  FITS extension to Starman extension.


  This program loads the contents on one 'extension' that contains a
  set of 'descriptors' into another 'extension'. It does not create
  a new image. Thus you need write access to the input image, as
  well as the usual read access.

  It has some suggestions for extension names for reading from and
  writing to, but you can copy between any extensions.

}\sstparameters{

\sstsubsection{DELETE = LITERAL (Read)}{
  (Default - `no'   \hspace*{6ex}   Choice  - `yes:no')

  Delete the contents of extension (and the extension itself) that you
  are reading the descriptors from.

}\sstsubsection{FROM = LITERAL (Read)}{
  (Default - `fits'   \hspace*{6ex}   Choice  - `fits:starman:figaro:other')

  The choice of extension to copy descriptors from.

}\sstsubsection{IN = NDF (Read/Write)}{
  (Default - null)

  The name of the input image file.

}\sstsubsection{IN{\undersc}EXTEN = LITERAL (Read)}{
  (Default - null  \hspace*{6ex}   Choice  - any)

  The name of the extension to copy descriptors from.

  This is asked for if the input extension is not one of the
  standard ones (starman:fits:figaro).

}\sstsubsection{OUT{\undersc}EXTEN = LITERAL (Read)}{
  (Default - null  \hspace*{6ex}   Choice  - any)

  The name of the extension to copy descriptors to.

  This is asked for if the output extension is not one of the
  standard ones (starman:fits:figaro).

}\sstsubsection{TO = LITERAL (Read)}{
  (Default - `starman'   \hspace*{6ex}   Choice  - `fits:starman:figaro:other')

  The choice of extension to copy descriptors from.

}}}



\addcontentsline{toc}{subsection}{ Imrotate}


\ajhsect{\arabic{section}}{Image Programs - \hspace*{0.2in} IMROTATE}

\sstroutine{IMROTATE}{Rotate an Image by  90, 180, or 270 Degrees}{

\sstdescription{
  Rotates an image anti-clockwise by 90, 180, or 270 degrees.

}\sstparameters{

\sstsubsection{DEGREES = LITERAL (Read)}{
  (Default - '90'  \hspace{6ex}    Choice - `90:180:270')

  Number of degrees anti-clockwise to rotate image.

}\sstsubsection{IN = NDF (Read)}{
 (Default - null)

  The name of the input image file.

  The input image must be a standard \starman ADAM .SDF image, with
  either `real' 32-bit real values, or `short' 16-bit integer values.

}\sstsubsection{OUT = NDF (Write)}{
 (Default - null)

  The name of the new file containing the output image.

  The output image will be a standard \starman ADAM .SDF image, with
  the same pixel types, either `real' 32-bit real values or `short'
  16-bit integer values, as the input image.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - input image title, or if null, 'Output from IMROTATE'
   Choice  - any)

  Title to add to output image

}}}



\addcontentsline{toc}{subsection}{ Imsmooth}


\ajhsect{\arabic{section}}{Image Programs - \hspace*{0.2in} IMSMOOTH}

\sstroutine{IMSMOOTH}{ Smooth an Image }{

\sstdescription{
  Smooth an image to make a new image.

  Smoothing by:-

\begin{list}{{-}}{}
\item 'top-hat' in a rectangular box
\item median in a rectangular box
\item circular Gaussian profile in a rectangular box
\end{list}

}\sstdiytopic{Method}{

  Method of smoothing:-

\vspace*{2mm}\begin{tabular}{|l|p{4.0in}|} \hline
   Name  &  Function  \\ \hline
   box  &   Applies a 'top-hat' smoothing, running a rectangular
           box over the image, calculating the average of this box,
           and applying that value at the pixel. Clearly the box
           must have sides of an odd number of pixels, so that the
           box is centered on the pixel. \\

   median &  Applies a median smoothing, running a rectangular
           box over the image, calculating the median of this box,
           and applying that value at the pixel. Clearly the box
           must have sides of an odd number of pixels, so that the
           box is centered on the pixel. \\

   gauss &  Applies a Gaussian smoothing, running a rectangular
           box over the image, calculating for the pixel at the centre
           of the box what contribution it makes to the individual
           pixels in the box, if were spread by a Gaussian point-spread-
           function. (This is scaled so that the total contributions
           to all the pixels in the box sum to the original pixel
           value. Thus a flat image would give an identical output image.)
           Clearly the box must have sides of an odd number of pixels, so
           that the box is centered on the pixel. \\
\hline\end{tabular}\vspace*{2mm}

  The problem of the edge of the image, for both methods is dealt with
  by assuming that the input image 'spreads' out beyond its limits, with
  the values at the edges.

  `Invalid' pixels in the rectangular box are ignored, unless they
  are all invalid, in which case the output value is set as invalid.


}\sstparameters{

\sstsubsection{BOX = {\undersc}INTEGER(2) (Read)}{
  (Default - 3,3    \hspace*{6ex}   Range - 1 to max size of image)

  The XY size of the rectangular box sued in 'top-hat'
  smoothing. The sides must have an odd number of pixels.

}\sstsubsection{GBOX = {\undersc}INTEGER(2) (Read)}{
  (Default - 10*rad,10*rad  \hspace*{6ex}   Range - 1 to max size of image)

  The XY size of the rectangular box sued in 'gaussian'
  smoothing. The sides must have an odd number of pixels.

  'rad' here is the Gaussian radius of the smoothing function.

}\sstsubsection{GRADIUS = {\undersc}REAL (Read)}{
  (Default - 2.0   \hspace*{6ex}   Range - 1.0e-5 to 1.0e5)

 Radius of the Gaussian to use in the Gaussian smoothing.

 This is radius at which the profile is 1/e of its peak height.

}\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The name of the input image file.

  The input image must be a standard \starman ADAM .SDF image, with
  either `real' 32-bit real values, or `short' 16-bit integer values.
  It can have the `BSCALE' and `BZERO' values, and `magic pixel values'
  indicating `bad' pixels.

}\sstsubsection{METHOD = LITERAL (Read)}{
  (Default - `box'    \hspace*{6ex}   Choice  - `gauss:box:median')

  Method of smoothing.

  For a description of the methods, see the section on `Method'
  above.

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

  The name of the new file containing the output image.

  The output image will be a standard \starman ADAM .SDF image, with
  the same type as the input image, either `real' 32-bit real values,
  or `short' 16-bit integer values.
  It will have the `BSCALE' and `BZERO' values, and `magic pixel values'
  indicating `bad' pixels, of the input image

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - input image title, or if null, 'Output from IMCUT'
    \hspace*{6ex}   Choice  - any)

  Title to add to output image

}}}



\addcontentsline{toc}{subsection}{ Imstat}


\ajhsect{\arabic{section}}{Image Programs - \hspace*{0.2in} IMSTAT}

\sstroutine{IMSTAT}{ Statistics of an Image Area  }{

\sstdescription{
  Calculates statistics of an area of the image

  Takes an input area of an image, and calculates the mean and
  standard deviation, minimum and maximum pixel values (with their
  locations), the number of valid and invalid pixels, and the sum
  of the valid pixel values.

  The results are typed out, and also put as parameters of the
  program

}\sstdiytopic{Output parameters}{
 These are stored as parameters of the program. They are:-

   Max, Mean, Min, Nbad, Ngood, Stddev, Sum, Xmaxloc, Xminloc,
   Ymaxloc, Yminloc

}\sstparameters{

\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The name of the input image file.

  The image must be a standard \starman ADAM .SDF image, with
  either `real' 32-bit real values, or `short' 16-bit integer values.
  It can have the `BSCALE' and `BZERO' values, and `magic pixel values'
  indicating `bad' pixels.

}\sstsubsection{XRANGE = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,input image X size     Range - 1 to input image X size)

  X start and X end of the area of image to analyse

}\sstsubsection{YRANGE = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,input image Y size     Range - 1 to input image Y size)

  Y start and Y end of the area of image to analyse

}\sstsubsection{MEAN = {\undersc}REAL (Write)}{
  (Output parameter)

  Set by program. The mean of the valid pixel values in the
  selected area.

}\sstsubsection{NBAD = {\undersc}INTEGER (Write)}{
  (Output parameter)

  Set by program. The number of invalid pixels in the selected area.

}\sstsubsection{NGOOD = {\undersc}INTEGER (Write)}{
  (Output parameter)

  Set by program. The number of valid pixels in the selected area.

}\sstsubsection{STDDEV = {\undersc}REAL (Write)}{
  (Output parameter)

  Set by program. The standard deviation of the valid pixel values in
  the selected area.

}\sstsubsection{SUM = {\undersc}REAL (Write)}{
  (Output parameter)

  Set by program. The sum of the values of the valid pixels in the
  selected area.

}\sstsubsection{XMAXLOC = {\undersc}INTEGER (Write)}{
  (Output parameter)

  Set by program. The X location of the pixel with the maximum value
  in the selected area.

}\sstsubsection{XMINLOC = {\undersc}INTEGER (Write)}{
  (Output parameter)

  Set by program. The X location of the pixel with the minimum value
  in the selected area.

}\sstsubsection{YMAXLOC = {\undersc}INTEGER (Write)}{
  (Output parameter)

  Set by program. The Y location of the pixel with the maximum value
  in the selected area.

}\sstsubsection{YMINLOC ={\undersc}INTEGER (Write)}{
  (Output parameter)

  Set by program. The Y location of the pixel with the minimum value
  in the selected area.


}}}



\addcontentsline{toc}{subsection}{ Imtype}


\ajhsect{\arabic{section}}{Image Programs - \hspace*{0.2in} IMTYPE}

\sstroutine{IMTYPE}{Convert `Type' of Image}{

\sstdescription{
  This program converts an image whose pixel values are stored
  in one type into one whose pixel values are stored as another type.

  The types it can deal with are:-

\vspace*{2mm}\begin{tabular}{|c|c|}\hline
     Type            &  Name \\ \hline
     32-bit real     &  REAL \\
     32-bit integer  &  INTEGER \\
     16-bit integer  &  SHORT \\ \hline
\end{tabular}\vspace*{2mm}

 It deals with values above and below the range of permitted values
 in the output image, by truncating them at the edge of the permitted
 ranges. Permitted ranges:- INTEGER -2147483648 to 2147483647 and
 SHORT   -327678 to 32767

 For the conversion from Real to Integer or Short, and from Integer
 to Short, there is the possibility of overflow of the numbers, so
 they may be scaled by the formula

            `stored value' = (`true value'-BZ)/BS

 where the `stored value' is the one that must not overflow the
 output data format limits.

 It translates the `INVAL' parameter to and from real and integer.

 If an `INVAL' value lies outside the permitted output ranges, this
 is dealt with by putting it at the format pixel value limits.

}\sstdiytopic{Output type}{

 The output types are one of these:-

\vspace*{2mm}\begin{tabular}{|l|p{4.0in}|}\hline
  'real' &   This is a 32-bit real image with a precision of about
            1 in 10 million, nad values between +/- 10**38. \\

  'short' &  This is a 16-bit integer image, with a precision of about
            1 in 60000. The numbers are stored on disk as integers
            between -32768 and +32767. They are used in the \starman
            programs as real numbers, by the use of BSCALE and BZERO,
            such that:-

                'used value' = BSACLE*'disk value' + BZERO

            The advantage of this is that if this precision is adequate
            then the files are half the size of 'real' files. The
            problem is that one has to be constantly aware of the
            'digitisation' of the images when being stored on disk.
            Also, many other program packages do not use the
            BSCALE and BZERO, so cannot get the 'true' values. \\


  'integer' & This is a 32-bit integer image, with a precision of about
            1 in 4 thousand million. The numbers are stored on disk as
            integers between -2147483648 and +2147483647. Such images
            cannot be accessed by \starman programs. \\
\hline\end{tabular}\vspace*{2mm}

}\sstparameters{

\sstsubsection{IN = NDF (Read)}{
 (Default - null)

  The name of the input image.

  The image must be a standard \starman ADAM .SDF image, with
  `real' 32-bit real values, or `integer' 32-bit integer values, or
  `short' 16-bit integer values.
  It can have the `BSCALE' and `BZERO' values, and `magic pixel values'
  indicating `bad' pixels.

}\sstsubsection{OUT = NDF (Write)}{
 (Default - null)

  The name of the output image.

  The image will be a standard \starman ADAM .SDF image, with
  `real' 32-bit real values, or `integer' 32-bit integer values, or
  `short' 16-bit integer values.
  It will have the `BSCALE' and `BZERO' values, and `magic pixel values'
  indicating `bad' pixels.

}\sstsubsection{OUTTYPE = LITERAL (Read)}{
  (Default - `short'   \hspace*{6ex}      Choice - `real:integer:short')

  The type of the output image.

  For a description of the types, see the section above.

}\sstsubsection{RANGE = LITERAL (Read)}{
  (Default - `no'       \hspace*{6ex}    Choice - `yes:no')

  Calculate range of input data, i.e. its maximum and minimum
  pixel value?

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - input image title  \hspace*{6ex}    Choice - any)

  The title to be attached as a header to the output image.

}}}



\addcontentsline{toc}{subsection}{ Imweed}


\ajhsect{\arabic{section}}{Image Programs - \hspace*{0.2in} IMWEED}

\sstroutine{IMWEED}{ Set range of pixels values to `invalid' }{

\sstdescription{
  Set range of pixels values to `invalid'.

  Set those pixels to `invalid', whose values are within a range
  of pixel values.

}\sstparameters{

\sstsubsection{IN = NDF (Read)}{
 (Default - null)

  The name of the input image.

  The input image must be a standard \starman ADAM .SDF image, with
  `real' 32-bit real values, or `integer' 32-bit integer values, or
  `short' 16-bit integer values.
  It can have the `BSCALE' and `BZERO' values, and `magic pixel values'
  indicating `bad' pixels.

}\sstsubsection{OUT = NDF (Write)}{
 (Default - null)

  The name of the output image.

  The image will be a standard \starman ADAM .SDF image, with
  `real' 32-bit real values, or `integer' 32-bit integer values, or
  `short' 16-bit integer values.
  It will have the `BSCALE' and `BZERO' values, and `magic pixel values'
  indicating `bad' pixels.

}\sstsubsection{RANGE = {\undersc}REAL(2) (Read)}{
  (Default - 0.0,0.0   \hspace*{6ex}    Range - -1.0e20 to 1.0e20)

  Range of pixel values, such that if a pixel had a value within that
  range, the pixel is set to `invalid'.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - input image title  \hspace*{6ex}    Choice - any)

  The title to be attached as a header to the output image.

}}}

\end{small}


\newpage
\section{Table Programs}
\ajhsect{\arabic{section}}{TABLE PROGRAMS}
\label{se:progtb}
\newpage

\begin{small}
\addcontentsline{toc}{subsection}{ Tbcalc}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in} TBCALC}

\sstroutine{TBCALC}{Calculate table elements}{

\sstdescription{
 Calculate table elements.

 This program allows arithmetic and mathematical functions to be
 applied to a number of input tables and constants by means of a
 FORTRAN-like expression which specifies the required functions. In
 addition to the standard FORTRAN facilities, a number of special
 functions are available (e.g. for adding noise).

}\sstdiytopic{Method}{
 For up to 20 columns of the output table, the user inputs a
 Fortran-like equation (through the parameters EQN1, EQN2, ...).
 These equations can contain references to:-

 \begin{list}{{-}}{}
   \item specified columns of specified tables (which must all have the
     same number of rows, but may have different numbers of columns)
   \item variables
   \item constants
   \item Fortran operators on these (e.g. `+', or `cos()', ... )
  \end{list}

 (For more details on the structure of these equations ) see
 the `equation' section.)

 For each specified output column, the relevant equation is
 analysed and the operations are performed. Each row of that output
 column contains the results of the equation, with the data for
 the input tables coming from the matching row of those input tables.

 More specifically, the equations are analysed to identify the names
 of tables and variables and to evaluate constants and are then
 converted into reverse-Polish notation. The tables and variables are
 prompted for in alphabetical order and the program then performs
 simple `stack-arithmetic' to evaluate the expression for each output
 table element.

 The output table can be made by:-

  \begin{list}{{-}}{}
   \item  Imposing the calculated columns on a `template' table - which
          must be one of the input tables.
   \item  Imposing the calculated columns on a `template' table - which
          must be one of the input tables - and zeroing all the other
          columns
   \item  Making a new table from scratch - whose total number of
          columns is user defined, and whose columns that are not
          calculated set to zero.
   \end{list}

 If a 'template' table is used, and any of the calculated columns
 are 'beyond' the end of the template, then the output is extended
 to hold those, with any columns missed out set to zero.

 The size of the output table is:-

  \begin{list}{{-}}{}
  \item That of the `template' table, plus (optionally) some columns.
  \item Or has a user defined number of columns with the number of rows
        being the same as the number of rows in the input tables.
  \item Or, if there are no input tables, the number or columns and rows
        are user defined.
  \end{list}

}\sstdiytopic{Equations}{
 An arithmetic expression of up to 80 characters which gives the
 function to be evaluated for each output table element. The syntax
 is similar to Fortran (same operator precedence, etc.) but with the
 following differences:

 \begin{enumerate}
 \item Input tables are represented by any of the variables TAn1, TBn2, ...
    to TZnm, where the `A', `B' etc., refer to the table and the `n1',
    `n2', .. etc., refer the column number in that table to use.
 \item Numerical parameters by any of the variables variables A to Z
 \item  Constants by any numerical Fortran constant (real or integer,
    including exponent if required).
 \item Arithmetic is performed as though all values were real, The actual
    calculations are performed in double precision, and the results
    translated back to reals.
 \item The standard Fortran functions are available and identified
    by their generic names, i.e. SQRT, EXP, LOG10, LOG, SIN, COS, TAN,
    ASIN, ACOS, ATAN, ATAN2, SINH, COSH, TANH, ABS, AINT, ANINT, MOD,
    SIGN, DIM, MIN and MAX. Note, however, that MIN and MAX may take only
    2 arguments.
 \item To avoid problems with the way the Starlink environment
    handles character parameters:-
    \begin{enumerate}
       \item The comma ',' must be replaced with
             the colon ':' for separating function arguments.
       \item The division sign '\/' may be replaced by the percent sign '\%',
             although this latter substitution is not necessary when
             replying to a prompt at the terminal.
    \end{enumerate}
 \item There are three extra functions available:-

    \begin{tabular}{lp{4in}}
    CLIP(A,B,C) & This gives the value B so long as it lies in the
                 interval A to C (inclusive). Otherwise it gives a
                 zero result. It may be used to remove output values
                 outside a certain range (e.g. if a division operation
                 has resulted in very large output values). \\
    GAUSS(X)    & Gives gaussian noise with zero mean and standard
                 deviation X (the value returned is different at each
                 element and for each call of GAUSS). \\
    RAN(X)      & Gives uniform noise with a value between zero and X
                 (the value returned is different at each element and
                 for each call of RAN). \\
    \end{tabular}
  \end{enumerate}

  For example, an equation of the form:-

 $$        TA2*3.3 + 0.5 + COS(TB1) + A + MOD(RR:10.0) + CC\%3 $$

  will fill each row of a specified output column with:-

 \hspace*{1.0em}( 3.3 times the element in that row of column 2 of input
    table specifed by parameter `INA' ) \hspace*{\fill} \\
  + ( 0.5 ) \hspace*{\fill} \\
  + ( cosine of the element in that row of column 1 of input table
    specifed by parameter `INB' )
   \hspace*{\fill} \\
  + ( the user defined value of the variable `A' ) \hspace*{\fill} \\
  + ( row number, modulo 10 ) \hspace*{\fill} \\
  + ( (column number)/3 ) \hspace*{\fill} \\


}\sstdiytopic{Input}{
  Only tables and variables used in the expressions are prompted for and
  these are requested in alphabetical order, and only once each.

}\sstparameters{

\sstsubsection{A = {\undersc}REAL (Read)}{
  (Default - 0.0         \hspace*{6em}        Range -1.0e37 to 1.0e37)

  The value to be used in the expressions for the value of
  the variable 'A'.

  [This help applies to any of the input variables from 'A', 'B',
   'C' .... 'Z'.]


}\sstsubsection{CLEAR = LITERAL (Read)}{
  (Default - `no'  \hspace*{6em}    Choice - `yes:no')

  Are the columns of the output table that have not been set by
  the equations to be set to zeroes?

}\sstsubsection{COLUMN = {\undersc}INTEGER (Read)}{
  (Default - 1         \hspace*{6em}    Range - 0 to 999 )

  The column number in the output table that the results of the
  calculations from the first equation are to be put into.

  A response of zero indicates that no more columns are to be
  calculated.

  [This help applies to 'COLUMN1', 'COLUMN2', ... 'COLUMN20'
   which apply to any of the up to 20 input equations.]

}\sstsubsection{EQN = LITERAL (Read)}{
  (Default - null         \hspace*{6em}    Choice - as defined below)

  The FORTRAN-style expression that gives the elements in the
  defined (by `Column1') column in the output table.

  Its style is given the `equation' section of this help.

  [This help applies to 'EQN1', 'EQN2', ... 'EQN20'
   of any of the up to 20 input equations.]

}\sstsubsection{HEAD = LITERAL (Read)}{
  (Default - see below          \hspace*{6em}      Choice - any)

  The (up to) 20 character string giving the `header' of the
  column for the first equation.

  The default will be that of the template table or just blanks
  if there is no template.

  [This help applies to 'HEAD1', and any of the other 'HEAD2',
   'HEAD3', .... 'HEAD20', of the up to 20 input equations,
   each with its own column from 'NCOLUMN1' , etc..]

}\sstsubsection{INA = NDF (Read)}{
 (Default - null)

 The input table corresponding to 'TA' to be used in the arithmetic
 expressions.

 If a template is used, and no tables are mentioned in the equation,
 this will be used for the template file.

}\sstsubsection{INB = NDF (Read)}{
 (Default - null)

 The input table corresponding to 'TB' to be used in the arithmetic
 expressions.

 [This help is also used for the other input tables 'TC', ... 'TZ'.]

}\sstsubsection{NUMCOLS = {\undersc}INTEGER (Read)}{
  (Default - largest column number defined     \hspace*{6em}
   Range - that to 999)

  The number of columns in the output table. If a template table is
  not being used, then this must be a user-defined value. This
  number must be at least as large as the largest column number
  defined for any of the equations.

}\sstsubsection{NUMROWS = {\undersc}INTEGER (Read)}{
  (Default - 1            \hspace*{6em}    Range - 1 to 100000)

  If there are no input tables, the user has the choice of how
  many rows there are in the output table. Then all the rows will
  have the same set of values for the columns. The names of the
  rows will be `\#1', `\#2', etc..

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

 The output table to contain the result.

 This contains the defined columns. There may be other columns. These
 other columns contain either the values from the input template table,
 or are full of zeroes if there was;- no input tables, no input
 template table, or the user decided to set those columns to zero.

 The size of the output table is:-

  \begin{list}{{-}}{}
  \item That of the `template' table, plus (optionally) some columns.
  \item Or has a user defined number of columns with the number of rows
        being the same as the number of rows in the input tables.
  \item Or, if there are no input tables, the number or columns and rows
        are user defined.
  \end{list}

  The names of the rows will either be those from the template table,
  or will be `\#1', `\#2', etc..

  The table is stored as a standard \starman table in an ADAM .SDF image,
  with `real' 32-bit real values.

}\sstsubsection{SEED = {\undersc}INTEGER (Read)}{
  (Default - 1234567891     \hspace*{6em}    Range - 1200000001 to 1400000001)

  The seed number to be used in any random number generators.
  This is used in the `GAUSS()' and `RAN()' operators. These
  will provide the same pattern of numbers in the same
  seed number is input.

  It has to be a large positive odd number.

}\sstsubsection{TEMPLATE = LITERAL (Read)}{
  (Default - `none'    \hspace*{6em}    Choice -
   `none:ta:tb:tc:td:te:tf:tg:th:ti:tj:tk:tl:tm:tn:to:tp:tq: \\
   \hspace*{\fill} tr:ts:tt:tu:tv:tw:tx:ty:tz')

  The parameter that defines the input table to be used as the
  template for the output table.

  If a template tables is used (selected from the `TA', etc. parameters
  that must come from those already used in the `EQN1', etc.,
  parameters), then the output table is a copy of the that template
  table, except for the new columns values from the equations (with
  the choice of zeroing all the other values).

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - title of input template table or `Output from Tbcalc'
     \hspace*{6em}    Choice - any )

  The title for the output table.

}\sstsubsection{USE{\undersc}TEMPLATE = LITERAL (Read)}{
  (Default - `no'    \hspace*{6em}    Choice - `yes:no')

 There are no input tables, so use a template table to provide
  names, headers, number of rows and columns?


}}}



\addcontentsline{toc}{subsection}{ Tbchart}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in} TBCHART}

\sstroutine{TBCHART}{Star Chart from Table of Positions, Magnitudes }{

\sstdescription{
 This plots out a realistic looking star map, with filled circles,
 bigger for brighter stars, at the positions of an input list of
 star positions and magnitudes. The star identifications may be put
 by the stars. Overlapping stars may be distinguished by having
 circles round all stars. If used, these circles may be removed
 (overwritten).

 The program is worked using a menu-driven approach. You choose
 various options from the menu. This menu can be driven through a
 'panel-button' type of display.

 With an interactive device, a cursor can be used to read out the
 cursor position and the details of the nearest star read out.

 The user has control of the ranges of star positions and magnitudes
 that are plotted out and the size of the area plotted. More than
 one input list may be plotted.

 In a star identifier, a `\#' as the 1st charcater is ignored, and a star
 identifier consisting solely of `\#' is not put out.

}\sstdiytopic{Menu}{
  This is the menu of options open to the user.

\begin{tabular}{|l|p{4.0in}|}\hline
   Option  &    Function \\ \hline
  clear    &     Clear plot \\
  close    &     Close the graphical device \\
  cursor   &     Use cursor to get position and nearest star \\
  exit     &     Exit from this program \\
  getdata  &     Get star posns and magns from an input table \\
  label    &     Plot by each star its name from input table \\
  lsize    &     Set the size of the names written by the stars \\
  mrange   &     Set the magnitude range of stars to be plotted \\
  mscale   &     Set rate which stars get bigger with magnitude \\
  open     &     Open the plot device \\
  panel    &     Switch between panel and keyboard option selection \\
  plot     &     Plot the stars as filled-in circles \\
  prange   &     Set the range in X an Y of stars to be plotted \\
  psize    &     Set the range of the graph axes in X and Y \\
  ring     &     Write rings round stars \\
  ring{\undersc}rem &     Remove rings written round stars \\
\hline\end{tabular}


 To input cursor positions, position cursor at desired point
 and press any key. End by locating cursor outside graph


}\sstdiytopic{Cursor Use}{
   To input cursor positions, position cursor at desired point
   and press any key. End by locating cursor outside graph

}\sstdiytopic{Panel Choice}{
 In the menu-driven mode of this program, there is the capability
 to interact with this menu in a `windows' type mode. If you choose
 the `Panel' option in the `Option' choice, then if you have an
 X-window device a small panel appears on the screen. This has what look
 like buttons with all the available options. You select these by
 putting a cursor on the `button' and then pressing a mouse button.

 The panel has a `help' button which lists out one line
 descriptions of all the options. This button also tells you what
 the program is doing:- 'working', 'waiting', etc.

}\sstparameters{

\sstsubsection{DEVLIMX = {\undersc}INTEGER(2) (Read)}{
  (Default - Min,max in table     \hspace*{6ex}
   Range - -1.0e10 to 1.0e10)

  The X start and end of the area to be plotted.

}\sstsubsection{DEVLIMY =  {\undersc}INTEGER(2) (Read)}{
  (Default - Min,max in table   \hspace*{6ex}
   Range - -1.0e10 to 1.0e10)

  The Y start and end of the area to be plotted.

}\sstsubsection{GTYPE = LITERAL (Read)}{
  (Default - `ask'    \hspace{6ex}    Choice - any)

  A character string giving the local name for the graphics
  display type.

  `xwindows' will put it out on the screen of your workstation,
  if you are using one.

  If `ask' is input, then the program asks a very similar question,
  in a different way. A response here of `?' will bring up a listing
  of all the possible names of graphics devices which are supported
  on your machine, and you then input the appropriate name.

}\sstsubsection{IN = NDF (Read)}{
  (default - null)

  The name of the file containing the input (position, magnitude)
  table.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{LINECOL = LITERAL (Read)}{
  (Default - `black'    \hspace{6ex}    Choice - `black:white')

  Colour of plot lines. This is determined by whether you have a
  black or white background to your plots.


}\sstsubsection{LSIZE =  {\undersc}REAL (Read)}{
  (Default - 1.0        \hspace*{6ex}             Range - 0.0 to 1.0e10)

  The size of the text to be used when plotting the stars
  identifiers. A size of 1.0 gives letters with heights of about
  1/100th of the plotted Y range.

}\sstsubsection{MMIN =  {\undersc}REAL (Read)}{
  (Default - Maximum in table   \hspace*{6ex}
   Range - -1.0e10 to 1.0e10)

  The zero point in the scale for plotting the radii of the
  circles to represent a star. These circles have radii
  of:- (MMIN-mag)*MSCALE in terms of the plotted scale.

}\sstsubsection{MRANGE =  {\undersc}REAL(2) (Read)}{
  (Default - Min,max in table   \hspace*{6ex}
   Range - -1.0e10 to 1.0e10)

  The start and end of the range of magnitudes in the table
  that a star can have to be plotted.

}\sstsubsection{MSCALE =  {\undersc}REAL (Read)}{
  (Default - 1.0         \hspace*{6ex}     Range - -1.0e10 to 1.0e10)

  The 'SCALE' in the scale for plotting the radii of the
  circles to represent a star. These circles have radii
  of:- (MMIN-mag)*MSCALE in terms of the plotted scale.

}\sstsubsection{NUMBUTT = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - see below   \hspace*{6ex} Range - 2 to 3)

  Number of `X-Window' buttons available on the mouse.

  Some devices have two and some have three buttons available. This
  can depend both on their actual presence, and also on the X Windows
  software that is being run.

  With three buttons, then the \starman programs use all three, with
  the right-hand button being used mainly as the `exit' button.

  With two buttons, then the third button is simulated by pressing
  both of the buttons down, with the middle one being pressed slightly
  BEFORE the left-hand one. Use of the middle button in its normal
  way has to be modified, in that one has to pause for half a second
  after using it.

  [This parameter is usally 'hidden', with the machine manager setting
   it to the appropriate value for the local set-up. Sometimes it will
   be left to the user to set, depending on his software configuartion.]

}\sstsubsection{OPTION = LITERAL (Read)}{
  (Default - see below   \hspace*{6ex}             Choices - see below)

  This is the menu of options open to you.

  See the section above on `Menu'

}\sstsubsection{XRANGE =  {\undersc}INTEGER(2) (Read)}{
  (Default - Min,max in table   \hspace*{6ex}
   Range - -1.0e10 to 1.0e10)

  The X start and end of X range of positions in the table
  that a star can have to be plotted.

}\sstsubsection{YRANGE =  {\undersc}INTEGER(2) (Read)}{
  (Default - Min,max in table   \hspace*{6ex}
   Range - -1.0e10 to 1.0e10)

  The Y start and end of Y range of positions in the table
  that a star can have to be plotted.

}}}



\addcontentsline{toc}{subsection}{ Tbcomps}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in} TBCOMPS}

\sstroutine{TBCOMPS}{ Find Star Companions in Table}{

\sstdescription{
   This takes a table and finds positions in it which are within a
   given annulus of any other position in the table. Such positions are output
   to an output table.

   Optionally, it can output those positions which are NOT within these
   annulii.

}\sstparameters{

\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The file containing the input table

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{LIMITS = {\undersc}REAL(2) (Read)}{
  (Default - 0.0,0.0     \hspace*{6ex}       Range - 0.0 to 1.0e10)

  Annulus around every position which is either forbidden or
  necessary to output positions.

}\sstsubsection{OPTION = LITERAL (Read)}{
   (Default - 'in'     \hspace*{6ex}        Choice -  'in:not{\undersc}in')

   Find all positions within (in) or not within (not{\undersc}in)
   annulus round any other position.

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

  The file containing the output table.

  The table will be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - `Output from TBCOMPS'   \hspace*{6ex}           Choice - any)

    The Title to be added to the output file

}}}



\addcontentsline{toc}{subsection}{ Tbcut}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in} TBCUT}

\sstroutine{TBCUT}{ Cut Parts Out of a Table to Make a New One }{

\sstdescription{
   This cuts out columns and rows of a table and ouputs those cut out
   rows and columns to a new table in a new file.

   You input up to 20 stretches of columns and up to 20 stretches
   of rows to cut out and save.

}\sstparameters{

\sstsubsection{COL = {\undersc}INTEGER(2) (Read)}{
  (Default - 0,all   \hspace*{6ex}      Range - 0 to no of columns)

   The 1st section of columns to cut out and save. Thus `1,2' would cut
   out and save the first two columns of the input table.

   If the first number is zero, then this entry is ignored
   and no more column sections are requested.

   This help is applied to the up to 10 parameters, 'COL{\undersc}1',
   'COL{\undersc}2', 'COL{\undersc}3', .... 'COL{\undersc}10',
   for the 10 possible different column sections.

}\sstsubsection{IN = NDF (Read)}{
  (Default - null)

   The name of the file containing the input table.


  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.


}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

  The name of the file to contain the output table.

  The table will be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{ROW = (Read)}{
  (Default - 0,all   \hspace*{6ex}      Range - 0 to no of rows)

   The 1st section of rows to cut out and save. Thus `1,2' would cut
   out and save the first two rows of the input table.

   If the first number is zero, then this entry is ignored
   and no more row sections are requested.

   This help is applied to the 10 parameters, 'ROW{\undersc}1',
   'ROW{\undersc}2', 'ROW{\undersc}3', .... 'ROW{\undersc}10',
   for the 10 possible different row sections.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - `Output from TBCUT'  \hspace*{6ex}         Choice - any)

  The keyword to be added to the output file as a 'Title'.

}}}



\addcontentsline{toc}{subsection}{ Tbdes}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in} TBDES}

\sstroutine{TBDES}{ List/copy/write/delete table descriptors }{

\sstdescription{
  List, copy, write or delete the descriptors of a table.

  Choose which one of the four options you wish to do, with
  the `OPTION' parameter. Then do that option. The options are:-

\begin{list}{{-}}{}
\item List some or all of the descriptors of a table
\item Copy all descriptors to another table
\item Write new descriptors from keyboard to table
\item Delete some of the descriptors of a table
\end{list}

}\sstdiytopic{List option}{
  It types the size; pixel value scale and zero; title.

  Then it asks whether you want all descriptors output or just specificied
  ones. If you want all, it outputs them. If you want specific ones, it
  asks for the name of a specific descriptor. You give it, and it types
  out the descriptors value. It then repeats asking for names until you
  reply with a null (' ` or $<$carriage return$>$).

  You can specify that the program looks at only one descriptor before
  exiting. This mode is chosen with the `ALL{\undersc}LIST=no' and `ONLYONE=yes'
  setting of the parameters.

}\sstdiytopic{Copy option}{
  This copies the descriptors of one table onto another.
  Optionally you can choose to overwrite or not descriptors that
  already occur in the output table. If you do overwrite, then
  you can choose to delete existing descriptors before overwriting.

}\sstdiytopic{Write option}{
  Allows descriptor items to be overwritten with new information, or
  inserted if they were not present, into a table.

  If the `LOOP' parameter is not set (or set to `yes'), then the
  program loops, asking for new descriptor names until a `null'
  response is input. If it is set to `no' (in the command line),
  then only one descriptor is asked for.

}\sstdiytopic{Delete option}{
  Allows descriptor items to be deleted from a table.

  If the `LOOP' parameter is not set (or set to `yes'), then the
  program loops, asking for new descriptor names until a `null'
  response is input. If it is set to `no' (in the command line),
  then only one descriptor is asked for.

}\sstparameters{

\sstsubsection{ALL{\undersc}LIST = LITERAL (Read)}{
  (Default - `yes'   \hspace*{6ex}     Choice - `yes:no')

  Do you want all the descriptors output, or just specified one or ones?

}\sstsubsection{CVALUE = LITERAL (Read)}{
  (Default - null  \hspace*{6ex}     Choice - any)

  A character string to give the `value' to insert into
  the descriptor.

  This is asked from when in the `write' mode, using descriptors
  input from the keyboard and writing them to the table.

}\sstsubsection{DELETE = LITERAL (Read)}{
  (Default - `yes'   \hspace*{6ex}     Choice - `yes:no')

  In copying descriptors, delete any previously existing descriptor
  with the same name as any of the descriptors to be copied over.

  This is only asked for if you have already said you wish to
  overwrite any existing decsriptor.

}\sstsubsection{FORMAT = LITERAL (Read)}{
  (Default - `char'   \hspace*{6ex}     Choice - `char:int:real')

  The data format for the descriptor to have.

  This is asked from when in the `write' mode, using descriptors
  input from the keyboard and writing them to the table.

}\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The name of the input table file.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

  In the `write' and `delete' options, this table is also written
  to, and is thus also an `output' file.

}\sstsubsection{IVALUE = {\undersc}INTEGER (Read)}{
  (Default - 0   \hspace*{6ex}        Range - -2147483648 to 2147483647)

  The integer value to give the `value' to insert into
  the descriptor.

  This is asked from when in the `write' mode, using descriptors
  input from the keyboard and writing them to the table.

}\sstsubsection{MORE = LITERAL (Read)}{
  (Default - `yes'   \hspace*{6ex}     Choice - `yes:no')

  Do you want any more typing out of these descriptors (if doing all of
  them) or of this descriptor (if doing single specific descriptors)?

}\sstsubsection{NAME = LITERAL (Read)}{
  (Default - null    \hspace*{6ex}       Choice - any)

  Name of descriptor you want to have its value typed out.

  If you reply with a null (' ` or $<$carriage return$>$), it ceases
  asking for descriptor names.

}\sstsubsection{ONLYONE = LITERAL (Read)}{
  (Default - `no'   \hspace*{6ex}     Choice - `yes:no')

  Do you want the program to look at only one descriptor before
  exiting?

  This option can only be chosen if the `ALL{\undersc}LIST=no' option has
  previously been chosen.


}\sstsubsection{OPTION = LITERAL (Read)}{
  (Default - `list'   \hspace*{6ex}     Choice - `copy:delete:list:write')

 Choose one of the options.

\vspace*{2mm}\begin{tabular}{|l|p{4.0in}|}\hline
  Option  &    Function \\ \hline
  Copy    &    Copy descriptors from one table to another \\
  Delete  &    Delete a descriptor(s) from a table \\
  List    &    List descriptor(s) in a table \\
  Write   &    Write descriptors from the keyboard into a table \\
\hline\end{tabular}\vspace*{2mm}

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

 The output table to copy descriptors from the input table into.

  The table will be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{OVER = LITERAL (Read)}{
   (Default = `yes'  \hspace*{6ex}   Choice - `yes:no')

  In copying descriptors, overwrite existing values where there
  is an existing descriptor of the same name.

}\sstsubsection{PAGING = LITERAL (Read)}{
   (Default = `no'  \hspace*{6ex}   Choice - `yes:no')

  When listing out descriptors, should the listing halt every 20
  descriptors to give you a chance to read them.? (You then
  carry on with the `MORE' parameter.)

}\sstsubsection{RVALUE = {\undersc}REAL (Read)}{
  (Default - 0.0   \hspace*{6ex}   Range - -1.0e37 to 1.0e37)

  The real value to give the `value' to insert into
  the descriptor.

  This is asked from when in the `write' mode, using descriptors
  input from the keyboard and writing them to the table.

}}}





\addcontentsline{toc}{subsection}{ Tbjoin}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in} TBJOIN}

\sstroutine{TBJOIN}{ Concatenate Tables }{

\sstdescription{
  This program allows up to nine tables to be concatenated.

  It allows you to shift the data in the tables relative to each
  other before joining.

  Thus if you have:-

\setlength{\unitlength}{1mm}
\begin{picture}(100,55)
\put(20,25){A}
\put(60,25){B}
\put(10,5){\framebox(30,45){\hspace*{1ex}}}
\put(50,5){\framebox(30,45){\hspace*{1ex}}}
\end{picture}


  you can join them

\setlength{\unitlength}{1mm}
\begin{picture}(100,75)
\put(30,40){A}
\put(60,30){B}
\put(20,20){\framebox(30,45){\hspace*{1ex}}}
\put(40,10){\framebox(30,45){\hspace*{1ex}}}
\end{picture}

   They do not even have to overlap.

   The 2nd (and optionally ) later file is written on top of the 1st
   file data,identifiers, and headers deleting them. Parameters with no
   entry are put to 0.0.

   To simply add one file onto the end of another, use the default
   displacements.

}\sstparameters{

\sstsubsection{COLOFF = {\undersc}INTEGER (Read)}{
 (Default - 0    \hspace*{6ex}       Range - -1000000 to 1000000)

  The number of columns that the parameters in the table are to shifted
  left or right before the table is added, relative to the first
  table.

  Can be +ve or -ve.

  [This help parameter applies to all tables except the first.
  The parameters are 'COLOFF2', 'COLOFF3', ... 'COLOFF9'.]

}\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  One of the up to nine input tables.

  Put null (just 'return') to exit.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

  [This help parameter applies to all tables. The parameters are
  'IN1', 'IN2', ... 'IN9'.]

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

  The output table.

  The table will be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{ROWOFF = {\undersc}INTEGER (Read)}{
 (Default - see below    \hspace*{6ex}      Range - -1000000 to 1000000)

  The number of rows that the parameters in the table are to shifted
  up or down before the table is added, relative to the first input
  table.

  The default is that value which will add this table to the end
  of the previously input tables.

  Can be +ve or -ve.

  [This help parameter applies to all tables except the first.
  The parameters are 'ROWOFF1', 'ROWOFF2', ... 'ROWOFF9'.]

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - That of 1st table or 'Output from TBJOIN'
   \hspace*{6ex}    Choice - any)

      The title for the output table.


}}}



\addcontentsline{toc}{subsection}{ Tbkey}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in} TBKEY}

\sstroutine{TBKEY}{ Input a Table from the Keyboard}{

\sstdescription{
  This program inputs data for a table from the keyboard.

  The user inputs the following information on the keyboard:-

\begin{enumerate}
\item The number of columns the output table will have.

\item The lines (rows) of data, in the format:-

\hspace*{\fill}         r1,r2,r3,,,rn,name   \hspace*{\fill}

     The `r1', `r2' ,,   are the input values. If less numbers than
     the number of columns is input, the later ones will be assigned
     the value zero. Up to 100 entries can be input in the line (up
     to the maximum set by the `NUMCOL' parameter).

     The `name' is the identifier for the row. If this is ommitted
     then the identifier will be "\#N', where `N' is the number of the
     row. The identifier can have up to 20 characters.

     The total length of the character string must be less than or
     equal to 256 characters.

\item A null entry signifying the end of inputting data.

\item The name of the file to output the table to.

\item A text string as the `title' to the table

\item Text strings as `headers' for each column.
\end{enumerate}

   If more than 1000 lines are to be input, you must set the MAXROW
   parameter accordingly, before entering the program.

}\sstparameters{

\sstsubsection{DATA = LITERAL (Read)}{
  ( Default - null     \hspace*{6ex}  Choice - see below)

  A character string giving the data to be input, in the format:-

        \hspace*{\fill}  r1,r2,r3,,,rn,name \hspace*{\fill}

  The `r1', `r2' ,,   are the input values. If less numbers than
  the number of columns is input, the later ones will be assigned
  the value zero. Up to 100 entries can be input in the line (up
  to the maximum set by the `NUMCOL' parameter).

  The total length of the character string must be less than or
  equal to 256 characters.

  Where `name' is the identifier for the row. If this is ommitted
  then the identifier will be "\#N', where `N' is the number of the
  row. The identifier can have up to 20 characters.

  A null entry signifies the end of inputting data.

}\sstsubsection{HEADER = LITERAL (Read)}{
  (Default - see below  \hspace*{6ex}  Choice - see below)

  The character string to act as header for the column. This can
  be up to 20 characters long. This is asked for each column.

  The defaults are:-

\begin{tabular}{|c|l|}\hline
 Column Number & Default \\ \hline
     1 & `X' \\
     2 & `Y' \\
     3 & `MAGNITUDE' \\
  later ones & ` ' \\ \hline
\end{tabular}

}\sstsubsection{NUMCOL = {\undersc}INTEGER (Read)}{
  (Default - 2     \hspace*{6ex}   Range - 1 to 20)

  The number of columns to input into the table. (The identifier
  does not count as a column.)

}\sstsubsection{MAXROW = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - 1000    \hspace*{6ex}   Range - 1 to 1000000)

  The maximum number of rows that can be input.

  This is a hidden parameter, and is not asked for. It can be set on the
  command line, or by setting outside.

}\sstsubsection{OUT = NDF (Read)}{
  (Default - null)

  The name of the file to contain the output table.

  The table will be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - `Output from TBKEY'    \hspace*{6ex}
   Choice - any)

  A character string (up to 50 characters) to be added to the output
  file as its `title'.

}}}



\addcontentsline{toc}{subsection}{ Tblist}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in} TBLIST}

\sstroutine{TBLIST}{ Make a Text file of a Table }{

\sstdescription{
 Make a text (ASCII) version of a table. This can be typed out
 on the user's console, and can be output to an ASCII text file.

}\sstdiytopic{Modes}{

 There are four modes of formatting the output:-

\begin{tabular}{|c|p{4.5in}|}\hline
   Option   &   Output from each row \\ \hline
  'SHORT'   &  The name and the values of the first three columns.
               The values are output in a 12 character floating format. \\
  'FULL'    &  The name (optionally), and all columns. The values are
               output in a 12 character floating format, with four
               values in each line of the output. \\
  'FIXFORM' &  The name (optionally) and up to 15 selected columns are
               output. The number of characters output in the names is
               defined. The values are output with each column having a
               fixed format of having so many places before the
               decimal point, and so many after. \\
  'FORM'    &  Up to 15 selected columns may be chosen from the table.
               These are output with (optionally) the name. The number
               of characters output in the names is defined. The values
               are output in a 12 character floating format, with four
               values in each line of the output. \\
  'HEADER'  &  Just puts out the standard header (see below). \\ \hline
\end{tabular}

}\sstdiytopic{Headers}{

  There is an option to preceed the values by a standard header.
  This gives the title and the headers for the columns.
  This standard is useful, as TBLOAD can use it to input a similar
  (perhaps edited) text file. Its format is:-

\begin{tabular}{|c|l|l|l|}\hline
   No & Contents          & 1st ten characters   &   Contents \\ \hline
   1  & Title             & 'Title is: '         &   up to 50 characters \\
   2  & No of columns     & 'Columns = '         &   Integer \\
   3  & No of rows        & 'Rows =    '         &   Integer \\
   4  & 1st column header & 'HEAD001   '         &   up to 20 characters \\
   5  & 2nd column header & 'HEAD002   '         &   up to 20 characters \\
 ...  &   ....            &     ....            &    .... \\
   X  & No of descriptors &  'NumDes =  '        &    Integer \\
   Y  & 1st descriptor   &  name                 &   value \\
   Y  & 2nd descriptor   &  name                 &   value \\
 ...  &   ....            &     ....            &    .... \\ \hline
\end{tabular}

   There must be the same number of headers as there are columns.

   [The number of columns does not include the names.]

   The 'no of descriptors' line must be there. If there are no
   descriptors, then the number should be '0'.

   [The table size and headers are, strictly speaking, descriptors
    themselves, but they are not counted as such in this
    descriptor count. It is only concerned with other, incidental,
    descriptors.]

}\sstparameters{

\sstsubsection{HEADER = LITERAL (Read)}{
  (Default - see below \hspace*{6ex}     Choice - 'full:short:none')

 The type of the text lines that precede the table contents lines in the
 output.

  The choice of types is:-

\begin{tabular}{|c|p{4.5in}|}\hline
   Choice  &  Contents of the Lines\\ \hline
   Full    &  A standard heading, which gives the size, the title, the
             headers for the columns, and the descriptors. \\
   Short   &  Just the title and the headers in a short form \\
   None    &  Nothing \\ \hline
\end{tabular}

  The standard heading is useful, as TBLOAD can use it to input a similar
  (perhaps edited) text file.

  The default is 'short', or 'full' if 'full' chosen for the value
  output mode.

}\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The name of the file containing the input table

}\sstsubsection{NAFT = {\undersc}INTEGER (Read)}{
  (Default - 2         \hspace*{6ex}         Range - 0 to 100)

  The number of characters after the decimal point in the 1st output
  column.

  [This refers to the up to 15 output columns through the parameters
   'NAFT1', 'NAFT2', ... 'NAFT15'.]

}\sstsubsection{NBEF = {\undersc}INTEGER (Read)}{
  (Default - 4     \hspace*{6ex}      Range - 0 to 100)

  The number of characters before the decimal point in the 1st output
  column.

  [This refers to the up to 15 output columns through the parameters
   'NBEF1', 'NBEF2', ... 'NBEF15'.]

}\sstsubsection{NCOL = {\undersc}INTEGER (Read)}{
  (Default - next       \hspace*{6ex}      Range - 0 to no of columns in table)

  The number of the column in the table to be output in the 1st text
  column.

  If 0 is input, no more columns are asked for.

 [This refers to the up to 15 output columns through the parameters
   'NCOL1', 'NCOL2', ... 'NCOL15'.]


}\sstsubsection{NUMNAME = {\undersc}INTEGER (Read)}{
  (Default - 12           \hspace*{6ex}        Range - 0 to 20)

  The number of characters of the name of each row to output.

  If 0 is chosen, then the name is not output.

}\sstsubsection{OUT = ASCII (Write)}{
  (Default - null     \hspace*{6ex}            Choice - see below)

  The name of the file containing the output ASCII file. This
  should have a descriptor, i.e. a simple choice would be
  'tblist.lis'. If the descriptor is omitted, then '.dat' is
  taken.

  If the default null response is made, then no file is output.

}\sstsubsection{OUTMODE = LITERAL (Read)}{
  (Default - 'short'     \hspace*{6ex}
   Choice - 'short:full:fixform:form')

 The mode of formatting the output.

 There are four modes of formatting the output. They are listed in the
 section above on 'Modes'.

}\sstsubsection{TYPING = LITERAL (Read)}{
  (Default - 'yes'       \hspace*{6ex}             Choice - 'yes:no')

  Type out the output to the user's console?

}}}



\addcontentsline{toc}{subsection}{ Tbload}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in} TBLOAD}

\sstroutine{TBLOAD}{ Turn an ASCII File into a Table  }{

\sstdescription{
  This takes an ASCII text file, and loads the contents into a table.

  The input file may contain either just the numbers or both the names
  and numbers. In the first case, then default names \#1,\#2,,,\#n are
  put into the table. In the second case, the name should be the first
  entry in the line.

  The numbers for one row of the output table may take up more than one
  line in the input file. In this case, all the lines of the input file
  should be in the same format, that is a constant number of lines in
  the input file are put into each row of the output table. Also in this
  case, if names are being input, then the name for each row must occur
  only once in the set of input lines (at the beginnning of the first
  line).

  The numbers in a line in the input file must be separated by blanks
  and/or commas.

}\sstdiytopic{Headers}{
  The table title and headers may be input automatically, if they are
  put in a standard format at the start of the input file. This format
  is a series of lines with the first ten characters being a description
  and the remainder the values. The order of these lines is fixed. It
  is:-


\begin{tabular}{|c|l|l|l|}\hline
   No & Contents          & 1st ten characters   &   Contents \\ \hline
   1  & Title             & 'Title is: '         &   up to 50 characters \\
   2  & No of columns     & 'Columns = '         &   Integer \\
   3  & No of rows        & 'Rows =    '         &   Integer \\
   4  & 1st column header & 'HEAD001   '         &   up to 20 characters \\
   5  & 2nd column header & 'HEAD002   '         &   up to 20 characters \\
 ...  &   ....            &     ....            &    .... \\
   N  & No of descriptors &  'NumDes =  '        &    Integer \\
   N+1  & 1st descriptor   &  name                 &   value \\
   N+2  & 2nd descriptor   &  name                 &   value \\
 ...  &   ....            &     ....            &    .... \\ \hline
\end{tabular}

   There must be the same number of headers as there are columns.

   [The number of columns does not include the names.]

   The 'no ofdescriptors' line must be there. If there are no
   descriptors, then the number should be '0'.

   [The table size and headers are, strictly speaking, descriptors
    themselves, but they are not counted as such in this
    descriptor count. It is only concerned with other, incidental,
    descriptors.]


  If this standard format is not chosen, then the headers are input by
  hand, with the first 20 coming from individual program parameters, and
  any remaining input on a single program parameter.


}\sstparameters{

\sstsubsection{HEAD = LITERAL (Read)}{
  (Default - ' '       \hspace*{6ex}          Choice - see below)

  The character string to put as the header of the next column.
  This may be up to 20 characters long

}\sstsubsection{HEAD001 = LITERAL (Read)}{
  (Default - ' '           \hspace*{6ex}      Choice - see below)

  The character string to put as the header of the 1st column.
  This may be up to 20 characters long

  [This help applies to the up to 20 headers, 'HEAD001', 'HEAD002',
  ..., 'HEAD020'.]

}\sstsubsection{HEADER = LITERAL (Read)}{
  (Default - 'no'         \hspace*{6ex}       Choice - 'yes:no')

  Does the input file start of with the standard header format
  information? If it does, then this format is as given
  in the section above on `headers'.

   There must be the same number of headers as there are columns.

   [The number of columns does not include the names.]

   The 'no of descriptors' line must be there. If there are no
   descriptors, then the number should be '0'.

   [The table size and headers are, strictly speaking, descriptors
    themselves, but they are not counted as such in this
    descriptor count. It is only concerned with other, incidental,
    descriptors.]

}\sstsubsection{HIGNORE = {\undersc}INTEGER (Read)}{
  (Default - 0             \hspace*{6ex}       Range - 0 to 10000)

  As there is not the standard header start to the file, how many
  lines at the start of the file shall be ignored?

}\sstsubsection{IN = LITERAL (Read)}{
  (Default - null)

  The name of the file containing the input text ASCII data.

}\sstsubsection{NAMES = LITERAL (Read)}{
  (Default - 'no'        \hspace*{6ex}        Choice - 'yes:no')

  Does the input file contain a name for each row of
  the output table?

}\sstsubsection{NLINES = {\undersc}INTEGER (Read)}{
  (Default - 1            \hspace*{6ex}       Range - 1 to 1000)

  The number of lines in the input file that the data, for
  each output table row, occupy.

}\sstsubsection{OUT = NDF (Read)}{
  (Default - null)

  The name of the file to contain the output table.

  The table will be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - ' '   \hspace*{6ex}    Choice - any)

  The title to put into the output table. This can be
  up to 50 characters long.

}}}



\addcontentsline{toc}{subsection}{ Tbmatch}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in} TBMATCH}

\sstroutine{TBMATCH}{ Finds Entries with The Same Names in Two Tables }{

\sstdescription{
   This takes two tables and makes two new ones which are copies
   of the old ones, but only contain the entries which do (or
   optionally do not) have names which occur in the other table.

   If the choice is to have entries which do occur in both tables,
   then there is the choice to have those entries occur in the
   output tables either in the same order, or in the order that
   they appeared in their input tables, If the same order is chosen,
   the order is that of occurence in the first table. If there are
   repeated entries with the same names, then only the last such
   occurence is copied over. If the original order is chosen
   however, then those entries occur in the output tables in the
   same order as they occur in their respective input tables and
   repeated entries of the same name are all copied over.

   If the choice is to have entries which do not occur in both
   tables, then those entries occur in the output tables in the
   same order as they occur in their respective input tables.
   Repeated entries of the same name are all copied over.

}\sstparameters{

\sstsubsection{IN1 = NDF (Read)}{
  (Default - null)

  The name of the file with the 1st input table.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{IN2 = NDF (Read)}{
  (Default - null)

  The name of the file with the 2nd input table.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{OPTION = LITERAL (Read)}{
   (Default - 'accept'        \hspace*{6ex}     Choice - 'accept:reject')

   Accept or reject stars who have names in common with the other table.

}\sstsubsection{OUT1 = NDF (Write)}{
  (Default - null)

  The name of the file for the 1st output table.

  The table will be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{OUT2 = NDF (Write)}{
  (Default - null)

  The name of the file for the 2nd output table.

  The table will be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{SAME = LITERAL (Read)}{
  (Default - `yes' \hspace*{6ex} Choice - `yes:no')

  Are entries to be copied over in the same order (`yes'), or
  not (when they are copied in the order they occur in their
  repective input tables) (`no')?

}\sstsubsection{TITLE1 = LITERAL (Read)}{
  (Default - Input 1st table title or 'Output from TBMATCH'  \hspace*{6ex}
   Choice - any)

   The Title to be added to the 1st output file.


}\sstsubsection{TITLE2 = LITERAL (Read)}{
  (Default - Input 2nd table title or 'Output from TBMATCH' \hspace*{6ex}
   Choice - any)

   The Title to be added to the 2nd output file.

}}}



\addcontentsline{toc}{subsection}{ Tbnative}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in} TBNATIVE}

\sstroutine{TBNATIVE}{ Convert Table Format from different machine}{

\sstdescription{
  This programs converts a table made on a different type of machine
  to the format suitable for the machine the program is run on.

  This is not essential, as the programs automatically convert
  tables written on different machines, but it saves time and
  simplifies things if this is done.

  The table must already be in NDF format.

}\sstparameters{

\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The name of the file with the input table.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

  The name of the file for the output table.

  The table will be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}}}



\addcontentsline{toc}{subsection}{ Tbnmatch}


\ajhsect{\arabic{section}}{General Programs - \hspace*{0.2in} TBNMATCH}

\sstroutine{TBNMATCH}{ Put tables in the same order of names}{

\sstdescription{
  Put tables in the same order of names.

  This takes up to 40 tables and reorders the occurence of their rows
  so that the output tables all have the row names in the
  same order. As some tables may not have rows with names that
  occur in other table(s), then dummy rows with zero entries are
  added and/or inserted into the output tables. Such rows are
  flagged with a user defined value set in a user defined column.

  If a table has more than one row with the same name, then of those
  rows, only the last such row is copied over.

  The order of the output rows will be that of the first table,
  then that of those rows in the second table which are not in
  the first table, then that of the rows in the third table that
  are not in the first two, and so on.

  Up to 40 tables may be input.

}\sstparameters{

\sstsubsection{FLAGCOL = {\undersc}INTEGER (Read)}{
  (Default - 3    \hspace*{6ex}
   Range - 1 to smallest number of columns in input tables)

  Column in output tables to put a flag value into to indicate a
  missing entry. The other entries in that row will be set at zero.

}\sstsubsection{FLAGVAL = {\undersc}REAL (Read)}{
  (Default - 50.0          \hspace*{6ex} Range - -1.0e20 to 1.0e20)

  Value to put in `flag' column to indicate a missing entry.
  The other entries in that row will be set at zero.

}\sstsubsection{IN = LITERAL (Read)}{
  (Default - null)

  The input file containing the table.

  Put a null to end. (Must have at least one input table.)

  [This help refers to the up to 40 input tables, through the
  parameters 'IN1', 'IN2', ... 'IN40'.]

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{MAXIMUM = LITERAL (Read)}{
  (Default - 10000    \hspace*{6ex} Range - 1 to 1000000)

  Maximum number of rows allowed to occur in output tables.
  (This is limitedfor the sake of efficiency in the computing.)

}\sstsubsection{OUT1 = LITERAL (Write)}{
  (Default - null)

  The output file containing the reordered (and possibly extended)
  version of the corresponding input table.

  [This help refers to the up to 40 input tables, through the
  parameters 'OUT1', 'OUT2', ... 'OUT40'.]

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{TITLE = LITERAL (Read)}{
 (Default - Input file title or `Output from Tbnmatch'  \hspace*{6ex}
  Choice - any)

 The Title to be inserted in the Output file.

}}}



\addcontentsline{toc}{subsection}{ Tbplot}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in} TBPLOT}

\sstroutine{TBPLOT}{Plot Graph or Histogram from a Table }{

\sstdescription{
 Plots tables or images out onto a graph:-

\begin{enumerate}
   \item The contents of two columns of one or two tables can be plotted
        as X,Y points, or as a line joining those points.
   \item An image may be plotted as a grey-scale image, or as a contour map.
   \item Text and axes labels may be put onto the graph.
   \item The contents of one table column can be plotted as a histogram (not
        onto the graph of actions 1-3).
   \item A cursor position can be read out.
\end{enumerate}

 The program uses either an 'automatic' mode, where the input can be
 done as a simple series of commands, or a menu-driven approach. In the
 latter options from a menu can be repeatedly chosen either from a
 'panel-button' type of display, or via the keyboard.

}\sstdiytopic{Menu}{
  This is the menu of options open to the user.

\vspace*{2mm}\begin{tabular}{|l|p{4.5in}|}\hline
   Option    & Function \\ \hline
   all\_clear &  Clear Display - data and axes \\
   aspect    &  Select between graph having axes on the same scale or
                 being independantly scaled \\
   clear     &  Clear Display - just data \\
   close     &  Close Display \\
   contour   &  Plot the counter map of the image \\
   cursor    &  Get position in graph and nearest table point, with cursor \\
   display   &  Display the image as a picture \\
   exit      &  Exit from program \\
   get\_image &  Open an input image \\
   get\_table &  Open an input table(s) \\
   histogram &  Plot histogram of values in a table column \\
   label     &  Plot axis labels on graph \\
   line      &  Plot table data as line \\
   open      &  Open (new) display device \\
   panel     &  Toggle between keyboard and panel option input \\
   points    &  Plot table data as points \\
   prange    &  Change limits on table X,Y acceptable limits \\
   psize     &  Change the size of the plot \\
   text      &  Plot input text at a position on the graph \\
\hline
\end{tabular}\vspace*{2mm}

}\sstdiytopic{Cursor Use}{
   To input cursor positions, position cursor at desired point
   and press any key on the keyboard, or maybe press any
   button on the cursor. End by locating cursor outside graph
   and pressing a key.

}\sstparameters{

\sstsubsection{ASPECT = LITERAL (Read)}{
  (Default - 'yes' or last   \hspace{6ex}        Choice - 'yes:no')

  Should the graph axes be scaled the same?

  If not, then the X range of the graph will fill the X size of
  the window, whilst the Y range will fill the Y size. If yes, then
  the graph will be plotted with X and Y scales the same (as is done
  with maps).

}\sstsubsection{ATYPE = LITERAL (Read)}{
  (Default - `points'    \hspace{6ex}    Choice - points:line:hist:disp:cont')

 What type of graph do you want plotted?

\vspace*{2mm}\begin{tabular}{|l|l|}\hline
   Option &  Result \\ \hline
   Points &  Plot symbols at table XY positions \\
   Line   &  Plot of a line joining successive table XY positions \\
   Hist   &  A histogram of table, where X = X and Y = number at X \\
   Disp   &  Grey-scale display of image \\
   Cont   &  Contour map of image \\
\hline\end{tabular}\vspace*{2mm}

}\sstsubsection{CONTOUR = {\undersc}REAL(3) (Read)}{
  (Default - see below \hspace*{6ex}  Range - -1.0e20 to 1.0e20)

  The lower and upper limits of image values that are plotted out
  in the contour map, and the step between the contour levels.

  Thus an input of `10.0,100.0,20.0' would put out contour
  levels of (10.0,30.0,50.0,70.0,90.0).

  The default is `(minimum of data),(maximum of data),(1/10th of range)'

}\sstsubsection{DEVLIMX = {\undersc}REAL(2) (Read)}{
  (Default - Min,max in table    \hspace*{6ex}  Range - -1.0e20 to 1.0e20)

  The X values of the ends of the plotted graph.

}\sstsubsection{DEVLIMY = {\undersc}REAL(2) (Read)}{
  (Default - Min,max in table    \hspace*{6ex}  Range - -1.0e20 to 1.0e20)

  The Y values of the ends of the plotted graph.

}\sstsubsection{GTYPE = LITERAL (Read)}{
  (Default - `ask'    \hspace{6ex}    Choice - any)

  A character string giving the local name for the graphics
  display type.

  `xwindows' will put it out on the screen of your workstation,
  if you are using one.

  If `ask' is input, then the program asks a very similar question,
  in a different way. A response here of `?' will bring up a listing
  of all the possible names of graphics devices which are supported
  on your machine, and you then input the appropriate name.

}\sstsubsection{HRANGE = {\undersc}REAL(2) (Read)}{
  (Default - Min,max in table   \hspace*{6ex}   Range - -1.0e20 to 1.0e20)

  The lower and upper limits of data to be put into histogram.

}\sstsubsection{IM = NDF (Read)}{
  (Default - null)

  The name of the file containing the input image

  The table must be a standard Starman image format file. It
  is a Starman ADAM .SDF image, with `real' 32-bit real or 'short'
  16-bit integer ones.

}\sstsubsection{IMOFFSET = {\undersc}REAL(2) (Read)}{
  (Default - 0.0,0.0  \hspace*{6ex}   Range - -1.0e20 to 1.0e20)

  The X and Y offset from the (1,1) position in the graph of the
  (1,1) position of the displayed points, line, image, or contour.

}\sstsubsection{IMXRANGE = {\undersc}INTEGER(2) (Read)}{
  (Default - 1, X size of image \hspace*{6ex}   Range - 1 to X size of image)

  The X start and end of the X range of the image to be plotted.

}\sstsubsection{IMYRANGE = {\undersc}INTEGER(2) (Read)}{
  (Default - 1, Y size of image \hspace*{6ex}   Range - 1 to Y size of image)

  The Y start and end of the Y range of the image to be plotted.

}\sstsubsection{IN1 = NDF (Read)}{
  (Default - null)

  The name of the file containing the first input table.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{IN2 = NDF (Read)}{
  (Default - null)

  The name of the file containing the second input table.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{LINECOL = LITERAL (Read)}{
  (Default - `black'    \hspace{6ex}    Choice - `black:white')

   Colour of plot lines. This is determined by whether you have a
   black or white background to your plots.

}\sstsubsection{LSTYLE = {\undersc}INTEGER (Read)}{
  (Default - 1       \hspace*{6ex} Range - 1 to 5)

  Code for style line is to be plotted.

\vspace*{2mm}\begin{tabular}{|c|l|}\hline
  Number & Style \\ \hline
    1  &   Full line \\
    2  &   Long dashes \\
    3  &   Dash-dot-dash \\
    4  &   Dotted \\
    5  &   Dash-dot-dot \\ \hline
\end{tabular}\vspace*{2mm}

}\sstsubsection{NBIN = {\undersc}INTEGER (Read)}{
  (Default - last chosen, first=40        \hspace*{6ex} Range - 1 to 200)

  Number of bins in histogram.

}\sstsubsection{NCOL1 = {\undersc}INTEGER (Read)}{
  (Default - 1    \hspace*{6ex}     Range - 1 to no of columns)

  Column in first table to take data from.

}\sstsubsection{NCOL2 = {\undersc}INTEGER (Read)}{
  (Default - 1      \hspace*{6ex}   Range - 1 to no of columns)

  Column in second table to take data from.

}\sstsubsection{NUMBUTT = {\undersc}INTEGER [HIDDEN] (Read)}{
  (Default - see below   \hspace*{6ex} Range - 2 to 3)

  Number of `X-Window' buttons available on the mouse.

  Some devices have two and some have three buttons available. This
  can depend both on their actual presence, and also on the X Windows
  software that is being run.

  With three buttons, then the \starman programs use all three, with
  the right-hand button being used mainly as the `exit' button.

  With two buttons, then the third button is simulated by pressing
  both of the buttons down, with the middle one being pressed slightly
  BEFORE the left-hand one. Use of the middle button in its normal
  way has to be modified, in that one has to pause for half a second
  after using it.

  [This parameter is usally 'hidden', with the machine manager setting
   it to the appropriate value for the local set-up. Sometimes it will
   be left to the user to set, depending on his software configuartion.]

}\sstsubsection{OPTION = LITERAL (Read)}{
  (Default - see below     \hspace*{6ex}         Choices - see below)

  This is the menu of options open to the user.

  (The list is given in the section above on `Menu'.)

   To input cursor positions, position cursor at desired point
   and press any key on the keyboard, or maybe press any
   button on the cursor. End by locating cursor outside graph

}\sstsubsection{POSITION = {\undersc}REAL(2) (Read)}{
  (Default - b.l.h corner of graph \hspace*{6ex}     Range - -1.0e20 to 1.0e20)

  X,Y position to put into the graph the input text.

}\sstsubsection{SYMBOL = {\undersc}INTEGER (Read)}{
  (Default - 2       \hspace*{6ex}     Range - 0 to 31)

  Code for style that the points to be plotted in the graph as.

  The full explanation of the symbols is given in the PGPLOT manual.

}\sstsubsection{TEXT = LITERAL (Read)}{
  (Default - null          \hspace{6ex}    Choice - as defined below)

 The text to plot onto the graph.

}\sstsubsection{USE = LITERAL (Read)}{
  (Default - `auto'    \hspace{6ex}    Choice - `auto:panel:key')

  Automatic (auto) or interactive (panel:key) mode?

  In the interactive mode, after you have input the X and Y
  data, you can do any operations you like (although the
  program suggests a route for the first few operations). You
  then exit when you want.

  The 'panel' choice puts you straight into the 'panel' mode,
  whereas 'key' selects the 'keyboard' entry.

  In the automatic mode, you choose the type of graph you
  want plotted up, the program then asks you for the relevant
  input, plots the graph and exits. This is useful if you have
  a simple thing to do, and/or wnat to exit automatically.

  In either case, any graph left on the X-window at the end
  remains displayed. It can be removed by closing the window
  or by doing `xdestroy xwindows'.

}\sstsubsection{VPRANGE = {\undersc}REAL(2) (Read)}{
  (Default - -2/+3 std dev from mean in image \hspace*{6ex}
   Range - -1.0e20 to 1.0e20)

  The minimum and maximum pixel values in the image that are plotted.
  The grey-scale is scaled between these limits.

}\sstsubsection{XLABEL = LITERAL (Read)}{
  (Default - null or Header of Column in table 1 \hspace{6ex}
  Choice - see below)

 Text to put onto X axis of graph.

}\sstsubsection{XRANGE = {\undersc}REAL(2) (Read)}{
  (Default - Min,max in table    \hspace*{6ex}     Range - -1.0e20 to 1.0e20)

  The X start and end of X range of positions in the table
  that a data point can have to be plotted.

}\sstsubsection{YLABEL = LITERAL (Read)}{
  (Default - null or Header of Column in table 2 \hspace{6ex}
  Choice - see below)

 Text to put onto Y axis of graph.

}\sstsubsection{YRANGE = {\undersc}REAL(2) (Read)}{
  (Default - Min,max in table      \hspace*{6ex}   Range - -1.0e20 to 1.0e20)

  The Y start and end of Y range of positions in the table
  that a data point can have to be plotted.

}}}



\addcontentsline{toc}{subsection}{ Tbpmatch}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in} TBPMATCH}

\sstroutine{TBPMATCH}{ Match XY Positions in Two Tables }{

\sstdescription{
   This takes two tables and makes two new ones which are copies of
   the old ones, but only contain the rows which match in X,Y position
   (within an input tolerance).

   The new table entries are in the same order as order they occur in
   the 1st table, but of course there may be rows missing if a match
   fails for that row.

   If the second table has more than one star near enough to the position
   of the star in the 1st to qualify, then selection is done on the
   basis of the option chosen.

\vspace*{2mm}\begin{tabular}{|l|p{4.5in}|}\hline
     Option   &  Function \\ \hline
     alldup   &   All such stars - each star as often as it appears \\
     allnodup &   All such stars - each star only once \\
     largest  &   Only the star with the largest value in NUMCOL \\
     nearest  &   Only the nearest star \\
     smallest &   Only the star with the smallest value in NUMCOL \\ \hline
\end{tabular}\vspace*{2mm}

   The position of an entry is taken as X from the first column
   and Y from the second column in the table.

}\sstparameters{

\sstsubsection{IN1 = NDF (Read)}{
  (Default - null)

  The name of the file containing the 1st input table

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{IN2 = NDF (Read)}{
  (Default - null)

  The name of the file containing the second input table

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{METHOD = LITERAL (Read)}{
    (Default - 'nearest'   \hspace*{6ex}        Choice -
                            'alldup:allnodup: nearest:largest:smallest')

   If the second table has more than one star near enough to the position
   of the star in the 1st to qualify, then selection is done on the
   basis of the option chosen.

   The option list is given in the section above on `Description'.

   The position of an entry is taken as X from the first column
   and Y from the second column in the table.

}\sstsubsection{MISMATCH = {\undersc}REAL (Read)}{
   (Default - 1.0  \hspace*{6ex}     Range - 0.0 to 1.0e20)

    Distance two stars can be apart and still be regarded as matching
    in X,Y position.

}\sstsubsection{NUMCOL = {\undersc}INTEGER (Read)}{
    (Default - 1     \hspace*{6ex}       Range - 1 to number of columns)

   If any duplicity is to be resolved by parameter value (see 'Method')
   then this is the table column to get the value from.

}\sstsubsection{OUT1 = NDF (Write)}{
  (Default - null)

  The name of the file to contain the 1st output table

  The table will be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{OUT2 = NDF (Write)}{
  (Default - null)

  The name of the file to contain the second output table

  The table will be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{TITLE1 = LITERAL (Read)}{
  (Default - First input table title or 'Output from TBPMATCH'
   \hspace*{6ex}     Choice - any)

   The Title to be added to the first output table.

}\sstsubsection{TITLE2 = LITERAL (Read)}{
  (Default - Second input table title or 'Output from TBPMATCH'
   \hspace*{6ex}     Choice - any)

   The Title to be added to the second output table.

}}}



\addcontentsline{toc}{subsection}{ Tbrenum}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in} TBRENUM}

\sstroutine{TBRENUM}{ Renumbers Names in a Table }{

\sstdescription{
   It takes a table and outputs an identical one, except the
   identifiers are labelled \#1,\#2,,,\#n.

}\sstparameters{

\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The name of the file with the input table.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

  The name of the file with the output table.

  The table will be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - Input table title or 'Output from TBRENUM'
   \hspace*{6ex} Choice - any)

    The Title to be added to the output table.

}}}



\addcontentsline{toc}{subsection}{ Tbsheet}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in} TBSHEET}

\sstroutine{TBSHEET}{ Spread-Sheet for the Tables }{

\sstdescription{
 TBSHEET is a spread-sheet program for the \starman tables.

 An input table (or part of it) is displayed as a grid on your graphics
 screen. You may perform various inspections, changes, and
 manipulations on the table. Part of these are the ability to add up to
 200 columns and up to 2000 rows to the table. The resultant table may
 be output to file.

 The format of the displayed screen is to some extent under the control
 of the user.

 The input table may be omitted. In this case a table of a size defined
 by the user, containing zeroes is set up for starting with.

 The display of the spread sheet uses the `PGPLOT' graphics
 sub-routines, so you will need a terminal capable of graphics display,
 capable of writing `black' areas, for which a PGPLOT driver exists.

}\sstdiytopic{Use}{
  The user starts the programs, inputs the input file name (or null),
  and inputs the display type and whether it is monochrome or not.
  The programs then puts up the table on the screen.

  The user then chooses to replace a value or row name or column
  header by clicking on them, or chooses one of the options. The option
  choice is done by placing the cursor on an `option' box and pressing
  any key on the keyboard, or maybe cursor button. Then the program
  performs that option (which may involve further user input either
  from the cursor or from the keyboard - the `prompt' message will
  indicate this).

  This process is then repeated, until the user chooses to exit.

}\sstdiytopic{Menu}{
 Numbers in the table are changed by clicking on them, and then
 using the keyboard to replace the values. The same goes for the
 row names and the column headers. For the other options, place
 the cursor on the desired option in the menu panel displayed above
 the table, and press a key on the keyboard or maybe use the
 cursor button.

 Menu of options available:-

\begin{tabular}{|l|p{4.5in}|}\hline
 Name      &    Function \\ \hline
 Add Cols  &    Add columns to the table. A column (or columns)
                is added to the data, located after the
                column picked by the cursor. (See below for
                data entry.) \\
 Add Rows   &   Add rows to the table. A row (or rows)
                is added to the data, located after the
                row picked by the cursor. (See below for
                data entry.) \\
 Calculate   &  Make the entries in a column from a FORTRAN-like
                equation. \\
 Command     &  Access the command line for help or exit \\
 Correlate   &  Calculate the statistics of two columns
                (picked by the cursor), first of themselves
                then of the correlation between them. \\
 Delete Col  &  Delete a column, picked by the cursor \\
 Delete Cols &  Delete a number of contiguous columns, defined
                by user input \\
 Delete Row  &  Delete a row, picked by the cursor \\
 Delete Rows &  Delete a number of contiguous rows, defined
                by user input \\
 Down        &  Move the displayed table so that the number
                of the row displayed at the top increases
                by one. \\
 Down page   &  Move the displayed table so that the number
                of the row displayed at the top increases
                by the number of rows displayed. \\
 Exit        &  Exit from the program. \\
 Format      &  Change the format and colour of the display. \\
 Help        &  Type out this help information. \\
 Histogram   &  Histogram of a column is plotted by picking a
                column with a cursor. The sheet is then
                replaced by the histogram. When you wish
                to return to the sheet, just answer question. \\
 Input       &  Load a new table \\
 Insert      &  Insert data into table. Select a range of rows
                of columns by the cursor (t.l.h and b.r.h
                corners). Keyboard enter data one at a time. \\
 Insert Cols &  Add columns to the table. A column (or columns)
                is added to the data, located before the
                column picked by the cursor. (See below for
                data entry.) \\
 Insert Rows &  Add rows to the table. A row (or rows)
                is added to the data, located before the
                row picked by the cursor. )See below for
                data entry.) \\
 Left        &  Move the displayed table so that the number
                of the column displayed at the left increases
                by one. \\
 Left page   &  Move the displayed table so that the number
                of the column displayed at the left increases
                by the number of columns displayed. \\
 Plot        &  One column can be plotted against another, both
                picked by cursor. Double click gives column
                choice by keyboard. The sheet is then
                replaced by the plot. When you wish
                to return to the sheet, just answer question. \\
\hline\end{tabular}

\newpage

(contd)

\begin{tabular}{|l|p{4.5in}|}\hline
 Name      &    Function \\ \hline
 Position    &  Change the column/row shown at the top left
                of the display to that demanded. \\
 Renumber    &  Load the names of all the rows with numbers
                in the format \#n, where n is the number of
                the row. \\
 Right       &  Move the displayed table so that the number
                of the column displayed at the left decreases
                by one. \\
 Right page  &  Move the displayed table so that the number
                of the column displayed at the left decreases
                by the number of columns displayed. \\
 Sort Down   &  Sort the rows of the table by looking at the
                values of entries in a column (picked by the
                the cursor), and sorting so these are in
                descending order. \\
 Sort Up     &  Sort the rows of the table by looking at the
                values of entries in a column (picked by the
                the cursor), and sorting so these are in
                ascending order. \\
 Stats       &  Calculate the statistics of one or two columns
                (picked by the cursor). Double click gives
                column choice by keyboard. \\
 Store       &  Store the present table in an output file \\
 Title       &  Change the title of the table \\
 Undo        &  Undo the last deletion or weed, if no sub-
                sequent changes have been made in the table. \\
 Up          &  Move the displayed table so that the number
                of the row displayed at the top decreases
                by one. \\
 Up page     &  Move the displayed table so that the number
                of the row displayed at the top decreases
                by the number of rows displayed.  \\
 Weed        &  Delete rows of the table by looking at the
                values of entries in a column (picked by the
                the cursor), and seeing if they lie within
                (or without) a chosen range. \\ \hline
\end{tabular}

}\sstdiytopic{Data Entry}{

Table values may be entered in three ways:-

\begin{tabular}{lp{5in}}
 1) & Click on (row,column)  position, and enter a value by the keyboard. \\

 2) & Click on the 'insert' option, choose an area of the table
    to enter the data into, and then use the keyboard.

    Use the cursor to set top left hand row and column corner of
    the set and then again to specify the bottom right hand corner.

    Then through the keyboard enter values, one at a time. The data are
    entered from the top down.

    To stop, enter - !! - \\

 3) & Click one of the four the 'insert cols/rows' or 'add rows/cols' options.

    {\bf Row Data Entry}

     Entering data for a row is done by typing in values for
     the entries in the row, separated by commas. If you do not
     enter all the values, the rest are given the value of zero.
     If you enter all the row values, you may add the name. The
     name must have no spaces (you may wish to use \_ for a space)
     If you do not input a name, the row is given the name \#n
     where n is the number of the row. You are then asked for the
     values for the next row to be entered. A completely null
     response ends the inputting of data.

    {\bf Column Data Entry}

     Entering data for columns is done by typing in values for
     the entries in the first row of each column, separated by
     commas. The number of entries you put in will be taken as
     the number of columns to put into the table. All the rows
     in each column are then given the value of that in the their
     first row. The column header is set as a blank space. \\

 4) & Row names and columns headers can be input by clicking on them, and
      entering values through the keyboard. \\
\end{tabular}

}\sstdiytopic{Calculations}{

 There is an option when using this program to perform arithmetic
 and mathematical functions to be applied to the values of column(s) in
 the table ( and to, optionally, a number of input tables) and
 constants by means of a FORTRAN-like expression which specifies the
 required functions. The results are then loaded into the desired
 column of the working table.

 In addition to the standard FORTRAN facilities, a number of special
 functions are available (e.g. for adding noise).

  {\bf \large General}

 The user inputs a Fortran-like equation (through the parameter
 EQUATION).

 These equations can contain references to:-

  \begin{list}{{-}}{}
   \item specified columns of specified tables (which must all have the
        same number of rows, but mayhave different numbers of columns)
        The table presently in the spread-sheet can be refered to.
   \item variables
   \item constants
   \item Fortran operators on these (e.g. '+', or 'cos()', ... )
   \end{list}

 (For more details on the structure of these equations ) see below.

 The equation is then analysed and the operations are performed.
 Each row of the output column column contains the results of the
 equation, with the data for the input tables coming from the matching
 row of those input tables.

 More specifically, the equation is analysed to identify the names
 of tables and variables and to evaluate constants and are then
 converted into reverse-Polish notation. The tables and variables are
 prompted for in alphabetical order and the program then performs
 simple 'stack-arithmetic' to evaluate the expression for each output
 table element.

 {\bf \large The Equation}

 An arithmetic expression of up to 80 characters which gives the
 function to be evaluated for each output table element. The syntax
 is similar to Fortran (same operator precedence, etc.) but with the
 following differences:

 \begin{enumerate}

 \item Input tables are represented by any of the variables TBn1, TCn2,...
       to TZnm, where the 'B', 'C', etc., refer to the table and the 'n1',
       'n2', .. etc., refer the column number in that table to use.

 \item The table presently displayed in the spread sheet is refered to
       as 'TA'. The column numbers are refered to as normal.

 \item Numerical parameters by any of the variables variables A to Z
 \item Constants by any numerical Fortran constant (real or integer,
    including exponent if required).
 \item Arithmetic is performed as though all values were real, The actual
    calculations are performed in double precision, and the results
    translated back to reals.
 \item The standard Fortran functions are available and identified
    by their generic names, i.e. SQRT, EXP, LOG10, LOG, SIN, COS, TAN,
    ASIN, ACOS, ATAN, ATAN2, SINH, COSH, TANH, ABS, AINT, ANINT, MOD,
    SIGN, DIM, MIN and MAX. Note, however, that MIN and MAX may take only
    2 arguments.
 \item To avoid problems with the way the Starlink environment
    handles character parameters:-
    \begin{enumerate}
       \item The comma ',' must be replaced with
             the colon ':' for separating function arguments.
       \item The division sign '\/' may be replaced by the percent sign '\%',
             although this latter substitution is not necessary when
             replying to a prompt at the terminal.
    \end{enumerate}
 \item There are three extra functions available:-

    \begin{tabular}{lp{4in}}
    CLIP(A,B,C) & This gives the value B so long as it lies in the
                 interval A to C (inclusive). Otherwise it gives a
                 zero result. It may be used to remove output values
                 outside a certain range (e.g. if a division operation
                 has resulted in very large output values). \\
    GAUSS(X)    & Gives gaussian noise with zero mean and standard
                 deviation X (the value returned is different at each
                 element and for each call of GAUSS). \\
    RAN(X)      & Gives uniform noise with a value between zero and X
                 (the value returned is different at each element and
                 for each call of RAN). \\
    \end{tabular}
  \end{enumerate}

  For example, an equation of the form:-

 $$        TA2*3.3 + 0.5 + COS(TB1) + A + MOD(RR:10.0) + CC\%3 $$

  will fill each row of a specified output column with:-

 \hspace*{1.0em}( 3.3 times the element in that row of column 2 of the
    presently displayed table ) \hspace*{\fill} \\
  + ( 0.5 ) \hspace*{\fill} \\
  + ( cosine of the element in that row of column 1 of input table
    specifed by parameter `INB' )
   \hspace*{\fill} \\
  + ( the user defined value of the variable `A' ) \hspace*{\fill} \\
  + ( row number, modulo 10 ) \hspace*{\fill} \\
  + ( (column number)/3 ) \hspace*{\fill} \\

  {\bf \large Input}

  Only tables and variables used in the expressions are prompted for and
  these are requested in alphabetical order, and only once each.
  The table refered to as 'TA' is the table presently in the spread
  sheet, and is thus not asked for.

}\sstdiytopic{Cursor Use}{
 Place the cursor on the desired location and press any key
 on the keyboard, or maybe use the cursor button.

}\sstdiytopic{Description of Screen}{
 When the table is displayed, the screen shows the table itself
 and a number of other things.

 To the left of the table, there are the row numbers and the names
 attached to each row.

 Above the table, there are the column numbers and the headers attached
 to each row.

 To the left and above the table, there is the program `prompts', which
 indicate the current state of the program.

 Along the top of the screen, there are the `option' boxes which the
 user points to undertake an action.


}\sstdiytopic{Program Prompts}{
 In using the program, you may occaisionly be wondering if it is waiting
 for input from you. It actually tells you what it is doing, with a
 display to the top left of the table:-

\begin{tabular}{|l|l|p{3.5in}|}\hline
   Displayed        &       Colour &   Action desired of user \\ \hline
   `Waiting (Option)' &     Red    &   Place cursor on Option box, press
            any key or maybe cursor button \\
   `Waiting (Position)' &   Red     &  Place cursor on Option box, press
            any key or maybe cursor button \\
   `Waiting (Keyboard)'  &  Red     &  Input data via keyboard \\
   `Working'             &  Green   &  Wait until program asks you \\ \hline
\end{tabular}


}\sstparameters{

\sstsubsection{A = {\undersc}REAL (Read)}{
  (Default - 0.0         \hspace*{6em}        Range- -1.0e37 to 1.0e37)

  The value to be used in the expressions for the value of
  the variable 'A',  in the `calculations' option.

  This help is repeated for the variables `B' to `Z'.

}\sstsubsection{ASPECT = {\undersc}LITERAL (Read)}{
  (Default - `no'  table    \hspace*{6ex}  choice - `yes:no')

  Plot the X and Y axes of the graph at the same scale?

  If not, then the X and Y axes are scaled to fit the display
  area.

}\sstsubsection{CHNAMES = {\undersc}INTEGER (Read)}{
  (Default - present value (starting value=10)   \hspace*{6ex} Range - 2 to 20)

  The number of characters of the row names to display.

}\sstsubsection{COLNUM = {\undersc}INTEGER (Read)}{
  (Default - present value (starting value=4)    \hspace*{6ex} Range - 2 to 100)

  The number of columns to display on the screen.

  The number of rows displayed is automatically adjusted to fill the
  screen.

  Clearly, the more columns shown, the smaller the character size.

}\sstsubsection{COLOURS = {\undersc}INTEGER(5) (Read)}{
  (Default - present value (starting value = `2,1,3,4,5')   \hspace*{6ex}
   Range - 5 integers with values between 1 and 10)

  The colour to give to each of five elements of the screen.

\begin{tabular}{|l|l|l|}\hline
  Number &  Element          &   Default \\ \hline
    1    &  Background       &   White \\
    2    &  Numbers/names/   &   Black \\
         &  table grid       &          \\
    3    &  Prompt - waiting &   Red \\
    4    &  Prompt - working &   Green \\
    5    &  Options box grid &   Blue \\ \hline
\end{tabular}

  The colours that can be given instead to these are:-

\begin{tabular}{cccccc}
   Number  &  1    & 2       &  3     &   4    &   5 \\
   Colour  & Black & White   & Red    & Green  & Blue \\
           &   6   &  7      &    8   &    9   &     10 \\
           & Cyan  & Magenta & Yellow & Orange & Grn/Ylw \\
\end{tabular}

  (If the screen is monochrome, then the background is displayed
  as white and the rest as black.)

}\sstsubsection{COLS = {\undersc}INTEGER(2) (Read)}{
  (Default - 1,2       \hspace*{6ex}     Range - 1 to X size of table)

  The numbers of the two columns use.

}\sstsubsection{COMMAND = LITERAL (Read)}{
  (Default - `no'       \hspace*{6ex}  Choice - `yes:no')

  This performs no operation. It merely gives the user a chance
  access the CL command line for help

  The user types '?' or '??', (without the 's) and gets access to
  help system. Then do 'return' to get back.

  '!!' will exit.

}\sstsubsection{DATA = LITERAL (Read)}{
  (Default - null      \hspace*{6ex}     Choice - any)

  A character string giving the data to input to a column or row.
  These are numbers (in the form (e.g.) 123 or -12.34 or -1.2e4),
  and maybe a name, separated by commas or spaces. There should
  be as many numbers as are needed to fill the column or row. If
  there are more, then the first numbers filling up the table
  are taken, and the next entry is taken as the column header or
  row name. If there are fewer, then the remaining numbers are
  filled up with zeroes. If there is no name at the end of the
  entry, then the column header/row name is taken as `\#n' where
  n is the number of the column/row.

  The name must be no more than 20 characters long

  Numbers in a bad form, (e.g. 12j34) are taken as 0.0.

  Thus for a table row entry for row number five, where there are
  three columns, the character strings below would give the following
  input:-

\begin{tabular}{|l|l|l|c|c|}\hline
                    & \multicolumn{4}{c|}{Stored}  \\ \cline{2-5}
    Input           &  Column1  &  Column2 &  Column3  &  Name \\ \hline
    1,2.1,-1.2e3     &    1.0    &   2.0     &  -1200.0  &  \#5 \\
    1,2,3,fred       &    1.0    &   2.0     &     3.0   &  fred \\
    1,2              &    1.0    &   2.0     &     0.0   &  \#5 \\
    1,2,3,4,fred     &    1.0    &   2.0     &     3.0   &  4 \\
    1,2j2,3          &    1.0    &   0.0     &     3.0   &  \#5 \\ \hline
\end{tabular}

}\sstsubsection{DEVLIMX = {\undersc}REAL(2) (Read)}{
  (Default - Min,max in table    \hspace*{6ex}  Range - -1.0e20 to 1.0e20)

  The X values of the ends of the plotted graph.

}\sstsubsection{DEVLIMY = {\undersc}REAL(2) (Read)}{
  (Default - Min,max in table    \hspace*{6ex}  Range - -1.0e20 to 1.0e20)

  The Y values of the ends of the plotted graph.

}\sstsubsection{EQUATION = LITERAL (Read)}{
  (Default - null         \hspace*{6em}    Choice - as defined below)

  The FORTRAN-style expression that gives the elements to be loaded into the
  desired column in the working table,  in the `calculations' option.

  Its style is given the `The Equation' part of the `Calculations'
  section above.

}\sstsubsection{GTYPE = LITERAL (Read)}{
  (Default - `ask'    \hspace{6ex}    Choice - any)

  A character string giving the local name for the graphics
  display type.

  `xwindows' will put it out on the screen of your workstation,
  if you are using one.

  If `ask' is input, then the program asks a very similar question,
  in a different way. A response here of `?' will bring up a listing
  of all the possible names of graphics devices which are supported
  on your machine, and you then input the appropriate name.

}\sstsubsection{HEADER = LITERAL (Read)}{
  (Default - present value    \hspace*{6ex}        Choice - any)

  The character string to replace the current column header with.

  This must be no longer than 20 characters long.

}\sstsubsection{HRANGE = {\undersc}REAL(2) (Read)}{
  (Default - Min,max in table   \hspace*{6ex}   Range - -1.0e20 to 1.0e20)

  The lower and upper limits of data to be put into histogram.

}\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The name of the file containing the input table, or a new input table.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{INB = NDF (Read)}{
 (Default - null)

 When using the `calculation' mode to input data, then tables
 can be accessed in the `EQUATION' parameter. This is the input
 file containing the table corresponding to a 'TB' specfication
 in the equation.

 This is not to be confused with the `main' input table specified
 via the `IN' parameter.

 There can be up to 25 other tables accessed through the `TA' and
 `TC' to `TZ' parameters in the equation.

 All input tables must come from different files. To input a table
 more than once in the equation - refer to it by only one parameter.

 [This help is used for the `INC' to `INZ' parameters, accessed
  through the `TC' to `TZ', too.]

 The table must be a standard \starman table format file. It
 is a \starman ADAM .SDF image, with `real' 32-bit real values,
 with each column having a header of up to 20 characters, and
 each row having a name of up to 20 characters.

}\sstsubsection{LIMITS = {\undersc}REAL(2) (Read)}{
  (Default - 0.0,0.0     \hspace*{6ex}        Range - 2 real numbers in the
            range -1.0e20 to 1.0e20)

  If the value of a table entry (in the specified column) in a row
  lies within this range of values, then the row will either be
  accepted or rejected. (The choice of accept/reject is made with
  the `weedopt' parameter after this parameter.)

}\sstsubsection{LINECOL = LITERAL (Read)}{
  (Default - `black'      \hspace*{6ex}        Choice - `black:white')

   Colour of plot lines. Your choice should be determined by whether
   you have a black or white background to your plots.

}\sstsubsection{LSTYLE = {\undersc}INTEGER (Read)}{
  (Default - 1       \hspace*{6ex} Range - 1 to 5)

  Code for style line is to be plotted.

\vspace*{2mm}\begin{tabular}{|c|l|}\hline
  Number & Style \\ \hline
    1  &   Full line \\
    2  &   Long dashes \\
    3  &   Dash-dot-dash \\
    4  &   Dotted \\
    5  &   Dash-dot-dot \\ \hline
\end{tabular}\vspace*{2mm}

}\sstsubsection{MONO = LITERAL (Read)}{
  (Default - `no'      \hspace*{6ex}        Choice - `yes:no')

  Is the display screen for the table, a monochrome display or not?
  (If it is a colour display, then the display can be made a little
   clearer than for a monochrome display.)

}\sstsubsection{MORE = LITERAL (Read)}{
  (Default - `yes'      \hspace*{6ex}        Choice - `yes:no')

  Do you want any more typing out of this help?

}\sstsubsection{NAME = LITERAL (Read)}{
  (Default - present value   \hspace*{6ex}         Choice - any)

  The character string to replace the current row name with.

  This must be no longer than 20 characters long.

}\sstsubsection{NBIN = {\undersc}INTEGER (Read)}{
  (Default - last chosen, first=40        \hspace*{6ex} Range - 1 to 200)

  Number of bins in histogram.

}\sstsubsection{NUMCOLS = {\undersc}INTEGER(2) (Read)}{
  (Default - 0,end of current table      \hspace*{6ex} Range - 2 integers between 0 and
                       end of cureent table)

  The range of columns to delete.

  If either of the limits is `0', then no deletion takes place.

}\sstsubsection{NUMROWS = {\undersc}INTEGER(2) (Read)}{
  (Default - 0,end of current table      \hspace*{6ex} Range - 2 integers between 0 and
                       end of cureent table)

  The range of rows to delete.

  If either of the limits is `0', then no deletion takes place.

}\sstsubsection{OK = LITERAL (Read)}{
  (Default - `no'    \hspace*{6ex}        Choice - `yes:no')

  In choosing to exit from the program without having previously
  stored the table since the last change, you will loose all the
  changes made to the table since the start (or since you last
  stored the then current state of the table).

  If you want this, then answering `yes' will result in the
  program finishing. If on the other hand you do want to store the
  current state of the table, then answer `no' (the default) and you
  will get back to the option choice. You can then store the table
  and then exit.

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

  The name of the file to contain the output table.

  The table will be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{POSITION = {\undersc}INTEGER (Read)}{
  (Default - present position     \hspace*{6ex}        Range - 1 to max of num of
                       columns and rows)

  The column position and row position of the table entry displayed
  at the top left hand of the display.

  This positions the display so that the specified entry is at the
  top left of the display.

}\sstsubsection{SEED = {\undersc}INTEGER (Read)}{
  (Default - 1234567891     \hspace*{6em}    Range - 1200000001 to 1400000001)

  The seed number to be used in any random number generators.
  This is used in the `GAUSS()' and `RAN()' operators. These
  will provide the same pattern of numbers in the same
  seed number is input. This is used  in the `calculations' option.

  It has to be a large positive odd number.

}\sstsubsection{SIZE = {\undersc}INTEGER(2) (Read)}{
  (Default - 2,100     \hspace*{6ex}           Choice - 2 integers each between
              1 and 10000)

  As there is no input table, a blank one is made. This parameter
  defines the size of the table - the number of columns and the
  numbers of rows. The table will have zeroes in it and the `\#n'
  format entries for the names and headers.

}\sstsubsection{SYMBOL = {\undersc}INTEGER (Read)}{
  (Default - 2       \hspace*{6ex}           Range - 0 to 31)

  Code for style that the points to be plotted in the graph as.

  The full explanation of the symbols is given in the PGPLOT manual.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - the title of the input table   \hspace*{6ex}    Choice - any)

  The title to give to the present table. This is a
  character string, less than 50 characters long.

}\sstsubsection{VALUE = {\undersc}REAL (Read)}{
  (Default - present value    \hspace*{6ex}        Range - -1.0e20 to 1.0e20)

  The value to replace the current table entry value with.

}\sstsubsection{WEEDOPT = LITERAL (Read)}{
  (Default - `accept'     \hspace*{6ex}        Choice - `accept:reject')

  Do you want to accept or reject those rows whose entries
  in the specificed column lie within the limits specified?

}\sstsubsection{XRANGE = {\undersc}REAL(2) (Read)}{
  (Default - Min,max in table    \hspace*{6ex}     Range - -1.0e20 to 1.0e20)

  The X start and end of X range of positions in the table
  that a star can have to be plotted.

}\sstsubsection{YRANGE = {\undersc}REAL(2) (Read)}{
  (Default - Min,max in table      \hspace*{6ex}   Range - -1.0e20 to 1.0e20)

  The Y start and end of Y range of positions in the table
  that a star can have to be plotted.

}}}



\addcontentsline{toc}{subsection}{ Tbsort}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in} TBSORT}

\sstroutine{TBSORT}{ Sort a Table }{

\sstdescription{
   This takes a table and makes a new one with identical entries,
   but sorted on the values in a user defined column, either in
   ascending or descending order.

}\sstparameters{

\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The file containing the input table

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{NUMCOL = {\undersc}INTEGER (Read)}{
  (Default - 1      \hspace*{6ex}      Range - 1 to last column)

  The  number of the column to do the sorting on.

}\sstsubsection{OPTION = LITERAL (Read)}{
   (Default - 'ascending'    \hspace*{6ex} Choice -  'ascending:descending')

   Whether to sort into ascending or descending order.

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

  The file to contain the output table.

  The table will be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - input table title or 'Output from Tbsort'   \hspace*{6ex}
   Choice - any)

    The Title to be added to the output file

}}}



\addcontentsline{toc}{subsection}{ Tbstat}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in} TBSTAT}

\sstroutine{ TBSTAT}{ Statistics of Column(s) in Table(s) }{

\sstdescription{
  Calculate some statistics of one or two columns of data in a
  table or tables.

  The input of the second column is optional.

  It calculates statistics for each column:- number of values,
  minimum, maximum, mean, std dev, and std dev of mean.

  If there are two columns, it also calculates the regression line
  fit of one on the other and the correlation.

}\sstparameters{

\sstsubsection{IN1 = NDF (Read)}{
  (Default - null)

  The name of the file containing the first input table.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{IN2 = NDF (Read)}{
  (Default - null)

  The name of the file containing the second input table.

  (optional)

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{NCOL1 = {\undersc}INTEGER (Read)}{
  (Default - 1  \hspace*{6ex}   Range - 1 to no of columns)

  First column in first table to take data from.

}\sstsubsection{NCOL2 = {\undersc}INTEGER (Read)}{
  (Default - 1     \hspace*{6ex}     Range - 1 to no of columns)

  Second column in same or another table to take data from.

  (optional)

}}}



\addcontentsline{toc}{subsection}{ Tbtran{\undersc}auto}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in}
TBTRAN{\undersc}AUTO}

\sstroutine{TBTRAN{\undersc}AUTO}{ Transform one XY table onto another
automatically}{

\sstdescription{
   This takes a table with X,Y positions and makes a new one with identical
   entries, but with the positions transformed onto the same coordinate
   system as another XY table.

   There have to be common stars in the two tables but they do not have to
   be matched, or aligned, or complete. The two coordinate systems must be
   related by (shift:rotation:magnification). Thus `shapes' in the two
   coordinate systems must be  similar. The program will fail if there is
   a shear, or a different scaling in and X and Y, or a distortion.

   It helps the program considerably if there are heights or magnitudes
   of the stars available. This is looked for in column three. If there
   is a header with `height' or 'mag', then this column is taken to
   have those values. If there is no such header, the user is asked
   if they are. If there is no column 3, or it does not contain heights
   or magnitudes, then the stars are analysed as though there are
   ordered by height, with the `brightest' first.

   The entries in columns 1 and 2 are taken as `$X$', `$Y$'. The output
   table then has values `$X_1$', `$Y_1$' with:-

    $$    X_1   =    c_x(1) + c_x(2)*X  + c_x(3)*Y $$

    $$    Y_1   =    c_y(1) + c_y(2)*X  + c_y(3)*Y  $$

  With the `X~coefficents', $c_x(1)$, $c_x(2)$, $c_x(3)$ and the
  `Y~coefficents', $c_y(1)$, $c_y(2)$, $c_y(3)$, are calculated by
  the program.

}\sstdiytopic{Method}{

  The program works out the triangle between the three
  brightest stars in each list. It then looks at the two
  triangles, and sees if they are the same by comparing
  the ratios in each triangle of the length of longest
  side to the length of next longest, and to the length
  of the shortest side. If the ratios are the same within
  a chosen tolerance, then the triangle probably must have
  been made with the same stars.

  If the triangles do not match, then this is repeated
  with the four brightest in each list. The program works
  out all the possible triangles between the stars in each
  list. It then looks at each triangle in one list, and
  sees if there is a matching triangle in the other list.
  If there is no match, this is then repeated with the five
  brightest stars, and so on, until a match is made.

  The precision of the matching needed, and the number of
  matched triangles needed to confirm the right matching has
  been done is at the users choice.

  After enough triangles have been matched, and for each of these
  matched triangles they are enough like it, and enough such
  well matched triangles have been found, the stars in these
  triangles are assumed to be the same in the two lists.

  Then the transformation equation between them is calculated.

  The transform can either be the (shift:rotation:magnification)
  transform described above or a simple XY shift without rotation,
  magnification or squeezing.

  The first ('input') list is then transformed into the
  coordinate system of the second ('master') list, using this
  transformation equation.

 Column three of the Input and Master tables are assummed to have either
 the heights or magnitudes of the stars in the tables. These are then
 used so that the program searches amongst the bright stars first for
 triangle matches. If there is no column three for a table, then the
 stars are taken in the order they are in in the table.

}\sstparameters{

\sstsubsection{FTOL = {\undersc}REAL (Read)}{
  (Default - 5.0 or 2.0      \hspace*{6ex}     Range - 0.0 to 1.0e7)

  The X or Y distance that a position calculated from the transform
  made for one matched triangle may be off from the position calculated
  from another matched triangle, and the two triangles still
  considered to be on the same coordinate system.

  The positions are calculated at the four corners of the system of
  stars that are in the matched triangles. Actually a bit outside the
  corners.

  This should be set as small as you think reasonable. If too small
  the program will reject real triangle matches. If too large,
  it will accept false triangle matches.

  The default error allowed is set at 2.0, for a simple XY shift, and
  at 5.0 for the more flexible full transform.

}\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The file containing the input table, to be transformed.

  The first two columns must be X,Y. It helps if there is a third
  column with either height or magnitude.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{IN\_MAGS = LITERAL (Read)}{
  (Default - 'heights'  \hspace*{6ex}   Choice - 'heights:mags:none')

 Are the values in column three of the Input table magnitudes or
 heights? [If this is described in the table header for this
 column, this question is not asked.]

 Column three is used so that the program searches amongst the
 bright stars first for matches. If there is no column three, or the
 answer to this is `none', then the stars are taken in the order
 they are in in the table.

}\sstsubsection{MS\_MAGS = LITERAL (Read)}{
  (Default - 'heights'  \hspace*{6ex}   Choice - 'heights:mags:none')

 Are the values in column three of the Master table magnitudes or
 heights? [If this is described in the table header for this
 column, this question is not asked.]

 Column three is used so that the program searches amongst the
 bright stars first for matches. If there is no column three, or the
 answer to this is `none', then the stars are taken in the order
 they are in in the table.

}\sstsubsection{MASTER = NDF (Read)}{
  (Default - null)

  The file containing the master table, to whose coordinate
  system the `input' table will be transformed.

  The first two columns must be X,Y. It helps if there is a third
  column with either height or magnitude.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{NTRI = {\undersc}INTEGER (Read)}{
  (Default - 4      \hspace*{6ex}     Range - 1 to 10000)

  For each matched triangle, this is the number of other matched
  triangles that must be like it, for the matched triangle to count
  as a 'good' matched triangle.

  If made larger, the program will do a better job of rejecting
  false triangles, but will take longer.

  If the program finds matches from only a small number of triangles,
  it automatically relaxes this criteria.

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

  The file containing the output table.

  The table will be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - Input table title or
   `Output from TBTRAN{\undersc}AUTO' \hspace*{6ex}   Choice - any)

  The Title to be added to the output file.

}\sstsubsection{TOL = {\undersc}REAL (Read)}{
  (Default - 1.0      \hspace*{6ex}     Range - 0.0 to 1.0e7)

  The X or Y distance a vertex of one triangle may be off from
  the system of another matched triangle, and the two triangles
  still be recognised as a match.

  This should be set as small as you think reasonable. If too small
  the program will reject real triangle matches. If too large,
  it will accept false triangle matches.

}\sstsubsection{TOTNTRI = {\undersc}INTEGER (Read)}{
  (Default - 8      \hspace*{6ex}     Range - 1 to 10000)

  This is the number of 'good' matched triangles that must be found
  for a fit to be considered sound and the calculations stopped.

  [The definition of 'good' is given in the help for the NTRI
   parameter.]

  If made larger, the program will do a better job of rejecting
  false triangles, but will take longer.

  If the program finds matches from only a small number of triangles,
  it automatically relaxes this criteria.

}\sstsubsection{TYPE = LITERAL (Read)}{
  (Default - 'full'  \hspace*{6ex}   Choice - 'full:xyshift')

 Should the transformation equation determined be a full one
 (xy shift, rotation, magnification), or just an xy shift?

 The fit cannot be one that changes the shape of objects.

}\sstsubsection{XCOEFF = {\undersc}REAL(3) (Write)}{
  (This is an output parameter)

  The three output coefficents for the X transform.

    $$ Calculated \hspace{3ex}   X_1   =    c_x(1) + c_x(2)*X  + c_x(3)*Y $$


}\sstsubsection{YCOEFF = {\undersc}REAL(3) (Write)}{
  (This is an output parameter)

  The three output coefficents for the Y transform.

    $$ Calculated \hspace{3ex}   Y_1   =    c_y(1) + c_y(2)*X  + c_y(3)*Y $$



}}}



\addcontentsline{toc}{subsection}{ Tbtran{\undersc}do}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in}
TBTRAN{\undersc}DO}

\sstroutine{TBTRAN{\undersc}DO}{ Transform XY table poistions using
transform eqn}{

\sstdescription{
   This takes a table and makes a new one with identical entries,
   but with the positions transformed through a transformation matrix.

   The entries in columns 1 and 2 are taken as `$X$', `$Y$'. The output table
   then has values `$X_1$', `$Y_1$' with:-

    $$    X_1   =    c_x(1) + c_x(2)*X  + c_x(3)*Y $$

    $$    Y_1   =    c_y(1) + c_y(2)*X  + c_y(3)*Y  $$

  With the `X~coefficents', $c_x(1)$, $c_x(2)$, $c_x(3)$ and the
  `Y~coefficents', $c_y(1)$, $c_y(2)$, $c_y(3)$, being input by the user.

}\sstparameters{

\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The file containing the input table. It must have the X,Y positions
  in columns 1 and 2.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{OUT = NDF (Write)}{
  (Default - null)

  The file containing the output table, with the transformed
  positions.

  The will be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - Input table title or `Output from TBTRAN{\undersc}DO'
   \hspace*{6ex} Choice - any)

    The Title to be added to the output file.

}\sstsubsection{XCOEFF = {\undersc}REAL(3) (Read)}{
  (Default - 0.0,0.0,0.0       \hspace*{6ex}     Range - -1.0e20 to 1.0e20)

  The three coefficents for the X transfomation.

    $$    X_1   =    c_x(1) + c_x(2)*X  + c_x(3)*Y $$

}\sstsubsection{YCOEFF = {\undersc}REAL(3) (Read)}{
  (Default - 0.0,0.0,0.0       \hspace*{6ex}     Range - -1.0e20 to 1.0e20)

  The three coefficents for the Y transfomation.

    $$    Y_1   =    c_y(1) + c_y(2)*X  + c_y(3)*Y  $$

}}}



\addcontentsline{toc}{subsection}{ Tbtran{\undersc}load}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in}
TBTRAN\hspace{-0.1em}{\undersc}LOAD}

\sstroutine{TBTRAN\hspace{-0.1em}{\undersc}LOAD}{
Turn `Magn,Rotn,Shift' to Position Transformation}{

\sstdescription{
   Calculates the transformation coefficents between two
   coordinate systems, converting:-

    'magnification, rotation, shift'

   to a transformation matrix of the form:-

    $$    X_1   =    c_x(1) + c_x(2)*X  + c_x(3)*Y $$

    $$    Y_1   =    c_y(1) + c_y(2)*X  + c_y(3)*Y  $$


    The input parameters are fed in, and the six transformation
    coefficents are calculated.

    The input parameters are:-

\begin{list}{{-}}{}
\item The centre of the old coordinate system.
\item The magnification to apply to the old coordinate system.
\item The anticlockwise rotation in degrees to apply to the
      magnified coordinate system, about its old centre.
\item The shift to apply to that magnified, rotated coordinate system.
\end{list}

  The results are typed out, and also put into the program paramters.

}\sstparameters{

\sstsubsection{CENTRE =  {\undersc}REAL(2) (Read)}{
  (Default - 0.0,0.0      \hspace*{6ex}      Range - -1.0e20 to 1.0e20)

  The old X,Y centre of the system.

}\sstsubsection{MAGNIFY = {\undersc}REAL (Read)}{
  (Default - 1.0        \hspace*{6ex}      Range - 0.0 to 1.0e20)

  The magnification to apply.

}\sstsubsection{ROTATE =  {\undersc}REAL (Read)}{
  (Default - 0.0     \hspace*{6ex}  Range - -1.0e20 to 1.0e20)

  The anticlockwise rotation (in degrees) to apply to the magnified
  system, about the old centre.

}\sstsubsection{SHIFT =  {\undersc}REAL(2) (Read)}{
  (Default - 0.0,0.0      \hspace*{6ex}     Range - -1.0e20 to 1.0e20)

  The X,Y shift to apply to the magnified, rotated system.

}\sstsubsection{XCOEFF =  {\undersc}REAL(3) (Write)}{
  (This is an output parameter)

  The three output cofficents for the X system

    $$    X_1   =    c_x(1) + c_x(2)*X  + c_x(3)*Y $$

}\sstsubsection{YCOEFF =  {\undersc}REAL(3) (Write)}{
  (This is an output parameter)

  The three output cofficents for the Y system

    $$    Y_1   =    c_y(1) + c_y(2)*X  + c_y(3)*Y  $$

}}}



\addcontentsline{toc}{subsection}{ Tbtran{\undersc}make}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in}
TBTRAN{\hspace{-0.1em}}{\undersc}MAKE}

\sstroutine{TBTRAN{\hspace{-0.1em}}{\undersc}MAKE}{ Calculate Posn
Transforms Between Two Tables}{

\sstdescription{
   This takes two tables (whose entries in columns 1 and 2 are X,Y
   positions of at least some same points) and calculates the
   transformation between the coordinate systems of the two tables.

   The coordinates in the first table are taken as `$X$', `$Y$', and those
   in the second are taken as `$X_1$', `$Y_1$', and the transformation is:-

    $$ Calculated \hspace{3ex}   X_1 = c_x(1) + c_x(2)*X  + c_x(3)*Y $$

    $$ Calculated \hspace{3ex}   Y_1 = c_y(1) + c_y(2)*X  + c_y(3)*Y $$


   The coefficients are calculated so as to minimise the errors
   between 'calculated positions in the second table' and
   'actual positions in the second tables'. Points which are too
   discordant are dropped from the calculation of the transformation.

   Four types of transformation may be calculated:-

\begin{tabular}{|l|l|}\hline
   Code          &   Type \\ \hline
   shift         &  Shift [$c\_x$(2)=1; $c\_x$(3)=0; $c\_y$(2)=0;
                                $c\_y$(3)=1] \\
   rotshift      &   Shift and rotation \\
   magnrotshift  &   Shift, rotation and magnification \\
   full          &   Shift, rotation, magnification and X/Y stretch \\ \hline
\end{tabular}

  The input tables may either be taken as consisting of matching pairs,
  or the program can look for rows with the same names to treat as the
  matching pairs.

  The results are typed out, and also put into the program paramters.

}\sstparameters{

\sstsubsection{IN1 = NDF (Read)}{
  (Default - null)

  The name of the file containing the 1st input table.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{IN2 = NDF (Read)}{
  (Default - null)

  The name of the file containing the 2nd input table.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{NAMES = LITERAL (Read)}{
  (Default - 'no'    \hspace*{6ex}             Choice - 'yes:no')

  Match up pairs of points in the 1st and 2nd tables by looking
  for rows with the same names? If not, then assume entries
  are the same order in the two tables.

}\sstsubsection{SIGLIM = {\undersc}REAL (Read)}{
  (Default - 2.5      \hspace*{6ex}    Range - 0.0 to 1.0e20)

  When calculating the transformations, discordant points are
  rejected if their calculated positions in the 2nd table lie
  more than 'SIGLIM' times the standard deviation away from the
  2nd table positions.

}\sstsubsection{TRTYPE = {\undersc}INTEGER (Read)}{
  (Default - 4   \hspace*{6ex}   Range - 1 to 4)

  The type of transformation to be calculated.

\begin{tabular}{|l|l|}\hline
   Code          &   Type \\ \hline
   shift         &  Shift [$c\_x$(2)=1; $c\_x$(3)=0; $c\_y$(2)=0;
                                $c\_y$(3)=1] \\
   rotshift      &   Shift and rotation \\
   magnrotshift  &   Shift, rotation and magnification \\
   full          &   Shift, rotation, magnification and X/Y stretch \\ \hline
\end{tabular}

}\sstsubsection{XCOEFF = {\undersc}REAL(3) (Write)}{
  (This is an output parameter)

  The three output cofficents for the X system

  $$ Calculated \hspace{3ex}   X_1   =    c_x(1) + c_x(2)*X  + c_x(3)*Y $$


}\sstsubsection{YCOEFF = {\undersc}REAL(3) (Write)}{
  (This is an output parameter)

  The three output cofficents for the Y system

  $$ Calculated \hspace{3ex}   Y_1   =    c_y(1) + c_y(2)*X  + c_y(3)*Y $$

}}}



\addcontentsline{toc}{subsection}{ Tbvalue}


\ajhsect{\arabic{section}}{ Table Programs - \hspace*{0.2in} TBVALUE}

\sstroutine{TBVALUE}{Output an element of a Table }{

\sstdescription{
  This takes the value of a single element in an input table, and types
  out that value and also puts it out as a parameter of the program.

  The column the element is taken from may be defined either from the
  number of the column or from the column's header.

  The row the element is taken from may be defined either from the
  number of the row or from the row's name.

}\sstparameters{

\sstsubsection{COLUMN = {\undersc}INTEGER (Read)}{
  (Default - 1  \hspace*{6em}         Range - 1 to number of columns in table)

  The number of the desired column.

}\sstsubsection{HEADER = LITERAL (Read)}{
  (Default - ' '        \hspace*{6em}       Choice - any)

  The (up to) 20 character string of the header of the desired
  column.

}\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The input file containing the input table.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{NAME = LITERAL (Read)}{
  (Default - ' '       \hspace*{6em}        Choice - any)

  The (up to) 20 character string of the name of the desired row.

}\sstsubsection{ROW = {\undersc}INTEGER (Read)}{
  (Default - 1        \hspace*{6em}  Range - 1 to number of rows in table)

  The number of the desired row.

}\sstsubsection{USEHEAD = LITERAL (Read)}{
  (Default - 'no'     \hspace*{6em}      Choice - 'yes:no')

  Define the column desired from its header ('yes'), or from the
  the number of the column ('no')?

}\sstsubsection{USENAME = LITERAL (Read)}{
  (Default - 'no'    \hspace*{6em}       Choice - 'yes:no')

  Define the row desired from its name ('yes'), or from the
  the number of the row ('no')?

}\sstsubsection{VALUE = {\undersc}REAL (Write)}{
  (Output parameter)

  The value of the table element is put out into this program
  parameter.

}}}



\addcontentsline{toc}{subsection}{ Tbweed}


\ajhsect{\arabic{section}}{Table Programs - \hspace*{0.2in} TBWEED}

\sstroutine{TBWEED}{ Weed a Table }{

\sstdescription{
  This makes a new table which is a copy of an old table, but
  with only those rows whose values in user defined columns lie in
  (or optionally outside) user assigned ranges are copied over.

  Up to ten columns can be tested. The repeated asking for columns
  is stopped by responding '0' to the request for column number.

}\sstparameters{

\sstsubsection{IN = NDF (Read)}{
  (Default - null)

  The name of the input file containing the input table.

  The table must be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{LIMS = {\undersc}REAL(2) (Read)}{
  (Default - 0.0,0.0  \hspace*{6ex}        Range - -1.0e20,1.0e20)

   The lower and upper limits to the acceptable values for the entries
   in this column.

   If 0 is input, then this column input is ignored, and no more
   are asked for.

   [This help applies to the up to 10 columns, through the 'LIMS1',
    'LIMS2', ... 'LIMS10' parameters.]

}\sstsubsection{NCOL = {\undersc}INTEGER (Read)}{
  (Default - 1       \hspace*{6ex}     Range - 0, no of columns)

  The number of the first column whose values are to be tested.

   If 0 is input, then this column input is ignored, and no more
   are asked for.

   [This help applies to the up to 10 columns, through the 'NCOL1',
   'NCOL2', ... 'NCOL10' parameters.]

}\sstsubsection{OPTION = LITERAL (Read)}{
   (Default - 'accept'     \hspace*{6ex}   Choice - 'accept:reject')

   Accept or reject entries whose column values falls in the
   given ranges.

}\sstsubsection{OUT = NDF (Read)}{
  (Default - null)

  The name of the output file to contain the output table.

  The table will be a standard \starman table format file. It
  is a \starman ADAM .SDF image, with `real' 32-bit real values,
  with each column having a header of up to 20 characters, and
  each row having a name of up to 20 characters.

}\sstsubsection{TITLE = LITERAL (Read)}{
  (Default - Input table title or 'Output from TBWEED'   \hspace*{6ex}
   Choice - any)

    The Title to be added to the output file.

}}}

\end{small}

\end{document}
