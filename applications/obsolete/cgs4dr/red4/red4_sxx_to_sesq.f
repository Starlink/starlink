*+  RED4_SXX_TO_SESQ - Convert meanX, sumX**2 and N into standard error squared
      SUBROUTINE RED4_SXX_TO_SESQ( XMEAN, SXX, NELM, NADDS, SESQ,
     :   STATUS )
*    Description :
*     This routine calculates the "standard error squared" for each
*     pixel in a data set, given the average value, the sum of the
*     values squared and the number of coadds making up the data.
*
*     The routine is used for converting the mean and sum of squares
*     arrays generated by the ADP into standard error squared.
*    Invocation :
*     CALL RED4_SXX_TO_SESQ (XMEAN, SXX, NELM, NADDS, SESQ,
*    :   STATUS)
*    Parameters :
*     XMEAN( NELM )  = REAL( READ )
*           The average of the data values.
*     SXX( NELM )    = REAL( READ )
*           The sum of the squares of the data values.
*     NELM           = INTEGER( READ )
*           The number of elements in the arrays.
*     NADDS          = INTEGER( READ )
*           The number of coadds which have been combined to obtain
*           the mean data values and sum of squares.
*     SESQ( NELM )   = REAL( WRITE )
*           The "standard error squared" for the data.
*    Method :
*     The algorithm used is described by P.R.Bevington, 1969. "Data
*     Reduction and Error Analysis for the Physical Sciences", p.19.
*     The variance is divided by NADDS to obtain standard error squared.
*    Deficiencies :
*    Bugs :
*    Authors :
*     J. Lightfoot (REVAD::JFL)
*     S.M.Beard (REVAD::SMB)
*     P.N.Daly (JACH::PND)
*    History :
*     1989?:       Original version.                            (JFL)
*     24-Jul-1990: History added. Local double precision
*                  variables used to guard against rounding
*                  errors. Mistake in prologue corrected. Code
*                  spaced out.                                  (SMB)
*      4-Oct-1990: Algorithm checked against that quoted in
*                  Bevington. "Description" amended. "Parameters"
*                  and "Method" added. Code restructured and
*                  comments added. Test on NADDS taken outside
*                  loop. Renamed from RED4_VARIANCE to
*                  RED4_SXX_TO_SESQ.                            (SMB)
*     23-Feb-1993: Conform to error stategy                     (PND)
*    endhistory
*    Type Definitions :
      IMPLICIT NONE
*    Global constants :
      INCLUDE 'ADAMDEFNS'
      INCLUDE 'ADAMERRS'
*    Import :
      INTEGER
     :  NELM,                       ! Number of elements in arrays
     :  NADDS                       ! Number of coadds in arrays
      REAL
     :  XMEAN( NELM ),              ! Pixel averages (=SUMX/NADDS)
     :  SXX( NELM )                 ! Sum of squares
*    Export:
      REAL
     :  SESQ( NELM )                ! The "standard error squared"
*    Status :
      INTEGER
     :  STATUS                      ! Global status
*    Local Constants :
*    Local variables :
      INTEGER
     :  I                           ! Loop index
      DOUBLE PRECISION
     :  DXMEAN,                     ! Double precision XMEAN
     :  DDEN,                       ! Double precision denominator
     :  DSUM1, DSUM2,               ! Double precision sums
     :  DSESQ                       ! Double precision "standard error squared"
*-

*   Check for error on entry
      IF ( STATUS .NE. ADAM__OK ) RETURN

*   Check that the number of coadds is at least 2 (otherwise a divide
*   by zero will occur).
      IF ( NADDS .GT. 1 ) THEN

*      Loop through each of the array elements
         DO I = 1, NELM

*         Load up some local double precision variables :-
            DSUM1 = DBLE( SXX(I) )
            DXMEAN = DBLE( XMEAN(I) )
            DSUM2 = DBLE( NADDS ) * DXMEAN * DXMEAN
            DDEN = DBLE( NADDS ) * DBLE( NADDS - 1 )

*         Calculate the standard error squared, using the population variance.
            DSESQ = ( DSUM1 - DSUM2 ) / DDEN

*         Assign this result to the single precision output array.
            SESQ(I) = REAL( DSESQ )

*         Ensure a rounding error can never make the standard error
*         squared less than zero.
            IF ( SESQ(I) .LT. 0.0 ) THEN

               SESQ(I) = 0.0
            END IF
         END DO
      ELSE

*      The number of coadds is less that 1. Return a zero standard
*      error squared array.
         DO I = 1, NELM

            SESQ(I) = 0.0
         END DO
      END IF

      END
