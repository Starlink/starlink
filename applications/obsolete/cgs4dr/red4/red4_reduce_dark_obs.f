*+  RED4_REDUCE_DARK_OBS - Reduce a complete DARK observation
      SUBROUTINE RED4_REDUCE_DARK_OBS (OBS_NAME, STATUS)
*    Description :
*     This routine take a DARK observation of name Oyymmdd_n in ODIR, searches
*     IDIR (the raw integration directory) for the integrations that belong to
*     it (Iyymmdd_n_m) and reduces them all at once into a reduced observation
*     file ROyymmdd_n in RODIR. Individual files containing reduced integrations
*     are not produced.
*
*     The reduction in this case consists of
*        dividing the numbers coadded in the ADP for each integration by the
*        number of exposures that went into the coadd, subtracting the
*        corresponding BIAS observation
*     then adding the result into the result array of the observation.
*     Errors are calculated from the spread of the numbers about the mean.
*     Chopped integrations are not allowed, nor are weighted frames.
*     It is assumed that a valid BIAS (if required) observation is available
*     and filed in the index file.
*
*     When this routine is entered the parent observation file has already been
*     opened by the DSA system, and a file to hold the reduced observation
*     has been created and opened.
*
*    Invocation :
*     CALL RED4_REDUCE_DARK_OBS (OBS_NAME, STATUS)
*    Parameters :
*     parameter[(dimensions)]=type(access)
*           <description of parameter>
*    Method :
*    Deficiencies :
*     The routine is still badly structured, and the errors
*     reported by this routine can be unhelpful or even
*     misleading. A better error reporting strategy is needed.
*
*     Note that the logical names IDIR:, ODIR:, RIDIR:, RODIR: CANNOT
*     be changed, because the character handling in the code has
*     assumptions about these names hard-wired in various places.
*
*     DSA status values do not conform to the ADAM scheme. It has
*     therefore been necessary to trap these statuses before they
*     get translated into confusing messages like "exceeded quota".
*     The traps can be removed once DSA conforms.
*    Bugs :
*     The DTA cache bug, mentioned in the history section, has been
*     fixed. At the time of writing, the routine needs to be linked
*     with a private version of DTA_CACHEL to solve this problem.
*    Authors :
*     John Lightfoot (REVAD::JFL)
*     Steven Beard (REVAD::SMB)
*     Phil Daly (JACH::PND)
*    History :
*     1989:  Original (JFL)
*     22-Jan-1990: Modified to overcome compilation problems
*                  in RED4_DO_COADD.                         (SMB)
*     24-Jan-1990: Converted from RED4_REDUCE_BIAS_OBS into
*                  RED4_REDUCE_DARK_OBS, following JFL's
*                  suggestions.                              (SMB)
*     29-Jan-1990: Frantic effort to remove the bugs
*                  generated by the above editing. Addresses
*                  of IRACS and OPTICAL structures defined.  (SMB)
*     29-Jan-1990: It still didn't work. The CGS4_INT_DESCR
*                  structure is required to obtain the name
*                  of a suitable BIAS observation, but this
*                  structure is not available until an
*                  integration file is opened. Code modified
*                  So that the CGS4_INT_DESCR structure in
*                  the FIRST integration file is used. This
*                  assumes that the SAME BIAS observation may
*                  be used to calibrate every integration.   (SMB)
*     30-Jan-1990: The LINEARISED flag was being written into
*                  the CGS4_OBSRED structure instead of the
*                  CGS4_INTRED structure. Also, I forgot to
*                  record the name of the BIAS observation in
*                  each CGS4_INTRED structure. Mistakes
*                  corrected.                                (SMB)
*     7-Feb-1990:  Major re-write. BIAS observation now stored in
*                  'virtual' common. GOTO 500s replaced by inherited
*                  bad status. Same BIAS need not be used for all
*                  integrations, separate reduction path for first
*                  integration removed.                      (JFL)
*     20-Feb-1990: Null bad pixel mask changed from ' ' to '#',
*                  as it was difficult to process ' ' with ICL
*                  variables.                                (SMB)
*     26-Feb-1990: More detailed description of method added (JFL)
*      9-Mar-1990: MAXDIM and RMAXDIM parameters added.      (SMB)
*      9-Mar-1990: VARIANCE_MAP added to ensure that variance array is checked
*                  for negative numbers if it has been mapped, even if status
*                  is bad at the checkpoint. Modified so that the same
*                  BIAS, FLAT-FIELD observation used for every integration.
*                  JFL says this is a lot more efficient after all. (SMB, JFL)
*      9-Mar-1990: Division by number of exposures commented out,
*                  since this operation is now carried out
*                  automatically by the ADP. (If this works, the
*                  code may be deleted).                     (SMB)
*      9-Mar-1990: Division by number of exposures commented out,
*                  since this operation is now carried out
*                  automatically by the ADP. (If this works, the
*                  code may be deleted).                     (SMB)
*     12-Mar-1990: Bug fix. Superfluous call to DSA_CLOSE removed.(SMB)
*     20-Apr-1990: This routine has been found to corrupt the
*                  COADDED_INTS structure when reducing the
*                  second integration of an observation. For some
*                  reason the COADDED_INTS structure is being
*                  copied instead of the reduced integration
*                  template. Experiments with the debugger have
*                  failed to duplicate this fault. Temporary
*                  DSA_WRUSERs have been added so that any
*                  corruption of INT_RECORD can be detected
*                  next time the error occurs.                 (SMB)
*     23-Apr-1990: No corruption of any pointers can be
*                  detected. Suspect the bug may be a subtle
*                  memory corruption problem, especially as
*                  the fault seems to depend on what data has
*                  been reduced in the past, and can be made
*                  to go away by killing and reloading RED4.
*                  RED4_SEEK_OBSERVATION is the suspected
*                  culprit. Offending code from this routine
*                  commented out as a temporary fudge so that
*                  the system will work for tomorrow's first
*                  light.                                      (SMB)
*     24-Apr-1990: Because of memory corruption problems, the
*                  code needs to be compiled with array bounds
*                  checking switched on. The Figaro dynamic
*                  memory functions (DYN_ELEMENT, DYNAMIC_MEM,
*                  DYN_INCREMENT) would not allow this. Code
*                  modified to use %val() instead.            (SMB)
*     24-Apr-1990: DYN_INCREMENT replaced by direct
*                  manipulation of address (with the aid of
*                  DSA_TYPESIZE).                             (SMB)
*     24-Apr-1990: Fudge removed so the memory corruption
*                  bug can be investigated.                   (SMB)
*     25-Apr-1990: A different bug fix. This routine was
*                  ignoring the quality array in the reduced
*                  BIAS observation instead of passing it on
*                  to the DARK. BIAS_QUAL is now copied to
*                  WORK_QUAL.                                 (SMB)
*     26-Apr-1990: Debug statements removed, as they are no
*                  longer useful.                             (SMB)
*     30-Apr-1990: Corruption bug investigations abandonned.
*                  More detail added to "Bugs" section .      (SMB)
*      2-May-1990: The routines DSA_GET_DATA_INFO and
*                  DSA_SET_DATA_INFO require a double
*                  precision array for the NUM_ARRAY argument.
*                  This routine was giving an integer (0),
*                  which could cause problems. Fixed.         (SMB)
*      4-May-1990: Superfluous output commented out.          (SMB)
*      4-May-1990: All masks now written to CGS4_MASKS
*                  directory.                                 (SMB)
*      5-Jul-1990: Commented out code removed.                (SMB)
*      6-Jul-1990: Made to write object name and exposure
*                  time in a standard Figaro structure (as
*                  well as the special CGS4 structure). (Why
*                  was this not done in the first place??).   (SMB)
*     10-Jul-1990: Hard-wired "4"s replaced by "FLOATSIZE".   (SMB)
*     20-Jul-1990: "Integration does not exist" message was
*                  confusing. Replaced.                       (SMB)
*     20-Jul-1990: Modified to check that the number of
*                  detector increments is 1. Oversampled
*                  DARK frames are not allowed.               (SMB)
*     23-Jul-1990: Checked to ensure that 4 digit
*                  observation and integration numbers can
*                  be processed.                              (SMB)
*     31-Jul-1990: The 15 character limit on the length of
*                  the name of the DSA COADDS structures was
*                  causing problems when the observation and
*                  integration numbers became large. COADDS
*                  structure naming convention changed from
*                  Iyymmdd_oooo_iiii to I_oooo_iiii.          (SMB)
*      6-Aug-1990: Bug, which caused the string 'CGS4_MASKS:'
*                  to be erroneously tacked onto the beginning
*                  of the 'Propagated from BIAS observation'
*                  string, fixed.                             (SMB)
*     22-Aug-1990: Phase 1 of major changes: Header
*                  information in the observation and reduced
*                  observation files is now written in a .FITS
*                  structure. Linearisation coefficients are
*                  now obtained from a file rather than being
*                  buried in the data structure. KTC mode
*                  replaced by NDR.                           (SMB)
*      3-Sep-1990: Phase 2 of major changes: Header
*                  information in the integration and reduced
*                  integration files is now written in a .FITS
*                  structure.                                 (SMB)
*      6-Sep-1990: The phase 2 changes made the reduced
*                  observation data structure created when
*                  reducing a whole observation in one go
*                  different from that created when reducing
*                  one integration at a time. This effect fixed
*                  by copying the .FITS structure from the raw
*                  integration to the CGS4_COADDS structure,
*                  rather than from the reduced integration
*                  template.                                  (SMB)
*      7-Sep-1990: Output made less verbose.                  (SMB)
*     14-Sep-1990: MASKUSED, BIASUSED and LINEARIS parameters
*                  written to FITS structure of reduced
*                  observation file.                          (SMB)
*     14-Sep-1990: Code simplified by encapsulating low-level
*                  DTA calls in RED4_COPY_STRUCTURE.          (SMB)
*     26-Sep-1990: Dimension check between integrations and
*                  bad pixel mask included.                   (SMB)
*     26-Sep-1990: Modified to check the MASK parameter, to
*                  be more consistent with the other routines.(SMB)
*      7-Nov-1990: Modified to check for the -50.0 values
*                  set by the ADP when it detects a bad value.(SMB)
*     21-Nov-1990: The routine RED4_SEEK_OBSERVATION has to be
*                  changed to allow wavelength calibration.
*                  This routine modified to keep up.          (SMB)
*     23-Nov-1990: Bug fix: Only call RED4_FLAG_BAD if the
*                  status is ok (to prevent adjustable array
*                  bounds violation).                         (SMB)
*     29-Nov-1990: Modified to read linearisation coefficients
*                  from a text file. MAXDIM and RMAXDIM constants
*                  moved to RED4_COMMON.INC. Unnecessarily
*                  large character variables reduced in size. (SMB)
*     13-Feb-1991: Modified to reject observations with no
*                  integrations.                              (SMB)
*     24-Feb-1991: DSA error statuses trapped, as these no
*                  not conform to the ADAM error scheme.      (SMB)
*      1-OCT-1991: Change GEN_routines.                       (PND)
*      8-Oct-1991: Call RED4_GET_OBSERVATION instead of
*                  RED4_SEEK_OBSERVATION, so that calibration
*                  observations can be specified explicitly when
*                  required (DRIMP/5.1 and 5.2).              (SMB)
*     20-Jul-1992: Add SUBTRACT_BIAS option                   (PND)
*     22-Feb-1993: Conform to error strategy                  (PND)
*      7-Jan-1993: Allow NDFs, include PRM_PAR                (PND)
*      7-Nov-1994: Make vaguely portable                   (AB)
*    endhistory
*    Type Definitions :
      IMPLICIT NONE
*    Global constants :
      INCLUDE 'SAE_PAR'
      INCLUDE 'PRM_PAR'
*    Status :
      INTEGER STATUS
*    Input :
      CHARACTER*(*) OBS_NAME             ! the basic name of the observation
*                                             file to be reduced, e.g.O890816_1
*    External references :
      INTEGER DSA_TYPESIZE               ! DSA type size enquiry function
      INTEGER CHR_LEN                    ! ADAM stringlength function
      CHARACTER*13 ICH_CI                ! Figaro integer->string function
      CHARACTER*2 GEN_NTH                ! Figaro "Nth" determination function
*                                            (i.e. 1st, 2nd, 3rd, 4th ...)
*    Global variables :
      INCLUDE 'RED4_COMMON.INC'          ! 'Virtual common' block, holding
*                                             reduced BIAS observation required
*                                             for this reduction.
*    Local Constants :
      INTEGER DTA__OK                    ! DTA success status
      PARAMETER ( DTA__OK = 0 )
*    Local variables :
      INTEGER BYTESIZE                   ! Bytes per element of 'BYTE' array
      INTEGER FLOATSIZE                  ! Bytes per element of 'FLOAT' array
      LOGICAL LOOPING                    ! T while looping through component
*                                            integrations
      LOGICAL EXIST                      ! T if the integration file currently
*                                            being searched for exists
      LOGICAL FIRST                      ! T if this is the first integration
*                                            in the observation to be reduced
      LOGICAL VARIANCE_MAP               ! T if variance array of reduced
*                                            observation has been mapped
      INTEGER INTEGRATION                ! number of integration currently being
*                                            added to the observation
      INTEGER TOTAL_INTS                 ! Total number of integrations
      INTEGER NDIM                       ! the dimensions of the integration
*                                             array
      INTEGER DIMS( MAXDIM )             !                "
      INTEGER N_EXPOSURES                ! the number of exposures that were
*                                             coadded in the integration
      INTEGER DET_NINCR                  ! The number of detector positions
*                                        !   which are being combined into
*                                        !   the current observation.
      INTEGER DET_INDEX                  ! the index of the detector position
*                                             at which the current integration
*                                             was taken
      INTEGER DTA_STATUS                 ! obvious
      INTEGER INT_SLOT                   !  for integration data
      INTEGER INT_DATA                   !        "
      INTEGER DATA_SLOT                  !  for reduce observation data
      INTEGER RED_DATA                   !        "
      INTEGER QUAL_SLOT                  !  quality
      INTEGER RED_QUAL                   !        "
      INTEGER VAR_SLOT                   !  variances
      INTEGER RED_VAR                    !        "
      INTEGER COADDS_SLOT                !  coadds data in reduced observation
      INTEGER COADDS_PTR                 !        "
      INTEGER INDEX_SLOT                 !  index array in reduced observation.
*                                              the index array points each
*                                              column of an integration at a
*                                              particular detector position to
*                                              its place in the reduced data
      INTEGER INDEX_PTR                  !        "
      INTEGER MASK_SLOT                  !  pixel quality mask
      INTEGER MASK_DATA                  !        "
      INTEGER WORK_SLOT                  !  temporary work area
      INTEGER WORK_DATA                  !        "
      INTEGER WORK_V_SLOT                !  with variances
      INTEGER WORK_VAR                   !        "
      INTEGER WORK_Q_SLOT                !  and quality
      INTEGER WORK_QUAL                  !        "
      INTEGER NELM                       ! number of elements in integration
*                                             array
      INTEGER NPLANE                     ! number of elements in one plane of
*                                             the integration array
      INTEGER OBSDIMS( RMAXDIM )         ! dimensions of reduced observation
*                                             data
      INTEGER INTDIMS( RMAXDIM )         ! dimensions of reduced integration
*                                             data
      INTEGER INDEX_DIMS( RMAXDIM )      ! dimensions of index array in
*                                             reduced observation data.
      INTEGER NELM_OBS                   ! number of elements in reduced
*                                             observation data array
      INTEGER N_COEFFS                   ! number of non-zero coefficients in
*                                             array linearisation polynomial
      INTEGER I                          ! DO loop
      INTEGER LDAY, LDATE, LHOUR         ! lengths of date strings
      INTEGER IGNORE                     ! unimportant parameter
      INTEGER CLEN                       ! Non-blank length of character string
      INTEGER DSA_STATUS                 ! DSA status value
      INTEGER CPOS                       ! Position in character string.
      REAL EXPOSURE_TIME                 ! on-chip exposure time
      REAL INTEGRATION_TIME              ! EXPOSURE_TIME * N_EXPOSURES
      REAL OBSERVATION_TIME              ! total integration for det_index 1
*                                             columns in reduced observation
      DOUBLE PRECISION
     :  LCOEFFS( MAXCOEFFS )             ! Linearisation coefficients array
      CHARACTER*80 INDEX_FILE            ! The name of the relevant index file.
      CHARACTER*80 BIAS_NAME             ! The name of the file containing the
*                                             reduced BIAS observation
      CHARACTER*80 COADDED_INTS          ! DTA name of .COADDED_INTS structure
*                                             in reduced observation file
      CHARACTER*80 OBSREDFILE            ! full name of file holding reduced obs
      CHARACTER*80 INTNAME               ! the name of a particular integration
*                                             belonging to the observation
*                                             being reduced
      CHARACTER*80 COADD_NAME            ! The name of the COADD structure
*                                        !    corresponding to an integration
      CHARACTER*80 ROOT                  ! the root from which the INTNAMEs are
*                                             derived
      CHARACTER*80 OBJECT                ! DTA name of an object to be accessed
      CHARACTER*80 ERROR                 ! DTA error translation
      CHARACTER*80 INT_TYPE              ! type of integration
      CHARACTER*80 MASK                  ! file containing dud-pixel info
      CHARACTER*80 LINCOEFFS             ! file containing linearisation
*                                        !    coefficients
      CHARACTER*80 RECORD                ! DTA name of reduction record extensions
*                                             in reduced integration and
*                                             observation structures
      CHARACTER*40 OBJECT_NAME           ! The name of the object
      CHARACTER*32 CHAR_ARRAY(2)         ! array to hold data units and title
      CHARACTER*40 TIME                  ! A string holding the date of the
*                                             reduction
      CHARACTER*20 DAY, DATE, HOUR       ! components of date
      CHARACTER*4  SUBTRACT_BIAS         ! Subtract a BIAS frame?
      CHARACTER*8  ITEM                  ! Name of FITS item
      CHARACTER*4  COMMENT               ! Dummy comment
      LOGICAL      PROCEED_BIAS          ! T if BIAS frame to be subtracted
      CHARACTER*20 LPREFIX               ! prefix to add to file
*    Internal References :
*    Local data :
*-

*    Return if entry status bad
      IF ( STATUS .NE. SAI__OK ) RETURN

*    The observation file has already been opened as 'OBS_IN', and a file
*    created to contain the reduced observation and opened as 'OBS_RED',
*    before this routine is called
*    Get the INT_TYPE (i.e. the observation mode; CHOP, STARE etc...)
      DSA_STATUS = SAI__OK
      CALL DSA_GET_FITS_C( 'OBS_IN', 'INTTYPE', 0, INT_TYPE,
     :  COMMENT, DSA_STATUS )

*    Chop observations and weighted frames are meaningless for a DARK
*    observation, so treat them as an error.
      IF (INDEX(INT_TYPE,'CHOP') .NE. 0) THEN

         STATUS = SAI__ERROR
         CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :     /'This DARK observation was taken in chop '/
     :     /'mode. There must have been a mistake!', STATUS )
      ENDIF

      IF (INDEX(INT_TYPE,'WEIGHTED') .NE. 0) THEN

         STATUS = SAI__ERROR
         CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :     /'This DARK observation was taken in '/
     :     /'weighted frames mode which is '/
     :     /'meaningless. There must have been a '/
     :     /'mistake!', STATUS )
      ENDIF

*    Check that the number of detector increments is 1, and hence that
*    the observation has not been made with oversampling (which is only
*    relevant for SPECTRA-type observations).
      CALL DSA_GET_FITS_I( 'OBS_IN', 'DETNINCR', 0, DET_NINCR,
     :  COMMENT, DSA_STATUS )

      IF ( DSA_STATUS .EQ. SAI__OK ) THEN

         IF ( DET_NINCR .NE. 1 ) THEN

            STATUS = SAI__ERROR
            CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :       /'This DARK observation was taken with '/
     :       /'oversampling, which is not sensible. '/
     :       /'There must have been a mistake!', STATUS )
         END IF
      ELSE

         STATUS = SAI__ERROR
         CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :     /'Error getting FITS item DETNINCR', STATUS )
      END IF

*    Obtain the name of the bad pixel mask to be used, if any.
*    If a mask has been specified, map its data as a byte array.
      CALL PAR_GET0C ('MASK', MASK, STATUS)
      CALL PAR_CANCL ('MASK', STATUS)
      CPOS = INDEX( MASK, ':')
      IF (CPOS .EQ. 0) CPOS = INDEX( MASK, '/')
      IF ( CPOS .EQ. 0 ) THEN
         CALL RED4_GET_PREFIX ('MASK', LPREFIX, STATUS)
         CLEN = CHR_LEN( MASK )
         MASK = LPREFIX(:CHR_LEN(LPREFIX)) // MASK(1:CLEN)
      END IF

      IF ( INDEX( MASK, '#' ) .EQ. 0 ) THEN

         IF ( VERBOSE ) THEN

            CALL MSG_SETC( 'MASK', MASK )
            CALL MSG_OUT( ' ', 'Using the bad pixel mask ^MASK',
     :        STATUS )
         END IF

         DSA_STATUS = STATUS
         CALL DSA_NAMED_INPUT ('MASK', MASK, DSA_STATUS)
         CALL DSA_MAP_DATA ('MASK', 'READ', 'BYTE', MASK_DATA,
     :     MASK_SLOT, DSA_STATUS)
      ENDIF

*    Find out if we are to subtract a BIAS
      IF ( DSA_STATUS .NE. SAI__OK ) THEN
         STATUS = SAI__ERROR
         CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :     /'Error before subtracting BIAS', STATUS )
      END IF

      CALL PAR_GET0C( 'SUBTRACT_BIAS', SUBTRACT_BIAS, STATUS )

      IF ( SUBTRACT_BIAS .EQ. 'YES' ) THEN

         PROCEED_BIAS = .TRUE.
      ELSE IF ( SUBTRACT_BIAS .EQ. 'NO' ) THEN

         PROCEED_BIAS = .FALSE.
      ELSE

         CALL PAR_CANCL( 'PROCEED_BIAS', STATUS )
         CALL PAR_GET0L( 'PROCEED_BIAS', PROCEED_BIAS, STATUS )
      ENDIF

      IF ( INDEX( INT_TYPE, 'NDR' ) .NE. 0 ) PROCEED_BIAS = .FALSE.

      IF ( VERBOSE ) THEN

         IF ( .NOT. PROCEED_BIAS ) CALL MSG_OUT( ' ',
     :      'No BIAS subtraction will be performed', STATUS )
      ENDIF

*    Find out if the data are to be linearised with some previously
*    defined linearisation polynomial. The polynomial coefficients
*    are held in a text file. If the name of the file is given
*    as '#', then no linearisation will be carried out.
      IF ( DSA_STATUS .NE. SAI__OK ) THEN
         STATUS = SAI__ERROR
         CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :     /'Error before linearisation', STATUS )
      END IF

      CALL PAR_GET0C( 'LINCOEFFS', LINCOEFFS, STATUS )
      CALL PAR_CANCL( 'LINCOEFFS', STATUS )

      IF ( STATUS .EQ. SAI__OK ) THEN

         IF ( INDEX( LINCOEFFS, '#' ) .EQ. 0 ) THEN

*         Read the linearisation coefficients from the named file.
            CALL RED4_READ_COEFFS( LINCOEFFS, MAXCOEFFS, N_COEFFS,
     :        LCOEFFS, STATUS )
         END IF
      END IF

*    Get the exposure time for the integrations in this observation
      DSA_STATUS = STATUS
      CALL DSA_GET_FITS_F( 'OBS_IN', 'DEXPTIME', 0, EXPOSURE_TIME,
     :  COMMENT, DSA_STATUS )

      IF ( DSA_STATUS .EQ. SAI__OK ) THEN

         IF (EXPOSURE_TIME .LE. 0.0) THEN

            STATUS = SAI__ERROR
            CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :        /'Exposure time is negative', STATUS )
         ENDIF
      ELSE

         STATUS = SAI__ERROR
         CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :     /'Error getting FITS item DEXPTIME', STATUS )
      ENDIF

*    Map in the data array of the reduced observation file, and the
*    variance and quality arrays.
      CALL DSA_USE_QUALITY ('OBS_RED', DSA_STATUS)
      CALL DSA_MAP_DATA ('OBS_RED', 'WRITE', 'FLOAT', RED_DATA,
     :   DATA_SLOT, DSA_STATUS)
      CALL DSA_MAP_QUALITY ('OBS_RED', 'WRITE', 'BYTE', RED_QUAL,
     :   QUAL_SLOT, DSA_STATUS)
      CALL DSA_MAP_VARIANCE ('OBS_RED', 'WRITE', 'FLOAT', RED_VAR,
     :   VAR_SLOT, DSA_STATUS)

      IF (DSA_STATUS .EQ. SAI__OK) THEN

         VARIANCE_MAP = .TRUE.
      ELSE

         VARIANCE_MAP = .FALSE.
      ENDIF

      CALL DSA_DATA_SIZE ('OBS_RED', RMAXDIM, NDIM, OBSDIMS,
     :  NELM_OBS, DSA_STATUS)

*    Obtain the number of bytes per element in a data array of
*    type 'FLOAT' from DSA
      FLOATSIZE = DSA_TYPESIZE( 'FLOAT', DSA_STATUS )
      BYTESIZE  = DSA_TYPESIZE( 'BYTE', DSA_STATUS )

*    Initialise the variance array to zero
      IF ( DSA_STATUS .EQ. SAI__OK ) THEN

         CALL GEN_FILL( FLOATSIZE*NELM_OBS, 0, %val(RED_VAR) )
      END IF

*    Open the COADDS structure of the reduced observation file. This will
*    hold info on how many coadds have gone into the result array. Map in
*    its data array, and get the DTA name of the associated .COADDED_INTS
*    structure that will hold the (compressed) names of those
*    integrations that are added
      CALL DSA_GET_ACTUAL_NAME ('OBS_RED', OBSREDFILE, DSA_STATUS)

      CALL DSA_NAMED_INPUT ('COADDS',
     :   OBSREDFILE(1:CHR_LEN(OBSREDFILE))/
     :   /'.MORE.CGS4_COADDS', DSA_STATUS)
      CALL DSA_MAP_DATA ('COADDS', 'UPDATE', 'SHORT', COADDS_PTR,
     :   COADDS_SLOT, DSA_STATUS)
      CALL DSA_SPECIFIC_STRUCTURE ('COADDS', 'COADDED_INTS',
     :   'UPDATE', COADDED_INTS, DSA_STATUS)

*    Map in the index array of the reduced observation file
      CALL DSA_NAMED_INPUT ('INDEX', OBSREDFILE(1:CHR_LEN(OBSREDFILE))//
     :   '.MORE.CGS4_INDEX', DSA_STATUS)
      CALL DSA_MAP_DATA ('INDEX', 'READ', 'SHORT', INDEX_PTR,
     :   INDEX_SLOT, DSA_STATUS)
      CALL DSA_DATA_SIZE ('INDEX', RMAXDIM, NDIM, INDEX_DIMS,
     :  NELM, DSA_STATUS)

      IF ( DSA_STATUS .NE. SAI__OK ) THEN
         STATUS = SAI__ERROR
         CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :     /'Error mapping data', STATUS )
      END IF

*    now search through the possible integration file names, and reduce them
*    into the output file
      INTEGRATION = 0
      CPOS = INDEX( OBS_NAME, ':' )
      IF (CPOS .EQ. 0) CPOS = INDEX( OBS_NAME, '/')
      CLEN = CHR_LEN( OBS_NAME )

*    get the prefix
      CALL RED4_GET_PREFIX ('I', LPREFIX, STATUS)

      ROOT = LPREFIX(:CHR_LEN(LPREFIX))//'i'//OBS_NAME(2+CPOS:CLEN)//'_'
      LOOPING = .TRUE.
      FIRST = .TRUE.
      OBSERVATION_TIME = 0.0

*    Now loop through the possible integration files, stopping when we
*    come across one that doesn't exist.
      DO WHILE (LOOPING)

*       construct integration file name
         INTEGRATION = INTEGRATION + 1
         INTNAME = ROOT(1:CHR_LEN(ROOT))//ICH_CI(INTEGRATION)

*       we've finished if it doesn't exist
         CALL DSA_SEEK_NAMED_STRUCTURE (INTNAME, EXIST, DSA_STATUS)

         IF ( DSA_STATUS .NE. SAI__OK ) THEN
            STATUS = SAI__ERROR
            CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :        /'Error seeking integration', STATUS )
         END IF

         IF (.NOT. EXIST) THEN

            TOTAL_INTS = INTEGRATION - 1
            IF ( TOTAL_INTS .EQ. 0 ) THEN

               STATUS = SAI__ERROR
               CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :           /'This observation has no '/
     :           /'integrations', STATUS )
            ELSE IF ( TOTAL_INTS .EQ. 1 ) THEN

               CALL MSG_OUT( ' ', '1 integration only',
     :           STATUS )
            ELSE

               CALL MSG_SETI( 'TOTAL_INTS', TOTAL_INTS )
               CALL MSG_OUT( ' ', '^TOTAL_INTS integrations in total',
     :           STATUS )
            END IF

            LOOPING = .FALSE.
         ELSE

            IF ( (STATUS .EQ. SAI__OK) .AND. (VERBOSE) ) THEN

               CALL MSG_SETC( 'INTNAME', INTNAME )
               CALL MSG_OUT( ' ',
     :           'Reducing DARK integration ^INTNAME', STATUS )
            ENDIF

*          open the file.
            DSA_STATUS = STATUS
            CALL DSA_NAMED_INPUT ('INT_IN', INTNAME, DSA_STATUS)

*         If a bad pixel mask has been specified, check that the first
*         two dimensions of the integration data array match those of
*         the bad pixel mask.
            IF ( INDEX( MASK, '#' ) .EQ. 0 ) THEN

               CALL DSA_MATCH_DIMENSION( 'INT_IN', 1, 'MASK', 1,
     :           DSA_STATUS )
               CALL DSA_MATCH_DIMENSION( 'INT_IN', 2, 'MASK', 2,
     :           DSA_STATUS )
            END IF

*         Get the number of exposures in this integration N_EXPOSURES
            CALL DSA_GET_FITS_I( 'INT_IN', 'NEXP', 0, N_EXPOSURES,
     :        COMMENT, DSA_STATUS )

            IF (DSA_STATUS .EQ. SAI__OK) THEN

               IF (N_EXPOSURES .LT. 1) THEN

                  STATUS = SAI__ERROR
                  CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :              /'No exposures were made during the '/
     :              /'integration', STATUS )
               ENDIF
            ELSE

               STATUS = SAI__ERROR
               CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :           /'Error getting FITS item NEXP', STATUS )
            ENDIF

*          Get the detector position index of this particular integration
            CALL DSA_GET_FITS_I( 'INT_IN', 'DINDEX', 0, DET_INDEX,
     :        COMMENT, DSA_STATUS )

*          check that the index array can handle this index position (always
*          should do but the program will crash*?! if it doesn't)
            IF (DSA_STATUS .EQ. SAI__OK) THEN

               IF ((INDEX_DIMS(2) .LT. DET_INDEX) .OR.
     :                                      (DET_INDEX .LT.1 ))THEN

                  STATUS = SAI__ERROR
                  CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :              /'Detector position is outside '/
     :              /'range of the index array for this '/
     :              /'observation', STATUS )
               ENDIF
            ELSE

               STATUS = SAI__ERROR
               CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :           /'Error getting FITS item DINDEX', STATUS )
            ENDIF

*          Work out integration time
            INTEGRATION_TIME = N_EXPOSURES * EXPOSURE_TIME

            IF (DET_INDEX .EQ. 1) THEN

               OBSERVATION_TIME = OBSERVATION_TIME + INTEGRATION_TIME
            ENDIF

*          If this is the first integration to be reduced, search for
*          other reduced observations that will be required.
*          ALL INTEGRATIONS WILL BE REDUCED USING THE SAME BIAS.
            IF (FIRST) THEN

               FIRST = .FALSE.

*             If non-destructive reads are not being used, then we need
*             a ready reduced BIAS observation for this reduction.
*             RED4_GET_OBSERVATION will either search the index file for a
*             suitable BIAS, or use one which has been specified explicitly.
*             The data, errors and quality for this observation will be held
*             in virtual memory, with the relevant pointers stored in
*             /RED4_COMMON/.
               IF ( PROCEED_BIAS .AND.
     :              (INDEX(INT_TYPE,'NDR').EQ.0) ) THEN

*                  Construct the name of the the observation index file
*                  which should have a name of the form CGS4_yymmdd.INDEX
*                  Index files are found in the directory whose logical name is
*                  CGS4_INDEX.
                  CALL RED4_OBSTOINDEX( OBS_NAME, INDEX_FILE, STATUS )

*                  Either search the index file for a suitable BIAS observation
*                  or use one specified explicitly.
                  CALL RED4_GET_OBSERVATION ( INDEX_FILE, 'OBS_IN',
     :               'BIAS', BIAS_NAME, STATUS)

                  IF (STATUS .EQ. SAI__OK) THEN

                     IF (BIAS_NAME .EQ. ' ') THEN

                        STATUS = SAI__ERROR
                        CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :                    /'No suitable reduced BIAS '/
     :                    /'observation found. '/
     :                    /'Data reduction aborted!', STATUS )
                     ELSE

                        CALL MSG_SETC( 'BIAS_NAME', BIAS_NAME )
                        CALL MSG_OUT(' ', 'Using the reduced BIAS '/
     :                    /'observation in ^BIAS_NAME', STATUS )
                     ENDIF
                  ENDIF
               ENDIF

*             Find the size of the input integration array and create two 2-d
*             work arrays to match, one to hold the data, one to hold the
*             variances. The variance array is only used to fill up subroutine
*             calls so fill it with zeros (the errors of individual integrations
*             are ignored in the observation coadd). Also create a workspace
*             array for a bad pixel mask.
*             All the integrations will be the same size so the work arrays need
*             only be created once.
               DSA_STATUS = STATUS
               CALL DSA_DATA_SIZE ('INT_IN', MAXDIM, NDIM, DIMS, NELM,
     :            DSA_STATUS)
               INTDIMS(1) = DIMS(1)
               INTDIMS(2) = DIMS(2)

               NPLANE = DIMS(1) * DIMS(2)

               CALL DSA_GET_WORKSPACE (FLOATSIZE*NPLANE, WORK_DATA,
     :            WORK_SLOT, DSA_STATUS)
               CALL DSA_GET_WORKSPACE (FLOATSIZE*NPLANE, WORK_VAR,
     :            WORK_V_SLOT, DSA_STATUS)
               CALL DSA_GET_WORKSPACE (BYTESIZE*NPLANE, WORK_QUAL,
     :            WORK_Q_SLOT, DSA_STATUS)

*            Initialise the variance array to zero.
               IF (DSA_STATUS .EQ. SAI__OK) THEN

                  CALL GEN_FILL (FLOATSIZE*NPLANE, 0, %val(WORK_VAR))
               ENDIF

*            If a bad pixel mask has been specified, copy it to the
*            quality array. Otherwise initialise the quality array to
*            zero.
               IF ( DSA_STATUS .EQ. SAI__OK ) THEN

                  IF ( INDEX( MASK, '#' ) .EQ. 0 ) THEN

                     CALL GEN_MOVE( NPLANE, %val(MASK_DATA),
     :                  %val(WORK_QUAL) )
                  ELSE

                     CALL GEN_FILL( NPLANE, 0, %val(WORK_QUAL) )
                  ENDIF
               ELSE

                  STATUS = SAI__ERROR
                  CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :              /'Error initialising variance array', STATUS )
               ENDIF
            END IF      ! end of special set-up for first integration

*          Map in the integration data array
            CALL DSA_MAP_DATA ('INT_IN', 'READ', 'FLOAT', INT_DATA,
     :         INT_SLOT, DSA_STATUS)

*          Do the reduction.
*          Copy the Phase A plane of the integration array into the work
*          array
            IF (DSA_STATUS .EQ. SAI__OK) THEN

               CALL GEN_MOVE (FLOATSIZE*NPLANE, %val(INT_DATA),
     :            %val(WORK_DATA))
            ENDIF

*          Flag as "bad" any values which the ADP has set to -50.0.
            IF ( DSA_STATUS .NE. SAI__OK ) THEN
               STATUS = SAI__ERROR
               CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :           /'Error flagging bad values', STATUS )
            END IF

            IF ( STATUS .EQ. SAI__OK ) THEN

               CALL RED4_FLAG_BAD( NPLANE, -50.0, %val(WORK_DATA),
     :           %val(WORK_QUAL), STATUS )
            END IF

            IF (STATUS .EQ. SAI__OK) THEN

*             If non-destructive reads are not being used,
*             subtract the bias observation from the result,
*             propagating the data quality from the BIAS.
               IF ( PROCEED_BIAS .AND.
     :              (INDEX(INT_TYPE,'NDR').EQ.0) ) THEN

                  CALL GEN_SUBAFV( NPLANE,
     :               %val(WORK_DATA), %VAL(BIAS_DATA),
     :               %val(WORK_DATA),%val(WORK_QUAL),
     :               %VAL(BIAS_QUAL), %val(WORK_QUAL),
     :               %val(WORK_VAR), %VAL(BIAS_VAR),
     :               %val(WORK_VAR), .TRUE., .FALSE., 0, .TRUE. )
               END IF
            ENDIF

*         Linearise the data if required.
            IF ( STATUS .EQ. SAI__OK ) THEN

               IF ( INDEX( LINCOEFFS, '#' ) .EQ. 0 ) THEN

                  IF ( VERBOSE ) THEN

                     CALL MSG_SETI( 'NCOEFFS', N_COEFFS )
                     CALL MSG_SETC( 'NTH', GEN_NTH(N_COEFFS) )
                     CALL MSG_SETC( 'LINCOEFFS', LINCOEFFS )
                     CALL MSG_OUT( ' ', 'Linearising using '/
     :                 /'^NCOEFFS^NTH order polynomial in ^LINCOEFFS',
     :                 STATUS )
                  END IF

                  CALL RED4_LINEARISE( N_COEFFS, LCOEFFS, NPLANE,
     :               %val(WORK_DATA), %val(WORK_VAR), %val(WORK_QUAL),
     :               STATUS )
               END IF
            END IF

*          Coadd the work array into the observation result. External
*          status check is to prevent adjustable array errors if any
*          of the arrays aren't mapped.
            IF (STATUS .EQ. SAI__OK) THEN

               CALL RED4_DO_COADD (%val(WORK_DATA),
     :                             %val(WORK_QUAL),
     :                             INTDIMS(1),
     :                             INTDIMS(2),
     :                             %val(INDEX_PTR),
     :                             INDEX_DIMS(1),
     :                             INDEX_DIMS(2),
     :                             DET_INDEX,
     :                             %val(RED_DATA),
     :                             %val(RED_VAR),
     :                             %val(RED_QUAL),
     :                             %val(COADDS_PTR),
     :                             OBSDIMS(1),
     :                             OBSDIMS(2),
     :                             STATUS)
            ENDIF

*          End of integration reduction -
*          Copy the FITS structure from the raw integration
*          file into a structure corresponding to the integration just
*          added in the COADDED_INTS structure. This is to record the fact
*          that this integration has been coadded into the result.
            DSA_STATUS = STATUS
            IF (STATUS .EQ. SAI__OK) THEN

               CALL RED4_INTTOCOADD( INTNAME, COADD_NAME, STATUS )
               RECORD = COADDED_INTS(1:CHR_LEN(COADDED_INTS))
     :                  // '.' // COADD_NAME

               CALL RED4_COPY_STRUCTURE( 'INT_IN.'//FITS_STRUCTURE,
     :            RECORD, STATUS )
            END IF

*          now record how this integration was reduced,
*          ensuring that all the required items are created.
*          date&time
*           IF (STATUS .EQ. SAI__OK) THEN

*              CALL GEN_TIME (6, DAY, LDAY, DATE, LDATE,
*    :            HOUR, LHOUR)
*              TIME = DATE(1:LDATE)//' at '//HOUR(1:LHOUR)

*              OBJECT = RECORD(1:CHR_LEN(RECORD))//'.STREDUCE'

*              DTA_STATUS = DTA__OK
*              CALL DTA_CRVAR( OBJECT, '_CHAR*32', DTA_STATUS )
*              DTA_STATUS = DTA__OK
*              CALL DTA_WRVARC (OBJECT, 32, TIME, DTA_STATUS)

*              IF ( DSA_STATUS .NE. DTA__OK ) THEN
*                 STATUS = SAI__ERROR
*                 CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
*    :              /'Error writing reduction date and time', STATUS )
*              END IF
*           ENDIF

*          the name of the dud pixel mask used
*           IF (STATUS .EQ. SAI__OK) THEN

*              OBJECT = RECORD(1:CHR_LEN(RECORD))//'.MASKUSED'

*              DTA_STATUS = DTA__OK
*              CALL DTA_CRVAR( OBJECT, '_CHAR*80', DTA_STATUS )
*              DTA_STATUS = DTA__OK

*              IF ( INDEX( MASK, '#' ) .EQ. 0 ) THEN

*                 CALL DTA_WRVARC (OBJECT, 80, MASK, DTA_STATUS)
*              ELSE IF ( PROCEED_BIAS .AND.
*    :                 (INDEX(INT_TYPE,'NDR').EQ.0) ) THEN

*                 CALL DTA_WRVARC (OBJECT, 80, 'Propagated from '/
*    :              /'BIAS observation', DTA_STATUS)
*              ELSE

*                 CALL DTA_WRVARC (OBJECT, 80, '(none)',
*    :              DTA_STATUS)
*              END IF

*              IF ( DSA_STATUS .NE. DTA__OK ) THEN
*                 STATUS = SAI__ERROR
*                 CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
*    :              /'Error writing MASK name', STATUS )
*              END IF
*           ENDIF

*          the name of the BIAS observation used.
*           IF (STATUS .EQ. SAI__OK) THEN

*              OBJECT = RECORD(1:CHR_LEN(RECORD))//'.BIASUSED'

*              DTA_STATUS = DTA__OK
*              CALL DTA_CRVAR( OBJECT, '_CHAR*80', DTA_STATUS )

*              DTA_STATUS = DTA__OK
*              IF ( PROCEED_BIAS .AND.
*    :              (INDEX(INT_TYPE,'NDR').EQ.0) ) THEN

*                 CALL DTA_WRVARC (OBJECT, 80, BIAS_NAME,
*    :               DTA_STATUS)
*              ELSE

*                 CALL DTA_WRVARC (OBJECT, 80, '(none)',
*    :               DTA_STATUS)
*              ENDIF

*              IF ( DSA_STATUS .NE. DTA__OK ) THEN
*                 STATUS = SAI__ERROR
*                 CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
*    :              /'Error writing BIAS name', STATUS )
*              END IF
*           ENDIF

*          the integration time
*           IF (STATUS .EQ. SAI__OK) THEN

*              OBJECT = RECORD(1:CHR_LEN(RECORD))//'.EXPOSED'

*              DTA_STATUS = DTA__OK
*              CALL DTA_CRVAR( OBJECT, '_REAL', DTA_STATUS )

*              DTA_STATUS = DTA__OK
*              CALL DTA_WRVARF (OBJECT, 1, INTEGRATION_TIME,
*    :            DTA_STATUS)

*              IF ( DSA_STATUS .NE. DTA__OK ) THEN
*                 STATUS = SAI__ERROR
*                 CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
*    :              /'Error writing integration time', STATUS )
*              END IF
*           ENDIF

*          whether linearised or not
*           IF (STATUS .EQ. SAI__OK) THEN

*              OBJECT = RECORD(1:CHR_LEN(RECORD))//'.LINEARIS'

*              DTA_STATUS = DTA__OK
*              CALL DTA_CRVAR( OBJECT, '_CHAR*3', DTA_STATUS )

*              DTA_STATUS = DTA__OK

*              IF ( INDEX( LINCOEFFS, '#' ) .EQ. 0 ) THEN

*                 CALL DTA_WRVARC (OBJECT, 80, 'yes', DTA_STATUS)
*              ELSE

*                 CALL DTA_WRVARC (OBJECT, 80, 'no', DTA_STATUS)
*              ENDIF

*              IF ( DSA_STATUS .NE. DTA__OK ) THEN
*                 STATUS = SAI__ERROR
*                 CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
*    :              /'Error writing LINEARIS', STATUS )
*              END IF
*           ENDIF

*          release the integration data array, and close the file
            DSA_STATUS = STATUS
            CALL DSA_UNMAP (INT_SLOT, DSA_STATUS)
            CALL DSA_CLOSE_STRUCTURE ('INT_IN', DSA_STATUS)
         ENDIF

*       break out of loop if status is bad
         IF ( DSA_STATUS .NE. SAI__OK ) THEN
            STATUS = SAI__ERROR
            CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :         /'A general DSA error has been detected', STATUS )
         END IF
         IF (STATUS .NE. SAI__OK) LOOPING = .FALSE.
      END DO

*    Check that the variances are non-negative, they'll crash DSA close
*    if they are. The check is made if the variances have been mapped,
*    even if status is now bad.
      IF ( VARIANCE_MAP .AND. (NELM_OBS.GT.0) ) THEN

         CALL GEN_CLIPF (%val(RED_VAR),
     :      NELM_OBS, 0.0, VAL__MAXR, IGNORE, IGNORE,
     :      %val(RED_VAR))
      ENDIF

*    Set the data label and units
      CHAR_ARRAY (1) = 'A/D numbers per exposure'
      CHAR_ARRAY (2) = 'DARK'
      CALL CHR_CTOC( CHAR_ARRAY(2), CHAR_ARRAY(2), CLEN )

      IF ( PROCEED_BIAS ) THEN
        CHAR_ARRAY(2) = '(' // CHAR_ARRAY(2)(1:CLEN) // '-BIAS)'
        CALL CHR_CTOC( CHAR_ARRAY(2), CHAR_ARRAY(2), CLEN )
      ENDIF

      CALL DSA_SET_DATA_INFO ('OBS_RED', 2, CHAR_ARRAY, 0, 0.0D0,
     :  DSA_STATUS)

*    Obtain the name of the object and write it to the reduced
*    observation structure in the standard Figaro way.
      CALL DSA_GET_FITS_C( 'OBS_IN', 'OBJECT', 0, OBJECT_NAME,
     :  COMMENT, DSA_STATUS )
      CALL DSA_SET_OBJECT( 'OBS_RED', OBJECT_NAME, DSA_STATUS )

*    Record how the reduction went
*    date&time
      CALL GEN_TIME (6, DAY, LDAY, DATE, LDATE, HOUR, LHOUR)
      TIME = DATE(1:LDATE)//' at '//HOUR(1:LHOUR)
      CLEN = MAX( 1, CHR_LEN( TIME ) )
      CALL DSA_PUT_FITS_C( 'OBS_RED', 'STREDUCE', TIME(1:CLEN),
     :  ' ', DSA_STATUS )

*    the integration time for the observation as a whole.
*    (Write this in both the FITS structure and the OBS structure).
      CALL DSA_PUT_FITS_F( 'OBS_RED', 'EXPOSED', OBSERVATION_TIME,
     :  ' ', DSA_STATUS )
      CALL DSA_SET_EXPOSURE( 'OBS_RED', OBSERVATION_TIME, DSA_STATUS )

*   The name of the bad pixel mask used
      IF ( PROCEED_BIAS .AND. (INDEX(INT_TYPE,'NDR').EQ.0) ) THEN

         CALL DSA_PUT_FITS_C( 'OBS_RED', 'MASKUSED', 'Propagated from '/
     :     /'BIAS observation', ' ', DSA_STATUS )
      ELSE IF ( INDEX( MASK, '#' ) .EQ. 0 ) THEN

         CALL DSA_PUT_FITS_C( 'OBS_RED', 'MASKUSED',
     :     MASK, ' ', DSA_STATUS )
      ELSE

         CALL DSA_PUT_FITS_C( 'OBS_RED', 'MASKUSED', '(none)',
     :     ' ', DSA_STATUS )
      ENDIF

*   The name of the BIAS observation used.
      IF ( PROCEED_BIAS .AND. (INDEX(INT_TYPE,'NDR').EQ.0) ) THEN

         CALL DSA_PUT_FITS_C( 'OBS_RED', 'BIASUSED', BIAS_NAME,
     :     ' ', DSA_STATUS )
      ELSE

         CALL DSA_PUT_FITS_C( 'OBS_RED', 'BIASUSED', '(none)',
     :     ' ', DSA_STATUS )
      ENDIF

*   Whether linearised or not & the linearisation coefficients.
      IF ( INDEX( LINCOEFFS, '#' ) .EQ. 0 ) THEN

         CALL DSA_PUT_FITS_C( 'OBS_RED', 'LINEARIS', 'yes', ' ',
     :     DSA_STATUS )

         DO I = 1, N_COEFFS

            CPOS = 0
            CALL CHR_PUTC( 'LINCF', ITEM, CPOS )
            CALL CHR_PUTI( I, ITEM, CPOS )

            CALL DSA_PUT_FITS_D( 'OBS_RED', ITEM(1:CPOS), LCOEFFS(I),
     :        ' ', DSA_STATUS )
         END DO
      ELSE

         CALL DSA_PUT_FITS_C( 'OBS_RED', 'LINEARIS', 'no', ' ',
     :     DSA_STATUS )
      ENDIF

      IF ( DSA_STATUS .NE. DTA__OK ) THEN
         STATUS = SAI__ERROR
         CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :     /'Error writing FITS item', STATUS )
      END IF

*    Check for pending DTA error
      IF (DTA_STATUS .NE. DTA__OK) THEN

         STATUS = SAI__ERROR
         CALL MSG_SETC( 'OBJECT', OBJECT )
         CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :     /'Error accessing ^OBJECT (reason follows)', STATUS )
         CALL MSG_SETI( 'DTA_STATUS', DTA_STATUS )
         CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :     /'DTA_Status = ^DTA_STATUS', STATUS )
         CALL MSG_SETC( 'ERROR', ERROR )
         CALL ERR_REP( ' ', 'RED4_REDUCE_DARK_OBS: '/
     :      /'^ERROR', STATUS )
      ENDIF

      END
