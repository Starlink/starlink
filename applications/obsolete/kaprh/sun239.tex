\documentclass[twoside,11pt,nolof]{starlink}

% ? Specify used packages
% ? End of specify used packages

% -----------------------------------------------------------------------------
% ? Document identification
\stardoccategory    {Starlink User Note}
\stardocinitials    {SUN}
\stardocsource      {sun239.2}
\stardocnumber      {239.2}
\stardocauthors     {David S. Berry}
\stardocdate        {20 November 2001}
\stardoctitle       {KAPRH ---  A home for retired KAPPA applications}
\stardocversion     {2.0}
\stardocmanual      {User's Guide}
\stardocabstract {
{\footnotesize KAPRH} is an applications package containing commands
which have been ``retired'' from the KAPPA package (see SUN/95). They
are retained within KAPRH to satisfy any occasional need there may be fo 
them.
}
% ? End of document identification

% -----------------------------------------------------------------------------
% ? Document-specific \providecommand or \newenvironment commands.

% degrees symbol
\providecommand{\dgs}{\hbox{$^\circ$}}

% arcminute symbol
\providecommand{\arcm}{\hbox{$^\prime$}}

% arcsec symbol
\providecommand{\arcsec}{\arcm\hskip -0.1em\arcm}

% hours symbol
\providecommand{\hr}{\hbox{$^{\rm h}$}}

% minutes symbol
\providecommand{\mn}{\hbox{$^{\rm m}$}}

% seconds symbol
\providecommand{\scn}{\hbox{$^{\rm s}$}}

% decimal-minutes symbol
\providecommand{\um}{\hskip-0.3em\hbox{$^{\rm m}$}\hskip-0.08em}

% decimal-degree symbol
\providecommand{\udeg}{\hskip-0.3em\dgs\hskip-0.08em}

% decimal-second symbol
\providecommand{\us}{\hskip-0.27em\hbox{$^{\rm s}$}\hskip-0.06em}

% decimal-arcminute symbol
\providecommand{\uarcm}{\hskip-0.28em\arcm\hskip-0.04em}

% decimal-arcsecond symbol
\providecommand{\uarcs}{\hskip-0.27em\arcsec\hskip-0.02em}

% centre an asterisk
\providecommand{\lsk}{\raisebox{-0.4ex}{\rm *}}

% conditional text
\providecommand{\latexelsehtml}[2]{#1}

\hyphenation{which-ever}

% Lines for breaking up Appendices A and B.
\providecommand{\jrule}{\noindent\rule{\textwidth}{0.45mm}}
\providecommand{\krule}{\vspace*{-1.5ex}
                    \item [\rm \rule{\textwidth}{0.15mm}]}

% Shorthands for hypertext links.
% -------------------------------
\providecommand{\AGIref}{\xref{AGI}{sun48}{}}
\providecommand{\ARDref}{\xref{ARD}{sun183}{}}
\providecommand{\ASTERIXref}{\xref{{\footnotesize ASTERIX}}{sun98}{}}
\providecommand{\CCDPACKref}{\xref{{\footnotesize CCDPACK}}{sun139}{}}
\providecommand{\CGSDRref}{\xref{{\footnotesize CGS4DR}}{sun27}{}}
\providecommand{\CONVERTref}{\xref{{\footnotesize CONVERT}}{sun55}{}}
\providecommand{\ECHOMOPref}{\xref{{\footnotesize ECHOMOP}}{sun152}{}}
\providecommand{\ESPref}{\xref{{\footnotesize ESP}}{sun180}{}}
\providecommand{\Figaroref}{\xref{{\footnotesize FIGARO}}{sun86}{}}
\providecommand{\FITSref}{\htmladdnormallink{FITS}{http://www.gsfc.nasa.gov/astro/fits/fits\_{}home.html}}
\providecommand{\GAIAref}{\xref{GAIA}{sun214}{}}
\providecommand{\GKSref}{\xref{GKS}{sun83}{}}
\providecommand{\GWMref}{\xref{GWM}{sun130}{}}
\providecommand{\HDSref}{\xref{HDS}{sun92}{}}
\providecommand{\HDSTRACEref}{\xref{{\footnotesize HDSTRACE}}{sun102}{}}
\providecommand{\ICLref}{\xref{{\footnotesize ICL}}{sg5}{}}
\providecommand{\IDIref}{\xref{IDI}{sun65}{}}
\providecommand{\IRCAMPACKref}{\xref{{\footnotesize IRCAMPACK}}{sun177}{}}
\providecommand{\IRAFref}{\htmladdnormallink{{\footnotesize IRAF}}{http://iraf.noao.edu/iraf-homepage.html}}
\providecommand{\IRASref}{\xref{{\footnotesize IRAS90}}{sun163}{}}
\providecommand{\JCMTDRref}{\xref{{\footnotesize JCMTDR}}{sun132}{}}
\providecommand{\NDFextref}[1]{\xref{#1}{sun33}{}}
\providecommand{\NDFref}[1]{\xref{#1}{sun95}{ap_NDFformat}}
\providecommand{\PDAref}{\xref{PDA}{sun194}{}}
\providecommand{\PGPLOTref}{\htmladdnormallink{PGPLOT}{http://astro.caltech.edu/\~{}tjp/pgplot/}}
\providecommand{\PHOTOMref}{\xref{{\footnotesize PHOTOM}}{sun45}{}}
\providecommand{\PISAref}{\xref{{\footnotesize PISA}}{sun109}{}}
\providecommand{\PONGOref}{\xref{{\footnotesize PONGO}}{sun137}{}}
\providecommand{\PSMERGEref}{\xref{{\footnotesize PSMERGE}}{sun164}{}}
\providecommand{\SGSref}{\xref{SGS}{sun85}{}}
\providecommand{\TSPref}{\xref{{\footnotesize TSP}}{sun66}{}}
\providecommand{\TWODSPECref}{\xref{{\footnotesize TWODSPEC}}{sun16}{}}

\providecommand{\noteroutine}[2]{\item[\htmlref{#1}{#1}] \emph{#2}  }

%  Format the graphics style parameters section (for an application).
\providecommand{\sstgraphparameters}[1]{
  \goodbreak
  \item[Graphics-style Parameters:] \mbox{} \\
  \vspace{-3.5ex}
  \begin{description}
     #1
  \end{description}
}

% ? End of document specific commands
%------------------------------------------------------------------------------

\begin{document}
\scfrontmatter

\section{\xlabel{se_kaprhintro}Introduction\label{se:kaprhintro}}

KAPRH forms a sort of ``rest home'' for old and worn-out KAPPA commands,
that is, commands which have been removed from the KAPPA package for
various reasons. They are retained here in order to satisfy
any occasional need there may be for them. It is not intended to spend
any significant effort in the maintenance or development of these
commands - they are presented ``as is''.

This document contains the reference information for these commands, but
does not contain any general information about data structure,
parameters, \emph{etc}. See SUN/95 for extra information. The one
exception to this is that the appendix contains a description of the
old IMAGE format data structure which is used by some of the commands within
KAPRH.

\newpage
\appendix

\section{\xlabel{ap_summary}An Alphabetical Summary of KAPRH Commands
\label{ap:summary}}
\begin{small}
\begin{description}
\noteroutine{CONTOVER}{
 Contours a 2-d NDF overlayed on an image displayed previously.}
\noteroutine{CRELUT}{
 Creates or manipulates an image-display lookup table using a palette.}
\noteroutine{GREYPLOT}{
 Produces a greyscale plot of a 1-d or 2-d NDF.}
\noteroutine{IDCLEAR}{
 Clears an image display and purges its database entries.}
\noteroutine{IDSET}{
 Selects a current image-display device.}
\noteroutine{IDSTATE}{
 Shows the current status of an image display.}
\noteroutine{IDINVISIBLE}{
 Makes memory planes of an image-display device invisible.}
\noteroutine{IDPAZO}{
 Pans and zooms an image-display device.}
\noteroutine{INSPECT}{
 Inspects a 2-d NDF in a variety of ways.}
\noteroutine{KRHHELP}{
 Gives help about KAPRH.}
\noteroutine{LUTFLIP}{
 Flips the colour table of an image-display device.}
\noteroutine{LUTHILITE}{
 Highlights a colour table of an image-display device.}
\noteroutine{LUTROT}{
 Rotates the colour table of an image-display device.}
\noteroutine{LUTTWEAK}{
 Tweaks a colour table of an image-display device.}
\noteroutine{MOSAIC}{
 Merges several non-congruent  2-d data arrays into one output data array.}
\noteroutine{OVCLEAR}{
 Clears an graphics device overlay.}
\noteroutine{OVSET}{
 Selects a current graphics device overlay.}
\noteroutine{QUILT}{
 Generates a mosaic from equally sized 2-d data arrays, optionally specified
 from an ASCII file.}
\noteroutine{SNAPSHOT}{
 Dumps an image-display memory to a graphics hardcopy and optionally to an NDF.}
\noteroutine{TRANINVERT}{
 Inverts a transformation.}
\noteroutine{TRANJOIN}{
 Joins two transformations.}
\noteroutine{TRANMAKE}{
 Makes a transformation structure given its co-ordinate mappings.}
\noteroutine{TRANSFORMER}{
 Applies a transformation to an NDF.}
\noteroutine{TRANTRACE}{
 Lists the contents of a transformation structure.}
\noteroutine{TURBOCONT}{
 Draws contours of a 2D NDF using a fast algorithm.}
\end{description}
\end{small}

\newpage
\section{\xlabel{ap_full}Specifications of KAPRH applications\label{ap:full}}
\subsection{Explanatory Notes}
For historical reasons, in this Appendix there are two formats---the
first, exemplified by \htmlref{TURBOCONT}{TURBOCONT}, is the layout indicating
that this is one of the applications which uses the NDF structure. An
example of the old style is \htmlref{QUILT}{QUILT}.  Applications
in this format use the moribund \htmlref{IMAGE format}{ap:IMAGEformat}.

\begin{description}
\item [NDF layout]
In this layout the specification of parameters has the following
format.

\begin{verbatim}
     name  =  type (access)
        description
\end{verbatim}
This format also includes a \emph{Usage\/} entry.  \label{ap:usage}
This shows how the application is invoked from the command line.  It
lists the positional parameters in order followed by any prompted
keyword parameters using a \mbox{``KEYWORD=?''} syntax.  Defaulted
keyword parameters do not appear.  Positional parameters that are
normally defaulted are indicated by being enclosed in square brackets.
Keyword ({\it{i.e.}}\ not positional) parameters are needed where the
number of parameters are large, and usually occur because they depend
on the value of another parameter.  These are denoted by a curly
brace; the parameters on each line are related, and each line is
mutually exclusive.  An example should clarify.
\bigskip

{\tt \hspace*{1.0em}
        contour ndf [comp] mode ncont [key] [device]
        \newline\hspace*{2.5em}
        $\left\{ {\begin{tabular}{l}
                    FIRSTCNT=? STEPCNT=? \\
                    HEIGHTS=?
                   \end{tabular} }
        \right.$
        \newline\hspace*{2.9em}
        \makebox[0mm][c]{\footnotesize mode}
}
\bigskip

NDF, COMP, MODE, NCONT, KEY, DEVICE, and SMOOTHING are all positional
parameters.  Only NDF, MODE, and NCONT would be prompted if not given
on the command line.  The remaining parameters depend on the value of
MODE.  If the mode is to nominate a list of contour heights, HEIGHTS
will be needed (MODE~=~{\tt "Free"}); alternatively, if the mode requires a
start height and spacing between contours FIRSTCNT and STEPCNT should be
specified (MODE~=~{\tt "Linear"} or {\tt "Magnitude"}).  Note that there
are other modes which do not require additional information, and hence no
more parameters.

There is also an \emph{Examples\/} section. \label{ap:example}  This
shows how to run the application from the command line.  More often
you'll enter the command name and just some of the parameters, and be
prompted for the rest. \emph{Note that from the C-shell you must escape
any special characters that appear in these examples.} For instance,
the fourth example of COMPAVE would be written like this

\begin{verbatim}
     compave cosmos galaxy '[4,3]' weight title='"COSMOS compressed"'
\end{verbatim}

from the C-shell.

\item [IMAGE layout]
In this layout the specification of parameters has the following format
\begin{verbatim}
    name    type    access    description
\end{verbatim}
\end{description}
\medskip

The following notes apply to both layouts.

Some parameters will only be used when another parameter has a certain
value or mode. These are indicated by the name of the mode in
parentheses at the end of the parameter description, but before any
default, {\it{e.g.}}\ parameter DEVICE in \htmlref{INSPECT}{INSPECT}
is only relevant when parameter MODE is {\tt "Cursor"}.

{\tt \%name} means the value of parameter {\it name}.

The description entry has a notation scheme to indicate
normally defaulted parameters, {\it{i.e.}}\ those for which there will
be no prompt.
For such parameters a matching pair of square brackets ({\tt{[]}})
terminates the description.  The content between the brackets mean
\begin{description}
\item[{\tt{[]}}]
Empty brackets means that the default is created dynamically
by the application, and may depend on the values of other parameters.
Therefore, the default cannot be given explicitly.
\item[{\tt [,]}]
As above, but there are two default values that are created dynamically.
\item[{\tt [}{\rm default}{\tt{]}}]
Occasionally, a description of the default is given in normal type,
{\it{e.g.}}\ the size of the plotting region in a graphics application,
where the exact default values depend on the device chosen.
\item[{\tt [default]}]
If the brackets contain a value in teletype-fount, this is the explicit
default value.
\end{description}

\sstroutine{
   CONTOVER
}{
   Contours a 2-d NDF overlaid on an image displayed previously
}{
   \sstdescription{
      This application draws a contour plot of a 2-dimensional NDF
      using an efficient algorithm.  The array may be part or whole of
      the data array, but also the variance or quality can be shown.

      The contour plot is drawn over an existing image that is
      displayed on the chosen graphics workstation or its overlay,
      provided the displayed image has been recorded in the
      graphics database.  (This will be the case for display routines
      in KAPPA.)  The contour plotting occurs within the current picture
      only if it is a DATA picture, otherwise contours are overlaid in
      the last DATA picture within the current picture.  This
      application assumes that the world co-ordinate systems of the data
      array and the displayed image are both in pixel units, but not to
      the same origins.  Pixel $x$-$y$ offsets may be given to match the
      contour plot with the image, provided some contouring will be
      visible.  These displacements are in the sense image co-ordinate
      minus the data-array co-ordinate for an arbitrary fiducial point.

      The contouring algorithm has only pixel resolution, and
      so the contours are not smooth, but this makes the processing
      much faster.  There are seven methods for selecting contours.

      The best way to use this application is to first display an image
      on the base plane of an image display, make this the current
      picture, and then plot contours on the overlay plane, clearing
      the overlay picture each time. This enables more than one attempt
      at getting the correct contour heights.  The underlying image will
      not be erased. (Note that if you do not make the underlying image
      the current picture, the contour plot becomes the last DATA
      picture, and so any subsequent $x$-$y$ offsets should be set to 0,0 to
      prevent successive contour plots being incorrectly located.)
   }
   \sstusage{
      contover ndf [comp] offset mode ncont [device]
        \newline\hspace*{1.5em}
        $\left\{ {\begin{tabular}{l}
                    firstcnt=? stepcnt=? \\
                    heights=? \\
                    percentiles=?
                   \end{tabular} }
        \right.$
        \newline\hspace*{1.9em}
        \makebox[0mm][c]{\small mode}
   }
   \sstparameters{
      \sstsubsection{
         CLEAR = \_LOGICAL (Read)
      }{
         True if the graphics device is to be cleared before display
         of the array. It should only be true for an overlay device.
         \texttt{[TRUE]}
      }
      \sstsubsection{
         COMP = LITERAL (Read)
      }{
         The NDF component to be contoured.  It may be \texttt{"Data"},
         \texttt{"Quality"}, \texttt{"Variance"}, or \texttt{"Error"} (where
         \texttt{"Error"} is the alternative to \texttt{"Variance"} and causes
         the square root of the variance values to be taken before
         plotting contours).  If \texttt{"Quality"} is specified, then
         the quality values are treated as numerical values (in the
         range 0 to 255).  \texttt{["Data"]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The plotting device. The device must be in one of the following
         GNS categories: IMAGE\_DISPLAY, IMAGE\_OVERLAY, WINDOW,
         WINDOW\_OVERLAY, or MATRIX\_PRINTER.
         \texttt{[}Current image-display-overlay device\texttt{]}
      }
      \sstsubsection{
         FIRSTCNT = \_REAL (Read)
      }{
         Height of the first contour (Linear and Magnitude modes).
      }
      \sstsubsection{
         HEIGHTS() = \_REAL (Read)
      }{
         Contour levels (Free mode).  The suggested default is the
         current value.
      }
      \sstsubsection{
         MODE = LITERAL (Read)
      }{
         The method used to select the contour levels.  The options are
         described below.
         \begin{description}
         \item \texttt{"Area"} --- The contours enclose areas of the array for
                         which the equivalent radius increases by equal
                         increments.  You specify the number of levels.
         \item \texttt{"Automatic"} --- The contour levels are equally spaced between the maximum
                        the maximum and minimum pixel values in the
                        array.  You supply the number of contour levels.
         \item \texttt{"Equalised"} --- You define the number of equally spaced
                          percentiles.
         \item \texttt{"Free"} --- You specify a series of contour values
                        explicitly.
         \item \texttt{"Linear"} --- You define the number of contours, the start
                        contour level and linear step between contours.
         \item \texttt{"Magnitude"} --- You define the number of contours, the start
                        contour level and step between contours.  The
                        step size is in magnitudes so the $n^{\rm th}$
                        contour is 10$^{-0.4*(n-1)*{\rm step}}$ times the
                        start contour level.
         \item \texttt{"Percentiles"} --- You specify a series of percentiles.
         \end{description}

         The suggested default is the current value, which is initially
         \texttt{"Free"}.
      }
      \sstsubsection{
         NCONT = \_INTEGER (Read)
      }{
         The number of contours required (all modes except Free and
         Percentiles).  It must be between 1 and 50.  If the number is
         large, the plot may be cluttered and take longer to produce.
         \texttt{6}, the initial suggested default, gives reasonable results.
         The current value becomes the suggested default.
      }
      \sstsubsection{
         NDF = NDF (Read)
      }{
         NDF structure containing the 2-d image to be contoured.
      }
      \sstsubsection{
         OFFSET( 2 ) = \_INTEGER (Read)
      }{
         $x$-$y$ offsets of the input data-array with respect to the
         displayed image ({\it i.e.}\ $x_{\rm data} - x_{\rm image}$
         followed by $y_{\rm data} - y_{\rm image}$ for any fiducial
         point).   These are
         constrained so that some part of the contour plot will be
         overlaid on the displayed image.  The suggested default is
         [0,0], {\it i.e.}\ no shift.
      }
      \sstsubsection{
         PENROT = \_LOGICAL (Read)
      }{
         If \texttt{TRUE}, the plotting pens are cycled through the contours to
         aid identification of the contour heights.  It is ignored
         when annotation is selected. \texttt{[FALSE]}
      }
      \sstsubsection{
         STEPCNT = \_REAL (Read)
      }{
         Separation between contour levels, linear for Linear mode
         and in magnitudes for Magnitude mode.
      }
   }
   \sstgraphparameters{
      \sstsubsection{
         CONCOL = LITERAL (Read)
      }{
        The colour of the contour lines on devices that support colour.
        The options are described below.

         \begin{description}
         \item \texttt{"MAX"}  --- The maximum colour index in the image
                          display colour lookup table.
         \item \texttt{"MIN"}  --- The minimum (non-reserved) colour index in
                          the image-display colour lookup table.
         \item {\bf An integer} --- The actual colour index.  It is
                          constrained between 0 and the maximum colour
                          index available on the device.
         \item {\bf A named colour} --- Uses the named colour from the
                          palette, and if it is not present, the nearest
                          colour from the palette is selected.
         \end{description}

         If the colour is to remain unaltered as the lookup table is
         manipulated choose an integer between 0 and 15, or a named
         colour.  This parameter will be ignored if PENROT = \texttt{TRUE}.
         \texttt{[}The current value, but equals \texttt{1} (the foreground
         colour) if there is no current value.\texttt{]}
      }
      \sstsubsection{
         DASHED = \_REAL (Read)
      }{
         The height below which the contours will be drawn with dashed
         lines.  A null value (\texttt{!}) means all contours are drawn with
         solid lines.  This facility is only available when ANNOTA =
         \texttt{FALSE}. \texttt{[!]}
      }
      \sstsubsection{
         THICK = \_REAL (Read)
      }{
         The thickness of the lines and NCAR-fount characters in the plot, where
         \texttt{1.0} is the normal thickness.  Currently, this is only available
         on a few devices.  It must take a value in the range 0.5--10.0.
         \texttt{[1.0]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         contover myfile d [-20,7] $\backslash$
      }{
         Contours the data array in the NDF called myfile on the
         current image-display overlay device; the overlay is displaced
         such that pixel ($i$,~$j$) in myfile corresponds to pixel
         ($i-20$,~$j+$7) in
         the displayed image.  All other settings are defaulted, so for
         example the current method for determining heights is used,
         and as much of myfile will be contoured that fits into the
         current picture.
      }
      \sstexamplesubsection{
         contover ndf=ngc6872 mode=au ncont=5 offset=[0,0]
      }{
         Contours the data array in the NDF called ngc6872 on the
         current image-display overlay device.  Five equally spaced
         contours between the maximum and minimum data values are
         drawn.  There is no offset between the contour plot and the
         displayed image; this can be useful for comparing an NDF
         before and after some processing, {\it e.g.}\ smoothing.
      }
      \sstexamplesubsection{
         contover iras60(200:300,100:350) comp=d offset=[3,5] $\backslash$
      }{
         Contours the portion of the data array in the NDF called iras60
         on the current image-display overlay using the current method
         for height selection.  The maximum portion of the data array
         that can be contoured goes from pixel (200,100) to (300,350).
         The overlay is displaced such that pixel ($i$,~$j$) in the
         data array corresponds to pixel ($i+$3,~$j+$5) in the displayed
         image.
      }
      \sstexamplesubsection{
         contover comp=v mode=fr heights=[10,20,40,80] device=xov $\backslash$
      }{
         Contours the variance array in the current NDF on the xov
         device.  Contours at 10, 20, 40 and 80 are
         drawn.  There is no displacement between the variance contour
         plot and the displayed image.
      }
      \sstexamplesubsection{
         contover mode=eq ncont=5 dashed=15 pencol=blue ndf=skyflux
      }{
         Contours the data array in the NDF called skyflux on the
         current image-overlay device.  Contours at heights
         corresponding to the 10, 30, 50, 70 and 90 percentiles are
         drawn in blue (if available).  Those contours whose values less
         than 15 will appear as dashed lines.  There is no displacement
         between the contour plot and the displayed image.
      }
      \sstexamplesubsection{
         contover xx1 mode=pe percentiles=[90,95,98,99] pencol=white
         noclear device=epsf\_l
      }{
         Contours the data array in the NDF called xx1 on the epsf\_l
         device.  White contours at heights corresponding to the 90, 95,
         98, and 99 percentiles are drawn.  The display is not cleared.
         There is no displacement.  The output file could be combined
         with a DISPLAY plot (using PSMERGE) to make a hardcopy of a
         contour plot on a dark image.
      }
  }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The application records the contour plot as a DATA picture
         with world co-ordinates in units of data pixels in the graphics
         database.  The DATA picture may also may have double-precision
         data co-ordinates derived from the NDF axis components provided
         these are linear and different from pixel co-ordinates; the data
         co-ordinates are stored via a linear transformation.  The NDF
         associated with the plot is stored by reference with the DATA
         picture.  On exit the current database picture for the chosen
         device reverts to the input picture.
         picture for the chosen device reverts to the input picture.

         \sstitem
         There are some options for setting the characteristics of the
         contour lines.  By default, solid lines are drawn with the same
         colour as the axes and key, namely the foreground colour.  The
         colour will depend on the graphics device chosen, but it is often
         black for printers or white for terminals.  The alternatives to
         override this default behaviour are listed below.

         \begin{enumerate}
         \item Set a colour for all contours using parameter CONCOL.
               The choices may be quite restrictive on certain devices,
               for example a window overlay only has one colour.  Use
               the PALENTRY command to change this colour.
         \item Request dashed contours below some threshold given by
               parameter DASHED and solid lines for other heights.  All
               contours have either the foreground colour or that
               prescribed by parameter CONCOL.
         \item Cycle the pens modulo 3 for each contour height actually
               plotted by setting PENROT = \texttt{TRUE}.  The characteristics of
               the second and third line styles will depend on the chosen
               graphics device.  An image display or pen plotter will draw
               coloured lines using palette entries 1 to 3; whereas a
               window overlay, or monochrome laser printer or terminal
               will draw a variety of dashed or thicker lines.
         \item Combine options 2 and 3.  However, palette colours 1 to 3
               will always be used and CONCOL ignored.  The contours below
               the threshold continue the cycle through the three colours.
               There may be some confusion on devices that already use
               dashed lines, so this is only suitable for devices
               supporting at least three colours simultaneously.
         \end{enumerate}

         Pen rotation takes precedence over colour control through CONCOL.
      }
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPPA: CONTOUR; Figaro: ICONT, SPECCONT.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Only real data can be processed directly.  Other data types
         will undergo a type conversion before the contour plot is drawn.

         \sstitem
         Processing of bad pixels and automatic quality masking are supported.

      }
   }
}
\sstroutine{
   CRELUT
}{
   Creates or manipulates an image-display lookup table using a
   palette
}{
   \sstdescription{
      This application allows a lookup table to be created or modified
      interactively on a chosen image display from a palette of
      colours.  All plotting is performed within the current
      graphics-database picture for that device.  The phases in the
      creation or manipulation of the lookup table are enumerated below.
      \begin{enumerate}
      \item The initial colour table is read from an NDF lookup-table file
         or a greyscale used if there is no input lookup table.
      \item The name of an NDF containing a 2-dimensional array is obtained and the
         array is scaled and displayed in the top half of the picture
         at the largest magnification without distortion.  Below this an
         histogram of the values between the scaling limits is drawn
         with the colour index of each bin corresponding to the bin's
         scaled value. Thus colours in the image and the histogram
         match.   Axes of number versus data value are plotted about
         the histogram. If a null character, \texttt{!}, is given then no NDF
         array is read and a ramp is produced instead of the histogram.
         An axis of pen numbers in the lookup table is drawn around the
         ramp.
      \item A numbered palette is drawn below the histogram.  A palette
         created in an earlier run of CRELUT may be restored from an
         NDF.  Otherwise the palette comprises eight coloured blocks
         (black, white, red, green, blue, yellow, magenta and cyan)
         with palette numbers 0--7, an eight-level greyscale (8--15)
         and a sixteen-level greyscale (16--31).  Palette numbers
         16--31 may be replaced randomly by colours you define.  The
         colours are specified by either the giving the red, green, blue
         intensities; or by name.  The loop is terminated by a null.
      \item Inside a loop you select the palette colour(s) to be
         assigned to the first and last pen numbers of a band within
         the lookup table.  For convenience, where there is an image
         and histogram the equivalent data values are entered rather
         than pen numbers directly, though they are converted to the
         nearest pens in the lookup table.  Linear interpolation
         between the two palette colours yields the lookup-table
         colours inside the band.  Should only one colour be given then
         all the pens in the requested range are set to that colour.
         Pen numbers may be re-used indefinitely and assigned new
         colours if the desired effect is not obtained.  (The histogram
         of the array is produced to assist in a sensible choice).  The
         loop is terminated by a null in response to either of the
         prompts.
      \item The lookup table may be saved in an NDF.  A null response,
         \texttt{!}, to the request for the name of the file in which the table is
         to be stored will result in the table not being saved.
         Likewise the palette may be saved in an NDF.
      \end{enumerate}
   }
   \sstusage{
      crelut inlut outlut ndf [comp] low high [inpal] [outpal] [device]
   }
   \sstparameters{
      \sstsubsection{
         COLOUR() = LITERAL (Read)
      }{
         A colour to be added to the palette at the entry given by
         parameter PALNUM.  It is specified in one of two ways.
         \begin{itemize}
           \item A named colour from the standard colour set, which may
           be abbreviated.  If the abbreviated name is ambiguous the
           first match is selected.  The case of the name is ignored.
           Some examples are \texttt{"Seagreen"}, \texttt{"Violet"}, and
           \texttt{"Orchid"}.

           \item Normalised red, green, and blue intensities separated by
           commas or spaces.  Each value must lie in the range 0.0--1.0.
           For example, \texttt{"1.0,1.0,0.5"} would give a pale yellow.
         \end{itemize}
         To exit the loop that obtains new palette colours enter a null
         character (\texttt{!}) in response to the prompt.
      }
      \sstsubsection{
         COLRANGE() = \_INTEGER (Read)
      }{
         The numbers of the palette colours to be allocated to a range
         of pens within the lookup table.  One or two palette colours
         may be entered.  If only one is given all the range of pens
         are assigned that colour.  If two palette colours are given
         the colour of a pen is obtained by linear interpolation
         between the two colours at the fractional position of the pen
         in the range of colour indices.  Allowed values are 0--31.
      }
      \sstsubsection{
         COMP = LITERAL (Read)
      }{
         The NDF component to be displayed.  It may be \texttt{"Data"},
         \texttt{"Quality"}, \texttt{"Variance"}, or \texttt{"Error"} (where
         \texttt{"Error"} is the alternative to \texttt{"Variance"} and causes
         the square root of the variance values to be displayed).
         If \texttt{"Quality"} is specified, then the quality values are
         treated as numerical values (in the range 0 to 255).  \texttt{["Data"]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the image display to be used.  The device must be in
         one of the following GNS categories: IMAGE\_DISPLAY,
         IMAGE\_OVERLAY, or WINDOW, and have at least 48 colour indices.
         At least 120 colour indices is recommended.  The device must
         also not reset when the device is opened (since the new colour
         table would be lost).  \texttt{[}Current image-display device\texttt{]}
      }
      \sstsubsection{
         HIGH = \_DOUBLE (Read)
      }{
         This is the highest value in the 2-dimensional data array used for
         scaling and computing the histogram.  All larger array values
         are set to the highest colour index when HIGH is greater than
         LOW, otherwise all array values greater than HIGH are set to
         the lowest colour index.  The dynamic default is the maximum
         data value.
      }
      \sstsubsection{
         INLUT = NDF (Read)
      }{
         Name of the NDF containing the initial lookup table as its data
         array.  The LUT must be 2-dimensional, the first dimension
         being 3, and the second is arbitrary.  The method used to
         compress or expand the colour table if the second dimension is
         different from the number of unreserved colour indices is
         controlled by parameter NN.  Also the LUT's values must lie in
         the range 0.0--1.0.  If INLUT is null (\texttt{!}) a
         greyscale is used.
      }
      \sstsubsection{
         INPAL = NDF (Read)
      }{
         Name of the NDF containing the initial palette as its data
         array.  The palette must be 2-dimensional, the first dimension
         being 3, and the second 32.  If the second dimension is
         greater than 32 only the first 32 colours are used; if it has
         less than 32 just fill as much of the palette as is possible
         starting from the first colour.  The palette's values must lie
         in the range 0.0--1.0.  If INPAL is null (\texttt{!}) the default
         palette is loaded.
      }
      \sstsubsection{
         LOW = \_DOUBLE (Read)
      }{
         The array value that scales to the lowest pen in the colour
         table, and the minimum value to be included in the histogram.
         All smaller array values are set to the lowest colour
         index when LOW is less than HIGH, otherwise all array values
         smaller than LOW are set to the highest colour index.   The
         dynamic default is the minimum data value.
      }
      \sstsubsection{
         NDF = NDF (Read)
      }{
         Input NDF data structure containing the image to be displayed
         to show the effect of the created colour table.
      }
      \sstsubsection{
         NN = \_LOGICAL (Read)
      }{
         If \texttt{TRUE} the input lookup table is mapped to the colour table by
         using the nearest-neighbour method.  This preserves sharp
         edges and is better for lookup tables with blocks of colour.
         If NN is \texttt{FALSE}, linear interpolation is used, and this is
         suitable for smoothly varying colour tables. \texttt{[FALSE]}
      }
      \sstsubsection{
         OK = \_LOGICAL (Read)
      }{
         \texttt{TRUE} when the palette colour just produced is acceptable.
      }
      \sstsubsection{
         OUTLUT = NDF (Write)
      }{
         The output lookup table.
      }
      \sstsubsection{
         OUTPAL = NDF (Write)
      }{
         The palette used to create the lookup table.
      }
      \sstsubsection{
         PALNUM = \_INTEGER (Read)
      }{
         The number of the palette entry whose colour is to be
         modified.  (The numbers are plotted on the palette.) It is
         used within a loop to modify up to sixteen entries in the
         palette.  Entering a null, \texttt{!}, will end that loop.  The
         suggested default is the next palette number.  PALNUM must lie
         in the range 16--31.
      }
      \sstsubsection{
         PENRANGE() = \_INTEGER (Read)
      }{
         The range of pen numbers in the lookup table which is about to
         be allocated a set of colours from the palette.  PENRANGE is
         only used when there is no image and histogram plotted.  The
         pen number can be read from the axis below the ramp.  If one
         pen number is given, only this pen is altered, and it is given
         the first palette colour of COLRANGE.  If two are supplied,
         the first pen number entered will take the first palette
         colour entered, and the second pen is assigned the second
         palette colour.  The pens must lie in the range zero to the
         maximum number of available pens.
      }
      \sstsubsection{
         PTITLE = LITERAL (Read)
      }{
         Title for the output palette NDF. \texttt{["KAPRH - Crelut"]}
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Title for the output lookup table NDF. \texttt{["KAPRH - Crelut"]}
      }
      \sstsubsection{
         VALRANGE() = \_DOUBLE (Read)
      }{
         The range of data values in the histogram/image which is to
         be allocated a set of colours from the palette, and hence be
         assigned to a part of the lookup table.  VALRANGE is only used
         when there is an image and histogram plotted.  The data value
         may be read from the axis below the histogram.  If one data
         value is given, only the single pen in the lookup table
         corresponding to the value is altered, and it is given the
         first palette colour of COLRANGE.  If two values are supplied,
         the first data value entered will take the first palette
         colour entered, and the second data value is assigned the
         second palette colour.  The data values must lie in the range
         PVLO--PVHI.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         Note:
      }{
         Since the application is highly interactive and contains loops
         it is not possible to give one-line commands to perform a
         complete operation.  Therefore the examples show how to
         control the input and output data and not the interactive
         manipulation of the colour table.
      }
      \sstexamplesubsection{
         crelut heat bizarre hh12 $\backslash$
      }{
         Reads a lookup table in an NDF called heat.  If resampling of
         the lookup table is required it achieved via linear
         interpolation. The lookup table after the manipulation is
         stored in NDF bizarre.  The data array in NDF hh12 is scaled
         between its minimum and maximum values and displayed in the
         top half of the current picture on the current image-display
         device.  Also drawn is an histogram of the intensities.
      }
      \sstexamplesubsection{
         crelut heat bizarre hh12 inpal=mypal $\backslash$
      }{
         As above except a palette created previously via the OUTPAL
         parameter.  This palette is in an NDF called mypal.
      }
      \sstexamplesubsection{
         crelut inlut=! deluxe hh12 v low=100 high=400 $\backslash$
      }{
         A greyscale lookup table is manipulated and the result
         is stored in NDF deluxe.  The variance array in NDF hh12 is
         scaled between 100 and 400, and displayed in the top half of
         the current picture on the current image-display device.  Also
         drawn is an histogram of the intensities between those limits.
      }
      \sstexamplesubsection{
         crelut heat bizarre ndf=! device=xwindows $\backslash$
      }{
         Reads a lookup table in an NDF called heat.  If resampling of
         the lookup table is required it achieved via the
         nearest-neighbour method.  The lookup table after the
         manipulation is stored in NDF bizarre.  A linear ramp is
         displayed in the lower half of the current picture on the
         xwindows device.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The application stores, in the order given, the following
         pictures in the graphics database: a frame comprising the data
         picture, the histogram or ramp and the palette; the data-array
         picture with world co-ordinates in units of data pixels; the
         histogram/ramp frame picture including the histogram/ramp plus
         the annotated axes; and the histogram with world co-ordinates in
         units of data values and number, or the ramp with units of pen
         numbers and normalised frequency.  The NDF associated with the
         image/histogram plots is stored by reference with the DATA
         picture.  On exit the current database picture for the chosen
         device reverts to the input picture.

         \sstitem
         Bad pixels will appear with the lowest colour index in the
         plot.
      }
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPPA: LUTABLE, LUTEDIT, LUTFLIP, LUTREAD, LUTROT, LUTSAVE, LUTTWEAK, \linebreak
      LUTVIEW, PALREAD, PALSAVE; Figaro: COLOUR.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         The magic-value method is used for processing bad data.

         \sstitem
         This application will handle data in all numeric types, though
         type conversion to integer will occur for unsigned byte and word
         images.
      }
   }
}

\sstroutine{
   GREYPLOT
}{
   Produces a greyscale plot of a 1-d or 2-d NDF
}{
   \sstdescription{
      This application produce a greyscale plot of a 1- or
      2-dimensional NDF, especially for a hardcopy device.  The image
      is usually the data array, but may also be the variance or
      quality.  The plot appears in the current graphics-database
      picture.

      The greyscale plot resides within optional, annotated and
      enumerated axes. An optional key may be drawn to the right of the
      greyscale plot comprising a title and grey blocks annotated with
      the corresponding array value.  There are a number of scaling
      methods to map array values to grey levels in the plot.

      The time to output to hardcopy devices can be quite lengthy
      and generally depends on the size of the greyscale plot.
      Therefore, there are parameters for controlling the size of
      the plot.
   }
   \sstusage{
      greyplot in [comp] key [device] mode [pxsize] [pysize] [out]
        \newline\hspace*{1.5em}
        $\left\{ {\begin{tabular}{l}
                    white=? black=? \\
                    percentiles=? \\
                    sigmas=?
                  \end{tabular} }
        \right.$
        \newline\hspace*{1.9em}
        \makebox[0mm][c]{\small mode}
   }
   \sstparameters{
      \sstsubsection{
         ABSLAB  =  LITERAL (Read)
      }{
         Label for the plot abscissa, in which NCAR fancy founts
         may be embedded when FONT = \texttt{"}NCAR\texttt{"}.  This parameter is only
         used when the axes option is selected.  If axis information is
         present the suggested default is the NDF\texttt{'}s axis label followed
         by the units, in parentheses.  If an error occurs obtaining
         the label the suggested default is \texttt{"}X\texttt{"}. \texttt{[]}
      }
      \sstsubsection{
         AXES = \_LOGICAL (Read)
      }{
         TRUE if annotated axes are to be drawn around the displayed
         image.  The annotations are either the data co-ordinates from
         the NDF axis components, provided these are present and linear
         and COSYS = \texttt{"}Data\texttt{"}; otherwise pixel co-ordinates are used.
         \texttt{[FALSE]}
      }
      \sstsubsection{
         BADCOL = LITERAL (Read)
      }{
         The grey level to give a bad pixel in the display.  There are
         a number of options described below.

           \texttt{"}MAX\texttt{"}       - Black
           \texttt{"}MIN\texttt{"}       - White
           An integer  - The actual \texttt{'}colour\texttt{'} index.  It is constrained
                         to be between 0 and the maximum colour index
                         available on the device, and so gives a shade
                         of grey.  0 gives the background colour.
           A named     - Uses the named `colour\texttt{'} from the palette, and
           `colour\texttt{'}      if it is not present, the nearest colour from
                         the palette is selected.  The palette contains
                         grey levels at percentages from black to white,
                         \emph{e.g.} GREY50 is midway between black and white.

         If this application is run on a device that supports colour
         it is possible to mark the bad pixels in colour on the
         greyscale provided BADCOL is an integer between 0 and 15, or
         a named colour.  The bad pixels will remain unaltered if the
         lookup table is manipulated.  The suggested default is the
         current value. [The current value, but equals \texttt{"}MIN\texttt{"} if there
         is no current value.]
      }
      \sstsubsection{
         BLACK = \_DOUBLE (Read)
      }{
         The array value that scales to the black in the greyscale
         colour table.  All smaller array values appear black when
         BLACK is less than WHITE, otherwise all array values
         smaller than BLACK appear white.  The dynamic default is the
         minimum data value.   There is an efficiency gain when both
         BLACK and WHITE are given on the command line, because the
         extreme values need not be computed.  (Scale mode)
      }
      \sstsubsection{
         COMP = LITERAL (Read)
      }{
         The NDF component to be displayed.  It may be \texttt{"}Data\texttt{"},
         \texttt{"}Quality\texttt{"}, \texttt{"}Variance\texttt{"}, or \texttt{"}Error\texttt{"} (where \texttt{"}Error\texttt{"} is the
         alternative to \texttt{"}Variance\texttt{"} and causes the square root of the
         variance values to be displayed).  If \texttt{"}Quality\texttt{"} is specified,
         then the quality values are treated as numerical values (in
         the range 0 to 255). \texttt{[\texttt{"}Data\texttt{"}]}
      }
      \sstsubsection{
         COSYS = LITERAL (Read)
      }{
         The co-ordinate system to be used.  This can be either \texttt{"}World\texttt{"}
         or \texttt{"}Data\texttt{"}.  \texttt{"}World\texttt{"} makes pixel co-ordinates to appear on axes.
         If COSYS = \texttt{"}Data\texttt{"} the NDF\texttt{'}s axis information is used to
         annotate axes.  \texttt{[Current co-ordinate system]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the graphics device used to display the image.
         The device must be in one of the following GNS categories:
         IMAGE\_DISPLAY, IMAGE\_OVERLAY, MATRIX\_PRINTER, or WINDOW, and
         have at least 24 greyscale intensities.
         \texttt{[Current image-display device]}
      }
      \sstsubsection{
         FILL = \_LOGICAL (Read)
      }{
         The greyscale plot normally has square pixels, in other words
         a length along each axis corresponds to the same number of
         pixels.  However, for images with markedly different
         dimensions, such as two-dimensional spectra, this default
         behaviour may not be suitable or give the clearest plot.  When
         FILL is TRUE, the square-pixel constraint is relaxed and the
         greyscale plot is the largest possible within the current
         picture.  When FILL is FALSE, the pixels are square.  The
         suggested default is the current value.  \texttt{[FALSE]}
      }
      \sstsubsection{
         FONT = LITERAL (Read)
      }{
         The fount to be used for the line graphics.  It can be either
         \texttt{"}NCAR\texttt{"} for the NCAR fancy characters and \texttt{"}GKS\texttt{"} for the standard
         GKS san-serif fount.   The former is intended for hardcopy
         publication-quality plots, since it is relatively slow; the
         latter is intended for normal interactive graphics requiring
         rapid plotting, and it is clearer on small plots. The
         suggested default is the current value. \texttt{[\texttt{"}GKS\texttt{"}]}
      }
      \sstsubsection{
         FULL = \_LOGICAL (Read)
      }{
         If TRUE, the whole greyscale lookup table for the device is
         used including the normally reserved pens.  Thus all but two
         of the available intensities participate in the greyscale,
         which improves the photographic quality of the image.  The
         remaining pens are for the background, and for the key and
         axes.  This option is only available for devices that reset
         their `colour\texttt{'} tables when the device is opened, such as
         Laserprinters. (This restriction prevents problems on devices
         that retain their \texttt{"}colour tables\texttt{"}, where using the normally
         reserved pens would mean that either part of the greyscale
         would be emphemeral---departing when the application
         completes if the reserved pens are stored and reinstated on
         completion, or earlier plots drawn by other applications would
         be altered.)

         If FULL = FALSE, only non-reserved intensities will form the
         greyscale.  If a null (!) value is supplied, the value used is
         TRUE when the non-reserved pens is less than 32, and FALSE
         otherwise.  (This figure was chosen because it is roughly the
         number of grey levels at which the eye will clearly detect the
         quantisation in a complex scene.) \texttt{[!]}
      }
      \sstsubsection{
         IN = NDF (Read)
      }{
         Input NDF data structure containing the image to be displayed.
      }
      \sstsubsection{
         KEY = \_LOGICAL (Read)
      }{
         A key of the greyscale versus pixel value and title is to be
         produced when this is TRUE. \texttt{[TRUE]}
      }
      \sstsubsection{
         MAJTIC( 2 ) = \_REAL (Read)
      }{
         The parameter controlling the numbers of major tick marks
         for the x and y axes.  (Number used is between MAJTIC$+$2 and
         5$*$MAJTIC/2$+$4.)   A negative value for an axis makes the
         graphics package decide an appropriate value.  This parameter
         is only used when the axes option is selected. \texttt{[3.,3.]}
      }
      \sstsubsection{
         MINTIC( 2 ) = \_REAL (Read)
      }{
         The number of minor tick marks between each major tick mark
         for the x and y axes.  A negative value forces the graphics
         package to compute appropriate values.   This parameter is
         only used when the axes option is selected. \texttt{[-1.,-1.]}
      }
      \sstsubsection{
         MODE = LITERAL (Read)
      }{
         The type of scaling to be applied to the array.  There are a
         number of options described below.
           \texttt{"}Faint\texttt{"}       - The image is scaled from the mean minus one
                           standard deviation to the mean plus seven
                           standard deviations.  The scaling values are
                           reported so that the faster Scale mode may be
                           utilised later.
           \texttt{"}Flash\texttt{"}       - The image is flashed onto the screen without
                           any scaling at all.  This is the fastest
                           option.  Since there is no longer a
                           one-to-one mapping between data values and
                           grey levels this scaling mode is not
                           available with a key.
           \texttt{"}Percentiles\texttt{"} - The image is scaled between the values
                           corresponding to two percentiles.  The
                           scaling values are reported so that the
                           faster Scale mode may be utilised later.
           \texttt{"}Range\texttt{"}       - The image is scaled between the minimum and
                           maximum data values.
           \texttt{"}Scale\texttt{"}       - You define the upper and lower limits
                           between which the image is to be scaled.  The
                           application reports the maximum and the
                           minimum values for reference and makes these
                           defaults respectively.
           \texttt{"}Sigmas\texttt{"}      - The image is scaled between two standard-
                           deviation limits.  The scaling values used
                           are reported so that the faster Scale mode
                           may be utilised later.
      }
      \sstsubsection{
         NUMBIN  =  \_INTEGER (Read)
      }{
         The number of histogram bins used to compute percentiles for
         scaling. (Percentiles mode) \texttt{[2048]}
      }
      \sstsubsection{
         ORDLAB  =  LITERAL (Read)
      }{
         Label for the plot ordinate, in which NCAR fancy founts
         may be embedded when FONT = \texttt{"}NCAR\texttt{"}.   This parameter is only
         used when the axes option is selected.  If axis information is
         present the suggested default is the NDF\texttt{'}s axis label followed
         by the units, in parentheses.  If an error occurs obtaining
         the label the suggested default is \texttt{"}Y\texttt{"}. \texttt{[]}
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         The scaled NDF that is displayed; it also does not have
         values that equal the reserved portion of the colour table.
         The output NDF is intended to be used as the input data in
         conjunction with SCALE=FALSE.  It will be vertically
         inverted with respect to the input array because of GKS
         convention.  If it has a null value (!) no output NDF will be
         created.  This parameter is ignored when SCALE=FALSE. \texttt{[!]}
      }
      \sstsubsection{
         OUTTIC = \_LOGICAL (Read)
      }{
         True if the axis tick marks are to appear on the outside of
         the axes instead of inside.   This parameter is only used
         when the axes option is selected. \texttt{[TRUE]}
      }
      \sstsubsection{
         PERCENTILES( 2 ) = \_REAL (Read)
      }{
         The percentiles that define the scaling limits. For example,
         \texttt{[75,25]} would scale between the quartile values. (Percentile
         mode)
      }
      \sstsubsection{
         PLTITL = LITERAL (Read)
      }{
         The title of the plot.  Up to about 25 characters can be
         accommodated when there are no axes, and about 40 otherwise.
         NCAR fancy founts may be embedded (cf. SUN/90) when FONT =
         \texttt{"}NCAR\texttt{"}.  This parameter is only used when either the axes or
         key option is selected. \texttt{[The NDF title]}
      }
      \sstsubsection{
         PXSIZE = \_REAL (Read)
      }{
         The length (x axis) of the plot in metres.  [Maximum that can
         fit in the current picture whilst preserving square pixels.]
      }
      \sstsubsection{
         PYSIZE = \_REAL (Read)
      }{
         The length (y axis) of the plot in metres.  [Maximum that can
         fit in the current picture whilst preserving square pixels.]
      }
      \sstsubsection{
         REDUCT = \_REAL (Read)
      }{
         The reduction factor of the array, and must be in the range
         1/MAX(NX,NY)--1.0, where NX and NY are the number of pixels
         in the image along the x and y directions.  Since the output
         to the hardcopy device may be long, the size of the image
         with respect to the key can be reduced by lowering REDUCT.
         The spooling time goes approximately proportional to the
         square of REDUCT.  1.0 means the array fills the plotting zone.
         \texttt{[1.0]}
      }
      \sstsubsection{
         SCAHIGH = \_DOUBLE (Write)
      }{
         The array value scaled to white in the greyscale display.
         In Flash mode or when there is no scaling the colour index of
         white is used.  The current display linear-scaling maximum is
         set to this value.
      }
      \sstsubsection{
         SCALE = \_LOGICAL (Read)
      }{
         If TRUE the input array is scaled according to the value of
         parameter MODE.  If it is FALSE, MODE is ignored, and the input
         array is displayed as is.  There is no scaling, inversion
         or avoidance of annotation pens.  SCALE=FALSE is intended to
         be used with arrays previously scaled by this or similar
         applications which have already performed the scaling,
         inversion and exclusion.  It provides the quickest method of
         image display within this application. \texttt{[TRUE]}
      }
      \sstsubsection{
         SCALOW = \_DOUBLE (Write)
      }{
         The array value scaled to black in the greyscale display.
         In Flash mode or when there is no scaling the colour index of
         black is used.  The current display linear-scaling minimum is
         set to this value.
      }
      \sstsubsection{
         SIGMAS( 2 ) = \_REAL (Read)
      }{
         The standard-deviation bounds that define the scaling limits.
         To obtain values either side of the mean both a negative and
         a positive value are required.  Thus \texttt{[-2,3]} would scale
         between the mean minus two and the mean plus three standard
         deviations.  \texttt{[3,-2]} would give the negative of that. (Sigmas
         mode).
      }
      \sstsubsection{
         THICK = \_REAL (Read)
      }{
         The thickness of the axes and annotations in the plot, where
         1.0 is the normal thickness.  It should be between 0.5 and 5.
         This feature is only available on some devices.   This
         parameter is only used when the axes option is selected. \texttt{[1.0]}
      }
      \sstsubsection{
         WHITE = \_DOUBLE (Read)
      }{
         The array value that scales to white in the greyscale
         colour table.  All larger array values appear white when
         WHITE is greater than BLACK, otherwise all array values
         larger than WHITE appear black.  The dynamic default is the
         maximum data value.   There is an efficiency gain when both
         BLACK and WHITE are given on the command line, because the
         extreme values need not be computed.  (Scale mode)
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         greyplot sdor key mode=sc black=1 white=5.2
      }{
         Makes a greyscale display of the data component of the NDF
         called sdor on the current image-display device, scaling
         between 1 and 5.2.  Values up to 1.0 in the data array will
         appear black in the plot, and values larger than 5.2 will be
         white.  Intermediate values will a grey level determined by
         linear interpolation.  A key is drawn to the right of the
         greyscale.
      }
      \sstexamplesubsection{
         greyplot in=sdor nokey mode=p percentiles=[10,90] badcol=\texttt{"}Black\texttt{"}
      }{
         This makes a greyscale plot of the NDF called sdor on the
         current image-display device. The scaling is between the 10 and
         90 per cent percentiles of the image.  No key is drawn.  Bad
         data appear black in the plot.
      }
      \sstexamplesubsection{
         greyplot mode=fa axes out=video cosys=d $\backslash$
      }{
         Displays a greyscale of the current NDF data component with
         annotated axes on the current image-display device.  The axes
         take the axis labels and title from the NDF, and are annotated
         in data co-ordinates.  The scaling is between the -1 and $+$7
         standard deviations of the image around its mean.  A key is
         drawn.  The scaled data are stored in an NDF called video.
      }
      \sstexamplesubsection{
         greyplot video noscale $\backslash$
      }{
         Displays the data component of the NDF called video (created
         in the previous example) without scaling within the current
         picture on the current image-display device.
      }
      \sstexamplesubsection{
         greyplot cgs4k v key mode=ra device=canon\_l
      }{
         Makes a greyscale display of the variance component of NDF
         cgs4k on the Canon\_l device, scaling between the minimum and
         maximum variance values.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The application stores a number of pictures in the graphics
         database in the following order: a FRAME of the specified size
         containing the title, annotated axes, and the image area
         (provided AXES is TRUE), whose world co-ordinates are in pixels;
         a DATA picture with world co-ordinates in units of data pixels;
         and a KEY.  The DATA picture also may have double-precision data
         co-ordinates derived from the NDF axis component provided these
         are linear and different from pixel co-ordinates; the data
         co-ordinates are stored via a linear transformation.  The NDF
         associated with the plot is stored by reference with the DATA
         picture.  On exit the current database picture for the chosen
         device reverts to the input picture.

         \sstitem
         When axes are requested the axis annotations are defined by
         their lower and upper bounds, \emph{i.e.} a regular array is assumed.
         The bounds are in pixel or data co-ordinates.

         \sstitem
         The data type of the output NDF depends on the number of colour
         indices: \_UBYTE for no more than 256, \_UWORD for 257 to 65535,
         and \_INTEGER otherwise.   The output NDF will not contain any
         extensions, UNITS, QUALITY, and VARIANCE; but LABEL, TITLE, and
         AXIS information are propagated from the input NDF.  The output
         NDF does not become the new current data array.  It is a Simple
         NDF (because the bad-pixel flag is set to false in order to
         access the maximum grey level), therefore only NDF-compliant
         applications can process it.
      }
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPPA: DISPLAY; Figaro: IGREY, IMAGE; SPECDRE: MOVIE.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         This routine correctly processes the AXIS, DATA, QUALITY,
         VARIANCE, LABEL, TITLE, WCS and UNITS components of the input NDF.

         \sstitem
         Processing of bad pixels and automatic quality masking are
         supported.

         \sstitem
         This application will handle data in all numeric types, though
         type conversion to integer will occur for unsigned byte and word
         images.  However, when there is no scaling only integer data will
         not be type converted, but this is not expensive for the expected
         byte-type data.
      }
   }
}
\sstroutine{
   IDCLEAR
}{
   Clears an image display and purges its database entries
}{
   \sstdescription{
      This application software resets an image-display device. In effect
      the device is cleared.  It purges the graphics-database entries
      for the device.  Optionally, only the current picture is cleared
      and the database unchanged.  (Note that the clearing of the current
      picture may not work on some image-display devices.)
   }
   \sstusage{
      idclear [device] [current]
   }
   \sstparameters{
      \sstsubsection{
         CURRENT = \_LOGICAL (Read)
      }{
         If true then only the current picture is cleared. \texttt{[FALSE]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The graphics device to be cleared. \texttt{[}Current image-display
         device\texttt{]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         idclear
      }{
         Clears the current image display and purges its graphics
         database entries.
      }
      \sstexamplesubsection{
         idclear current
      }{
         Clears the current picture on the current image display.
      }
      \sstexamplesubsection{
         idclear xwindows
      }{
         Clears the xwindows device and purges its graphics-database entries.
      }
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPPA: GDCLEAR, IDSTATE, OVCLEAR.
   }
}
\sstroutine{
   IDINVISIBLE
}{
   Makes memory planes of an image-display device invisible
}{
   \sstdescription{
      This routine makes invisible nominated planes of an IDI-supported
      image display, such as X-windows.
   }
   \sstusage{
      idinvisible [planes] [device]
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the image-display device whose memory plane is to
         be made invisible.  The name of the base plane should be given
         even if an overlay plane is to be made invisible.
         \texttt{[}Current image display\texttt{]}
      }
      \sstsubsection{
         PLANES() = \_INTEGER (Read)
      }{
         The numbers of the memory planes to be made invisible.  All
         unspecified planes become visible.  If it is null the base
         (image) memory is made invisible.  The base memory is 0 and
         overlays are numbered consecutively from 1.  For an Ikon the
         only overlay plane is 1.
         \texttt{[0]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         idinvisible [0,1]
      }{
         Makes only planes 0 and 1 invisible on the current image
         display device.
      }
      \sstexamplesubsection{
         idinvisible device=xwindows
      }{
         Makes the base plane invisible on the xwindows device.
      }
      \sstexamplesubsection{
         idinvisible 1 ikon
      }{
         Makes the first overlay plane invisible on the Ikon device.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         On some devices making a memory invisible may have the effect
         of making other memories visible.

         \sstitem
         On the Ikon the visibilities are set to visible on start up,
         so that any set up change introduced by an application calling
         GKS are not lost, therefore all planes to be made invisible must
         be given in one invocation.
      }
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPPA: IDCLEAR, IDSTATE.
   }
}

\sstroutine{
   IDPAZO
}{
   Pans and zooms an image-display device
}{
   \sstdescription{
      This routine pans all planes of an IDI-supported image display,
      such as X-windows.  The zoom factor is controlled by the mouse
      or trackerball buttons.

      For an X-windows device, pressing the left button of the mouse
      increases the zooming, the centre button reduces the zoom factor, and
      the right-hand button ends the pan and zoom operation.
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the image-display device to be panned and zoomed.
         The name of the base plane should be given.
         \texttt{[}Current image display\texttt{]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         idpazo xwindows
      }{
         Pans and zooms the xwindows device.
      }
      \sstexamplesubsection{
         idpazo
      }{
         Pans and zooms the current image-display device.
      }
   }
}

\sstroutine{
   IDSET
}{
   Selects a current image-display device
}{
   \sstdescription{
      This application selects a current image-display device. This
      device will be used for all applications requiring an
      image-display until changed explicitly.
   }
   \sstusage{
      idset device
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The image-display device to become the current image-display
         device.  The device must be in one of the following GNS
         categories: IMAGE\_DISPLAY, IMAGE\_OVERLAY, MATRIX\_PRINTER, or
         WINDOW, and have at least 24 colour indices or greyscale
         intensities.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         idset xwindows
      }{
         Makes the xwindows device the current image-display device.
      }
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPPA: GDSET, IDSTATE, OVSET; Figaro: SOFT.
   }
}
\sstroutine{
   IDSTATE
}{
   Shows the current status of a graphics device
}{
   \sstdescription{
      This application displays information about the current graphics
      database picture on a graphics device, including the extreme axis
      values in any requested co-ordinate Frame (see parameter FRAME).
      Information is written to various output parameters for use by
      other applications, and is also written to the screen by default
      (see parameter REPORT). An outline may be drawn around the current
      picture if required (see parameter OUTLINE).
   }
   \sstusage{
      idstate [device] [frame]
   }
   \sstparameters{
      \sstsubsection{
         COMMENT = LITERAL (Write)
      }{
         The comment of the current picture.  Up to 132 characters
         will be written.
      }
      \sstsubsection{
         DESCRIBE = \_LOGICAL (Read)
      }{
         If TRUE, a detailed description is displayed of the co-ordinate
         Frame in which the picture bounds are reported (see parameter
         FRAME). \texttt{[current value]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Name of the graphics device about which information is
         required. \texttt{[Current graphics device]}
      }
      \sstsubsection{
         DOMAIN = LITERAL (Write)
      }{
         The Domain name of the current co-ordinate Frame for the current
         picture.
      }
      \sstsubsection{
         EPOCH = \_DOUBLE (Read)
      }{
         If a \texttt{"}Sky Co-ordinate System\texttt{"} specification is supplied (using
         parameter FRAME) for a celestial co-ordinate system, then an
         epoch value is needed to qualify it. This is the epoch at
         which the displayed sky co-ordinates were determined. It should
         be given as a decimal years value, with or without decimal places
         (\texttt{"}1996.8\texttt{"} for example). Such values are interpreted as a Besselian
         epoch if less than 1984.0 and as a Julian epoch otherwise.
      }
      \sstsubsection{
         FRAME = LITERAL (Read)
      }{
         A string determining the co-ordinate Frame in which the bounds
         of the current picture are to be reported. When a picture is
         created by an application such as PICDEF, DISPLAY, \emph{etc}, WCS
         information describing the available co-ordinate systems are stored
         with the picture in the graphics database. This application can
         report bounds in any of the co-ordinate Frames stored with the
         current picture. The string supplied for FRAME can be one of the
         following:

         \sstitemlist{

            \sstitem
            A domain name such as SKY, AXIS, PIXEL, BASEPIC, CURPIC, \emph{etc}. The
            special domain AGI\_WORLD is used to refer to the world co-ordinate
            system stored in the AGI graphics database. This can be useful if
            no WCS information was store with the picture when it was created.

            \sstitem
            An integer value giving the index of the required Frame.

            \sstitem
            A \texttt{"}Sky Co-ordinate System\texttt{"} (SCS) value such as EQUAT(J2000) (see
            section \texttt{"}Sky Co-ordinate Systems\texttt{"} in SUN/95).

         }
         If a null value (!) is supplied, bounds are reported in the
         co-ordinate Frame which was current when the picture was created.
         \texttt{[!]}
      }
      \sstsubsection{
         LABEL = LITERAL (Write)
      }{
         The label of the current picture.  It is blank if there is no
         label.
      }
      \sstsubsection{
         NAME = LITERAL (Write)
      }{
         The name of the current picture.
      }
      \sstsubsection{
         OUTLINE = \_LOGICAL (Read)
      }{
         If OUTLINE is TRUE, then an outline will be drawn around the
         current picture to indicate its position. \texttt{[FALSE]}
      }
      \sstsubsection{
         REFNAM = LITERAL (Write)
      }{
         The reference object associated with the current picture.  It
         is blank if there is no reference object.  Up to 132 characters
         will be written.
      }
      \sstsubsection{
         REPORT = \_LOGICAL (Read)
      }{
         If this is FALSE the state of the graphics device is not
         reported, merely the results are written to the output
         parameters.  It is intended for use within procedures. \texttt{[TRUE]}
      }
      \sstsubsection{
         STYLE = LITERAL (Read)
      }{
         A group of attribute settings describing the plotting style to use
         when drawing the outline (see parameter OUTLINE). The format
         of the axis values reported on the screen may also be controlled.

         A comma-separated list of strings should be given in which each
         string is either an attribute setting, or the name of a text file
         preceded by an up-arrow character \texttt{"}$\wedge$\texttt{"}. Such text files should
         contain further comma-separated lists which will be read and
         interpreted in the same manner. Attribute settings are applied in
         the order in which they occur within the list, with later settings
         over-riding any earlier settings given for the same attribute.

         Each individual attribute setting should be of the form:

            $<$name$>$=$<$value$>$

         where $<$name$>$ is the name of a plotting attribute, and $<$value$>$ is
         the value to assign to the attribute. Default values will be
         used for any unspecified attributes. All attributes will be
         defaulted if a null value (!) is supplied. See section \texttt{"}Plotting
         Attributes\texttt{"} in SUN/95 for a description of the available
         attributes. Any unrecognised attributes are ignored (no error is
         reported).

         The appearance of the outline is controlled by the attributes
         Colour(Border), Width(Border), \emph{etc} (the synonym \texttt{"}Outline\texttt{"} may be
         used in place of \texttt{"}Border\texttt{"}). In addition, the following attributes
         may be set in order to control the appearance of the formatted axis
         values reported on the screen: Format, Digits, Symbol, Unit. These
         may be suffixed with an axis number (\emph{e.g.} \texttt{"}Digits(2)\texttt{"}) to refer to
         the values displayed for a specific axis. \texttt{[current value]}
      }
      \sstsubsection{
         X1 = LITERAL (Write)
      }{
         The lowest value found within the current picture for axis 1 of the
         requested co-ordinate Frame (see parameter FRAME).
      }
      \sstsubsection{
         X2 = LITERAL (Write)
      }{
         The highest value found within the current picture for axis 1 of the
         requested co-ordinate Frame (see parameter FRAME).
      }
      \sstsubsection{
         Y1 = LITERAL (Write)
      }{
         The lowest value found within the current picture for axis 2 of the
         requested co-ordinate Frame (see parameter FRAME).
      }
      \sstsubsection{
         Y2 = LITERAL (Write)
      }{
         The highest value found within the current picture for axis 2 of the
         requested co-ordinate Frame (see parameter FRAME).
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         idstate
      }{
         Shows the status of the current graphics device. The bounds of
         the picture are displayed in the current co-ordinate Frame of
         the picture.
      }
      \sstexamplesubsection{
         idstate ps\_l basepic
      }{
         Shows the status of the ps\_l device. The bounds of the picture
         are displayed in the BASEPIC Frame (normalised device co-ordinates
         in which the short of the two dimensions of the display surface
         has length 1.0).
      }
      \sstexamplesubsection{
         idstate outline frame=pixel style=\texttt{"}\texttt{'}colour=red,width=3\texttt{'}\texttt{"}
      }{
         Shows the status of the current graphics device and draws a
         thick, red outline around the current database picture. The
         bounds of the picture are displayed in the PIXEL co-ordinate
         Frame (if available).
      }
      \sstexamplesubsection{
         idstate refnam=(ndfname)
      }{
         Shows the status of the current graphics device.  If there
         is a reference data object, its name is written to the ICL
         variable NDFNAME.
      }
      \sstexamplesubsection{
         idstate x1=(x1) x2=(x2) y1=(y1) y2=(y2) frame=basepic
      }{
         Shows the status of the current graphics device.  The bounds
         of the current picture in normalised device co-ordinates
         are written to the ICL variables: X1, X2, Y1, Y2.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The displayed bounds are the extreme axis values found anywhere
         within the current picture. In some situations these extreme
         values may not occur on the edges of the picture. For instance, if
         the current picture represents a region including the north
         celestial pole, then displaying the picture bounds in celestial
         co-ordinates will give a declination upper limit of $+$90 degrees,
         whilst the RA limits will be 0 hours and (close to) 24 hours.

         \sstitem
         Previous versions of this application reported bounds in
         \texttt{"}Normalised Device Co-ordinates\texttt{"}. Similar functionality is now
         provided by setting parameter FRAME to \texttt{"}BASEPIC\texttt{"}. Be aware though,
         that \texttt{"}Normalised Device Co-ordinates\texttt{"} were normalised so that the
         longer of the two axes had a length of 1.0, but BASEPIC co-ordinates
         are normalised so that the shorter of the two axes has length 1.0.
      }
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPPA: IDSTATE.
   }
}
\sstroutine{
   INSPECT
}{
   Inspects a 2-d NDF in a variety of ways
}{
   \sstdescription{
      This application provides an interactive facility to inspect the
      details of whole or part of the 2-dimensional data array in an input NDF.
      Briefly, the inspection options permit: a region to be selected
      for which statistics may be calculated, its values written to a
      text file, or an histogram be plotted and saved in an NDF; the
      region itself may be saved in an NDF; the value of a pixel or a
      region of pixels to be viewed; a slice between two pixels may be
      calculated, plotted and saved in an NDF; text files containing
      $x$-$y$-value of selected pixels may be created and extended, and
      chosen pixels marked.

      The application has two modes of interaction: cursor and
      interface.  In cursor mode the selection of pixels, and the
      definition of the region are made by moving a graphics cursor
      over a previously displayed image or contour plot.  Since
      instructional text showing the function of the mouse or
      trackerball buttons is shown, the graphics device providing the
      cursor must be an image-display overlay.  Also the name of the
      NDF used to display the image or contour plot is known and need
      not be entered.  This is the recommended interaction mode.  The
      alternative, interface, means that the pixel indices of pixels
      and regions to be inspected are specified in response to prompts.

      The application is composed of two parts.  First the preliminaries
      obtains the mode, the input NDF and graphics devices.  In cursor
      mode this usually amounts to a single prompt, and but two in
      interface mode.  The second stage is a loop where the inspection
      option is selected and performed.
   }
   \sstusage{
      inspect in [mode] gdevice option [overlay]
        \newline\hspace*{1.5em}
        $\left\{ {\begin{tabular}{l}
                   numbin=? hirep=? histogram=? hititle=? \\
                   filename=? \\
                   peind=? \\
                   lbound=? ubound=? \\
                   out=? \\
                   slstart=? slend=? slice=? sltitle=? \\
                   vaind=? \\
                   xycont=? xyfile=? xytitle=?
                   \end{tabular} }
        \right.$
        \newline\hspace*{1.9em}
        \makebox[0mm][c]{\small option}
   }
   \sstparameters{
      \sstsubsection{
         FILENAME = FILENAME (Write)
      }{
         Name of the text file to contain the Listing of image values.
         The suggested default is \texttt{inspect\_list.lis}.  This is only
         required for the \texttt{"List"} option.
      }
      \sstsubsection{
         GDEVICE = DEVICE (Read)
      }{
         The name of the graphics device for line plots produced by the
         \texttt{"Histogram"} and \texttt{"Slice"} options.  The device should
         not be the image display, but it may be the image-display overlay
         plane used in the cursor-interaction mode, {\it i.e.}\ the same
         value as parameter OVERLAY (though this is not advisable for
         X-windows).  In the latter case plotting occurs in the same
         picture as the overlay annotations, namely the current
         picture.  If the existing plot on the base plane of the image
         display has text, {\it e.g.}\ annotated axes, a mess can of confused
         lines can appear.  To avoid this the current picture should be
         made the DATA picture rather than the FRAME around it.  If
         null, \texttt{!}, is given no line plots will be drawn unless the
         \texttt{"Device"} option is selected.
      }
      \sstsubsection{
         HIREP = \_LOGICAL (Read)
      }{
         \texttt{TRUE} if the full Histogram is to be reported to you.  A
         large number of bins may be required for the plot but need not
         be listed in full.  This parameter provides a way of preventing
         unwanted, tedious and long output.  The suggested default is
         \texttt{FALSE}.  HIREP is only required for the \texttt{"Histogram"} option.
      }
      \sstsubsection{
         HISTOGRAM = NDF (Read)
      }{
         Name of the NDF structure to save the Histogram in its data
         array.  If null, \texttt{!}, is entered, the histogram NDF is not
         created.  This parameter is only required for the \texttt{"Histogram"}
         option.  The suggested default is \texttt{!}.
      }
      \sstsubsection{
         HITITLE = LITERAL (Read)
      }{
         Title for the output NDF containing the Histogram.  For the
         first histogram saved this defaults to
         \texttt{"KAPPA - Inspect\_Histogram"}, and subsequently this becomes
         the suggested default.   This parameter is only required for
         the \texttt{"Histogram"} option. \texttt{[]}
      }
      \sstsubsection{
         IN = NDF (Read)
      }{
         NDF structure containing the 2-dimensional data array to be inspected.
      }
      \sstsubsection{
         LBOUND( 2 ) = \_INTEGER (Read)
      }{
         Lower bounds in pixel indices of the Region.  The chosen pixel
         must be different from that at the lower bound.  It is only
         used in Interface mode with the \texttt{"Region"} option.
      }
      \sstsubsection{
         MODE = LITERAL (Read)
      }{
         The interaction mode.  The options are \texttt{"Cursor"} to use a
         graphics cursor to select regions and pixels to inspect,
         or \texttt{"Interface"} where prompted ADAM parameters are used to
         define those parts of the image to inspect. \texttt{[}Current
         interaction mode\texttt{]}
      }
      \sstsubsection{
         NUMBIN = \_INTEGER (Read)
      }{
         Number of bins needed for the Histogram.  The suggested default
         is the current value, which is 100 initially.  A value is the
         range 2--5000 is required.  This parameter is only required
         for the \texttt{"Histogram"} option.
      }
      \sstsubsection{
         OPTION = LITERAL (Read)
      }{
         Current inspection mode.  The options are:
         \begin{description}
         \item \texttt{"Device"} --- This allows the selection and opening of a new
                          line-plot graphics device, at the same time
                          closing down the old one, whose last plot is
                          stored in the graphics database.
         \item \texttt{"Exit"} --- Exit the application.
         \item \texttt{"Histogram"} --- This calculates the histogram of the current
                          region. A summary and plot (if there is a
                          graphics device available) of the histogram
                          is produced.  The style of the plot may be
                          adjusted via several parameters.  The full
                          histogram may also be reported. The histogram
                          data can be stored in a 1-d NDF.
         \item \texttt{"List"} --- This produces a formatted and headed listing
                          of the chosen region to a text file.
         \item \texttt{"Peep"} --- Obtain a formatted listing of the 7$\times$7 section
                          of the array data, centred on a pixel
                          specified using the cursor or via prompting.
         \item \texttt{"Region"} --- To define the region of the array to be used
                          by other options. If the image display
                          is available, then the cursor is used to
                          define the area, otherwise, the pixel bounds
                          of the region come from the environment. Using
                          the cursor, the functions of the choice-device
                          buttons are drawn on the overlay.
         \item \texttt{"Save"} --- Writes the current region to a new NDF,
                          propagating all the components.
         \item \texttt{"Slice"} --- Two points are defined via the cursor or from
                          parameter prompting between which a slice ({\it i.e.}
                          cross-section) is calculated.  Using the
                          cursor, the functions of the trackerball or
                          mouse buttons are drawn on the overlay. A plot
                          is made to the graphics device if available.
                          The style of the plot may be adjusted via
                          several parameters.  The slice can be stored
                          in a 1-d NDF.  The slice abscissa has units in
                          true pixels (assuming pixels are square), thus
                          a 45\dgs\ slice would have a length $\surd$2
                          times its projected length in $x$ or $y$.
         \item \texttt{"Statistics"} --- The key statistical parameters of the current
                          region are determined and reported.
         \item \texttt{"Value"} --- Obtain the value of a pixel at a point selected
                          via the cursor or via prompting.
         \item \texttt{"XYcur"} --- A list of the co-ordinates and values of pixels
                          selected by the image-display cursor are
                          written to a text file with Fortran carriage
                          control. The functions of the trackerball or
                          mouse buttons are displayed.  Optionally, an
                          existing file in the same format as produced
                          by XYcur can be appended to, for example, when
                          a session has been interrupted.  These stored
                          pixels are displayed on the overlay plane as
                          if there had been no interruption.  XYcur
                          requires cursor mode.
         \end{description}
         The suggested default is \texttt{"Region"}.

         If the option is specified on the command line a single
         inspection may be undertaken, {\it i.e.}\  there is no looping.  This
         feature is intended for command procedures.
      }
      \sstsubsection{
         OUT = NDF (Read)
      }{
         Name of the NDF structure to contain the Saved Region.  This
         is only used in the \texttt{"Save"} option.
      }
      \sstsubsection{
         OVERLAY = DEVICE (Read)
      }{
         Name of the overlay-plane device used in the cursor interaction
         mode.  It must have class IMAGE\_OVERLAY or WINDOW\_OVERLAY and
         support colour.  It is ignored when MODE is not \texttt{"Cursor"}.
         \texttt{[}Current image-display-overlay device\texttt{]}
      }
      \sstsubsection{
         PEIND( 2 ) = \_INTEGER (Read)
      }{
         $x$-$y$ pixel index of the pixel about which the Peep is required.
         The values must lie within their respective bounds of the
         input image.  The suggested default is the image centre.  It
         is only used in Interface mode with the \texttt{"Peep"} option.
      }
      \sstsubsection{
         SLEND( 2 ) = \_INTEGER (Read)
      }{
         The $x$-$y$ pixel index defining the end of the Slice.  It
         must lie within the bounds of the array and be distinct from
         the start of the slice.  The suggested default is the upper
         bound of the input NDF.  It is only used in Interface mode
         with the \texttt{"Slice"} option.
      }
      \sstsubsection{
         SLICE = NDF (Read)
      }{
         Name of the NDF structure to save the Slice in its data array.
         If null, \texttt{!}, is entered, the slice NDF is not created.
         It is only required in the \texttt{"Slice"} option.  The
         suggested default is \texttt{!}.
      }
      \sstsubsection{
         SLSTART( 2 ) = \_INTEGER (Read)
      }{
         The $x$-$y$ pixel index defining the start of the Slice.  It must
         lie within the bounds of the array.  The suggested default is
         the lower bound of the input NDF.  It is only used in
         Interface mode with the \texttt{"Slice"} option.
      }
      \sstsubsection{
         SLTITLE = LITERAL (Read)
      }{
         Title for the Slice NDF.  Title for the Region NDF.  For the
         first region saved this defaults to \texttt{"KAPPA - Inspect\_Slice"},
         and subsequently this becomes the suggested default.  It is
         only required in the \texttt{"Slice"} option. \texttt{[]}
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Title for the Region NDF.  For the first region saved this
         defaults to \texttt{"KAPPA - Inspect"}, and subsequently this becomes
         the suggested default.  It is only used in the \texttt{"Save"} option.
         \texttt{[]}
      }
      \sstsubsection{
         UBOUND( 2 ) = \_INTEGER (Read)
      }{
         Upper bounds in pixel indices of the Region.  The chosen pixel
         must be different from that at the lower bound.  It is only
         used in Interface mode with the \texttt{"Region"} option.
      }
      \sstsubsection{
         VAIND( 2 ) = \_INTEGER (Read)
      }{
         $x$-$y$ pixel index of pixel whose Value is required.  The values
         must lie within their respective bounds of the input image.
         The suggested default is the image centre.  It is only used in
         Interface mode with the \texttt{"Value"} option.
      }
      \sstsubsection{
         XYCONT = \_LOGICAL (Read)
      }{
         If \texttt{TRUE}, an existing file is appended to in the XYcur option.
         The suggested default is \texttt{FALSE}.  It is only available in
         cursor mode with the \texttt{"XYcur"} option.
      }
      \sstsubsection{
         XYFILE = FILENAME (Update)
      }{
         Name of the text file to which pixel data are written by
         XYcur option.  The suggested default is \texttt{xylist.lis}.  It is
         only available in cursor mode with the \texttt{"XYcur"} option.
      }
      \sstsubsection{
         XYTITLE = LITERAL (Read)
      }{
         Title for the text file in XYcur option.  For the first file
         created this defaults to \texttt{"\# KAPPA - Inspect\_XYcur"}, and
         subsequently this becomes the suggested default. It is not
         accessed if XYCONT is \texttt{TRUE}.   It is only available in cursor
         mode with the \texttt{"XYcur"} option. \texttt{[]}
      }
   }
   \sstgraphparameters{
      \sstsubsection{
         ABSLAB  =  LITERAL (Read)
      }{
         Label for the line-plot abscissa, in which NCAR fancy founts
         may be embedded when FONT = \texttt{"NCAR"}.  Note Slice and
         Histogram have different defaults and these are stored separately.

         For a slice plot the suggested default is the current value,
         which is initially \texttt{"Pixels"}.  If an error occurs obtaining the
         label the default is \texttt{"Pixels"}.

         If axis information is present the suggested default for a
         plot of an histogram is the NDF's axis label followed by the
         units, in parentheses.  If an error occurs obtaining the label
         or there is no axis information, the label takes its current
         value, which initially is \texttt{"Values"}.

         For the first plot ABSLAB is defaulted to the suggested value
         unless PLOTSTYLE is included on the command line, and
         subsequently will only be obtained whenever PLOTSTYLE is \texttt{TRUE}.
         \texttt{[]}
      }
      \sstsubsection{
         FONT = LITERAL (Read)
      }{
         The fount to be used for the line graphics.  It can be either
         \texttt{"NCAR"} for the NCAR fancy characters and \texttt{"GKS"} for the standard
         GKS san-serif fount.   The former is intended for hardcopy
         publication-quality plots, since it is relatively slow; the
         latter is intended for normal interactive graphics requiring
         rapid plotting, and it is clearer on small plots. The
         suggested default is the current value.

         For the first plot FONT is defaulted to \texttt{"GKS"}, and subsequently
         will only be obtained whenever PLOTSTYLE is \texttt{TRUE}. \texttt{[]}
      }
      \sstsubsection{
         MAJTIC( 2 ) = \_REAL (Read)
      }{
         The parameter controlling the numbers of major tick marks
         for the $x$ and $y$ axes in the slice or histogram plot.
         (The number used is between MAJTIC$+$2 and 5$*$MAJTIC/2$+$4.).

         By default, it is \texttt{[4.,4.]}.  For the first plot MAJTIC is
         defaulted, and subsequently will only be obtained whenever
         PLOTSTYLE is \texttt{TRUE}.  \texttt{[]}
      }
      \sstsubsection{
         MINTIC( 2 ) = \_REAL (Read)
      }{
         The number of minor tick marks between each major tick mark
         for linear $x$ and $y$ axes in the slice or histogram plot.  A
         negative value forces the graphics package to compute
         appropriate values.  The number of minor tick marks per major
         tick is fixed (8) for a logarithmic axis.

         By default, it is \texttt{[-1.,-1.]}.  For the first plot MINTIC is
         defaulted, and subsequently will only be obtained whenever
         PLOTSTYLE is \texttt{TRUE}.  \texttt{[]}
      }
      \sstsubsection{
         ORDLAB  =  LITERAL (Read)
      }{
         Label for the line-plot ordinate, in which NCAR fancy founts
         may be embedded.  Note Slice and Histogram have different
         defaults and these are stored separately.

         For an histogram plot the suggested default is the current
         value, which is initially \texttt{"Number"}.  If an error occurs
         obtaining the label the default is \texttt{"Number"}.

         If axis information is present the suggested default for a
         plot of a slice is the NDF's axis label followed by the
         units, in parentheses.  If an error occurs obtaining the label
         or there is no axis information, the label takes its current
         value, which initially is \texttt{"Data values"}.

         For the first plot ORDLAB is defaulted to the suggested value
         unless PLOTSTYLE is included on the command line, and
         subsequently will only be obtained whenever PLOTSTYLE is \texttt{TRUE}.
         \texttt{[]}
      }
      \sstsubsection{
         OUTTIC = \_LOGICAL (Read)
      }{
         \texttt{TRUE} if the axis tick marks are to appear on the outside of
         the axes instead of inside in the slice or histogram plots.
         This eliminates intersections of ticks with the data locus.

         By default, the tick marks are drawn inside the plot region.
         For the first plot OUTTIC is defaulted, and subsequently will
         only be obtained whenever PLOTSTYLE is \texttt{TRUE}.  \texttt{[]}
      }
      \sstsubsection{
         PLOTSTYLE = \_LOGICAL (Read)
      }{
         If \texttt{TRUE}, the plotting style of line plots is to be altered from
         the default for the first plot, or the existing values for
         subsequent graphs.  Initially, it is defaulted to \texttt{FALSE}, then
         the suggested value is the current value.  Therefore to
         override the plotting-style parameters on the first plot, new
         values should be given on the command line, and along with the
         PLOTSTYLE keyword for ABSLAB, ORDLAB, and PLTITL.
         Subsequently, the plotting style may be
         retained or modified via prompts.  \texttt{[]}
      }
      \sstsubsection{
         PLTITL = LITERAL (Read)
      }{
         The title of a line plot, in which NCAR fancy founts may be
         embedded.  Note Slice and Histogram have different defaults
         and these are stored separately.  Both attempt to use the NDF's
         title if present and no error occurs, otherwise the current
         value becomes the suggested default.  For the histogram plot
         this is initially \texttt{"Histogram of current region"} and for the
         slice plot it is initially \texttt{"Slice plot"}.

         For the first plot PLTITL is defaulted to the suggested value
         unless PLOTSTYLE is included on the command line, and
         subsequently will only be obtained whenever PLOTSTYLE is \texttt{TRUE}.
         \texttt{[]}
      }
      \sstsubsection{
         THICK = \_REAL (Read)
      }{
         The thickness of the axes and annotations in the histogram and
         line plots, where 1.0 is the normal thickness.  Currently,
         this is only available on a few devices.  It must take a value
         in the range 0.5--5.0.

         By default the line thickness is 1.0.  For the first plot
         THICK is defaulted to the suggested value, and subsequently
         will only be obtained whenever PLOTSTYLE is \texttt{TRUE}.  \texttt{[]}
      }
      \sstsubsection{
         XLOG = \_LOGICAL (Read)
      }{
         \texttt{TRUE} if the line-plot abscissa is to be logarithmic.  Note, for
         Slice and Histogram options each has its own independent
         switch.  It is unlikely that you would want to do this.  By
         default, the abscissa is linear.  For the first plot XLOG is
         defaulted, and subsequently will only be obtained whenever
         PLOTSTYLE is \texttt{TRUE}. \texttt{[]}
      }
      \sstsubsection{
         YLOG = \_LOGICAL (Read)
      }{
         \texttt{TRUE} if the line-plot ordinate is to be logarithmic. Note, for
         Slice and Histogram options each has its own independent
         switch.  By default, the ordinate is linear.  For the first
         plot YLOG is defaulted, and subsequently will only be
         obtained whenever PLOTSTYLE is \texttt{TRUE}.  \texttt{[]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         Note:
      }{
         Since INSPECT is an interacting, graphical and self-contained
         monolith of applications it is not straightforward to give
         command-line examples.  Generally, the best way to run INSPECT
         is in cursor mode after having displayed an image.  The
         following examples use the prompting mode.
      }
      \sstexamplesubsection{
         inspect rulupi i canon\_l sl slstart=[3,10] slend=[9,42] slice=!
      }{
         Plots a slice from pixel (3,10) to (9,42) of the NDF called
         rulupi to the CANON\_L graphics device.
      }
      \sstexamplesubsection{
         inspect rulupi i gdevice=x2w option=hi numbin=100 histogram=ru\_hg
      }{
         Calculates the histogram of the NDF called rulupi, reporting
         a summary to you, and plots the histogram to the x2w
         device.  The histogram has one hundred bins and is stored in
         an NDF called ru\_hg.
      }
      \sstexamplesubsection{
         inspect rulupi i ! option=hi numbin=100 hirep $\backslash$
      }{
         As above except no plot is made, no NDF is created, and
         the full one hundred histogram values are reported.  In this
         particular example the second parameter could equally well be
         C for cursor mode since no co-ordinate information is
         obtained.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         In cursor mode there must be an existing DATA picture for the
         chosen image display stored in the graphics database.  Valid
         cursor positions are bounded by the DATA picture.

         \sstitem
         On exit the input picture, if there was one, is made the
         current picture on the overlay; and the last graphics plot is
         stored in the database as a FRAME picture.  Also, if the
         \texttt{"Device"} option is used a FRAME picture is stored for
         that device.

         \sstitem
         The Histogram NDF has an AXIS component whose the LABEL and
         UNITS are those of the input NDF's data array; its centres are
         in data value of the bin centre.  The NDF LABEL is \texttt{"Number"}.

         \sstitem
         The Slice NDF has an AXIS component whose LABEL is \texttt{"Pixel"} and
         centres are pixel co-ordinates from 0.5; its LABEL and UNITS are
         propagated from the input NDF.

         \sstitem
         The current palette entries 1 to 4 associated with the OVERLAY
         are used as follows in the cursor mode for IMAGE\_OVERLAY devices.
         A sample slice or region, and the associated button, are drawn
         with palette index 1.  Similarly, index 3 is used to indicate an
         accepted slice or region.  The exit button is drawn in the colour
         of index 2.  Index 4 is used to draw the boxes representing the
         mouse or trackerball buttons.  Use the PAL$\lsk$ commands to select
         suitable complementary colours for the image's colour table,
         especially for palette indices 1 and 3.

         For WINDOW\_OVERLAY devices, all the above are drawn with the
         colour of palette index 1, but the various colours are replaced
         by different dashed-line patterns.  Use PALENTRY to change the
         colour of the lines.
      }
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPPA: CURSOR, HISTOGRAM, ELPROF, LOOK, NDFCOPY, STATS; ESP:
      SECTOR; Figaro: HIST, ICUR, IGCUR, ILIST, ISTAT, SLICE; GAIA.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Only real data can be processed directly.  Other data types
         will undergo a type conversion before processing occurs.

         \sstitem
         The routine correctly processes the AXIS, DATA, QUALITY, VARIANCE,
         LABEL, TITLE, UNITS, and HISTORY components of an NDF, and
         propagates the WCS component, plus all extensions, to the output
         Region NDF.

         \sstitem
         Processing of bad pixels and automatic quality masking are
         supported.  Bad pixels are excluded from statistics and are
         indicated in reports of data values by the word \texttt{INVALID}.  In the
         slice plot they appear as gaps, and they do not affect the limits
         of the ordinate.  The same applies to zero or negative data
         values if the plot is to have a logarithmic ordinate.  Similarly,
         for the histogram abscissa.
      }
   }
}
\sstroutine{
   KRHHELP
}{
   Gives help about KAPRH
}{
   \sstdescription{
      Displays help about {\footnotesize KAPRH}.  The help information
      describes individual commands in detail.

      Here are some of the main options.
      \begin{description}
      \item \texttt{krhhelp} \\
         No parameter is given so the introduction and the top-level
         help index is displayed.

      \item \texttt{krhhelp application/topic} \\
         This gives help about the specified application or topic.

      \item \texttt{krhhelp application/topic subtopic} \\
         This lists help about a subtopic of the specified application
         or topic.  The hierarchy of topics has a maximum of four levels.

      \item \texttt{krhhelp Hints} \\
         This gives hints for new and intermediate users.

      \item \texttt{krhhelp summary} \\
         This shows a one-line summary of each application.

      \item \texttt{krhhelp classified classification} \\
         This lists a one-line summary of each application in the
         given functionality classification.
      \end{description}

      See the Section \texttt{"}Navigating the Help Library\texttt{"} for details
      how to move around the help information, and to select the topics
      you want to view.
   }
   \sstusage{
      krhhelp [topic] [subtopic] [subsubtopic] [subsubsubtopic]
   }
   \sstparameters{
      \sstsubsection{
         TOPIC = LITERAL (Read)
      }{
         Topic for which help is to be given. \texttt{[" "]}
      }
      \sstsubsection{
         SUBTOPIC = LITERAL (Read)
      }{
         Subtopic for which help is to be given. \texttt{[" "]}
      }
      \sstsubsection{
         SUBSUBTOPIC = LITERAL (Read)
      }{
         Subsubtopic for which help is to be given. \texttt{[" "]}
      }
      \sstsubsection{
         SUBSUBSUBTOPIC = LITERAL (Read)
      }{
         Subsubsubtopic for which help is to be given. \texttt{[" "]}
      }
   }
   \sstdiytopic{
      Navigating the Help Library
   }{
      The help information is arranged hierarchically.  You can
      move around the help information whenever KRHHELP prompts.  This
      occurs when it has either presented a screen's worth of text or
      has completed displaying the previously requested help.  The
      information displayed by KRHHELP on a particular topic includes
      a description of the topic and a list of subtopics that further
      describe the topic.

      At a prompt you may enter:

      \sstitemlist{

         \sstitem
         a topic and/or subtopic name(s) to display the help for that
         topic or subtopic, so for example, \texttt{block parameters box}
         gives help on \texttt{BOX}, which is a subtopic of \texttt{Parameters},
         which in turn is a subtopic of \texttt{BLOCK};

         \sstitem
         a \texttt{$<$CR$>$} to see more text at a \texttt{Press RETURN to
         continue ...} request;

         \sstitem
         a \texttt{$<$CR$>$} at topic and subtopic prompts to move up one
         level in the hierarchy, and if you are at the top level it will
         terminate the help session;

         \sstitem
         a \texttt{CTRL/D }(pressing the CTRL and D keys simultaneously) in
         response to any prompt will terminate the help session;

         \sstitem
         a question mark \texttt{?} to redisplay the text for the current topic,
         including the list of topic or subtopic names; or

         \sstitem
         an ellipsis \texttt{...} to display all the text below the current
         point in the hierarchy.  For example, \texttt{BLOCK...} displays
         information on the BLOCK topic as well as information on all the
         subtopics under BLOCK.
      }

      You can abbreviate any topic or subtopic using the following rules.

      \sstitemlist{

         \sstitem
         Just give the first few characters, {\it e.g.}\ \texttt{PARA} for
         \texttt{Parameters}.

         \sstitem
         Some topics are composed of several words separated by
         underscores.  Each word of the keyword may be abbreviated,
         {\it e.g.}\ \texttt{Colour\_Set} can be shortened to \texttt{C\_S}.

         \sstitem
         The characters \texttt{\%} and \texttt{$\lsk$} act as wildcards, where
         the percent sign matches any single character, and asterisk
         matches any sequence of characters.  Thus to display information
         on all available topics, type an asterisk in reply to a prompt.

         \sstitem
         If a word contains, but does end with an asterisk wildcard, it
         must not be truncated.

         \sstitem
         The entered string must not contain leading or embedded spaces.
      }

      Ambiguous abbreviations result in all matches being displayed.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Uses the portable help system.

      }
   }
}


\sstroutine{
   LUTFLIP
}{
   Flips the colour table of an image-display device
}{
   \sstdescription{
      This routine `flips' the colour table of a nominated plane of
      an IDI-supported image display, such as X-windows.  The flip
      reverses the order of the colours, so that the first colour
      becomes the last and vice versa, {\it etc.}
   }
   \sstusage{
      lutflip [device] [plane]
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the image-display device whose colour table is to
         be flipped. The name of the base plane should be given even if
         the overlay colour table is to be flipped.
         \texttt{[}Current image-display device\texttt{]}
      }
      \sstsubsection{
         PLANE = \_INTEGER (Read)
      }{
         The number of the memory plane whose colour table is to be
         flipped.  If it is null the base (image) memory's colour table
         is reversed. The base memory is 0 and overlays are numbered
         consecutively from 1.  For an Ikon the only overlay plane is 1.
         PLANE is only permitted to have a value in the range 0 to the
         number of planes minus one. \texttt{[0]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         lutflip
      }{
         This reverses the colour table on the current image-display
         device.
      }
      \sstexamplesubsection{
         lutflip xwindows
      }{
         This reverses the colour table on the xwindows device.
      }
      \sstexamplesubsection{
         lutflip ikon 1
      }{
         This flips the colour table on the Ikon overlay plane.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Only Ikons and X-windows are supported.

         \sstitem
         Reserved pens are not flipped.
      }
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPPA: LUTHILITE, LUTROT, LUTTWEAK.
   }
}
\sstroutine{
   LUTHILITE
}{
   Highlights a colour table of an image-display device
}{
   \sstdescription{
      This routine adjusts the colour table of a nominated plane of
      an IDI-supported image display, such as X-windows.  The adjustment
      is like a highlight pen, only here it can traverse the colour
      table, widen or thin is under mouse, joystick or trackerball
      button control; and the colour of the highlight is arbitrary.
      Thus particular features in an image may readily become visible.

      For an Ikon or X-windows, moving the mouse left or right shifts
      the highlight in the colour table towards lower and higher colour
      indices respectively.  The highlight does not rotate around the
      colour table.  Pressing the left button of the mouse reduces the
      width of the highlight by one colour index.  Pressing the centre
      button increases the width of the highlight by one colour index.
      Hitting the right-hand button ends the modification of the colour
      table.

      The colour table may be viewed during its manipulation without
      permanently altering the display memory.  The colour-table
      display is situated via the cursor, and will disappear once the
      highlighting is complete.
   }
   \sstusage{
      luthilite colour [device] [plane] [view]
   }
   \sstparameters{
      \sstsubsection{
         COLOUR() = LITERAL (Read)
      }{
         The colour to be used as a highlight.  It is either of these
         alternatives.
         \begin{itemize}
           \item  A named colour from the standard colour set, which may
           be abbreviated.  If the abbreviated name is ambiguous the
           first match is selected.  The case of the name is ignored.
           Some examples are \texttt{"Seagreen"}, \texttt{"Violet"}, and
           \texttt{"Orchid"}.

           \item Normalised red, green, and blue intensities separated by
           commas or spaces.  Each value must lie in the range 0.0--1.0.
           For example, \texttt{1.0,1.0,0.5} would give a pale yellow.
         \end{itemize}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the image-display device whose lookup table is to
         be adjusted.  The name of the base plane should be given even
         if the overlay lookup table is to be adjusted.
         \texttt{[}Current image-display device\texttt{]}
      }
      \sstsubsection{
         FULL = \_LOGICAL (Read)
      }{
         If FULL is \texttt{TRUE}, the whole colour-table for the device is
         may be highlighted, including the reserved pens.  When FULL
         is \texttt{FALSE}, the reserved pens in the palette are unaltered.
         \texttt{[FALSE]}
      }
      \sstsubsection{
         PLANE = \_INTEGER (Read)
      }{
         The number of the memory plane whose lookup table is to be
         manipulated. If it is null the base (image) memory's lookup
         table is adjusted.  The base memory is 0 and overlays are
         numbered consecutively from 1.  For an Ikon the only overlay
         plane is 1.  PLANE is only permitted to have a value in the
         range 0 to the number of planes minus one. \texttt{[0]}
      }
      \sstsubsection{
         VIEW = \_LOGICAL (Read)
      }{
         If \texttt{TRUE} the colour table is displayed during its manipulation.
         \texttt{[FALSE]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         luthilite red
      }{
         Highlights the colour table on the current image-display
         device with a red marker.
      }
      \sstexamplesubsection{
         luthilite red full
      }{
         Highlights the colour table and palette on the current
         image-display device with a red marker.
      }
      \sstexamplesubsection{
         luthilite skyblue xwindows
      }{
         Highlights the colour table on the xwindows device with a
         sky-blue marker.
      }
      \sstexamplesubsection{
         luthilite [1.0,1.0,0.3] ikon 1
      }{
         Highlights the colour table on the Ikon overlay plane in a
         pale yellow.
      }
      \sstexamplesubsection{
         luthilite red view
      }{
         Highlights the colour table on the current image-display
         device with a red marker.  The colour table is displayed
         during the highlighting.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Only Ikons and X-windows are supported.

         \sstitem
         Initially, the highlight has a width of two colour indices,
         and it is located at the second lowest colour index.  The maximum
         width of the highlight is the larger of six and a quarter of the
         colour table, but may be narrower when there are less than 12
         colour indices.  Should the highlight prove to be unsuitable, it
         may be made invisible by reducing the width to zero.

         \sstitem
         The rate of motion of the highlight is a function of the
         speed of cursor movement in addition to the cursor position.
         For a given cursor displacement slow motion moves the highlight
         more slowly, and faster motion moves it more rapidly.  This
         permits both fine control and swift change in the highlight's
         location.
      }
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPPA: LUTFLIP, LUTROT, LUTTWEAK.
   }
}
\sstroutine{
   LUTROT
}{
   Rotates the colour table of an image-display device
}{
   \sstdescription{
      This routine rotates the colour table of a nominated plane of
      an IDI-supported image display, such as X-windows. The rotation
      is under mouse, joystick or trackerball button control.

      For an Ikon or X-windows, moving the mouse left or right
      rotates the colour table towards lower and higher pen numbers
      respectively.  Pressing the left button of the mouse resets the
      colour table to its input state, and hitting the right-hand
      button ends the rotation.
   }
   \sstusage{
      lutrot [device] [plane]
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the image-display device whose colour table is to
         be rotated.  The name of the base plane should be given even if
         the overlay colour table is to be rotated.
         \texttt{[}Current image-display device\texttt{]}
      }
      \sstsubsection{
         FULL = \_LOGICAL (Read)
      }{
         If FULL is \texttt{TRUE}, the whole colour-table for the device is
         rotated, including the reserved pens.  When FULL is \texttt{FALSE},
         the reserved pens in the palette are unaltered.
         \texttt{[FALSE]}
      }
      \sstsubsection{
         PLANE = \_INTEGER (Read)
      }{
         The number of the memory plane whose colour table is to be
         rotated. If it is null the base (image) memory's colour table
         is rotated. The base memory is 0 and overlays are numbered
         consecutively from 1.  For an Ikon the only overlay plane is 1.
         PLANE is only permitted to have a value in the range 0 to the
         number of planes minus one. \texttt{[0]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         lutrot
      }{
         This enables rotation of the colour table on the current
         image-display device.
      }
      \sstexamplesubsection{
         lutrot xwindows
      }{
         This enables rotation of the colour table on the xwindows
         device.
      }
      \sstexamplesubsection{
         lutrot full
      }{
         This enables rotation of the colour table and palette on the
         current image-display device.
      }
      \sstexamplesubsection{
         lutrot ikon 1
      }{
         This enables rotation of the colour table on the Ikon overlay
         plane.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Only Ikons and X-windows are supported.

         \sstitem
         The rate of motion of the colour table is a function of the
         speed of cursor movement in addition to the cursor position.
         For a given cursor displacement slow motion rotates the colour
         table more slowly, and faster motion moves it more rapidly.  This
         permits both fine control and swift rotation.
      }
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPPA: LUTFLIP, LUTHILITE, LUTTWEAK.
   }
}
\sstroutine{
   LUTTWEAK
}{
   Tweaks a colour table of an image-display device
}{
   \sstdescription{
      This routine adjusts the colour table of a nominated plane of
      an IDI-supported image display, such as X-windows.  The adjustment
      is under mouse, joystick or trackerball button control.

      For an Ikon or X-windows, moving the mouse left or right shifts
      the colour table towards lower and higher colour indices
      respectively.  Moving the mouse up stretches the lookup table,
      and moving it down squashes the lookup table until it disappears,
      then the lookup table is flipped.  If the lookup table is
      reversed, moving down stretches, and moving up squashes.
      Pressing the left button of the mouse resets the colour table to
      its input state.  Pressing the centre button alters the way in
      which a squashed lookup table is padded.  The two states are
      white or to use the first and last colours of the input lookup
      table, the sense depending on whether the lookup table is
      flipped.  Hitting the right-hand button ends the modification of
      the colour table.

      The colour table may be viewed during its manipulation without
      permanently altering the display memory.  The colour-table
      display is situated via the cursor, and will disappear once the
      tweaking is complete.
   }
   \sstusage{
      luttweak [device] [plane] [view]
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The name of the image-display device whose lookup table is to
         be adjusted.  The name of the base plane should be given even
         if the overlay lookup table is to be adjusted.
         \texttt{[}Current image-display device\texttt{]}
      }
      \sstsubsection{
         FULL = \_LOGICAL (Read)
      }{
         If FULL is \texttt{TRUE}, the whole colour-table for the device is
         may be modified, including the reserved pens.  When FULL
         is \texttt{FALSE}, the reserved pens in the palette are unaltered.
         \texttt{[FALSE]}
      }
      \sstsubsection{
         PLANE = \_INTEGER (Read)
      }{
         The number of the memory plane whose lookup table is to be
         manipulated.  If it is null the base (image) memory's lookup
         table is adjusted.  The base memory is 0 and overlays are
         numbered consecutively from 1.  For an Ikon the only overlay
         plane is 1.  PLANE is only permitted to have a value in the
         range 0 to the number of planes minus one. \texttt{[0]}
      }
      \sstsubsection{
         VIEW = \_LOGICAL (Read)
      }{
         If \texttt{TRUE} the colour table is displayed during its manipulation.
         \texttt{[FALSE]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         luttweak
      }{
         Tweaks the colour table on the current image-display device.
      }
      \sstexamplesubsection{
         luttweak xwindows
      }{
         Tweaks the colour table on the xwindows device.
      }
      \sstexamplesubsection{
         luttweak xwindows full
      }{
         Tweaks the colour table and palette on the xwindows device.
      }
      \sstexamplesubsection{
         luttweak ikon 1
      }{
         Tweaks the colour table on the Ikon overlay plane.
      }
      \sstexamplesubsection{
         luttweak view
      }{
         Tweaks the colour table on the current image-display device.
         The colour table is displayed during the tweaking.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Only Ikons and X-windows are supported.

         \sstitem
         The speed of the colour-table rotation is not linearly
         proportional to the mouse displacement; the speed of displacement
         tunes the effect so that slow motion makes a small change than
         a faster motion.  The squashing and stretching factors are also
         non-linear.
      }
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPPA: LUTFLIP, LUTHILITE, LUTROT.
   }
}

\sstroutine{
  MOSAIC
}{
Merges several non-congruent 2-d data arrays into one output data array.
}{
\sstdescription{
  Up to 20 non-congruent 2-d data arrays may be input, along with
  their relative offsets from the first data array, and these are
  then made into a mosaic into one (usually larger) output 2-d data
  array. Where the frames overlap, either the mean value or just the
  sum is inserted into the output data array. Normally averaging is
  performed. All data arrays are stored in \texttt{IMAGE} structures.

  The magic-value method is used for processing bad data.  Bad
  pixels are excluded from the averaging in overlap areas. Output
  pixels that have been mapped or correspond to one or more input
  arrays, yet have no good pixels contributing, are set to bad.
  Pixels in the output data array not mapped by any of the input
  arrays are set to zero.
}
 \sstusage{
  MOSAIC
}
\sstparameters{
\sstsubsection{
  NUMBER = \_INTEGER (Read)
}{
  Number of data arrays to be merged.
}
\sstsubsection{
  AVERAGE = \_LOGICAL (Read)
}{
  If true overlap regions are averaged, alternatively, they are
  summed.  \mbox{{\texttt [TRUE]}}
}
\sstsubsection{
  INPIC$n$ = IMAGE (Read)
}{
  {$n^{\rm th}$} {\texttt{IMAGE}} structure containing a data array to be a
  constituent of a mosaic.
}
\sstsubsection{
  OUTPIC = IMAGE (Write)
}{
  Output {\texttt{IMAGE}} structure containing the merged data array.
}
\sstsubsection{
 OTITLE = \_CHAR (Read)
}{
  Title for the output {\texttt{IMAGE}} structure. \mbox{{\texttt ['KAPPA - Mosaic']}}
}
\sstsubsection{
  XOFFSET = \_INTEGER (Read)
}{
  {$x$} offset of {$n^{\rm th}$} data array from the first, in the sense of the
  {$x$} origin of the {$n^{\rm th}$} data array minus the {$x$} origin of the
  first.
}
\sstsubsection{
 YOFFSET = \_INTEGER (Read)
}{
  {$y$} offset of {$n^{\rm th}$} data array from the first, in the sense of the
  {$y$} origin of the {$n^{\rm th}$} data array minus the {$y$} origin of the
  first.
}
}
}

\sstroutine{
  QUILT
}{
Generates a mosaic from equally sized 2-d data arrays, optionally specified from an ASCII file.
}{
\sstdescription{
  This routine provides a more-sophisticated version of the {\texttt{MOSAIC}}
  application for combining many 2-d data arrays into one large
  output data array. All the data arrays are stored in {\texttt{IMAGE}}
  structures.  The pixels in overlapping regions may be averaged or
  summed.

  The names of {\texttt{IMAGE}} structures to be concatenated and their
  respective offsets of their data arrays from a central
  data array can be input either one by one from the interface, or
  all at once from a free-format file.  The format of the file is
  as follows:  \mbox {}

  \begin{tabular}{@{\hspace{11mm}}l@{\hspace{24mm}}l}
        \\
        \texttt{Mosaic title}     & ! header \\
        \texttt{central\_image}   & ! name of central {\texttt{IMAGE}} \\
        \texttt{125}              & ! total number of frames \\
        \texttt{345  229}         & ! maximum {$x$}-{$y$} offsets \\
        \texttt{-356  -232}       & ! minimum {$x$}-{$y$} offsets \\
        \texttt{image\_2}         & ! subsequent {\texttt{IMAGE}} and \\
        \texttt{35  34}           & ! its {$x$}-{$y$} offsets \\
        \texttt{image\_3}         & \\
        \texttt{36  -33}          & \\
        \texttt{.}                & \\
        \texttt{.}                & \\
        \texttt{.}                & \\
        \\
  \end{tabular}

  Only like-sized data arrays may be input. The reason for this is
  that it is difficult to work out how big the output data array
  needs to be until all the input data arrays and their offsets have
  been read in. By confining the data arrays to be the same size,
  only the maximum and minimum {$x$} and {$y$} offsets from the central data
  array need be input by the user, then the output image size can be
  worked out from these numbers along with the size of the central
  data array.

  Bad pixels are processed by the magic-value method.
}
\sstusage{
  QUILT
}
\sstparameters{
\sstsubsection{
  WHERE = \_CHAR (Read)
}{
  Whether input comes from an ASCII {\texttt{'File'}} or from the
  {\texttt{'Interface'}}.
}
\sstsubsection{
  FNAME = \_CHAR (Read)
}{
  Name of the ASCII file holding the input information to define
  the mosaic.
}
\sstsubsection{
  NUMBER = \_INTEGER (Read)
}{
  Number of data arrays to form the mosaic.
}
\sstsubsection{
  INPICI = IMAGE (Read)
}{
  {\texttt{IMAGE}} structure containing the central data array (offset 0, 0).
}
\sstsubsection{
  MAXX = \_INTEGER (Read)
}{
  Maximum {$x$} offset of any data array from the central data array
  in {\texttt Interface} mode (must be {$\geq$}0).
}
\sstsubsection{
  MAXY = \_INTEGER (Read)
}{
  Maximum {$y$} offset of any data array from the central data array
  in {\texttt Interface} mode (must be {$\geq$}0).
}
\sstsubsection{
  MINX = \_INTEGER (Read)
}{
  Minimum {$x$} offset of any data array from the central data array
  in {\texttt Interface} mode (must be {$\leq$}0).
}
\sstsubsection{
 MINY = \_INTEGER (Read)
}{
  Minimum {$y$} offset of any data array from the central data array
  in {\texttt Interface} mode (must be {$\leq$}0).
}
\sstsubsection{
  AVERAGE = \_LOGICAL (Read)
}{
  If true overlap regions are averaged, alternatively, they are
  summed.
}
\sstsubsection{
  OUTPIC = IMAGE (Write)
}{
  Output {\texttt{IMAGE}} structure.
}
\sstsubsection{
  OTITLE = \_CHAR (Read)
}{
  Title string for output {\texttt{IMAGE}} structure.
 \mbox{{\texttt ['KAPPA - Quilt']}}
}
\sstsubsection{
  CURPIC = IMAGE (Read)
}{
  {\texttt{IMAGE}} containing the current data array being concatenated to
  the mosaic.
}
\sstsubsection{
  OFFSETX = \_INTEGER (Read)
}{
  {$x$} offset of current data array from the central one
  ({\texttt{Interface}} mode).
}
\sstsubsection{
  OFFSETY = \_INTEGER (Read)
}{
  {$y$} offset of current data array from the central one
  ({\texttt{Interface}} mode).
}
}
\sstimplementationstatus{
  Works with like-sized images only and uses Fortran i/o for getting
  stuff from a file.
}
}

\sstroutine{
   OVCLEAR
}{
   Clears an graphics device overlay
}{
   \sstdescription{
      This application clears an overlay device, but without purging
      the graphics-database entries for the device.  Optionally, only
      the current picture is cleared.
   }
   \sstusage{
      ovclear [device] [current]
   }
   \sstparameters{
      \sstsubsection{
         CURRENT = \_LOGICAL (Read)
      }{
         If \texttt{TRUE}, then only the current picture is cleared. \texttt{[FALSE]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The graphics device to be cleared.  It must be in GNS classes
         IMAGE\_OVERLAY or WINDOW\_OVERLAY.
         \texttt{[}Current graphics device-overlay device\texttt{]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         ovclear
      }{
         Clears the current image-overlay device.
      }
      \sstexamplesubsection{
         ovclear current
      }{
         Clears the current picture on the current image-overlay device.
      }
      \sstexamplesubsection{
         ovclear xoverlay
      }{
         Clears the xoverlay device.
      }
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPPA: GDCLEAR, OVSET.
   }
}

\sstroutine{
   OVSET
}{
   Selects a current graphics device overlay
}{
   \sstdescription{
      This application selects a current graphics device overlay. This
      device will be used for all applications requiring an
      graphics device overlay until changed explicitly.
   }
   \sstusage{
      ovset device
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The graphics device overlay to become the current graphics device
         overlay device.  The device must be in GNS categories
         IMAGE\_OVERLAY or WINDOW\_OVERLAY.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         ovset xov
      }{
         Makes the xov device the current graphics device overlay.
      }
   }
}

\sstroutine{
   SNAPSHOT
}{
   Dumps an image-display memory to a graphics hardcopy and
   optionally to an NDF
}{
   \sstdescription{
      This routine captures the data in the memory of an image-display
      device, and writes these data to a different GKS device.  For
      example, the contents of an X-windows memory might be captured and
      sent to a PostScript laser printer.

      Various options are available:
      \begin{itemize}
         \item you may choose to capture a whole or part of what is visible
           on the screen, or the entire contents of the memory.  For the
           former you adjust a rubber-band region until the desired
           area is enclosed. Instructions for controlling the
           rubber-band are given at run time.
         \item A title may be included in the output.
         \item The array may be output to an NDF.
      \end{itemize}
   }
   \sstusage{
      snapshot odevice [out] [whole] [scale] [negativ] [title] [planes]
   }
   \sstparameters{
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         Input image-display device.  \texttt{[}Current image-display
         device\texttt{]}
      }
      \sstsubsection{
         NEGATIVE = \_LOGICAL (Read)
      }{
         If \texttt{TRUE}, the output hardcopy is a negative version of what is
         stored in the image display.  On some output devices a
         constant dark background can give a non-uniform result, and
         so a negative representation is the default. \texttt{[TRUE]}
      }
      \sstsubsection{
         ODEVICE = DEVICE (Read)
      }{
         Name of the output device.  The suggested default is the
         graphics device last used in SNAPSHOT, and if there is not one,
         the suggested default is the global current graphics device.
         The device must be in the GNS category MATRIX\_PRINTER, and
         have at least 24 greyscale intensities.
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         Name given to the output NDF data structure used to store the
         contents of the image-display memory.  If it is null (\texttt{!}) no
         NDF will be created. \texttt{[!]}
      }
      \sstsubsection{
         PLANES = \_INTEGER (Read)
      }{
         The numbers of the image memory planes not be output.  All
         unspecified planes become visible.  If PLANES is null (\texttt{!}), all
         memory planes will be used to form the snapshot.  The base
         memory is 0 and overlays are numbered consecutively from 1.
         The value must be between 0 and the number of image memories
         minus 1.  For an Ikon the only overlay plane is 1.  \texttt{[!]}
      }
      \sstsubsection{
         SCALE = \_REAL (Read)
      }{
         Scale factor for output.  Unity gives the largest possible
         output, but it takes longest to compute and print (goes as the
         square of the scale factor).  On the other hand unity does
         provide maximum resolution. SCALE must be between 0 and 1.
         \texttt{[0.707]}
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Title of the plot and the output NDF.  There is only space on
         the plot for about 25 characters in the title.  If it is null
         (\texttt{!}) no title will be plotted, and the title in the output NDF
         becomes \texttt{"KAPPA - Snapshot"}. \texttt{[!]}
      }
      \sstsubsection{
         WHOLE = \_LOGICAL (Read)
      }{
         If \texttt{TRUE}, the whole image-display memory is recorded, otherwise
         a selected region of what is visible on the screen is plotted.
         Dumping the whole memory can require considerable disc space
         for work arrays and the output NDF. \texttt{[FALSE]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         snapshot whole odevice=canon\_l
      }{
         This will dump the whole of the current image display's
         memories to the canon\_l device.  The plot will occupy half
         of the maximum area available on the device, {\it i.e.}
         $\surd2/2$ magnification.
      }
      \sstexamplesubsection{
         snapshot scale=1.0 $\backslash$
      }{
         This will capture a the whole or part of what is visible on
         the screen of the current image display and dump it to the
         current snapshot device at the largest magnification.
      }
      \sstexamplesubsection{
         snapshot postscript views device=xw whole
      }{
         This dumps the whole of the xw device's memories to the postscript
         device, and also to a NDF called views.  The area magnification
         is a half.
      }
      \sstexamplesubsection{
         snapshot ps\_l device=ikon whole planes=0 title="Hardcopy Base"
      }{
         This dumps the whole of the Ikon's base memory to the ps\_l
         device.  The plot is entitled \texttt{"Hardcopy Base"}.  The entire
         output plot occupies half of the maximum area available on the
         device.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The whole of the screen and the whole of the memory may be
         different, for example, the image may have been zoomed or panned.

         \sstitem
         Files are not spooled to laserprinters.  They must be printed
         outside this application.
      }
   }
   \sstdiytopic{
       Related Applications
   }{
       KAPPA: DISPLAY.
   }
   \sstimplementationstatus{
      No origin information is passed to the output NDF.
   }
}

\sstroutine{
   TRANINVERT
}{
   Inverts a transformation
}{
   \sstdescription{
      This inverts a transformation stored in the TRANSFORM (SUN/61)
      format within an existing HDS file.
   }
   \sstusage{
      traninvert transform
   }
   \sstparameters{
      \sstsubsection{
         TRANSFORM = TRN (Read and Write)
      }{
         The transformation structure to be inverted.  This may be an
         HDS container file, in which case the transformation structure
         is assumed to be called TRANSFORM at the top level of the
         file; or a path to the HDS object.  The suggested default is
         the current transformation structure.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         traninvert shear.transform
      }{
         This inverts the transformation structure stored in object
         TRANSFORM within the HDS file called shear.
      }
      \sstexamplesubsection{
         traninvert shear
      }{
         This does the same as above.
      }
      \sstexamplesubsection{
         traninvert $\backslash$
      }{
         This inverts the current transformation structure.
      }
      \sstexamplesubsection{
         traninvert m51.more.polar
      }{
         This inverts the transformation structure called POLAR in
         the extension of the NDF called m51.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         On completion, the destination structure for the
         transformation information equates to the current transformation
         global parameter.
      }
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPRH: TRANSFORMER, TRANJOIN, TRANMAKE, TRANTRACE;
      CCDPACK: \linebreak CCDEDIT, TRANLIST, TRANNDF.
   }
}

\sstroutine{
   TRANJOIN
}{
   Joins two transformations
}{
   \sstdescription{
      This joins two transformations stored in the TRANSFORM (SUN/61)
      format.  The concatenated transformation can be stored with either
      original transformation or be placed in a new file.
   }
   \sstusage{
      tranjoin in1 in2 out dest=?
   }
   \sstparameters{
      \sstsubsection{
         DEST = LITERAL (Read)
      }{
         The destination for the concatenated transformations.  This can
         be one of the following:
         \begin{description}
         \item \texttt{"First"} --- Appends the second transformation in the first.
                        The second transformation is unchanged.
         \item \texttt{"Second"} --- Prefixes the first transformation in the second.
                        The first transformation is unchanged.
         \item \texttt{"New"}  --- Creates a new transformation structure using
                        parameter OUT.  The input transformations are
                        unchanged.
         \end{description}
         \texttt{["New"]}
      }
      \sstsubsection{
         IN1 = TRN (Read and Write)
      }{
         The first transformation structure to be concatenated.  It
         prefixes the second supplied transformation.  This may be an
         HDS container file, in which case the transformation structure
         is assumed to be called TRANSFORM at the top level of the
         file; or a path to the HDS object.  The suggested default is
         the current value.
      }
      \sstsubsection{
         IN2 = TRN (Read and Write)
      }{
         The second transformation structure to be concatenated.  It
         appends to the first supplied transformation.  This may be an
         HDS container file, in which case the transformation structure
         is assumed to be called TRANSFORM at the top level of the
         file; or a path to the HDS object.  The suggested default is
         the current value.
      }
      \sstsubsection{
         OUT = TRN (Write)
      }{
         The path to the new transformation structure created when
         DEST=\texttt{"NEW"} to hold the concatenated transformations.  If only
         an HDS container filename is supplied, the transformation is
         placed within a structure called TRANSFORM at the top-level of
         the file.  So for instance, if OUT=\texttt{warp9}, the transformation
         will be placed in the top-level structure TRANSFORM within the HDS
         file \texttt{warp9.sdf}.  In this case the container file may already
         exist.  If, on the other hand, an explicit structure is named,
         the transformation information will be placed there.  For
         example, to place the transformation in the extension GALPHOT
         of the NDF called NGC253, OUT would be
         \texttt{NGC253.MORE.GALPHOT}.  The structure name is limited to 15
         printing characters.  Note that the structure must not already
         exist.  If it does, an error condition results.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         tranjoin tr1 tr2 tr3
      }{
         This prefixes the transformation in the HDS file called
         \texttt{tr1.sdf} to that in file \texttt{tr2.sdf}, and stores the
         result in HDS file \texttt{tr3.sdf}.  All three transformations
         are located within objects called TRANSFORM at the top-level.
      }
      \sstexamplesubsection{
         tranjoin offset shear.tr1 shape.rotate
      }{
         This prefixes the transformation in the structure TRANSFORM at
         the top level of the HDS container file called \texttt{offset.sdf}
         ({\it i.e.} OFFSET.TRANSFORM) to the transformation in the structure
         TR1 in the HDS file \texttt{shear.sdf}.  The resulting transformation is in
         the file called \texttt{shape.sdf} and is named ROTATE.
      }
      \sstexamplesubsection{
         tranjoin norm.scale1 polar dest=S
      }{
         This prefixes the transformation structure NORM.SCALE1 to \linebreak
         POLAR.TRANSFORM, the concatenation being stored in
         POLAR.TRANSFORM.
      }
      \sstexamplesubsection{
         tranjoin norm.scale1 polar dest=f
      }{
         This appends the transformation structure POLAR.TRANSFORM to \linebreak
         NORM.SCALE1, the concatenation being stored in NORM.SCALE1.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The number of output variables of the first transformation must
         equal the number of input variables of the second.  Also it is not
         permitted to concatenate a transformation in which only the
         forward mapping is defined with another in which only the inverse
         mapping is specified.

         \sstitem
         On completion, the destination structure for the
         transformation information equates to the current transformation
         global parameter.
      }
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPRH: TRANSFORMER, TRANINVERT, TRANMAKE, TRANTRACE;
      CCDPACK: CCDEDIT, TRANLIST, TRANNDF.
   }
}

\sstroutine{
   TRANMAKE
}{
   Makes a transformation structure given its co-ordinate mappings
}{
   \sstdescription{
      This application creates a transformation data structure from
      forward and inverse mappings that you supply.  The
      TRANSFORMER application uses such a structure to transform an NDF
      by resampling.  The structure can have classification qualifiers
      and a comment.

      For convenience, TRANMAKE can create a two-dimensional linear
      transformation merely from the six coefficients, or
      two-dimensional Cartesian-to-polar transformation given the
      origin position and angle.
   }
   \sstusage{
      tranmake transform trtype comment
        \newline\hspace*{1.5em}
        $\left\{ {\begin{tabular}{l}
                  nvin=? nvout=? class=? for1-for7=? inv1-inv7=? fa-fz=? pa-pz=? \\
                  tr \\
                  \end{tabular} }
        \right.$
        \newline\hspace*{1.9em}
        \makebox[0mm][c]{\small trtype}
   }
   \sstparameters{
      \sstsubsection{
         CLASS( ) = LITERAL (Read)
      }{
         A list of classifications that describe the properties of the
         transformation.  This is optional, but the information can be
         used to make other applications run more efficiently.  This
         applies particularly to linear or constant determinants.
         Valid values are:
         \begin{description}
         \item \texttt{"Linear"}       --- linear and preserves straight lines,
         \item \texttt{"Independent"}  --- preserves the independence of the axes,
         \item \texttt{"Diagonal"}     --- preserves the axes themselves,
         \item \texttt{"Isotropic"}    --- preserves angles and shapes,
         \item \texttt{"Positive\_det"} --- a component of reflection is absent,
         \item \texttt{"Negative\_det"} --- a component of reflection is present,
         \item \texttt{"Constant\_det"} --- the scale factor is constant,
         \item \texttt{"Unit\_det"}     --- areas (or volumes {\it etc.}) are preserved.
         \end{description}

         See SUN/61 Appendix~B for more details of transformation
         classification and a table of the classifications of common
         mappings.  The suggested default is null (\texttt{!}) meaning unknown,
         and no classification is written to the transformation
         structure.  This parameter is ignored unless TRTYPE=\texttt{"Expres"}.
      }
      \sstsubsection{
         COMMENT = LITERAL (Read)
      }{
         The comment string associated with the transformation.
         A null value (\texttt{!}) causes a blank comment to be written into
         the transformation.  Use the \texttt{"--$>$"} symbol to indicate the
         forward transformation.  The suggested default is the null value.
      }
      \sstsubsection{
         FA-FZ = LITERAL (Read)
      }{
         These parameters supply the values of `sub-expressions' used
         in the expressions FOR1-FOR7, and INV1-INV7.  Any of the 26
         may appear; there is no restriction on order.  These
         parameters should be used when repeated expressions are
         present in complex transformations.  Sub-expressions may
         contain references to other sub-expressions and constants
         (PA-PZ).  An example of using sub-expressions is:
         \begin{description}
         \item FOR1 $>$ \texttt{"XX=PA$*$ASIND(FA/PA)$*$X/FA"}
         \item FOR2 $>$ \texttt{"YY=PA$*$ASIND(FA/PA)$*$Y/FA"}
         \item INV1 $>$ \texttt{"X=PA$*$SIND(FB/PA)$*$XX/FB"}
         \item INV2 $>$ \texttt{"Y=PA$*$SIND(FB/PA)$*$YY/FB"}
         \item FA $>$ \texttt{SQRT(X$*$X$+$Y$*$Y)}
         \item PA $>$ \texttt{100D0}
         \item FB $>$ \texttt{SQRT(XX$*$XX$+$YY$*$YY)}
         \end{description}
         where the parameter name is to the left of $>$ and its value is
         to the right of the $>$.  This parameter is ignored unless
         TRTYPE=\texttt{"Expres"}.
      }
      \sstsubsection{
         FITTYPE = \_INTEGER (Read)
      }{
         The type of fit specified by coefficients supplied via the
         TR parameter.  Appropriate values are:
         \begin{description}
         \item 1 -- shift of origin,
         \item 2 -- shift of origin and rotation,
         \item 3 -- shift of origin and magnification,
         \item 4 -- shift of origin, rotation, and magnification
                   (solid body), and
         \item 5 -- a full six-parameter fit.
         \end{description}

         The value of this parameter is used to classify the
         transformation (see the CLASS parameter).  This parameter is
         ignored unless TRTYPE=\texttt{"Bilinear"}.  \texttt{[5]}
      }
      \sstsubsection{
         FOR1-FOR7 = LITERAL (Read)
      }{
         The NVIN expressions that define the forward mapping or
         mappings of the transformation.  FOR1 applies to first
         output variable, and so on through to FOR7 for the seventh
         input variable.  The expressions are written in Fortran-like
         syntax.  The arithmetic operators (\texttt{$+$,$-$,/,$*$,$*$$*$})
         follow the normal order of precedence.  Using matching (nested)
         parentheses will explicitly define the order of expression
         evaluation.  The expression may contain constants and the
         built-in functions (LOG10, SQRT, SIN, TAND {\it etc.}) described in
         SUN/61 Appendix~A.

         For a null forward transformation there must still be NVOUT
         expressions, each just containing the name of the output
         variable, for example, \texttt{"X"}.  An example expression is
         \texttt{"Z=PA$*$(NINT(ZP)$+$0.5)"}.

         This parameter is ignored unless TRTYPE=\texttt{"Expres"}.
      }
      \sstsubsection{
         INV1-INV7 = LITERAL (Read)
      }{
         The NVOUT expressions that define the inverse mapping or
         mappings of the transformation.  INV1 applies to first
         input variable, and so on through to INV7 for the seventh
         input variable.  The expressions are written in Fortran-like
         syntax.  The arithmetic operators (\texttt{$+$,$-$,/,$*$,$*$$*$})
         follow the normal order of precedence.  Using matching (nested)
         parentheses will explicitly define the order of expression
         evaluation.  The expression may contain constants and the
         built-in functions (LOG10, SQRT, SIN, TAND {\it etc.}) described in
         SUN/61 Appendix~A.

         For a null inverse mapping there must still be NVIN
         expressions, each just containing the name of the input
         variable, for example, \texttt{"XX"}.  Generally, it is the
         inverse mapping that is required. An example expression is
         \texttt{"X=MOD(10$*$SQRT((XX$+$YY)$*$ZZ),360)"}.

         This parameter is ignored unless TRTYPE=\texttt{"Expres"}.
      }
      \sstsubsection{
         NVIN = \_INTEGER (Read)
      }{
         The number of input variables in the transformation.  It must
         lie in the range 1 to 7.  The suggested default is the current
         value, and 2 initially.   This parameter is ignored unless
         TRTYPE=\texttt{"Expres"}.
      }
      \sstsubsection{
         NVOUT = \_INTEGER (Read)
      }{
         The number of output variables in the transformation.  It must
         lie in the range 1 to 7.  The suggested default is the number
         of input variables.   This parameter is ignored unless
         TRTYPE=\texttt{"Expres"}.
      }
      \sstsubsection{
         PA-PZ = \_DOUBLE (Read)
      }{
         These parameters supply the values of constants used in the
         expressions FOR1-FOR7, and INV1-INV7.  Any of the 26 may
         appear; there is no restriction on order.  Using parameters
         allows the substitution of repeated constants using one
         reference.  This is especially convenient for constants with
         many significant digits.  It also allows easy modification of
         parameterised expressions (expressions say with an adjustable
         centre) provided the application has not been used in the
         interim.  The parameter PI has a default value of
         3.14159265359D0.  An example of using parameters is:
         \begin{description}
         \item FOR1 $>$ \texttt{"XX=SQRT(FX$*$FX$+$FY$*$FY)"}
         \item FOR2 $>$ \texttt{"YY=ATAN2D(-FY,FX)"}
         \item INV1 $>$ \texttt{"X=XX$*$SIND(YY)$+$PA"}
         \item INV2 $>$ \texttt{"Y=-YY$*$COSD(XX)$+$PB"}
         \item FX $>$ \texttt{X-PA}
         \item FY $>$ \texttt{Y-PB}
         \item PA $>$ X-centre-value
         \item PB $>$ Y-centre-value
         \end{description}
         where the parameter name is to the left of $>$ and its value is
         to the right of the $>$.  This example maps Cartesian
         co-ordinates ($x$,$y$) to polar ($r$,$\theta$) about a specified
         centre.
         This parameter is ignored unless TRTYPE=\texttt{"Expres"}.
      }
      \sstsubsection{
         PREC = LITERAL (Read)
      }{
         The arithmetic precision with which the transformation
         functions will be evaluated when used.  This may be either
         \texttt{"\_REAL"} for single precision, \texttt{"\_DOUBLE"} for
         double precision, or \texttt{"\_INTEGER"} for integer precision.
         Elastic precisions are used, such that a higher precision will
         be used if the input
         data warrant it.  So for example if PREC = \texttt{"\_REAL"}, but
         double-precision data were to be transformed, double-precision
         arithmetic would actually be used.  This parameter is
         ignored unless TRTYPE=\texttt{"Expres"}.  \texttt{["\_REAL"]}
      }
      \sstsubsection{
         TR( 6 ) = \_DOUBLE (Read)
      }{
         If TRTYPE=\texttt{"Bilinear"} is chosen then the values of this
         parameter are the 6 coefficients of a linear transformation of
         the type.
         \begin{description}
         \item X$^\prime$ = TR(1) $+$ TR(2)$*$X $+$ TR(3)$*$Y
         \item Y$^\prime$ = TR(4) $+$ TR(5)$*$X $+$ TR(6)$*$Y
         \end{description}
         The initial suggested default is the identity transformation.
         (\texttt{[0,1,0,0,0,1]}).

         If TRTYPE=\texttt{"Polar"}, only three values are needed.  TR(1) and
         TR(2) are the $x$-$y$ co-ordinates of the origin of the centre of
         the polar co-ordinate system.  An optional third value is
         the angular origin measured in degrees starting from the
         $x$-axis in an anticlockwise direction.  If this is omitted, it
         defaults to 0.  The initial suggested default is \texttt{[0,0,0]}.

         This parameter is ignored unless TRTYPE=\texttt{"Bilinear"} or
         \texttt{"Polar"}.
      }
      \sstsubsection{
         TRANSFORM = TRN (Write)
      }{
         The actual or implied HDS object to store the created
         transformation.  It may be an HDS container file, in which
         case the transformation structure is placed within a structure
         called TRANSFORM at the top level of the file; or a path to
         the HDS object.  So for instance, if parameter
         TRANSFORM=\texttt{warp9}, the transformation will be placed in
         the top-level structure TRANSFORM within the HDS file
         \texttt{warp9.sdf}.  In this case the container file may already
         exist.  If, on the other hand, the explicit structure is
         named, the transformation information will be placed there.
         For example, to place the transformation in the extension
         GALPHOT of the NDF called NGC253, parameter TRANSFORM would be
         \texttt{NGC253.MORE.GALPHOT}.  The structure name is limited to 15
         printing characters.  Note that in either case the structure
         must not already exist.  If it does, an error condition
         results.

         This has parameter no suggested default.
      }
      \sstsubsection{
         TRTYPE = LITERAL (Read)
      }{
         The type of transform which will be supplied.  Valid values are
         \texttt{"Bilinear"}, \texttt{"Expres"}, and \texttt{"Polar"}.

         \texttt{"Bilinear"} requests that the transform will be generated from
         the six coefficients specified by parameter TR in the
         equations:
         \begin{description}
         \item X$^\prime$ = TR(1) $+$ TR(2)$*$X $+$ TR(3)$*$Y
         \item Y$^\prime$ = TR(4) $+$ TR(5)$*$X $+$ TR(6)$*$Y
         \end{description}
         that define a linear two-dimensional transformation.

         \texttt{"Expres"} lets an arbitrary transformation be specified
         using algebraic-like statements of the type:
         \begin{description}
         \item  FOR1 $>$ \texttt{"XX=PA$+$PC$*$X"}
         \item  FOR2 $>$ \texttt{"YY=PD$+$PE$*$Y"}
         \item  INV1 $>$ \texttt{"X=(XX-PA)/PC"}
         \item  INV2 $>$ \texttt{"Y=(YY-PD)/PE"}
         \end{description}
         where the parameter name is to the left of $>$ and its value is
         to the right of the $>$.  The PA-PZs are reserved for constants
         (FA-FZ are also reserved for repeated expressions).  This
         example allows independent offsets and scales in $x$ and $y$.  The
         inverse mapping must be supplied.

         \texttt{"Polar"} makes a 2-dimensional Cartesian-to-polar
         transformation, where the origin in Cartesian co-ordinates, and
         polar angle are specified by parameter TR.

         \texttt{["Expres"]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         tranmake xyz nvin=1 nvout=1 for1="xd=1.01$*$x-0.34"
         inv1="x=(xd$+$0.34)/1.01" $\backslash$
      }{
          This creates a transformation structure TRANSFORM in the HDS
          file called \texttt{xyz.sdf}.  It specifies mappings between one input and
          one output variable.  The output variable is 1.01 the output
          variable less 0.34.
      }
      \sstexamplesubsection{
         tranmake xyz nvin=1 nvout=1 for1="xd=1.01$*$x-0.34" class=linear
         inv1="x=(xd$+$0.34)/1.01" comment="Copier correction"
      }{
          As above, except that because the transformation is linear
          (it is a magnification and translation), the classification is
          set to \texttt{"Linear"}.  \texttt{"Copier correction"} is written
          as the comment in the structure.
      }
      \sstexamplesubsection{
         tranmake transform=turn.more.rot45 nvin=2 nvout=2
         class=["linear","isotropic","unit\_det"] pa=45
         for1="xo=cosd(pa)$*$xi-sind(pa)$*$yi"
         for2="yo=sind(pa)$*$xi$+$cosd(pa)$*$yi"
         inv1="xi=cosd(pa)$*$xo$+$sind(pa)$*$yo"
         inv2="yi=-sind(pa)$*$xo$+$cosd(pa)$*$yo"
      }{
          This creates a transformation structure TURN.MORE.ROT45
          (in HDS file \texttt{turn.sdf}) that rotates
          a two-dimensional co-ordinate system by 45\dgs\ clockwise.
          Three classes---linear, isotropic, unit determinant---are
          assigned for this transformation.  (As it is
          a rotation, positive and constant determinants are also
          applicable.)
      }
      \sstexamplesubsection{
         tranmake shiftim trtype=lin tr=[8.73,1,0,-64.6,0,1] fittype=1 $\backslash$
      }{
         This creates an HDS file called \texttt{raw\_origin.sdf} containing a
         transformation structure called TRANSFORM at the top-level.
         This transformation defines a shift of 8.73 of the first
         variable (usually $x$ in an image) and a negative shift of 64.6
         in the second variable (normally $y$).  The shift is specified
         using the appropriate linear-transformation coefficients
         [XSHIFT,1,0,YSHIFT,0,1] and is correctly classified as a
         fit type of 1.  There is no comment.
      }
      \sstexamplesubsection{
         tranmake my\_ndf.more.my\_extension.tran1 bilinear "15-deg rotation"
         [0,0.965926,-0.258819,0,0.258819,0.965926] fittype=2
      }{
         This creates a transformation structure called TRAN1
         in the extension MY\_EXTENSION of the NDF called my\_ndf.  The
         structure defines a rotation by 15\dgs\ in about the (0,~0)
         position in a plane (say $x$-$y$ of an image).  The rotation
         is specified using the appropriate linear transformation
         coefficients [0,COS,$-$SIN,0,SIN,COS].  The comment stored in the
         structure is \texttt{"15-deg rotation"}.
      }
      \sstexamplesubsection{
         tranmake polish.origin1 trtype=p tr=[100.0,21.3] $\backslash$
      }{
         This creates an HDS file called \texttt{polish.sdf} containing a
         transformation structure called ORIGIN1 at the top-level.
         This structure defines a Cartesian-to-polar transformation
         about an origin at (100.3,~21.3) in pixel co-ordinates.
         There is no comment stored in ORIGIN1.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine does not check that the forward and inverse
         expressions actually define a pair of complementary mappings.

         \sstitem
         On completion, the destination structure for the
         transformation information equates to the current transformation
         global parameter.

         \sstitem
         Expressions supplied for parameters FOR1-FOR7 and INV1-INV7
         should be enclosed in double quotes (even when given in response
         to a prompt) to protect the equals sign from interpretation by
         the shell or parameter system.

      }
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPRH: FLIP, ROTATE, SLIDE, TRANINVERT, TRANJOIN, TRANSFORMER, \linebreak
      TRANTRACE; CCDPACK: CCDEDIT, TRANLIST, TRANNDF.
   }
}

\sstroutine{
   TRANSFORMER
}{
   Applies a transformation to an NDF
}{
   \sstdescription{
      This application performs an arbitrary transformation on an NDF to
      create an output NDF.  There is full control of the shape, origin,
      and co-ordinate limits of the output NDF.  The output NDF is
      calculated by resampling within the input NDF.  Output array
      elements are set to the bad value if their inverse-transformed
      co-ordinates lie outside the input NDF\texttt{'}s co-ordinate limits.
   }
   \sstusage{
      transformer in transform out [method] [shape]
        \newline\hspace*{1.5em}
        $\left\{ {\begin{tabular}{l}
                  lcoord=? ucoord=? \\
                  lbound=? ubound=? \\
                  \end{tabular} }
        \right.$
        \newline\hspace*{1.9em}
        \makebox[0mm][c]{\small shape}
   }
   \sstparameters{
      \sstsubsection{
         CONSERVE = \_LOGICAL (Read)
      }{
         If CONSERVE is TRUE, the output values are normalised by the
         ratio of the output-to-input pixel areas.  In other words this
         conserves flux.  If CONSERVE is FALSE, there is no
         normalisation.  \texttt{[FALSE]}
      }
      \sstsubsection{
         COSYS = LITERAL (Read)
      }{
         The co-ordinate system to be used.  This can be either \texttt{"}World\texttt{"}
         or \texttt{"}Data\texttt{"}.  \texttt{"}World\texttt{"} inputs pixel co-ordinates to the supplied
         transformation to derive the co-ordinates in the output NDF.
         \texttt{"}Data\texttt{"} causes the NDF\texttt{'}s axis information to be the input
         co-ordinates to the transformation.  See the SHAPE parameter.
         \texttt{[Current co-ordinate system]}
      }
      \sstsubsection{
         FULL = \_LOGICAL (Read)
      }{
         When the number of input variables is less than the number
         of dimensions of input NDF (but not less than the number of
         output variables), FULL set to TRUE applies the transformation
         to all the higher dimensions.  For example, FULL = TRUE
         would apply a 2-dimensional transformation to all the planes
         along the third dimension of a cube NDF.  FULL = FALSE would
         only transformed the first plane.  \texttt{[FALSE]}
      }
      \sstsubsection{
         IN = NDF (Read)
      }{
         The NDF to be transformed.
      }
      \sstsubsection{
         LBOUND() = \_INTEGER (Read)
      }{
         The lower pixel-index bounds of the output NDF.  The number of
         values should equal the number of output variables in the
         transformation.  This parameter is only used when SHAPE is
         \texttt{"}Full\texttt{"} or \texttt{"}Bounds\texttt{"}.  The suggested defaults are the lower
         bounds of the input NDF, and where there are more output than
         input dimensions they are set to 1.
      }
      \sstsubsection{
         LCOORD() = \_DOUBLE (Read)
      }{
         The lower co-ordinate limits of the output NDF.  The number of
         values should equal the number of output variables in the
         transformation.  This parameter is only used when SHAPE is
         \texttt{"}Full\texttt{"} or \texttt{"}Limits\texttt{"}.  The suggested defaults are the lower
         co-ordinate limits determined from applying the transformation
         to a series of test points.  Where there are more output than
         input dimensions they are set to 0.0.
      }
      \sstsubsection{
         METHOD = LITERAL (Read)
      }{
         The interpolation method used to resample the input array.
         Permitted values are \texttt{"}Nearest\texttt{"} for nearest-neighbour, and
         \texttt{"}Linint\texttt{"} for linear interpolation.  \texttt{[\texttt{"}Nearest\texttt{"}]}
      }
      \sstsubsection{
         OUT = NDF (Write)
      }{
         The transformed NDF.
      }
      \sstsubsection{
         SHAPE = LITERAL (Read)
      }{
         The method by which to define the bounds and co-ordinate limits
         of the output NDF.  See Section \texttt{"}Co-ordinate Limits and
         Bounds\texttt{"}.  The options for SHAPE are:

         \sstitemlist{

            \sstitem
            \texttt{"}Bounds\texttt{"} -- Specify the output bounds with LBOUND and UBOUND.
                           Use the default co-ordinate limits derived from
                           the transformation of test points in the input
                           NDF.

            \sstitem
            \texttt{"}Full\texttt{"}   -- Specify the output co-ordinate limits and bounds
                           with LCOORD, UCOORD, LBOUND and UBOUND.

            \sstitem
            \texttt{"}Limits\texttt{"} -- Use the bounds of the input NDF and specify the
                           output co-ordinate limits with LCOORD and UCOORD.

            \sstitem
            \texttt{"}Match\texttt{"}  -- Use the co-ordinate limits from transformed test
                           points of the input NDF, and make a co-ordinate
                           unit equivalent to one pixel.  The bounds are the
                           integer-rounded co-ordinate limits.  This option
                           results in an output NDF that is not clipped and
                           unlike the other options guarantees no further
                           linear compression or expansion.

            \sstitem
            \texttt{"}Same\texttt{"}   -- Use the bounds of the input NDF and take the
                           co-ordinate limits from transformed test points
                           of the input NDF.

         }
         The first three also cause the co-ordinate limits to be
         reported before obtaining the limits and/or bounds.

         Not all of these are permitted simultaneously.  \texttt{"}Same\texttt{"} is not
         allowed when the number of input and output transformation
         variables are not equal.  Otherwise it is the value of
         COSYS that controls the options.  When COSYS = \texttt{"}Data\texttt{"} all but
         \texttt{"}Match\texttt{"} are allowed, and COSYS = \texttt{"}World\texttt{"} excludes \texttt{"}Limits\texttt{"} and
         \texttt{"}Full\texttt{"}.  There is a special case where SHAPE is fixed to be
         \texttt{"}Bounds\texttt{"}.  This is when the number of output variables exceeds
         the number of input variables, and that in turn equals the
         number of dimensions in the input NDF.

         If a null (!) value is supplied, a default value is used. When
         COSYS = \texttt{"}Data\texttt{"} this is \texttt{"}Bounds\texttt{"}, and when COSYS = \texttt{"}World\texttt{"} the
         default is \texttt{"}Match\texttt{"}.  \texttt{[!]}
      }
      \sstsubsection{
         TITLE = LITERAL (Read)
      }{
         Title for the output NDF structure.  A null value (!)
         propagates the title from the input NDF to the output NDF. \texttt{[!]}
      }
      \sstsubsection{
         TRANSFORM = TRN (Read)
      }{
         The transformation to be applied.  This may be an HDS
         container file, in which case the transformation structure is
         assumed to be called TRANSFORM at the top level of the file;
         or a path to the HDS object.  For example, a value of
         distort.mapping would use the transformation structure called
         MAPPING in the HDS file distort.sdf; and a value of aitoff
         would make the routine look for the transformation in top-level
         object TRANSFORM within the HDS file aifoff.sdf.  Normally the
         object name is TRANSFORM.  The structure must contain both the
         forward and inverse mappings.

         Structures can be made using CCDEDIT in CCDPACK or TRANMAKE.
      }
      \sstsubsection{
         UBOUND() = \_INTEGER (Read)
      }{
         The upper pixel-index bounds of the output NDF.  The number of
         values should equal the number of output variables in the
         transformation.  This parameter is only used when SHAPE is
         \texttt{"}Full\texttt{"} or \texttt{"}Bounds\texttt{"}.  Each suggested-default value is the
         maximum of the input upper bound and the output lower bound.
      }
      \sstsubsection{
         UCOORD() = \_DOUBLE (Read)
      }{
         The upper co-ordinate limits of the output NDF.  The number of
         values should equal the number of output variables in the
         transformation.  This parameter is only used when SHAPE is
         \texttt{"}Full\texttt{"} or \texttt{"}Limits\texttt{"}.  Each suggested-default value is the
         upper co-ordinate limit determined from applying the
         transformation to a series of test points.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         transformer curved sdist straight
      }{
         This transforms the NDF called curved into an NDF called
         straight.sdf, using the transformation TRANSFORM in the HDS
         file called sdist.sdf.  It uses nearest-neighbour resampling.
         Assuming the current co-ordinate system is world, the
         transformation is performed in pixel co-ordinates, setting the
         bounds to just enclose the transformed input array.
      }
      \sstexamplesubsection{
         transformer curved sdist.transform straight linint same
      }{
         As above, except linear interpolation is used, and the array
         of NDF straight array uses the bounds of NDF curved.
      }
      \sstexamplesubsection{
         transformer a119 proj.merc a119s shape=bounds lbound=[1,-20]
      }{
      }
      \sstexamplesubsection{
         ubound=[256,172]
      }{
         This transforms the NDF called a119, using the transformation
         MERC in the HDS file called proj.sdf, into an NDF called
         a119s.  It uses nearest-neighbour resampling.  a119s just
         encloses the transformed arrays from a119, and has 256 x 192
         pixels from origin (1,-20).
      }
      \sstexamplesubsection{
         transformer spec2d scrunch.trn full method=l out=spec2d\_l
      }{
      }
      \sstexamplesubsection{
         shape=limits lcoord=5000 ucoord=6500
      }{
         This transforms the 2-dimensional NDF called spec2d, using
         the 1-dimensional transformation TRN in the HDS file called
         scrunch.sdf, into an NDF called spec2d\_l.  (NDF spec2d might
         be a set of spectra before scrunching.)  The
         linear-interpolation resampling is applied to all the lines in
         spec2d\_l.  The NDFs have the same pixel-index bounds.
         spec2d\_l is constrained to contain elements whose transformed
         co-ordinates lie between 5000 to 6500.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         In general the test points to calculate the co-ordinate limits
         for LCOORD and UCOORD are situated at the corners of each pixel,
         assuming spaced axes.  Thus for a 2-dimensional array of 9-by-7
         pixels there are 80 (10$*$8) test points.  For linear
         transformations there is a smaller set of test points for
         improved efficiency.  These are the corners of each axis and the
         midpoints between them.

         \sstitem
         On completion, the current transformation global parameter
         takes the value of parameter TRANSFORM.
      }
   }
   \sstdiytopic{
      Co-ordinate Limits and Bounds
   }{
      The limits are the lower co-ordinates of the first element, and
      the upper co-ordinates of the last element of the NDF.  Using
      these limits, TRANSFORMER derives the co-ordinates of the output
      NDF\texttt{'}s pixel centres by linear interpolation.  Therefore, the
      co-ordinate limits define the region of the input NDF that will
      appear in the output.

      The bounds of the output NDF define its shape and origin.  So
      an additional linear scaling transformation can be applied along
      each axis by adjusting the shape independently of the co-ordinate
      limits.
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPRH: FLIP, ROTATE, SLIDE, TRANINVERT, TRANJOIN, TRANMAKE,
      TRANTRACE; CCDPACK: CCDEDIT, TRANLIST, TRANNDF.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Flux conservation can only be applied to constant-determinant
         or linear transformations.

         \sstitem
         The NDF components are processed by this application as
         follows.
            o  LABEL, UNITS, HISTORY, and extensions are propagated.
            o  TITLE is controlled by the TITLE parameter.
            o  QUALITY is not derived from the input NDF for a linearly
            interpolated NDF.  The DATA and VARIANCE arrays are resampled.
            o  Axis centre arrays are created using the co-ordinate
            limits for COSYS = \texttt{"}Data\texttt{"}.

         \sstitem
         Processing of bad pixels and automatic quality masking are
         supported.

         \sstitem
         All non-complex numeric data types can be handled.

         \sstitem
         There can be an arbitrary number of NDF dimensions.
      }
   }
}
\sstroutine{
   TRANTRACE
}{
   Lists the contents of a transformation structure
}{
   \sstdescription{
      This application reports or write to a text file the contents of
      a TRANSFORM structure.  Items listed include:

      \ssthitemlist{

         \sstitem
            the structure's name;

         \sstitem
            the version of the TRANSFORM software used to write the
              structure;

         \sstitem
            the number of input and output variables for the nett
            transformation and for each transformation where the structure
            contains more than one;

         \sstitem
            the classification of the forward and inverse mappings; and

         \sstitem
            for each transformation its precision, comment, forward and
            inverse functions.
      }
   }
   \sstusage{
      trantrace transform [logfile]
   }
   \sstparameters{
      \sstsubsection{
         LOGFILE = FILENAME (Write)
      }{
         The name of the text file to store a list of the
         transformation structure.  If it is null (\texttt{!}) the list of the
         transformation structure is reported directly to you.
         \texttt{[!]}
      }
      \sstsubsection{
         TRANSFORM = TRN (Read)
      }{
         The transformation structure to be listed.  This may be an HDS
         container file, in which case the transformation structure is
         assumed to be called TRANSFORM at the top level of the file;
         or a path to the HDS object.  The suggested default is the
         current transformation structure.
      }
   }
   \sstresparameters{
      \sstsubsection{
         CLASSFOR = LITERAL (Write)
      }{
         A comma-separated list of classifications that describe the
         properties of the forward mapping of the transformation.  The
         possible values in the list are:
         \begin{description}
         \item \texttt{"Linear"}       --- linear and preserves straight lines,
         \item \texttt{"Independent"}  --- preserves the independence of the axes,
         \item \texttt{"Diagonal"}     --- preserves the axes themselves,
         \item \texttt{"Isotropic"}    --- preserves angles and shapes,
         \item \texttt{"Positive\_det"} --- a component of reflection is absent,
         \item \texttt{"Negative\_det"} --- a component of reflection is present,
         \item \texttt{"Constant\_det"} --- the scale factor is constant,
         \item \texttt{"Unit\_det"}     --- areas (or volumes {\it etc.}) are preserved.
         \end{description}

         See SUN/61 Appendix~B for more details of transformation
         classification and a table of the classifications of common
         mappings.
      }
      \sstsubsection{
         CLASSINV = LITERAL (Write)
      }{
         A comma-separated list of classifications that describe the
         properties of the inverse mapping of the transformation.  See
         parameter CLASSFOR for further details.
      }
      \sstsubsection{
         COMMENT = LITERAL (Write)
      }{
         The comment string associated with the transformation.  A
         \texttt{"--$>$"} symbol, if present, indicates the forward
         transformation.
      }
      \sstsubsection{
         FORWARD = LITERAL (Write)
      }{
         The expression that defines the last forward mapping of the
         transformation.
      }
      \sstsubsection{
         INVERSE = LITERAL (Write)
      }{
         The expression that defines the last inverse mapping of the
         transformation.
      }
      \sstsubsection{
         PREC = LITERAL (Write)
      }{
         The arithmetic precision of the transformation.  This may be
         either \texttt{"\_REAL"} for single precision, \texttt{"\_DOUBLE"} for double
         precision, or \texttt{"\_INTEGER"} for integer precision.
      }
      \sstsubsection{
         VERSION = LITERAL (Write)
      }{
         The version number of the TRANSFORM software used to write the
         transformation structure.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         trantrace rot45.transform
      }{
         This reports the contents of the transformation structure within
         the HDS container file \texttt{rot45.sdf}, component TRANSFORM.
      }
      \sstexamplesubsection{
         trantrace rot45
      }{
         This has the same affect as the previous example.
      }
      \sstexamplesubsection{
         trantrace $\backslash$
      }{
         This reports the contents of the current TRANSFORM structure.
      }
      \sstexamplesubsection{
         trantrace jkt256.more.ccdpack.transform trn.lis
      }{
         This lists to the text file \texttt{trn.lis} the contents of the
         transformation structure located within the HDS file
         \texttt{jkt256.sdf}, as component MORE.CCDPACK.TRANSFORM.
      }
      \sstexamplesubsection{
         trantrace stretch.limit nvin=(nvi) comment=(trncom)
      }{
         This reports the contents of the transformation structure within
         the HDS container file \texttt{stretch.sdf}, component LIMIT.  The
         number of input transformation variables is written to the
         {\footnotesize ICL} variable called NVI, and the
         transformation comment is stored in {\footnotesize ICL}
         variable TRNCOM.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Where a value is not optional but is absent, \texttt{"$<$undefined$>$"} appears
         in the listing.

         \sstitem
         TRANTRACE attempts to compile the forward and inverse mappings
         to check that it is a TRANSFORM structure, and will exit with an
         error if both of these compilations fail.

         \sstitem
         On completion, the current transformation global parameter
         takes the value of parameter TRANSFORM.
      }
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPRH: TRANSFORMER, TRANINVERT, TRANJOIN, TRANMAKE;
      CCDPACK: CCDEDIT, TRANLIST, TRANNDF.
   }
}

\sstroutine{
   TURBOCONT
}{
   Contours a 2-d NDF quickly
}{
   \sstdescription{

\vspace{5mm}
\begin{quote}
\begin{center}
\emph{ Note, this application will be withdrawn at the next release of
KAPPA. Use ``CONTOUR'' instead.}
\end{center}
\end{quote}
\vspace{5mm}

      This application draws a contour plot of a 2-dimensional NDF on the
      current graphics device via an efficient algorithm.  The image may be
      part or whole of the data array, but also the variance or quality
      can be shown.  The plot is situated within the current
      graphics-database picture.

      The contour plot resides within optional, annotated and enumerated
      axes.  An optional, but recommended, key may be drawn to the
      right of the contour plot.  It reports the NDF's units if there
      are any, and only contour heights actually plotted are included.
      There are seven methods for selecting contours.
   }
   \sstusage{
      turbocont ndf [comp] mode ncont [key] [device]
        $\left\{ {\begin{tabular}{l}
                    firstcnt=? stepcnt=? \\
                    heights=? \\
                    percentiles=?
                   \end{tabular} }
        \right.$
        \newline\hspace*{23.3em}
        \makebox[0mm][c]{\small mode}
   }
   \sstparameters{
      \sstsubsection{
         ANNOTA = \_LOGICAL (Read)
      }{
         If \texttt{TRUE} the contour lines will be annotated with a contour
         number corresponding to the key entry.  It is ignored and there
         are no annotations when KEY = \texttt{FALSE}.  \texttt{[FALSE]}
      }
      \sstsubsection{
         CLEAR = \_LOGICAL (Read)
      }{
         \texttt{TRUE} if the graphics device is to be cleared before display
         of the array. \texttt{[TRUE]}
      }
      \sstsubsection{
         COMP = LITERAL (Read)
      }{
         The NDF component to be contoured.  It may be \texttt{"Data"},
         \texttt{"Quality"}, \texttt{"Variance"}, or \texttt{"Error"} (where
         \texttt{"Error"} is the alternative to \texttt{"Variance"} and causes
         the square root of the variance values to be taken before
         plotting contours).  If \texttt{"Quality"} is specified, then
         the quality values are treated as numerical values (in the
         range 0 to 255).  \texttt{["Data"]}
      }
      \sstsubsection{
         COSYS = LITERAL (Read)
      }{
         The co-ordinate system to be used.  This can be either \texttt{"World"}
         or \texttt{"Data"}.  \texttt{"World"} makes pixel co-ordinates to appear on axes.
         If COSYS = \texttt{"Data"} the NDF's axis information is used to
         annotate axes.  \texttt{[}Current co-ordinate system\texttt{]}
      }
      \sstsubsection{
         DEVICE = DEVICE (Read)
      }{
         The plotting device. \texttt{[}Current image-display device\texttt{]}
      }
      \sstsubsection{
         FILL = \_LOGICAL (Read)
      }{
         The contour plot normally has square pixels, in other words
         a length along each axis corresponds to the same number of
         pixels.  However, for images with markedly different
         dimensions this default behaviour may not be suitable or give
         the clearest plot.  When FILL is \texttt{TRUE}, the square-pixel
         constraint is relaxed and the contour plot is the largest
         possible within the current picture.  When FILL is \texttt{FALSE}, the
         pixels are square.  The suggested default is the current
         value.  \texttt{[FALSE]}
      }
      \sstsubsection{
         FIRSTCNT = \_REAL (Read)
      }{
         Height of the first contour (Linear and Magnitude modes).
         The suggested value is the current value.
      }
      \sstsubsection{
         HEIGHTS() = \_REAL (Read)
      }{
         Contour levels (Free mode).  The suggested default is the
         current value.
      }
      \sstsubsection{
         KEY = \_LOGICAL (Read)
      }{
         When KEY is \texttt{TRUE}, a key of the contour level versus
         pixel value is to be produced. \texttt{[TRUE]}
      }
      \sstsubsection{
         MAXRES = \_LOGICAL (Read)
      }{
         If \texttt{TRUE} the contours are interpolated to the resolution of the
         plotting device, {\it i.e.}\ provides sub-pixel resolution, otherwise
         straight-line segments at pixel resolution are drawn.  The
         latter does not give smooth contours, but this makes the
         processing much faster.  The former draws smoother contours to
         the resolution of the graphics workstation, but they still
         have vertices.  If you require smooth well-rounded contours try
         the slower CONTOUR. \texttt{[FALSE]}
      }
      \sstsubsection{
         MODE = LITERAL (Read)
      }{
         The method used to select the contour levels.  The options are
         described below.
         \begin{description}
         \item \texttt{"Area"} --- The contours enclose areas of the array for
                         which the equivalent radius increases by equal
                         increments.  You specify the number of levels.
         \item \texttt{"Automatic"} --- The contour levels are equally spaced between the maximum
                        the maximum and minimum pixel values in the
                        array.  You supply the number of contour levels.
         \item \texttt{"Equalised"} --- You define the number of equally spaced
                          percentiles.
         \item \texttt{"Free"} --- You specify a series of contour values
                        explicitly.
         \item \texttt{"Linear"} --- You define the number of contours, the start
                        contour level and linear step between contours.
         \item \texttt{"Magnitude"} --- You define the number of contours, the start
                        contour level and step between contours.  The
                        step size is in magnitudes so the $n^{\rm th}$
                        contour is 10$^{-0.4*(n-1)*{\rm step}}$ times the
                        start contour level.
         \item \texttt{"Percentiles"} --- You specify a series of percentiles.
         \end{description}

         The suggested default is the current value, which is initially
         \texttt{"Free"}.
      }
      \sstsubsection{
         NCONT = \_INTEGER (Read)
      }{
         The number of contours required (all modes except Free and
         Percentiles).  It must be between 1 and 50.  If the number is
         large, the plot may be cluttered and take longer to produce.
         \texttt{6}, the initial suggested default, gives reasonable results.
         The current value becomes the suggested default.
      }
      \sstsubsection{
         NDF = NDF (Read)
      }{
         NDF structure containing the 2-dimensional image to be contoured.
      }
      \sstsubsection{
         PERCENTILES() = \_REAL (Read)
      }{
         Contour levels given as percentiles.  The values must lie
         between 0.0 and 100.0. (Percentiles mode).  The suggested
         default is the current value.
      }
      \sstsubsection{
         PXSIZE = \_REAL (Read)
      }{
         The length ($x$ axis) of the plot in metres.  There is an upper
         limit given by the $x$ size of the current picture.
         \texttt{[}Maximum that can fit in the current picture whilst
         preserving square pixels\texttt{]}
      }
      \sstsubsection{
         PYSIZE = \_REAL (Read)
      }{
         The length ($y$ axis) of the plot in metres.  There is an upper
         limit given by the $y$ size of the current picture.
         \texttt{[}Maximum that can fit in the current picture whilst
         preserving square pixels\texttt{]}
      }
      \sstsubsection{
         RESOLUTION = \_REAL (Read)
      }{
         The resolution factor. The actual plotting resolution is this
         times the $x$ and $y$ theoretical resolutions in world
         co-ordinates.  In GKS, whether or not a given `lamp' is
         illuminated or pen position is marked with ink cannot be
         determined, so a factor of unity is too small for the most
         efficient processing. It must lie between 2.0 and 10.0. \texttt{[2.0]}
      }
      \sstsubsection{
         STEPCNT = \_REAL (Read)
      }{
         Separation between contour levels, linear for Linear mode
         and in magnitudes for Magnitude mode.  The suggested value is
         the current value.
      }
   }
   \sstgraphparameters{
      \sstsubsection{
         ABSLAB  =  LITERAL (Read)
      }{
         Label for the plot abscissa, in which NCAR fancy founts may be
         embedded when FONT = \texttt{"NCAR"}.  If axis information is
         present the suggested default is the NDF's axis label
         followed by the units, in parentheses.  If an error occurs
         obtaining the label the suggested default is \texttt{"X"}. \texttt{[]}
      }
      \sstsubsection{
         AXES = \_LOGICAL (Read)
      }{
         \texttt{TRUE} if labelled and annotated axes are to be drawn around the
         contour plot.  The annotations are either the data
         co-ordinates from the NDF axis components, provided these are
         present and linear and COSYS = \texttt{"Data"}; otherwise pixel
         co-ordinates are used.  \texttt{[TRUE]}
      }
      \sstsubsection{
         BORDER = \_LOGICAL (Read)
      }{
         BORDER is \texttt{TRUE} if a box is to be drawn about the contour
         plot.  This is only accessed when there are no axes required.
         \texttt{[TRUE]}
      }
      \sstsubsection{
         CONCOL = LITERAL (Read)
      }{
        The colour of the contour lines on devices that support colour.
        The options are described below.

         \begin{description}
         \item \texttt{"MAX"}  --- The maximum colour index in the image
                          display colour lookup table.
         \item \texttt{"MIN"}  --- The minimum (non-reserved) colour index in
                          the image-display colour lookup table.
         \item {\bf An integer} --- The actual colour index.  It is
                          constrained between 0 and the maximum colour
                          index available on the device.
         \item {\bf A named colour} --- Uses the named colour from the
                          palette, and if it is not present, the nearest
                          colour from the palette is selected.
         \end{description}

         If the colour is to remain unaltered as the lookup table is
         manipulated choose an integer between 0 and 15, or a named
         colour.  This parameter will be ignored if PENROT = \texttt{TRUE}.
         \texttt{[}The current value, but equals \texttt{1} (the foreground
         colour) if there is no current value.\texttt{]}
      }
      \sstsubsection{
         DASHED = \_REAL (Read)
      }{
         The height below which the contours will be drawn with dashed
         lines.  A null value (\texttt{!}) means all contours are drawn with
         solid lines.  This facility is only available when ANNOTA =
         \texttt{FALSE}. \texttt{[!]}
      }
      \sstsubsection{
         FONT = LITERAL (Read)
      }{
         The fount to be used for the line graphics.  It can be either
         \texttt{"NCAR"} for the NCAR fancy characters and \texttt{"GKS"} for the standard
         GKS san-serif fount.   The former is intended for hardcopy
         publication-quality plots, since it is relatively slow; the
         latter is intended for normal interactive graphics requiring
         rapid plotting, and it is clearer on small plots. The
         suggested default is the current value. \texttt{["GKS"]}
      }
      \sstsubsection{
         LABELFREQ = \_INTEGER (Read)
      }{
         The frequency with which contour levels are annotated.  \texttt{1}
         means every level will be labelled.  This may be excessive in
         plots where the contours are closely packed.  This parameter
         is ignored
         unless contour annotation has been selected.  It must be between
         one and the number of contour heights. \texttt{[1]}
      }
      \sstsubsection{
         MAJTIC( 2 ) = \_REAL (Read)
      }{
         The parameter controlling the numbers of major tick marks
         for the $x$ and $y$ axes.  (Number used is between MAJTIC$+$2 and
         5$*$MAJTIC/2$+$4.) \texttt{[3.,3.]}
      }
      \sstsubsection{
         MINTIC( 2 ) = \_REAL (Read)
      }{
         The number of minor tick marks between each major tick mark
         for the $x$ and $y$ axes.  A negative value forces the graphics
         package to compute appropriate values. \texttt{[-1.,-1.]}
      }
      \sstsubsection{
         NOISY = \_LOGICAL (Read)
      }{
         If \texttt{TRUE} the contour lines will alternately be annotated with
         a contour number corresponding to the key entry, but at
         twice the frequency.  It is ignored unless annotated contours
         have been selected. \texttt{[FALSE]}
      }
      \sstsubsection{
         ORDLAB  =  LITERAL (Read)
      }{
         Label for the plot ordinate, in which NCAR fancy founts may be
         embedded when FONT = \texttt{"NCAR"}.  If axis information is
         present the suggested default is the NDF's axis label followed
         by the units, in parentheses.  If an error occurs obtaining
         the label the suggested default is \texttt{"Y"}. \texttt{[]}
      }
      \sstsubsection{
         OUTTIC = \_LOGICAL (Read)
      }{
         \texttt{TRUE} if the axis tick marks are to appear on the outside of
         the axes instead of inside.  By default, the tick marks are
         drawn outside the contouring region to eliminate
         intersections of ticks with the contours. \texttt{[TRUE]}
      }
      \sstsubsection{
         PENROT = \_LOGICAL (Read)
      }{
         If \texttt{TRUE}, the plotting pens are cycled through the contours to
         aid identification of the contour heights.  It is ignored
         when annotation is selected. \texttt{[FALSE]}
      }
      \sstsubsection{
         PLTITL = LITERAL (Read)
      }{
         The title of the plot.  Up to about 40 characters can be
         accommodated, and NCAR fancy founts may be embedded when
         FONT = \texttt{"NCAR"}.  If an error occurs obtaining the title, it
         is defaulted to \texttt{"Contour plot"}. \texttt{[}The NDF title\texttt{]}
      }
      \sstsubsection{
         THICK = \_REAL (Read)
      }{
         The thickness of the lines and NCAR-fount characters in the plot, where
         \texttt{1.0} is the normal thickness.  Currently, this is only available
         on a few devices.  It must take a value in the range 0.5--10.0.
         \texttt{[1.0]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         turbocont myfile D $\backslash$
      }{
         Contours the data array in the NDF called myfile on the current
         graphics device.  All other settings are defaulted, so for
         example the current method for determining heights is used, and
         a key is plotted.
      }
      \sstexamplesubsection{
         turbocont taurus1(100:199,150:269,4) $\backslash$
      }{
         Contours a 2-dimensional portion of current array component in
         the NDF cube called taurus1 on the current graphics device.
         The portion extends from pixel (100,~150,~4) to pixel
         (199,~269,~4).  All other settings are defaulted, so for example
         coarse contours are drawn, using the current mode for
         determining heights, and a key is plotted.
      }
      \sstexamplesubsection{
         turbocont ndf=ngc6872 mode=au ncont=5 device=ps\_l concol=white
      }{
         Contours the data array in the NDF called ngc6872 on the
         ps\_l graphics device.  Five equally spaced contours between
         the maximum and minimum data values are drawn in white.  The
         NDF's title adorns the plot.  A key is plotted.
      }
      \sstexamplesubsection{
         turbocont ngc6872 mode=au ncont=5 annota labelfreq=2 cosys=w
         device=ps\_l concol=white
      }{
         As above.  In addition the contours are annotated at
         alternate heights.  The axes are annotated with pixel
         co-ordinates.
      }
      \sstexamplesubsection{
         turbocont ngc6872 mode=li firstcnt=10 stepcnt=2 ncont=4 noaxes
      }{
         Contours the data array in the NDF called ngc6872 on the
         current graphics device.  Four contours at heights 10, 12, 14,
         and 16 are drawn.  A key is plotted, but no axes surround the
         contour plot.
      }
      \sstexamplesubsection{
         turbocont ss443 mode=pe percentiles=[80,90,95,98,99,99.9] annota
      }{
         Contours the data array in the NDF called ss443 on the
         current graphics device.  Annotated contours at heights
         corresponding to the 80, 90, 95, 98, 99, and 99.9 percentiles
         are drawn.  A key is plotted.
      }
      \sstexamplesubsection{
         turbocont mode=eq ncont=5 dashed=0 pencol=red ndf=skyflux
      }{
         Contours the data array in the NDF called skyflux on the
         current graphics device.  Contours at heights corresponding to
         the 10, 30, 50, 70 and 90 percentiles are drawn in red.  Those
         contours whose values are negative will appear as dashed
         lines.  A key is plotted.
      }
      \sstexamplesubsection{
         turbocont comp=d nokey penrot $\backslash$
      }{
         Contours the portion of the data array in the current NDF on
         the current graphics device using the current method for height
         selection.  The NDF's title adorns the plot.  No key is drawn.
         The appearance of the contours cycles every third contour.
      }
      \sstexamplesubsection{
         turbocont comp=v mode=fr heights=[10,20,40,80] title=Variance
      }{
         Contours the variance array in the current NDF on the
         current graphics device.  Contours at 10, 20, 40 and 80 are
         drawn.  \texttt{"Variance"} is the title of the plot.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The application stores a number of pictures in the graphics
         database in the following order: a FRAME of the specified size
         containing the title, annotated axes, contours and key; a DATA
         picture which is stored with world co-ordinates in units of data
         pixels; and a KEY picture to store the key if present.  The DATA
         picture also may have double-precision data co-ordinates derived
         from the NDF axis components provided these are linear and
         different from pixel co-ordinates; the data co-ordinates are
         stored via a linear transformation.  The NDF associated with the
         plot is stored by reference with the DATA picture.  On exit the
         current database picture for the chosen device reverts to the
         input picture.

         \sstitem
         There are some options for setting the characteristics of the
         contour lines.  By default, solid lines are drawn with the same
         colour as the axes and key, namely the foreground colour.  The
         colour will depend on the graphics device chosen, but it is often
         black for printers or white for terminals.  The alternatives to
         override this default behaviour are listed below.

         \begin{enumerate}
         \item Set a colour for all contours using parameter CONCOL.
         \item Request dashed contours below some threshold given by
               parameter DASHED and solid lines for other heights.  All
               contours have either the foreground colour or that
               prescribed by parameter CONCOL.
         \item Cycle the pens modulo 3 for each contour height actually
               plotted by setting PENROT = \texttt{TRUE}.  The characteristics of
               the second and third line styles will depend on the chosen
               graphics device.  An image display or pen plotter will draw
               coloured lines using palette entries 1 to 3; whereas a
               window overlay, or monochrome laser printer or terminal
               will draw a variety of dashed or thicker lines.
         \item Combine options 2 and 3.  However, palette colours 1 to 3
               will always be used and CONCOL ignored.  The contours below
               the threshold continue the cycle through the three colours.
               There may be some confusion on devices that already use
               dashed lines, so this is only suitable for devices
               supporting at least three colours simultaneously.
         \item Annotate the contours using the number of the contour height
               corresponding to the key entries rather than the values
               themselves.  (Set parameter ANNOTA = \texttt{TRUE}.)  The frequency
               of labelling may be defined (LABELFREQ).  The key option
               must be chosen (KEY = \texttt{TRUE}) in conjunction with annotated
               contours.  Annotation is not recommended should the data
               array have a large number of bad pixels, or if the contours
               are closely packed.  There is an additional parameter
               (NOISY) to select double annotations for short or noisy
               contours in option 2.
         \end{enumerate}

         Annotation takes precedence over pen rotation, which in turn
         overrides colour control through CONCOL.
      }
   }
   \sstdiytopic{
      Related Applications
   }{
      KAPPA: CONTOUR; Figaro: ICONT, SPECCONT.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Only real data can be processed directly.  Other non-complex
         numeric data types will undergo a type conversion before the
         contour plot is drawn.

         \sstitem
         Bad pixels and automatic quality masking are supported.
      }
   }
}

\newpage
\section{\xlabel{ap_IMAGEformat}IMAGE data format\label{ap:IMAGEformat}}

The IMAGE format as used by some of {\footnotesize KAPRH} is a simple
\HDSref\ structure, comprising a floating-point data array, a character title,
and the maximum and minimum data values.  It is variant of the
original Wright-Giddings IMAGE structure.  There are others is use
that contain more items. An example structure is shown schematically
below using the \HDSTRACEref\latex{ (SUN/102)} notation; see
\latexelsehtml{Appendix~\ref{ap:NDFformat}}{\htmlref{the NDF format}{ap:NDFformat}}.
\begin{verbatim}
   HORSEHEAD  <IMAGE>

      DATA_ARRAY(384,512)  <_REAL>   100.5,102.6,110.1,109.8,105.3,107.6,
                                     ... 123.1,117.3,119,120.5,127.3,108.4
      TITLE          <_CHAR*72>      'KAPPA - Flip'
      DATA_MIN       <_REAL>         28.513
      DATA_MAX       <_REAL>         255.94

   End of Trace.
\end{verbatim}

The DATA\_ARRAY may have up to seven dimensions.
IMAGE structures are associated with parameters like INPIC and OUTPIC.
The TITLE object of new IMAGE structures takes the value of the
parameter OTITLE.  DATA\_MIN and DATA\_MAX are now ignored.

The IMAGE format is not too dissimilar from a \emph{primitive\/} NDF
with no extensions.  Indeed if it did not have DATA\_MAX and DATA\_MIN
it would be a {\it bona fide}\ NDF.  Thus applications that handle the
IMAGE format can follow the rules of \xref{SGP/38}{sgp38}{} and
process it like an NDF.  In effect this means that all extensions are
propagated to output files, and a quality array is propagated where
the processing does not invalidate its values.  IMAGE applications
also handle most \emph{simple\/} NDFs correctly (those where the data
array is an array of numbers at the second level of the hierarchical
structure).  This similarity in formats enables NDF and IMAGE
applications to work in co-operation. Note that the primitive
variant is no longer the norm for NDFs, since for example, it does not
support origin information.

\section{Standard Components in an NDF\label{ap:NDFformat}}
See the \xref{appendix}{sun95}{ap_NDFformat} of the KAPPA manual (SUN/95)
for a description of the Starlink NDF data structure.

\end{document}
