	SUBROUTINE DEVICE_OPEN( BASE_ZONE, STATUS)

* subroutine to open SGS/GKS under specified workstation

* History
*   27-Jul-1994 Changed error reporting to use ERR_, removed VALUE,
*               changed IFIX to INT (SKL@JACH)
*   03-Oct-1994 Added changing of DEVICE_NAME to upper case (CAA@JACH)
*   03-Oct-1994 VMS GQMDS renames GQDSP for UNIX GKS (SKL@JACH)
*

	IMPLICIT NONE

	INCLUDE 'ADAM_DEFNS'
        INCLUDE 'SAE_PAR'
	INCLUDE 'DTDEFNS'
	INCLUDE 'DTERRS'

	INCLUDE 'GKS_PAR'

	INCLUDE 'PLT2DCOM'

	INTEGER ASFNUM
	  PARAMETER ( ASFNUM = 13)
	INTEGER ASF( ASFNUM)
	INTEGER BASE_ZONE
	INTEGER CFONT
	INTEGER CPREC
	INTEGER J
	INTEGER STATUS
	INTEGER ERROR
	INTEGER ERRIND
	INTEGER COLA
	INTEGER NPCI
	INTEGER GPX_XSIZE
	INTEGER GPX_YSIZE

	REAL SCREEN_X
	REAL SCREEN_Y
	REAL XLIMIT
	REAL GPX_XORIG
	REAL YLIMIT
	REAL GPX_YORIG

	CHARACTER*30 UDVCRD

* =============================================================================

* get device type for image display from interface file
	CALL PAR_GET0C( 'DEVICE_NAME', DEVICE_NAME, STATUS)
	IF( STATUS .NE. SAI__OK) THEN
          CALL ERR_REP('ERR',
     :     	    'Error : DEVICE_OPEN : After par_get0c device name',
     :                  STATUS )
          RETURN
	ELSE
	  CALL CHR_UCASE( DEVICE_NAME)
	END IF

* call subroutine to covert standard GKS device name to workstation ID
	CALL DEVICE_CODE( STATUS)
	IF( STATUS .NE. SAI__OK) THEN
          RETURN
	END IF

* if the device is the Vaxstation 8-plane then get the X,Y origin and size
* of workstation window
	IF( DEVICE_NAME .EQ. 'VAXSTATION8') THEN
	  CALL PAR_GET0R( 'GPX_XORIG', GPX_XORIG, STATUS)
	  CALL PAR_GET0R( 'GPX_YORIG', GPX_YORIG, STATUS)
	  CALL PAR_GET0I( 'GPX_XSIZE', GPX_XSIZE, STATUS)
	  CALL PAR_GET0I( 'GPX_YSIZE', GPX_YSIZE, STATUS)
	END IF

* open GKS for plotting on device WKSTN_ID
	CALL SGS_OPEN( WKSTN_ID, BASE_ZONE, STATUS)
	IF( STATUS .NE. SAI__OK) THEN
          CALL ERR_REP('ERR',
     :     	    'Error : DEVICE_OPEN : After SGS_OPEN',
     :                  STATUS )
          RETURN
	END IF

* get workstation extent
	CALL GQDSP( WKSTN_SEQ, ERROR, UDVCRD, SCREEN_X, SCREEN_Y,
     :              MAX_X, MAX_Y)

* subtract one unit from workstation size in both dimensions ????
	MAX_X = MAX_X - 1
	MAX_Y = MAX_Y - 1

* set the aspect source flags to individual all the way ...
	DO J = 1, ASFNUM
	  ASF( J) = GINDIV
	END DO
	CALL GSASF( ASF)

* call subroutine to set the line width for a specific device
	CALL SET_LINEWIDTH( STATUS)

* calculate the window limits
	IF( DEVICE_NAME .EQ. 'T5688') THEN
	  XLIMIT = REAL( MAX_X)/2.0
	  YLIMIT = REAL( MAX_Y)/2.0
	  X_CUR_REAL = XLIMIT/2.0
	  Y_CUR_REAL = YLIMIT/2.0
 	  IM_XST = 0.0
	  IM_YST = 0.0
	  IM_XEN = REAL( MAX_X)
	  IM_YEN = REAL( MAX_Y)
	ELSE
	  XLIMIT = REAL( MAX_X)
	  YLIMIT = REAL( MAX_Y)
	  X_CUR_REAL = XLIMIT/2.0
	  Y_CUR_REAL = YLIMIT/2.0
	  IM_XST = 0.0
	  IM_YST = 0.0
	  IM_XEN = REAL( MAX_X)
	  IM_YEN = REAL( MAX_Y)
	END IF

* set workstation viewport and window
	CALL GSWN( 1, 0.0, XLIMIT, 0.0, YLIMIT)

* set the new max in x and y
	MAX_X = INT( XLIMIT)
	MAX_Y = INT( YLIMIT)

* put maximum sizes into parameter system for user info
	CALL PAR_PUT0I( 'MAX_XSIZE', MAX_X, STATUS)
	CALL PAR_PUT0I( 'MAX_YSIZE', MAX_Y, STATUS)

* initialize some of the common variables
	NX = 64*MAX_Y/MAX_X
	NY = 64

* set GKS defferal and regeneration state
	CALL GSDS (1, GASTI, GALLOW)

* get and set the text font and precision
	CALL PAR_GET0I( 'COMMENT_FONT', CFONT, STATUS)
	CALL PAR_GET0I( 'COMMENT_PREC', CPREC, STATUS)
	CALL GSTXFP( CFONT, CPREC)

* get the color capabilities of the device
	CALL GQCF( WKSTN_SEQ, ERRIND, NCOLI, COLA, NPCI)
!	print *, 'from gqcf-ncoli, npci = ', ncoli, npci
	NCOLI = NPCI

* setup maximum and minimum color indices for image display
	CALL PAR_GET0I( 'NUM_LINECOL', NLINECOL, STATUS)

*      Test if device is QMS or PS and therefore cause max/min colors are
*      wrong from GKS driver (1,1 instead of 31,0???) set'um
	IF( DEVICE_NAME .EQ. 'QMS_LANDSCAPE' .OR.
     :	    DEVICE_NAME .EQ. 'QMS_PORTRAIT' .OR.
     :	    DEVICE_NAME .EQ. 'PS_LANDSCAPE' .OR.
     :	    DEVICE_NAME .EQ. 'PS_PORTRAIT' .OR.
     :	    DEVICE_NAME .EQ. 'EPSP' .OR.
     :	    DEVICE_NAME .EQ. 'EPSL' .OR.
     :	    DEVICE_NAME .EQ. 'CPSP' .OR.
     :	    DEVICE_NAME .EQ. 'CPSL') THEN
	  MAXIMCOL = NCOLI-2
	  MINIMCOL = 0
	ELSE
	  IF( NCOLI .EQ. 2) THEN
	    MAXIMCOL = NCOLI-1
	    MINIMCOL = 0
	  ELSE IF( NCOLI .NE. 2 .AND. NCOLI .LE. 64) THEN
	    MAXIMCOL = NCOLI-2
	    MINIMCOL = 1
	  ELSE
	    MAXIMCOL = NCOLI - NLINECOL
	    MINIMCOL = 1
	  END IF
	END IF
	CALL MSG_BLANK ( STATUS )
	CALL MSG_SETI( 'AVAIL', MAXIMCOL-MINIMCOL+1)
	CALL MSG_OUT('NCELL',
     :          'Maximum number of colour cells available = ^AVAIL',
     :	        STATUS)

* store range of pens used for line graphics in parameter system
	CALL PAR_PUT0I( 'LPENMIN', MAXIMCOL+1, STATUS)
	CALL PAR_PUT0I( 'LPENMAX', NCOLI, STATUS)

* put calculated pen numbers into the parameter system variables
	IF( DEVICE_NAME .NE. 'QMS_LANDSCAPE' .AND.
     :	    DEVICE_NAME .NE. 'QMS_PORTRAIT' .AND.
     :	    DEVICE_NAME .NE. 'PS_LANDSCAPE' .AND.
     :	    DEVICE_NAME .NE. 'PS_PORTRAIT' .AND.
     :	    DEVICE_NAME .NE. 'EPSP' .AND.
     :	    DEVICE_NAME .NE. 'EPSL' .AND.
     :	    DEVICE_NAME .NE. 'CPSP' .AND.
     :	    DEVICE_NAME .NE. 'CPSL') THEN

	  IF( MAXIMCOL .GE. 64) THEN
	    CALL PAR_PUT0I( 'COLBLOCK_PEN', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'CONTOUR_PENANN', MAXIMCOL+2, STATUS)
	    CALL PAR_PUT0I( 'CONTOUR_PENAXE', MAXIMCOL+3, STATUS)
	    CALL PAR_PUT0I( 'CONTOUR_PENNUM', MAXIMCOL+4, STATUS)
	    CALL PAR_PUT0I( 'CONTOUR_PENTIC', MAXIMCOL+5, STATUS)
	    CALL PAR_PUT0I( 'CONTOUR_PENCON', MAXIMCOL+6, STATUS)
	    CALL PAR_PUT0I( 'CONTOUR_PENCON1', MAXIMCOL+6, STATUS)
	    CALL PAR_PUT0I( 'CONTOUR_PENCON2', MAXIMCOL+7, STATUS)
	    CALL PAR_PUT0I( 'CROSS_PEN', MAXIMCOL+7, STATUS)
	    CALL PAR_PUT0I( 'CUT_PEN', MAXIMCOL+8, STATUS)
	    CALL PAR_PUT0I( 'CUT_PENANNOT', MAXIMCOL+9, STATUS)
	    CALL PAR_PUT0I( 'ANNOTATE_PEN', MAXIMCOL+10, STATUS)
	    CALL PAR_PUT0I( 'DEFANN_PEN', MAXIMCOL+11, STATUS)
	    CALL PAR_PUT0I( 'LABEL_PEN', MAXIMCOL+12, STATUS)
	    CALL PAR_PUT0I( 'BORDER_PEN', MAXIMCOL+13, STATUS)
	    CALL PAR_PUT0I( 'BOX_PEN', MAXIMCOL+14, STATUS)
	    CALL PAR_PUT0I( 'CIRCLE_PEN', MAXIMCOL+15, STATUS)
	    CALL PAR_PUT0I( 'ELLIPSE_PEN', MAXIMCOL+15, STATUS)
	    CALL PAR_PUT0I( 'COMMENT_PEN', MAXIMCOL+16, STATUS)
	    CALL PAR_PUT0I( 'LINE_PEN', MAXIMCOL+17, STATUS)
	    CALL PAR_PUT0I( 'GRID_PEN', MAXIMCOL+18, STATUS)
	    CALL PAR_PUT0I( 'POL_PEN1', MAXIMCOL+19, STATUS)
 	    CALL PAR_PUT0I( 'POL_PEN2', MAXIMCOL+20, STATUS)
	    CALL PAR_PUT0I( 'POL_PEN3', MAXIMCOL+21, STATUS)
	    CALL PAR_PUT0I( 'POL_PEN4', MAXIMCOL+22, STATUS)
	    CALL PAR_PUT0I( 'POL_PEN5', MAXIMCOL+23, STATUS)
	    CALL PAR_PUT0I( 'POL_PENANN', MAXIMCOL+24, STATUS)
	    CALL PAR_PUT0I( 'POL_PENAXE', MAXIMCOL+25, STATUS)
	    CALL PAR_PUT0I( 'POL_PENNUM', MAXIMCOL+26, STATUS)
	    CALL PAR_PUT0I( 'POL_PENTIC', MAXIMCOL+27, STATUS)
	    CALL PAR_PUT0I( 'POL_PENVEC', MAXIMCOL+28, STATUS)
	  ELSE
	    CALL PAR_PUT0I( 'COLBLOCK_PEN', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'CONTOUR_PENANN', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'CONTOUR_PENAXE', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'CONTOUR_PENNUM', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'CONTOUR_PENTIC', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'CONTOUR_PENCON', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'CROSS_PEN', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'CUT_PEN', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'CUT_PENANNOT', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'ANNOTATE_PEN', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'DEFANN_PEN', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'LABEL_PEN', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'BORDER_PEN', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'BOX_PEN', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'CIRCLE_PEN', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'ELLIPSE_PEN', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'COMMENT_PEN', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'LINE_PEN', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'GRID_PEN', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'POL_PEN1', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'POL_PEN2', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'POL_PEN3', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'POL_PEN4', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'POL_PEN5', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'POL_PENANN', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'POL_PENAXE', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'POL_PENNUM', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'POL_PENTIC', MAXIMCOL+1, STATUS)
	    CALL PAR_PUT0I( 'POL_PENVEC', MAXIMCOL+1, STATUS)
	  END IF
	ELSE
	  CALL PAR_PUT0I( 'COLBLOCK_PEN', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'CONTOUR_PENANN', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'CONTOUR_PENAXE', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'CONTOUR_PENNUM', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'CONTOUR_PENTIC', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'CONTOUR_PENCON', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'CONTOUR_PENCON1', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'CONTOUR_PENCON2', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'CROSS_PEN', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'CUT_PEN', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'CUT_PENANNOT', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'ANNOTATE_PEN', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'DEFANN_PEN', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'LABEL_PEN', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'BORDER_PEN', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'BOX_PEN', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'CIRCLE_PEN', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'ELLIPSE_PEN', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'COMMENT_PEN', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'LINE_PEN', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'GRID_PEN', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'POL_PEN1', maximcol+1, STATUS)
 	  CALL PAR_PUT0I( 'POL_PEN2', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'POL_PEN3', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'POL_PEN4', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'POL_PEN5', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'POL_PENANN', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'POL_PENAXE', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'POL_PENNUM', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'POL_PENTIC', maximcol+1, STATUS)
	  CALL PAR_PUT0I( 'POL_PENVEC', maximcol+1, STATUS)
	  CALL SET_COLOUR2( MAXIMCOL+1, 'N')
	END IF

	END
