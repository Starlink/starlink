C+
      SUBROUTINE GEN_ASTAT2E (ARRAY,QDATA,NX,NY, IXST,IXEN,IYST,IYEN,
     :           TOTAL,AMAX,AMIN,MEAN,XMAX,XMIN,YMAX,YMIN,SIGMA,SIZE,
     :           QUAL, FLAGS, FBAD)
C
C     G E N _ A S T A T 2 E
C
C     Examines a subset of a 2-dimensional array and returns a number
C     of statistics about the data in it.  This routine is similar to
C     GEN_ASTATE, but it calculates the SIGMA value using 2 passes through
C     the data, and so is slower that GEN_ASTATE but gives a more accurate
C     value for SIGMA. Recognizes and uses quality information, or
C     flagged values on the data.
C
C     Parameters -  (">" input, "<" output)
C
C     (>) ARRAY   (Real array ARRAY(NX,NY)) The input array.
C     (>) QDATA   (Byte array QDATA(NX,NY)) The input Quality data.
C     (>) NX      (Integer) The first (x) dimension of ARRAY.
C     (>) NY      (Integer) The second (y) dimension of ARRAY.
C     (>) IXST    (Integer) The first x-value of the subset.
C     (>) IXEN    (Integer) The last    "     "   "    "
C     (>) IYST    (Integer) The first y-value "   "    "
C     (>) IYEN    (Integer) The last    "     "   "    "
C     (<) TOTAL   (Real) The total data in the subset.
C     (<) AMAX    (Real) The maximum value in the subset.
C     (<) AMIN    (Real) The minimum   "   "   "   "
C     (<) MEAN    (Real) The mean      "   "   "   "
C     (<) XMAX    (Real) ) These four quantities return the positions
C     (<) XMIN    (Real) ) in x and y (ie the values of the array indices)
C     (<) YMAX    (Real) ) at which the maximum and minimum data values
C     (<) YMIN    (Real) ) were found.
C     (<) SIGMA   (Real) The standard deviation of the data in the subset
C     (<) SIZE    (Real) The number of pixels in the subset (this is
C                 not necessarily that implied by IXST,IYST etc, if these
C                 parameters would take the subset outside the array
C                 bounds.  SIZE is the number of pixels actually examined,
C                 or if some of the points are flagged as bad.
C     (>) QUAL    (Logical)    True if input has quality information
C     (>) FLAGS   (Logical)    True if input has flagged data values
C     (>) FBAD    (Real)       Flag value
C
C                                               KS / AA0 19th March 1987
C     Modified:
C
C     17th Nov  1990  PRB / ROE.  Modified from GEN_ASTAT2 to handle
C     quality or flagged values on the data.
C+
      IMPLICIT NONE
C
C     Parameters
C
      INTEGER NX,NY,IXST,IXEN,IYST,IYEN
      REAL TOTAL,AMAX,AMIN,MEAN,XMAX,XMIN,YMAX,YMIN
      REAL SIGMA,SIZE,FBAD
      REAL ARRAY(NX*NY)
      BYTE QDATA (NX*NY)
      LOGICAL QUAL, FLAGS
C
C          (Slightly more efficient than (NX,NY) in terms of code
C           generated by the compiler.)
C
C     Local variables
C
      INTEGER NXST,NYST,NXEN,NYEN,IX,IY,IPTR,IPBASE
      REAL    VALUE
      DOUBLE PRECISION SIGMADP,TOTALDP
C
C     Quality values defined symbolically
C
      BYTE GOOD
      PARAMETER (GOOD = 0)
C
C     FMIN, FMAX close to floating point limits
C
      REAL FMIN, FMAX
      PARAMETER (FMAX=1.0E+36, FMIN=1.0E-36)
C
C     Check array limits
C
      NXST=MAX(1,IXST)
      NYST=MAX(1,IYST)
      NXEN=MIN(NX,IXEN)
      NYEN=MIN(NY,IYEN)
C
C     Initial values
C
      SIZE=0.0
      IPBASE=(NYST-1)*NX+NXST
      AMAX=FMIN
      AMIN=FMAX
      TOTALDP=0.
      XMIN=NXST
      XMAX=NXST
      YMIN=NYST
      YMAX=NYST
C
C     Pass through data to get all values except sigma
C
C     Handle different quality methods separately...
C
      IF (QUAL) THEN
C
C       Use quality array
C
        DO IY=NYST,NYEN
           IPTR=IPBASE
           DO IX=NXST,NXEN
              IF (QDATA(IPTR).EQ.GOOD) THEN
                  VALUE=ARRAY(IPTR)
                  SIZE=SIZE+1.0
                  IF (VALUE.LT.AMIN) THEN
                    AMIN=VALUE
                    XMIN=IX
                    YMIN=IY
                  END IF
                  IF (VALUE.GT.AMAX) THEN
                     AMAX=VALUE
                     XMAX=IX
                     YMAX=IY
                  END IF
                  TOTALDP=TOTALDP+VALUE
              END IF ! (qdata(IX).eq.good)
              IPTR=IPTR+1
           END DO
           IPBASE=IPBASE+NX
        END DO
C
        IF (SIZE.GT.0.0) MEAN=SNGL(TOTALDP/DBLE(SIZE))
        TOTAL=SNGL(TOTALDP)
C
C     Now a second pass through to get Sigma.
C
        IF (SIZE.GT.1.0) THEN
C
           SIGMADP=0.
           IPBASE=(NYST-1)*NX+NXST
           DO IY=NYST,NYEN
              IPTR=IPBASE
              DO IX=NXST,NXEN
                 IF (QDATA(IX).EQ.GOOD) THEN
                    VALUE=ARRAY(IPTR)
                    SIGMADP=SIGMADP+
     :              ((VALUE-MEAN)*(VALUE-MEAN)/(SIZE-1.0))
                 ENDIF
                 IPTR=IPTR+1
              END DO
              IPBASE=IPBASE+NX
           END DO
C
           SIGMA=SQRT(SIGMADP)
C
        ELSE
           SIGMA=0.0
        END IF ! (size.gt.1.0)
C
      ELSEIF (FLAGS) THEN
C
C       flagged values are in use:
C
        DO IY=NYST,NYEN
           IPTR=IPBASE
           DO IX=NXST,NXEN
              VALUE=ARRAY(IPTR)
              IF (VALUE.NE.FBAD) THEN
                  SIZE=SIZE+1.0
                  IF (VALUE.LT.AMIN) THEN
                    AMIN=VALUE
                    XMIN=IX
                    YMIN=IY
                  END IF
                  IF (VALUE.GT.AMAX) THEN
                     AMAX=VALUE
                     XMAX=IX
                     YMAX=IY
                  END IF
                  TOTALDP=TOTALDP+VALUE
              END IF ! (qdata(ix).eq.good)
              IPTR=IPTR+1
           END DO
           IPBASE=IPBASE+NX
        END DO
C
        IF (SIZE.GT.0.0) MEAN=SNGL(TOTALDP/DBLE(SIZE))
        TOTAL=SNGL(TOTALDP)
C
C     Now a second pass through to get Sigma.
C
        IF (SIZE.GT.1.0) THEN
C
           SIGMADP=0.
           IPBASE=(NYST-1)*NX+NXST
           DO IY=NYST,NYEN
              IPTR=IPBASE
              DO IX=NXST,NXEN
                 IF (QDATA(IX).EQ.GOOD) THEN
                    VALUE=ARRAY(IPTR)
                    SIGMADP=SIGMADP+
     :                      ((VALUE-MEAN)*(VALUE-MEAN)/(SIZE-1.0))
                 ENDIF
                 IPTR=IPTR+1
              END DO
              IPBASE=IPBASE+NX
           END DO
           SIGMA=SQRT(SIGMADP)
        ELSE
           SIGMA=0.0
        END IF ! (size.gt.1.0)
      ELSE
C
C       Data has no quality information:
C
        SIZE=FLOAT(NXEN-NXST+1)*FLOAT(NYEN-NYST+1)
        DO IY=NYST,NYEN
           IPTR=IPBASE
           DO IX=NXST,NXEN
              VALUE=ARRAY(IPTR)
              IPTR=IPTR+1
              IF (VALUE.LT.AMIN) THEN
                 AMIN=VALUE
                 XMIN=IX
                 YMIN=IY
              END IF
              IF (VALUE.GT.AMAX) THEN
                 AMAX=VALUE
                 XMAX=IX
                 YMAX=IY
              END IF
              TOTALDP=TOTALDP+VALUE
           END DO
           IPBASE=IPBASE+NX
        END DO
C
        IF (SIZE.GT.0.0) MEAN=SNGL(TOTALDP/DBLE(SIZE))
        TOTAL=SNGL(TOTALDP)
C
C     Now a second pass through to get Sigma.
C
        IF (SIZE.GT.1.0) THEN
          SIGMADP=0.
          IPBASE=(NYST-1)*NX+NXST
          DO IY=NYST,NYEN
             IPTR=IPBASE
             DO IX=NXST,NXEN
                VALUE=ARRAY(IPTR)
                IPTR=IPTR+1
                SIGMADP=SIGMADP+((VALUE-MEAN)*(VALUE-MEAN)/(SIZE-1.0))
             END DO
             IPBASE=IPBASE+NX
          END DO
          SIGMA=SQRT(SIGMADP)
        ELSE
          SIGMA=0.0
        END IF ! (size.gt.1.0)
C
      END IF ! (Quality or flagged values)
      END
