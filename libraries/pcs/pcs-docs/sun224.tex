\documentclass[twoside,11pt]{article}

% ? Specify used packages
% \usepackage{graphicx}        %  Use this one for final production.
% \usepackage[draft]{graphicx} %  Use this one for drafting.
% ? End of specify used packages

\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocsource}    {sun\stardocnumber}
\newcommand{\stardoccopyright}
{Copyright \copyright\ 2000 Council for the Central Laboratory of the Research Councils}

% Variable part - replace [xxx] as appropriate.
\newcommand{\stardocnumber}    {224.2}
\newcommand{\stardocauthors}   {A J Chipperfield}
\newcommand{\stardocdate}      {10 February 2000}
\newcommand{\stardoctitle}     {HDSPAR - HDS Parameter Routines}
\newcommand{\stardocversion}   {1.1}
\newcommand{\stardocmanual}    {Programmers manual}
\newcommand{\stardocabstract}  {HDSPAR is a library of subroutines which
interface between the
\htmladdnormallink{Starlink}{\STARURL}
\xref{Hierarchical Data System (HDS)}{sun92}{abstract} and the
\xref{ADAM}{sg4}{} parameter system. HDS objects are handled by reference to a
program parameter name rather than their object name.}
% ? End of document identification
% -----------------------------------------------------------------------------

% +
%  Name:
%     sun.tex
%
%  Purpose:
%     Template for Starlink User Note (SUN) documents.
%     Refer to SUN/199
%
%  Authors:
%     AJC: A.J.Chipperfield (Starlink, RAL)
%     BLY: M.J.Bly (Starlink, RAL)
%     PWD: Peter W. Draper (Starlink, Durham University)
%
%  History:
%     17-JAN-1996 (AJC):
%        Original with hypertext macros, based on MDL plain originals.
%     16-JUN-1997 (BLY):
%        Adapted for LaTeX2e.
%        Added picture commands.
%     13-AUG-1998 (PWD):
%        Converted for use with LaTeX2HTML version 98.2 and
%        Star2HTML version 1.3.
%      1-FEB-2000 (AJC):
%        Add Copyright statement in LaTeX
%     {Add further history here}
%
% -

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markboth{\stardocname}{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %begin{latexonly} and %end{latexonly} lines (used by
%  LaTeX2HTML to signify text it shouldn't process).
%begin{latexonly}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

\newenvironment{latexonly}{}{}
\newcommand{\latex}[1]{#1}
\newcommand{\html}[1]{}
\newcommand{\latexhtml}[2]{#1}
\newcommand{\HTMLcode}[2][]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{\LaTeX2\texttt{HTML}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\renewcommand{\_}{\texttt{\symbol{95}}}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
%end{latexonly}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.
\newcommand{\STARURL}{http://www.starlink.ac.uk/}
% ? End of document specific commands
% -----------------------------------------------------------------------------
%+
%  Name:
%     SST.TEX

%  Purpose:
%     Define LaTeX commands for laying out Starlink routine descriptions.

%  Language:
%     LaTeX

%  Type of Module:
%     LaTeX data file.

%  Description:
%     This file defines LaTeX commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by LaTeX and
%     by LaTeX2html. The contents of this file should be included in the
%     source prior to any statements that make of the sst commnds.

%  Notes:
%     The style file html.sty provided with LaTeX2html needs to be used.
%     This must be before this file.

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)
%     PDRAPER: P.W. Draper (Starlink - Durham University)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     8-DEC-1994 (PDRAPER):
%        Added support for simplified formatting using LaTeX2html.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

%-

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}
\newlength{\sstexampleslength}
\newlength{\sstexampleswidth}

%  Define a \tt font of the required size.
\latex{\newfont{\ssttt}{cmtt10 scaled 1095}}
\html{\newcommand{\ssttt}{\tt}}

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \setlength{\sstexampleslength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-5.0pt}
   \settowidth{\sstexampleswidth}{{\bf Examples:}}
   \addtolength{\sstexampleslength}{-\sstexampleswidth}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{}
\\[1.3ex]{\raggedright \ssttt #1}}

%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{ \item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[2]{\sloppy
\item[\parbox{\sstexampleslength}{\ssttt #1}] \mbox{} \vspace{1.0ex}
\\ #2 }

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}]
\mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%% Now define html equivalents of those already set. These are used by
%  latex2html and are defined in the html.sty files.
\begin{htmlonly}

%  sstroutine.
   \newcommand{\sstroutine}[3]{
      \subsection{#1\xlabel{#1}-\label{#1}#2}
      \begin{description}
         #3
      \end{description}
   }

%  sstdescription
   \newcommand{\sstdescription}[1]{\item[Description:]
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstusage
   \newcommand{\sstusage}[1]{\item[Usage:]
      \begin{description}
         {\ssttt #1}
      \end{description}
      \\
   }

%  sstinvocation
   \newcommand{\sstinvocation}[1]{\item[Invocation:]
      \begin{description}
         {\ssttt #1}
      \end{description}
      \\
   }

%  sstarguments
   \newcommand{\sstarguments}[1]{
      \item[Arguments:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstreturnedvalue
   \newcommand{\sstreturnedvalue}[1]{
      \item[Returned Value:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstparameters
   \newcommand{\sstparameters}[1]{
      \item[Parameters:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstexamples
   \newcommand{\sstexamples}[1]{
      \item[Examples:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstsubsection
   \newcommand{\sstsubsection}[1]{\item[{#1}]}

%  sstexamplesubsection
   \newcommand{\sstexamplesubsection}[2]{\item[{\ssttt #1}] #2}

%  sstnotes
   \newcommand{\sstnotes}[1]{\item[Notes:] #1 }

%  sstdiytopic
   \newcommand{\sstdiytopic}[2]{\item[{#1}] #2 }

%  sstimplementationstatus
   \newcommand{\sstimplementationstatus}[1]{
      \item[Implementation Status:] #1
   }

%  sstitemlist
   \newcommand{\sstitemlist}[1]{
      \begin{itemize}
         #1
      \end{itemize}
      \\
   }
%  sstitem
   \newcommand{\sstitem}{\item}

\end{htmlonly}

%  End of "sst.tex" layout definitions.
%.

%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / \textsc{Rutherford Appleton Laboratory} \hfill \textbf{\stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Huge\textbf{\stardoctitle \\ [2.5ex]}}
   {\LARGE\textbf{\stardocversion \\ [4ex]}}
   {\Huge\textbf{\stardocmanual}}
   \end{center}
   \vspace{5mm}

% ? Add picture here if required for the LaTeX version.
%   e.g. \includegraphics[scale=0.3]{filename.ps}
% ? End of picture

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\textbf{Abstract}}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1> \end{rawhtml}
      \stardoctitle\\
      \stardocversion\\
      \stardocmanual
   \begin{rawhtml} </H1> <HR> \end{rawhtml}

% ? Add picture here if required for the hypertext version.
%   e.g. \includegraphics[scale=0.7]{filename.ps}
% ? End of picture

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory\ \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC / Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://www.starlink.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://www.starlink.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents.
%  ================================
%  Add table of contents header and a navigation button to return to this
%  point in the document (this should always go before the abstract \section).
  \label{stardoccontents}
  \begin{rawhtml}
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}
% ? End of new section for abstract
\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%  ==================
\stardocabstract
% ? End of document abstract

% -----------------------------------------------------------------------------
% ? Latex Copyright Statement
%  =========================
\begin{latexonly}
\newpage
\vspace*{\fill}
\stardoccopyright
\end{latexonly}
% ? End of Latex copyright statement

% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
  \newpage
  \begin{latexonly}
    \setlength{\parskip}{0mm}
    \tableofcontents
    \setlength{\parskip}{\medskipamount}
    \markboth{\stardocname}{\stardocname}
  \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------

\cleardoublepage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

\section{\xlabel{introduction}Introduction}
HDSPAR is a library of subroutines which
interface between the
\htmladdnormallink{Starlink}{\STARURL}
\xref{Hierarchical Data System (HDS)}{sun92}{abstract} and the
\xref{ADAM}{sg4}{} parameter system.

The subroutines do things like opening, closing, creating and deleting
\xref{HDS objects}{sun92}{HDS_objects}\latexonly{ (see SUN/92)}
but instead of passing the
object name to the subroutine, the name of a program parameter is passed.
The parameter system then associates the parameter with the required object,
using the normal parameter system process, involving the
\xref{Interface Module}{sun115}{abstract}\latexonly{ (see SUN/115)}
and possibly prompting the user.

Apart from
\htmlref{\texttt{DAT\_CANCL}}{DAT_CANCL},
all the routines obey the
\xref{Starlink error-handling
convention}{sun104}{err_error_reporting_system}\latexonly{ described in
SUN/104}
-- if the \texttt{STATUS} argument is not \texttt{SAI\_\_OK} on entry,
they return without action;
if they detect an error, they report an error message and return an
appropriate \texttt{STATUS} value.
\texttt{DAT\_CANCL} will attempt to operate regardless of the given status
value.

\section{\xlabel{associating_with_an_object}Associating with an Object}
If you just want to perform some operations on an existing
\xref{HDS object}{sun92}{HDS_objects}
using basic HDS subroutines, you need an
\xref{HDS locator}{sun92}{using_locators}\latexonly{ (see SUN/92)}
for the object and usually you will want to specify the name of the object as
a parameter of the program.

The
\htmlref{\texttt{DAT\_ASSOC}}{DAT_ASSOC}
routine will associate an object with a program parameter and return a locator
for it.
The association can be cancelled and the locator annulled by calling
\htmlref{\texttt{DAT\_CANCL}}{DAT_CANCL}.

\begin{quote} \begin{verbatim}
INCLUDE 'DAT_PAR'

INTEGER STATUS
CHARACTER*(DAT__SZLOC) LOC

CALL DAT_ASSOC( 'OBJECT', 'READ', LOC, STATUS )

... HDS operations ...

CALL DAT_CANCL( 'OBJECT', STATUS )
\end{verbatim} \end{quote}

If \texttt{DAT\_ASSOC} fails to associate the parameter with an object it
will report the problem and prompt for a new value.
It will do this up to five times before giving up and returning status
\texttt{PAR\_\_NULL}.

\htmlref{\texttt{DAT\_EXIST}}{DAT_EXIST} is similar to \texttt{DAT\_ASSOC}
but it will return immediately if the association fails. It can therefore be
used to test for the existence of an object. Status \texttt{PAR\_\_ERROR}
(not \texttt{DAT\_EXIST}, for historical reasons) will be returned if the
object does not exist, but the parameter value will not be cancelled so
a subsequent HDSPAR subroutine call (such as
\htmlref{\texttt{DAT\_CREAT}}{DAT\_CREAT})
specifying the same parameter would not prompt for a new object name.
See
\htmlref{the example}{example}\latexonly{ in Section \ref{example}} for an
illustration of this.

The
\xref{\texttt{ACCESS} Field}{sun115}{the_access_field}\latexonly{ (see SUN/115)}
specified in the Interface Module for the program must be compatible with
the access mode specified in the
\texttt{DAT\_ASSOC} or \texttt{DAT\_EXIST} call, otherwise status
\texttt{SUBPAR\_ICACM} will be returned.

Both routines may be called more than once for the same parameter but
\texttt{DAT\_CANCL} must be called to cancel an existing association if a
different object is required (see
\htmlref{`Parameter States'}{parameter_states}\latexonly{, Section \ref{parameter_states}}).

\section{\xlabel{parameter_states}Parameter States\label{parameter_states}}
A parameter has a number of states.  Initially, a parameter has no
value, and is said to be in the \textit{ground\/} state.  When the
parameter has been given a value, the parameter moves to the \textit{active\/}
state.  A parameter acquires a value in the first instance by
looking for one supplied on the command line.  Failing that, when the program
requests a parameter value, the parameter system will attempt to get a value
from one of a number of sources specified by
\xref{the VPATH Field}{sun115}{the_vpath_field}
in the Interface Module\latexonly{ (see SUN/115)}.
This may cause the user to be prompted and the prompt may contain a
\textit{suggested value} which can be accepted by just hitting the
\texttt{RETURN} key.

If a program requests a value for a parameter already in the active state,
the existing value is returned.
To obtain a new value the program must first \textit{cancel\/} the
parameter, moving it to the \textit{cancelled\/} state.
\htmlref{\texttt{DAT\_CANCL}}{DAT_CANCL} does this as well as annulling the
associated locator.

When the application gets a value for a \textit{ cancelled\/} parameter
\xref{the VPATH Field}{sun115}{the_vpath_field}
is ignored and the user prompted. When a value is obtained, the parameter
returns to the \textit{ active\/} state.

The parameter may also go into the \textit{null\/} state. This occurs if the
parameter is given the null value, for example by the user entering \texttt{!}
in response to a prompt. When the parameter is in the \textit{null\/} state,
any attempt to get its value will return status \texttt{PAR\_\_NULL} -- it
must be cancelled before another value can be obtained.


\section{\xlabel{creating_objects}Creating Objects}
\htmlref{\texttt{DAT\_CREAT}}{DAT_CREAT} may be used to create an object but
note that it does not return a locator -- a subsequent call to DAT\_ASSOC
or DAT\_EXIST is required before the object can be used.
Only one object can be created, its parents, if any, must already exist.
If the parameter specifies a top-level object, any existing container file will
be overwritten but it is an error (\texttt{DAT\_\_COMEX}) to try to overwrite
an existing lower-level component.

The
\xref{\texttt{ACCESS} Field}{sun115}{the_access_field}\latexonly{ (see SUN/115)}
specified in the Interface Module for the program must be `WRITE' or `UPDATE',
otherwise status \texttt{SUBPAR\_ICACM} will be returned.

\section{\xlabel{deleting_objects}Deleting Objects}
An object associated with a parameter can be deleted with the
\htmlref{\texttt{DAT\_DELET}}{DAT_DELET}
routine -- it calls
\xref{\texttt{HDS\_ERASE}}{sun92}{HDS_ERASE}
to delete a top-level object, and
\xref{\texttt{DAT\_ERASE}}{sun92}{DAT_ERASE}
to delete lower-level objects recursively.
The association is then cancelled.

If an object has not already been associated with the specified parameter,
an object name will be obtained from the parameter system.

The
\xref{\texttt{ACCESS} Field}{sun115}{the_access_field}\latexonly{ (see SUN/115)}
specified in the Interface Module for the program must be `WRITE' or `UPDATE',
otherwise status \texttt{SUBPAR\_ICACM} will be returned.

\section{\xlabel{freeing_files}Freeing Files}
In multi-tasking systems, it is sometimes required that an HDS file is
physically updated on disk and freed so that another program can use it.
Subroutine
\htmlref{\texttt{DAT\_UPDAT}}{DAT_UPDAT}
may be used to do this. It calls subroutine
\xref{\texttt{HDS\_FREE}}{sun92}{HDS_FREE}
for the container file of an object associated with a parameter.
If there is no associated object, \texttt{DAT\_UPDAT} will just return
-- no error is reported.

\section{\xlabel{setting_dynamic_defaults}Setting Dynamic Defaults}
The ADAM parameter system has the concept of `dynamic defaults' for program
parameters. These are values suggested by the program itself and the
\xref{Interface Module}{sun115}{abstract}
may be set up to cause the dynamic default to be used as the value for a
parameter using the
\xref{\texttt{VPATH} Field}{sun115}{the_vpath_field}\latexonly{ (see SUN/115)},
or given as a suggested value in a prompt, using the
\xref{\texttt{PPATH} Field}{sun115}{the_ppath_field}\latexonly{ (see SUN/115)}.

Subroutine
\htmlref{\texttt{DAT\_DEF}}{DAT_DEF}
can be used to set an HDS object as the dynamic default for a parameter but its
usefulness is limited because it has to be given a locator to the object.
The locator need only be valid when \texttt{DAT\_DEF} is called, the object
name is found then and stored as a character string.
The string is used when the dynamic default is required.

\section{\xlabel{hdspar_and_par}HDSPAR and PAR}
There is a very close relationship between
HDSPAR, intended for bulk data parameters, and
\xref{PAR}{sun114}{abstract},
intended for parameters which are simple,
\xref{primitive-type}{sun92}{HDS_objects}
values.
If a parameter is given a primitive value, The ADAM parameter system creates
an HDS object in the program's private parameter file (usually
\verb!~/adam/!\textit{program\_name}).
The object has the name of the parameter and contains the given value.
This object is then associated with the parameter in the same way as
\htmlref{\texttt{DAT\_ASSOC}}{DAT_ASSOC}
associates any other object.

This relationship allows primitive values and HDS object names to be used
interchangeably for parameter values to be accessed by either HDSPAR or PAR
subroutines (subject, of course, to suitable type and dimensionality).

Try typing:
\begin{quote} \begin{verbatim}
% hdstrace 3.3
\end{verbatim} \end{quote}

\xref{HDSTRACE}{sun102}{abstract}\latexonly{ (see SUN/102)}
would normally expect an HDS object (parameter OBJECT) as input and uses
\texttt{DAT\_ASSOC} to open it.
In this case it opens the parameter file component and displays:
\begin{quote} \begin{verbatim}
HDSTRACE.OBJECT  <_REAL>

   OBJECT         3.3

End of Trace.
\end{verbatim} \end{quote}

This feature also allows the program to handle parameters without knowing in
advance the type of parameter which will be given.

\section{\xlabel{compiling_and_linking}Compiling and Linking}
HDSPAR does not itself have any Fortran
\xref{INCLUDE files}{sun144}{include_files}
but use of the HDSPAR subroutines will almost certainly require the use of
the general Starlink Applications Environment INCLUDE file, \texttt{SAE\_PAR},
and INCLUDE files from other libraries, in particular
\xref{PAR}{sun114}{abort_and_null}
and
\xref{HDS}{sun92}{routines_and_constants},

To set up links to these files, type:
\begin{quote} \begin{verbatim}
% star_dev
% par_dev
% dat_dev
\end{verbatim} \end{quote}
Then include the files in the program with statements like:
\begin{quote} \begin{verbatim}
*  Define SAI__OK etc.
      INCLUDE 'SAE_PAR'
*  Define PAR__NULL, PAR__ERROR etc.
      INCLUDE 'PAR_ERR'
*  Define DAT__SZLOC etc.
      INCLUDE 'DAT_PAR'
\end{verbatim} \end{quote}
INCLUDE files from other libraries are handled similarly.

Programs using HDSPAR subroutines will be ADAM programs, linked using
\xref{\texttt{alink} or \texttt{ilink}}{sun144}{adam_link_scripts}.
For example:
\begin{quote}
\texttt{\% alink \textit{program}.f}
\end{quote}
Will compile the Fortran program in file \texttt{\textit{program}.f} and link
it with the ADAM infrastructure libraries.

\section{\xlabel{example}Example\label{example}}
The following contrived program shows how the HDSPAR routines can be used.

\begin{quote} \begin{verbatim}
      SUBROUTINE THDSPAR( STATUS)
*   Exercise the HDSPAR routines
*
*   The program creates a structure (parameter 'STRUCTURE') and an
*   INTEGER array component (parameter 'COMPONENT1') if they do not
*   already exist. (These would normally be a top-level structure and
*   a component of it.)
*   A REAL array is then written to the component and the component
*   set as the dynamic default for the parameter 'INPUT'.
*   A REAL array is then read from the data object associated with the
*   'INPUT' parameter - if the dynamic default is chosen, this will be
*   the INTEGER component just written.
*   The input array is then displayed. (Note that conversion will have
*   occurred in writing a REAL array to an INTEGER component.)
*   The INPUT object is then set as the dynamic default for COMPONENT2
*   and then deleted.
*   COMPONENT2 is then created if it does not exist (it should not
*   exist if the dynamic default is used) and a second attempt made to
*   create it, expecting error DAT__COMEX.

      INCLUDE 'DAT_PAR'
      INCLUDE 'PAR_ERR'

      INTEGER STATUS
      INTEGER NDIMS
      INTEGER DIMS(2), ACTDIMS(2)
      INTEGER I, J
      REAL ARR(2,3)
      CHARACTER*(DAT__SZLOC) LOC1, LOC2

      DATA ARR/1.1,2.2,3.3,4.4,5.5,6.6/

      NDIMS = 2
      DIMS(1) = 2
      DIMS(2) = 3

*   Create a structure if it does not already exist.
      CALL DAT_EXIST( 'STRUCTURE', 'WRITE', LOC1, STATUS )
      IF ( STATUS .EQ. PAR__ERROR ) THEN
         CALL ERR_REP( ' ', 'Structure did not exist', STATUS )
         CALL ERR_FLUSH( STATUS )
         CALL DAT_CREAT( 'STRUCTURE', 'STRUC', 0, DIMS, STATUS )
      ENDIF

*   Cancel the structure parameter.
      CALL DAT_CANCL( 'STRUCTURE', STATUS )

*   Create a component if it does not already exist.
      CALL DAT_EXIST( 'COMPONENT1', 'WRITE', LOC1, STATUS )
      IF ( STATUS .EQ. PAR__ERROR ) THEN
         CALL ERR_ANNUL( STATUS )
         CALL MSG_OUT( ' ', 'Component did not exist.', STATUS )
         CALL DAT_CREAT( 'COMPONENT1', '_INTEGER', 2, DIMS, STATUS )
      ENDIF

*   Get a locator for the specified component and write to it.
      CALL DAT_ASSOC( 'COMPONENT1', 'WRITE', LOC2, STATUS )
      CALL DAT_PUTNR( LOC2, NDIMS, DIMS, ARR, DIMS, STATUS )

*   Update the disk - we can't see the effect of this.
      CALL DAT_UPDAT( 'COMPONENT1', STATUS )

*   Set the specified component as the dynamic default for 'INPUT'.
      CALL DAT_DEF( 'INPUT', LOC2, STATUS )

*   The above locator may now be annulled.
      CALL DAT_CANCL( 'COMPONENT1', STATUS )

*   Get a locator for the 'INPUT' component and read from it.
      CALL DAT_ASSOC( 'INPUT', 'READ', LOC1, STATUS )
      CALL DAT_GETNR( LOC1, NDIMS, DIMS, ARR, ACTDIMS, STATUS )

*   Display the input data.
      CALL MSG_OUT( ' ', 'Input array is:', STATUS )
      DO 20 J = 1,ACTDIMS(2)
         DO 10 I = 1, ACTDIMS(1)
            CALL MSG_SETR( 'ROW', ARR(I,J) )
            CALL MSG_SETC( 'ROW', ' ' )
   10    CONTINUE
         CALL MSG_OUT( ' ', '^ROW', STATUS )
   20 CONTINUE

*   Set the 'INPUT' object as dynamic default for 'COMPONENT2',
      CALL DAT_DEF( 'COMPONENT2', LOC1, STATUS )

*   Delete the 'INPUT' component.
      CALL DAT_DELET( 'INPUT', STATUS )

*   Check that 'COMPONENT2' does not exist
*   and create it.
      CALL DAT_EXIST( 'COMPONENT2', 'WRITE', LOC1, STATUS )
      IF ( STATUS .EQ. PAR__ERROR ) THEN
         CALL ERR_REP( ' ', 'Component did not exist.', STATUS )
         CALL ERR_FLUSH( STATUS )
         CALL DAT_CREAT( 'COMPONENT2', '_INTEGER', 2, DIMS, STATUS )
      ENDIF

*   Attempt to create it again - expect an error.
      CALL MSG_OUT( ' ', 'Expect error DAT__COMEX.', STATUS )
      CALL DAT_CREAT( 'COMPONENT2', '_INTEGER', 2, DIMS, STATUS )

      END
\end{verbatim} \end{quote}

The following interface file could be used. This will cause prompts for
parameters \texttt{STRUCTURE} and \texttt{COMPONENT1}, and take the dynamic
defaults for \texttt{INPUT} and \texttt{COMPONENT2} (unless values are given
on the command line).
\begin{quote} \begin{verbatim}
interface THDSPAR
 parameter STRUCTURE
   position 1
   type univ
   access write
   vpath prompt
   ppath default
   default created
 endparameter
 parameter COMPONENT1
   position 2
   type univ
   access update
   vpath prompt
   ppath default
   default created.comp
 endparameter
 parameter INPUT
   position 3
   type univ
   access read
   vpath dynamic
 endparameter
 parameter COMPONENT2
   position 4
   type univ
   vpath dynamic
 endparameter
endinterface

\end{verbatim} \end{quote}

The resultant session, accepting suggested values would look like this:
\begin{quote} \begin{verbatim}
% thdspar
STRUCTURE /@created/ >
COMPONENT1 /@created.comp/ >
Input array is:
1 2
3 4
5 6
!! SUBPAR: Error finding component 'COMP' in
!     "/tmp_mnt/mount_nfs/user1/dec/ajc/test/created.sdf"CREATED.COMP
!  Component did not exist
Expect error DAT__COMEX
!! DAT_NEW: Error creating a new HDS component.
!  Application exit status DAT__COMEX, Component already exists
\end{verbatim} \end{quote}

\newpage
\appendix
\section{\xlabel{subroutine_specifications}Subroutine Specifications}
\sstroutine{
   DAT\_ASSOC
}{
   Return a locator associated with a parameter
}{
   \sstdescription{
      An HDS locator for the data object associated with the specified
      parameter is returned. The parameter system will attempt to associate
      an object if one is not already associated. In the event of a failure,
      an error message will be displayed and another attempt made (usually
      by prompting the user). Up to five attempts will be made, after which
      status PAR\_\_NULL will be returned.

      The object will be opened with the appropriate ACCESS mode. If ACCESS
      is incompatible with the access mode specified for the parameter in
      the program{\tt '}s Interface File, status SUBPAR\_\_ICACM will be returned.
   }
   \sstinvocation{
      CALL DAT\_ASSOC ( PARAM, ACCESS, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM=CHARACTER$*$($*$) (given)
      }{
         Name of program parameter
      }
      \sstsubsection{
         ACCESS=CHARACTER$*$($*$) (given)
      }{
         Access mode, {\tt '}READ{\tt '}, {\tt '}WRITE{\tt '} or {\tt '}UPDATE{\tt '}
         (case insignificant)
      }
      \sstsubsection{
         LOC=CHARACTER$*$($*$) (returned)
      }{
         Locator to the associated data object
      }
      \sstsubsection{
         STATUS=INTEGER (given and returned)
      }{
         Global status
      }
   }
}
\sstroutine{
   DAT\_CANCL
}{
   Cancel association between a parameter and a data object
}{
   \sstdescription{
      An existing association between the named parameter and a data
      system object is cancelled, and the container file closed.
      This routine will attempt to operate regardless of the given
      STATUS value.

      The parameter enters the CANCELLED state.
   }
   \sstinvocation{
      CALL DAT\_CANCL ( PARAM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM=CHARACTER$*$($*$) (given)
      }{
         Name of program parameter
      }
      \sstsubsection{
         STATUS=INTEGER (given and returned)
      }{
         Global status
      }
   }
}
\sstroutine{
   DAT\_CREAT
}{
   Create a data structure component
}{
   \sstdescription{
      An HDS data object is created, as specified by the character
      string associated with the parameter, and the given type and
      dimensionality. If the object is a component of a structure,
      the structure must already exist.
   }
   \sstinvocation{
      CALL DAT\_CREAT ( PARAM, TYPE, NDIMS, DIMS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM=CHARACTER$*$($*$) (given)
      }{
         Name of program parameter
      }
      \sstsubsection{
         TYPE=CHARACTER$*$($*$) (given)
      }{
         Type of HDS component. This may be a primitive type or a
         structure
      }
      \sstsubsection{
         NDIMS=INTEGER (given)
      }{
         Number of dimensions of the component
      }
      \sstsubsection{
         DIMS($*$)=INTEGER (given)
      }{
         Dimensions of the component
      }
      \sstsubsection{
         STATUS=INTEGER (given and returned)
      }{
         Global status
      }
   }
}
\sstroutine{
   DAT\_DEF
}{
   Suggest values for parameter
}{
   \sstdescription{
      Set a data-system object as the dynamic default for a parameter.
      The given locator must be valid when DAT\_DEF is called but may
      be annulled before the dynamic default is used.
   }
   \sstinvocation{
      CALL DAT\_DEF ( PARAM, LOC, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         PARAM=CHARACTER$*$($*$) (given)
      }{
         Name of program parameter.
      }
      \sstsubsection{
         LOC=CHARACTER$*$($*$) (given)
      }{
         Locator to a data object.
      }
      \sstsubsection{
         STATUS=INTEGER (given and returned)
      }{
         Global status
      }
   }
}
\sstroutine{
   DAT\_DELET
}{
   Delete an object associated with a parameter
}{
   \sstdescription{
      Get an object name and delete the object.
   }
   \sstinvocation{
      CALL DAT\_DELET ( PARAM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM=CHARACTER$*$($*$) (given)
      }{
         Name of program parameter
      }
      \sstsubsection{
         STATUS=INTEGER (given and returned)
      }{
         Global status
      }
   }
}
\sstroutine{
   DAT\_EXIST
}{
   Return a locator associated with a parameter
}{
   \sstdescription{
      An HDS locator for the data object associated with the specified
      parameter is returned. The parameter system will attempt to associate
      an object if one is not already associated. This operation is identical
      with DAT\_ASSOC except under error conditions. When there is an error,
      DAT\_EXIST reports the error and returns the status value immediately,
      whereas DAT\_ASSOC repeatedly attempts to get a valid locator.
      If the named object does not exist, status PAR\_\_ERROR is returned.

      The object will be opened with the appropriate ACCESS mode. If ACCESS
      is incompatible with the access mode specified for the parameter in
      the program{\tt '}s Interface File, status SUBPAR\_\_ICACM will be returned.
   }
   \sstinvocation{
      CALL DAT\_EXIST ( PARAM, ACCESS, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM=CHARACTER$*$($*$) (given)
      }{
         program parameter name
      }
      \sstsubsection{
         ACCESS=CHARACTER$*$($*$) (given)
      }{
         Access mode, {\tt '}READ{\tt '}, {\tt '}WRITE{\tt '} or {\tt '}UPDATE{\tt '}
         (case insignificant)
      }
      \sstsubsection{
         LOC=CHARACTER$*$($*$) (returned)
      }{
         Locator to the associated data object
      }
      \sstsubsection{
         STATUS=INTEGER (given and returned)
      }{
         Global status
      }
   }
}
\sstroutine{
   DAT\_UPDAT
}{
   Force HDS update
}{
   \sstdescription{
      If there is an HDS object associated with the parameter, force
      its container file to be freed so that its memory cache coincides
      with the data on disk and the file is available for other programs
      to use.
   }
   \sstinvocation{
      CALL DAT\_UPDAT ( PARAM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM=CHARACTER$*$($*$) (given)
      }{
         Name of program parameter.
      }
      \sstsubsection{
         STATUS=INTEGER (given and returned)
      }{
         Global status
      }
   }
}
\end{document}
