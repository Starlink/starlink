\documentclass[twoside,11pt,nolof]{starlink}

% ? Specify used packages
% ? End of specify used packages

% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\stardoccategory    {Starlink User Note}
\stardocinitials    {SUN}
\stardocsource      {sun\stardocnumber}
\stardoccopyright
{Copyright \copyright\ 2000 Council for the Central Laboratory of the Research Councils, 2006 Particle Physics and Astronomy Research Council}

% Variable part - replace [xxx] as appropriate.
\stardocnumber      {121.6}
\stardocauthors   {P M Allan\\
                                A J Chipperfield\\ T Jenness\\
                                David S Berry}
\stardocdate        {8th November 2007}
\stardoctitle      {PSX \\ [1ex]
                                POSIX interface routines}
\stardocversion     {Version 0.5-4}
\stardocmanual      {Programmer's Manual}
\stardocabstract  {%
PSX is a FORTRAN subroutine library that allows programmers to use the
functionality provided by the POSIX and X/OPEN libraries. The use of this
library will enable programmers to make use of operating system facilities in a
machine independent way.}
% ? End of document identification
% -----------------------------------------------------------------------------
% -----------------------------------------------------------------------------
% ? Document specific \providecommand or \newenvironment commands.

% Commands for displaying routines in routine lists:
% =================================================
\providecommand{\listline}{\hspace{1pt}\\}

\providecommand{\noteroutine}[4]{\item [\htmlref{#1}{#2} #3] \listline
\textit{#4} }

\providecommand{\notimproutine}[4]{\item [#1 #3] \listline
\textit{#4} }

% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\begin{document}
\scfrontmatter

% ? Main text

\section{\xlabel{introduction}Introduction}

% \subsection{Warning}

% The current version of this software is a preliminary version. It is not yet
% complete and will continue to be developed in the near future. However, this
% first release has been made to provide much needed facilities as soon as
% possible and to whet the appetite of the programmer.

% Future modifications to this package should not change any existing routines,
% but will consist of the addition of many new routines.

\subsection{\xlabel{who_should_read_this_document}Who should read this document?}

It is frequently the case that a FORTRAN programmer will need to use
facilities that the operating system of the host computer provides and
which pure FORTRAN~77 does not.  This document is intended for
programmers who need to use such facilities, and to do so in a portable
way.

\subsection{\xlabel{overview}Overview}

When writing programs that interact with the real world, as opposed to
those that do some purely mathematical calculation, it is often
necessary to make use of features of the operating system. A simple
example of this is getting the current date and time. Most FORTRAN
systems provide subroutines to let the programmer get this information,
but the syntax of these routines differ from one computer to another,
making the resulting code non portable. What is required
is a portable operating system interface, and that is exactly what
POSIX is. It is a set of routines that let an application program
interact with the host operating system of the computer in a standard
manner.

POSIX will eventually define a whole set of standards, but the one of
interest here is that known as IEEE~1003.1-1988. This standard is
published by the Institute of Electrical and Electronic Engineers
(IEEE) and is recognized by the American National Standards Institute
(ANSI). To quote from the standard \cite{psx:std}, `It defines a
standard operating system interface and environment to support
application portability at the source code level.' What this means is
that if you include a POSIX call in your program, then your program
will work on any system that is POSIX compliant. Since POSIX has its
origins in Unix, it is not surprising that several of the many
different Unix systems are already fully or nearly, POSIX compliant.
% Significantly, VMS is not yet POSIX compliant, but it will be `in a
% future major release of VMS', to use the DEC parlance.

On account of the Unix origin of POSIX, some of the terminology used in
describing the routines has a Unix accent. Any confusion caused by this
should be resolved by the notes for each routine.

\subsection{\xlabel{what_exactly_is_posix}What exactly \emph{is} POSIX?}

If you really mean that, you had better go and read the standard\cite{psx:std}.
However, to a reasonable approximation, POSIX (1003.1) is just the C run time
library and indeed the POSIX standard makes reference to the ANSI C standard
\cite{c:std}. Unfortunately, different computers have somewhat different C
run time libraries. The point of POSIX is to define a common run time library
that will be available on all computers.

\section{\xlabel{the_psx_library}The PSX library}

The 1003.1 standard actually defines a C interface to POSIX. This is
the obvious thing to do since POSIX is derived from the C run time
library. However, that is not much comfort if you actually want to call
the POSIX routines from FORTRAN. There is a draft standard (1003.9)
that defines how the routines should be called from FORTRAN (referred
to as the FORTRAN binding), but that is still a draft and commercial
products based on that standard are unlikely to be available for some
while. Furthermore, in order to cope with the C concepts that are
inherent in POSIX, the draft standard for the FORTRAN binding has
defined things in such a way that it makes using POSIX directly from
FORTRAN somewhat painful.

To make life easier for the FORTRAN programmer, a package of routines
called PSX has been written to which let FORTRAN programs make calls to
POSIX functions in a manner consistent with other Starlink subroutine
libraries. This means that FORTRAN programs that need to make use of
functions provided by the operating system can be written in a portable
manner. Another advantage of using the PSX routines instead of using
raw POSIX (even if we could) is that it allows us to use inherited
status that is a common feature of Starlink subroutine libraries. If a
PSX routine detects an error, it sets the STATUS argument of the
routine to one of the values given in appendix~\ref{include} and
reports an error via EMS (see \xref{SSN/4}{ssn4}{}).

Note that the names of the PSX routines are often longer than the
Starlink recommendation (\xref{SGP/16}{sgp16}{}) of the PSX\_ prefix
plus five more characters. This has been done so that the name of the
PSX routine corresponds directly with the name of the `real' POSIX
routine. This creates a potential problem with porting the routines to
other computers that might not accept names longer than six characters.
However, the draft standard for the FORTRAN binding to POSIX assumes
that compilers will accept names up to 31 characters (this is the
\emph{only}, extension to ANSI standard FORTRAN~77 that it assumes), so
this is no worse than basing routines directly on the specification of
the draft standard.

The PSX routines are just wrap around routines for POSIX routines. For further
details on these routines, you should consult the relevant standards documents
\cite{psx:std} and \cite{c:std}. If you do not have copies of these, the
documentation for the C run time library on your computer may be helpful.

\section{\xlabel{the_level_of_the_implementation}The Level of the Implementation}

So far, not all of the POSIX 1003.1 routines have been provided with a
PSX equivalent. Indeed this may never be achieved. The purpose of the
PSX routines is to enable the programmer to use functionality of POSIX,
so only those routines that are actually thought to be needed will be
provided. If you have a need for a routine that has not been provided,
please mail the author, who will do his best to provide the routine.
Each routine is fairly simple to write; it is only the sheer number of
routines that prevents a complete set being provided to date.

The POSIX 1003.1 standard refers to the ANSI~C standard for the
description of some of the routines. These are listed in the POSIX
standard under `language specific services for the C programming
language'. There are no corresponding routines in the draft FORTRAN
binding. Nevertheless, some of these routines are so useful that a PSX
implementation of them has been provided. Examples are allocating
virtual memory (using malloc) and getting the current date and time.

Descriptions of the routines that are currently available in the PSX
library are given in appendix~\ref{description}. Those routines that
have been considered for inclusion in the library and have been
rejected are listed in appendix~\ref{not-implelmented}.

\subsection{\xlabel{future_extensions}Future Extensions}

While the PSX routines are clearly very useful as they stand, they do
not always present the information in the manner that you may want. An
example of this is the subroutine PSX\_CTIME, which returns the data
and time in a particularly perverse format. The temptation to `improve'
some routines has been resisted to ensure that there is consistency
between the PSX routines and the corresponding true POSIX or C run-time
library routines. However, there is clearly a need for routines that
pull together some of the PSX routines in a more user friendly way and
to provide information in a different manner. These routines will be
provided in a separate package.

\section{\xlabel{xopen}X/OPEN}

Another attempt to achieve portable programs is that of the X/OPEN
group. The X/OPEN portability guide is a similar document to the POSIX
standard and is also based on the C run time library. The routines
defined in the X/OPEN portability guide tend to be of a higher level
than those in the POSIX standard and where appropriate, PSX equivalents
for X/OPEN routines will also be provided.

\section{\xlabel{compiling_and_linking}Compiling and Linking}

To use the PSX routines, you first need to `log on' for development by using
the \texttt{psx\_dev} command to create the necessary soft links in your
directory so that you can use the short form of the include file names.

\begin{terminalv}
% psx_dev
\end{terminalv}

If a FORTRAN program wishes to check for a particular error status returned by
a PSX routine, then it should contain the line

\begin{terminalv}
INCLUDE 'PSX_ERR'
\end{terminalv}

The use of upper-case in the file name is important. This will define the
symbolic constants listed in appendix~\ref{include}.

To compile and link a program that uses the PSX library, type

\begin{terminalv}
% f77 program.f -L/star/lib `psx_link` -o program
\end{terminalv}

\section{\xlabel{references}References}
%   % Stops the page heading changing to REFERENCES.
\begin{thebibliography}{9}
\bibitem{psx:std}IEEE Standard Portable Operating System Interface for Computer
Environments (IEEE Std 1003.1-1988). Publ, Institute of Electrical and
Electronic Engineers, Inc.
\bibitem{c:std}American National Standard for Information Systems --
Programming Language -- C (ANSI X3.159-1989). Publ, American National Standards
Institute.
\bibitem{psx:fortran}Portable Operating System Interface for Computer
Environments, FORTRAN~77 Bindings (P1003.9~/~Draft 5.0).
\end{thebibliography}

\newpage
\appendix
%   % Stops the page heading changing to REFERENCES.

\section{\xlabel{examples}Examples}

So much for theory, here are some examples of the use of PSX routines. Each
POSIX routine tends to stand on its own, so the examples are fairly simple.

\subsection{\xlabel{create_a_file_with_name_that_is_specific_to_a_user}Create a file with name that is specific to a user}

The requirement is to create a file that will be used to hold the output of
several programs, but this file must be in a directory that is used by several
people. Clearly the file name must be related to the username. Also it is
necessary to take into account the difference in the syntax of directory names
on VMS and Unix systems.

\begin{small}
\begin{terminalv}
      PROGRAM NEWFIL

      IMPLICIT NONE
      INCLUDE 'SAE_PAR'
      INTEGER STATUS                   ! The global status value
      CHARACTER * ( 32 ) NAME          ! The name of the current user
      CHARACTER * ( 80 ) FILNAM        ! The name of the file to be created
      CHARACTER * ( 15 ) SYSNAME       ! The name of the operating system
      CHARACTER * ( 1 ) DUMMY1
      CHARACTER * ( 1 ) DUMMY2
      CHARACTER * ( 1 ) DUMMY3
      CHARACTER * ( 1 ) DUMMY4

* Set STATUS since this is is not an ADAM program.
      STATUS = SAI__OK

* Get the username.
      CALL PSX_GETENV( 'USER', NAME, STATUS )

* Get the system name.
      CALL PSX_UNAME( SYSNAME, DUMMY1, DUMMY2, DUMMY3, DUMMY4, STATUS )

* Create the file.
      IF( STATUS .EQ. SAI__OK ) THEN
         IF( SYSNAME .EQ. 'VMS' ) THEN
            FILNAM = 'COMMON_AREA:' // NAME // '.DAT'
         ELSE
            FILNAM = '/usr/common/' // NAME // '.DAT'
         END IF
         OPEN( UNIT=1, FILE=FILNAM, STATUS='NEW' )
         CLOSE( UNIT=1 )
      ELSE
         PRINT *,'Could not get username'
      END IF

      END
\end{terminalv}
\end{small}

Although the PSX routines are designed to be used with other Starlink routines
in the ADAM environment and use the concept of inherited status, they can just
as easily be used in a stand alone program like the one above provided that the
status is set correctly before calling the first routine. This is important
since the PSX routine will exit immediately if STATUS is not set to the value
of the symbolic constant SAI\_\_OK.

\subsection{\xlabel{get_some_virtual_memory}Get some virtual memory}

One of the annoying features of FORTRAN~77 is that all storage space must be
allocated at compile time, \emph{i.e.} there are no dynamic arrays. Here is an
example of using PSX routines to dynamically allocate an array.

\begin{small}
\begin{terminalv}
      PROGRAM MAIN
      IMPLICIT NONE
      INCLUDE 'SAE_PAR'
      INTEGER STATUS

* Set the STATUS to OK.
      STATUS = SAI__OK

* Call the subroutine.
      CALL GETVM( STATUS )

      END


      SUBROUTINE GETVM( STATUS )
      IMPLICIT NONE
      INCLUDE 'SAE_PAR'
      INCLUDE 'CNF_PAR'
      INTEGER STATUS, PNTR

* Check global status.
      IF( STATUS .NE. SAI__OK ) RETURN

* Create a ten element integer array and return a pointer to it.
      CALL PSX_CALLOC( 10, '_INTEGER', PNTR, STATUS )

* If all is well, operate on the array.
      IF (STATUS .EQ. SAI__OK) THEN
         CALL FILL( %VAL(PNTR), 10 )
         CALL PRNT( %VAL(PNTR), 10 )
         CALL PSX_FREE( PNTR, STATUS )
      END IF

      END


      SUBROUTINE FILL( ARRAY, N )
* Put some numbers in the array.
      INTEGER N, ARRAY( N )
      INTEGER I

      DO I = 1, N
         ARRAY( I ) = I
      END DO

      END


      SUBROUTINE PRNT( ARRAY, N )
* Print the elements of ARRAY.
      INTEGER N, ARRAY( N )
      INTEGER I

      DO I = 1, N
         PRINT *,ARRAY( I )
      END DO

      END
\end{terminalv}
\end{small}

In this case the main program merely sets the value of STATUS and calls
the subroutine GETVM to do the work. Although this is more typing, it
does have the advantage that this could be made into an ADAM task
simply by deleting the main program. GETVM tests that the value of
STATUS returned from PSX\_CALLOC is OK, but does not print any error
message. This is not necessary, as the PSX routines all report their
own errors via the EMS routines. The reporting of error messages may be
deferred if required, as described in \xref{SUN/104}{sun104}{} and
\xref{SSN/4}{ssn4}{}.

If the code is required to work where pointers may be longer than INTEGERs,
The construct \texttt{\%VAL(CNF\_PVAL(PNTR))}, rather than simply
\texttt{\%VAL(PNTR)}, should be used in passing the pointer to FILL and PRNT.
Function CNF\_PVAL is defined in the CNF\_PAR include file and described in
\xref{SUN/209}{sun209}{accessing_dynamic_memory_from_c_and_fortran}
(section `Pointers').

\section{\xlabel{include_files}Include Files}
\label{include}

The symbolic constants that define the error codes returned by PSX
routines are defined in the file \texttt{/star/include/psx\_err}.  The
meaning of these constants is given below:

\begin{center}
\begin{tabular}{ll}
PSX\_\_INTYP & Invalid argument TYPE given in call to PSX\_CALLOC \\
PSX\_\_NOALL & Null pointer returned on memory allocation \\
PSX\_\_NOENV & No translation of an environment variable \\
PSX\_\_NOGMT & Could not get GMT with gmtime() \\
PSX\_\_NOTIM & Could not get current time with time() \\
PSX\_\_NOMEM & Could not get required memory \\
PSX\_\_ERRNO & System error during POSIX call
\end{tabular}
\end{center}

\newpage
\section{\xlabel{alphabetical_list_of_routines}Alphabetical list of routines}

% List of routines:
% =================
\begin{description}
\noteroutine{PSX\_ACCESS}{PSX_ACCESS}{( NAME, MODE, ACCESSIBLE, REASON, STATUS )}
            {Check file accessibility}
\noteroutine{PSX\_ASCTIME}{PSX_ASCTIME}{( TSTRCT, STRING, STATUS )}
            {Convert a time structure to a character string}
\noteroutine{PSX\_CALLOC}{PSX_CALLOC}{( NMEMB, TYPE, PNTR, STATUS )}
            {Allocate space for several objects of specified type}
\noteroutine{PSX\_CHDIR}{PSX_CHDIR}{( DIR, STATUS )}
            {Change working directory}
\noteroutine{PSX\_CTIME}{PSX_CTIME}{( NTICKS, STRING, STATUS )}
            {Convert the calendar time to a character string}
\noteroutine{PSX\_CUSERID}{PSX_CUSERID}{( USER, STATUS )}
            {Get the username}
\noteroutine{PSX\_FREE}{PSX_FREE}{( PNTR, STATUS )}
            {Free virtual memory }
\noteroutine{PSX\_GETCWD}{PSX_GETCWD}{( CWD, STATUS )}
            {Get the current working directory}
\noteroutine{PSX\_GETEGID}{PSX_GETEGID}{( GID, STATUS )}
            {Gets the effective group ID}
\noteroutine{PSX\_GETENV}{PSX_GETENV}{( NAME, TRANS, STATUS )}
            {Translate an environment variable}
\noteroutine{PSX\_GETEUID}{PSX_GETEUID}{( UID, STATUS )}
            {Gets the effective user ID}
\noteroutine{PSX\_GETGID}{PSX_GETGID}{( GID, STATUS )}
            {Gets the real group ID}
\noteroutine{PSX\_GETPID}{PSX_GETPID}{( PID, STATUS )}
            {Gets the process ID}
\noteroutine{PSX\_GETPPID}{PSX_GETPPID}{( PID, STATUS )}
            {Gets the process ID of the parent process}
\noteroutine{PSX\_GETUID}{PSX_GETUID}{( UID, STATUS )}
            {Gets the real user ID}
\noteroutine{PSX\_GMTIME}{PSX_GMTIME}{}
            {\textnormal{\textbf{( NTICKS, SECS, MINS, HOURS,
             DAY, MONTH, YEAR, WDAY, YDAY, TSTRCT, STATUS )}}\\
            Convert the value returned by PSX\_TIME to individual GMT values}
\noteroutine{PSX\_ISATTY}{PSX_ISATTY}{( FILDSC, ISTTY, STATUS )}
            {Determine if a file is a terminal}
\noteroutine{PSX\_LOCALTIME}{PSX_LOCALTIME}{}
            {\textnormal{\textbf{( NTICKS, SECS, MINS, HOURS,
             DAY, MONTH, YEAR, WDAY, YDAY, ISDST, TSTRCT, STATUS )}}\\
            Convert the value returned by PSX\_TIME to individual local time
            values}
\noteroutine{PSX\_MALLOC}{PSX_MALLOC}{( SIZE, PNTR, STATUS )}
            {Allocate virtual memory}
\noteroutine{PSX\_PUTENV}{PSX_PUTENV}{( NAME, VALUE, STATUS )}
            {Set a new environment variable value}
\noteroutine{PSX\_RAND}{PSX_RAND}{( INUM, MAXNUM, FNUM, STATUS )}
            {Generate a random number}
\noteroutine{PSX\_REALLOC}{PSX_REALLOC}{( SIZE, PNTR, STATUS )}
            {Change the size of an allocated region of virtual memory}
\noteroutine{PSX\_REMOVE}{PSX_REMOVE}{( PATH, STATUS )}
            {Remove a file or empty directory}
\noteroutine{PSX\_RENAME}{PSX_RENAME}{( INFIL, OUTFIL, STATUS )}
            {Rename a file}
\noteroutine{PSX\_SRAND}{PSX_SRAND}{( SEED, STATUS )}
            {Set the seed for the random number generator}
\noteroutine{PSX\_STAT}{PSX_STAT}{}
            {\textnormal{\textbf{( PATH, ITEM, VALUE, STATUS )}}\\
            Return an item of information about a file}
\noteroutine{PSX\_TIME}{PSX_TIME}{( NTICKS, STATUS )}
            {Get the current calendar time}
\noteroutine{PSX\_TTYNAME}{PSX_TTYNAME}{( FILDSC, TNAME, STATUS )}
            {Get the name of the terminal}
\noteroutine{PSX\_UNAME}{PSX_UNAME}{}
            {\textnormal{\textbf{( SYSNAME, NODENAME, RELEASE, VERSION,
            MACHINE, STATUS )}}\\
            Gets information about the host computer system }
\end{description}


\newpage
\section{\xlabel{classified_list_of_routines}Classified list of routines}
\subsection{\xlabel{process_environment}Process Environment}
\begin{description}
\noteroutine{PSX\_CUSERID}{PSX_CUSERID}{( USER, STATUS )}
            {Get the username}
\noteroutine{PSX\_GETEGID}{PSX_GETEGID}{( GID, STATUS )}
            {Gets the effective group ID}
\noteroutine{PSX\_GETENV}{PSX_GETENV}{( NAME, TRANS, STATUS )}
            {Translate an environment variable}
\noteroutine{PSX\_GETEUID}{PSX_GETEUID}{( UID, STATUS )}
            {Gets the effective user ID}
\noteroutine{PSX\_GETGID}{PSX_GETGID}{( GID, STATUS )}
            {Gets the real group ID}
\noteroutine{PSX\_GETPID}{PSX_GETPID}{( PID, STATUS )}
            {Gets the process ID}
\noteroutine{PSX\_GETPPID}{PSX_GETPPID}{( PID, STATUS )}
            {Gets the process ID of the parent process}
\noteroutine{PSX\_GETUID}{PSX_GETUID}{( UID, STATUS )}
            {Gets the real user ID}
\noteroutine{PSX\_ISATTY}{PSX_ISATTY}{( FILDSC, ISTTY, STATUS )}
            {Determine if a file is a terminal}
\noteroutine{PSX\_PUTENV}{PSX_PUTENV}{( NAME, VALUE, STATUS )}
            {Set a new environment variable value}
\noteroutine{PSX\_TTYNAME}{PSX_TTYNAME}{( FILDSC, TNAME, STATUS )}
            {Get the name of the terminal}
\noteroutine{PSX\_UNAME}{PSX_UNAME}{( SYSNAME, NODENAME, RELEASE, VERSION,
             MACHINE,}
            {\textnormal{\textbf{STATUS )}}\\
            Gets information about the host computer system }
\end{description}


\subsection{\xlabel{file_system_support}File System Support}
\begin{description}
\noteroutine{PSX\_ACCESS}{PSX_ACCESS}{( NAME, MODE, ACCESSIBLE, REASON, STATUS )}
            {Check file accessibility}
\noteroutine{PSX\_CHDIR}{PSX_CHDIR}{( DIR, STATUS )}
            {Change working directory}
\noteroutine{PSX\_GETCWD}{PSX_GETCWD}{( CWD, STATUS )}
            {Get the current working directory}
\noteroutine{PSX\_REMOVE}{PSX_REMOVE}{( PATH, STATUS )}
            {Remove a file or empty directory}
\noteroutine{PSX\_RENAME}{PSX_RENAME}{( INFIL, OUTFIL, STATUS )}
            {Rename a file}
\noteroutine{PSX\_STAT}{PSX_STAT}{( PATH, ITEM, VALUE, STATUS )}
            {Return an item of information about a file}
\end{description}

\subsection{\xlabel{language_specific_services_for_c_fortran_versions}Language Specific Services for C (FORTRAN versions)}
\subsubsection{Pseudo-Random Numbers}
\begin{description}
\noteroutine{PSX\_RAND}{PSX_RAND}{( INUM, MAXNUM, FNUM, STATUS )}
            {Generate a random number}
\noteroutine{PSX\_SRAND}{PSX_SRAND}{( SEED, STATUS )}
            {Set the seed for the random number generator}
\end{description}

\subsubsection{Memory Management}
\begin{description}
\noteroutine{PSX\_CALLOC}{PSX_CALLOC}{( NMEMB, TYPE, PNTR, STATUS )}
            {Allocate space for several objects of specified type}
\noteroutine{PSX\_FREE}{PSX_FREE}{( PNTR, STATUS )}
            {Free virtual memory}
\noteroutine{PSX\_MALLOC}{PSX_MALLOC}{( SIZE, PNTR, STATUS )}
            {Allocate virtual memory}
\noteroutine{PSX\_REALLOC}{PSX_REALLOC}{( SIZE, PNTR, STATUS )}
            {Change the size of an allocated region of virtual memory}
\end{description}

\subsubsection{Date and Time}
\begin{description}
\noteroutine{PSX\_ASCTIME}{PSX_ASCTIME}{( TSTRCT, STRING, STATUS )}
            {Convert a time structure to a character string}
\noteroutine{PSX\_CTIME}{PSX_CTIME}{( NTICKS, STRING, STATUS )}
            {Convert the calendar time to a character string}
\noteroutine{PSX\_GMTIME}{PSX_GMTIME}{}
            {\textnormal{\textbf{( NTICKS, SECS, MINS, HOURS,
             DAY, MONTH, YEAR, WDAY, YDAY, TSTRCT, STATUS )}}\\
            Convert the value returned by PSX\_TIME to individual GMT values}
\noteroutine{PSX\_LOCALTIME}{PSX_LOCALTIME}{}
            {\textnormal{\textbf{( NTICKS, SECS, MINS, HOURS,
             DAY, MONTH, YEAR, WDAY, YDAY, ISDST, TSTRCT, STATUS )}}\\
            Convert the value returned by PSX\_TIME to individual local time
            values}
\noteroutine{PSX\_TIME}{PSX_TIME}{( NTICKS, STATUS )}
            {Get the current calendar time}
\end{description}

\newpage
\section{\xlabel{routine_descriptions}Routine Descriptions}
\label{description}

% Routine descriptions:
% =====================

\sstroutine{
   PSX\_ACCESS
}{
   Check file accessibility
}{
   \sstdescription{
      Provides a FORTRAN interface to the C library function access() to
      determine the existence of a file for a specified type of access.
   }
   \sstinvocation{
      CALL PSX\_ACCESS( NAME, MODE, ACCESSIBLE, REASON, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER$*$($*$) (Given)
      }{
         The name of the file to test.
      }
      \sstsubsection{
         MODE = CHARACTER$*$($*$) (Given)
      }{
         The access mode - either a \texttt{'} \texttt{'} (space) to merely check
         for file existence or one or more of the letters R,W,X.
      }
      \sstsubsection{
         ACCESSIBLE = LOGICAL (Returned)
      }{
       .TRUE. if the access mode is allowed. .FALSE. otherwise.
      }
      \sstsubsection{
         REASON = INTEGER (Returned)
      }{
         Error code (errno) describing the reason for failure. Can be passed
         to EMS\_SYSER for translation if required. Will be zero if ACCESSIBLE
         is true or if status was set.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Inherited status.
      }
   }
   \sstnotes{
      Some FORTRAN compilers have an ACCESS intrinsic, but not all.
      This PSX routine is provided for portability.
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX Standard ISO/IEC 9945-1:1990
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1995 Council for the Central Laboratory of the Resarch Councils,
      Copyright (C) 2005 Particle Physics and Astronomy Research Council
   }
}


\sstroutine{
   PSX\_ASCTIME
}{
   Convert a time structure to a character string
}{
   \sstdescription{
      Convert the information in the structure pointed to by TSTRCT to a
      character string. TSTRCT should have been set by a call to
      \htmlref{PSX\_LOCALTIME}{PSX_LOCALTIME}
      or
      \htmlref{PSX\_GMTIME}{PSX_GMTIME}.
   }
   \sstinvocation{
      CALL PSX\_ASCTIME( TSTRCT, STRING, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TSTRCT = POINTER (Given)
      }{
         The pointer to the time structure.
      }
      \sstsubsection{
         STRING = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The character string representation of the time.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         \begin{tabular}{rl}
          & CALL PSX\_TIME( NTICKS, STATUS )\\
          & CALL PSX\_LOCALTIME( NTICKS, SEC, MINS, HOUR, DAY, MONTH, YEAR,\\
         : & \mbox{}  WDAY, YDAY, ISDST, TSTRCT, STATUS )\\
          & CALL PSX\_ASCTIME( TSTRCT, STRING, STATUS )\\
          & PRINT $*$,'The time is ', STRING
         \end{tabular}
      }{
          Prints the current local time as something like:\\
          \texttt{"Wed Apr 17 09:01:04 1991"} (without the quotes).
      }
   }
   \sstnotes{
      \sstitemlist{
         \sstitem
         TSTRCT is declared to be of type POINTER. This is usually
            represented in FORTRAN as an INTEGER, although any type that
            uses the same amount of storage would be just as good.

         \sstitem
         The C string returned by the function localtime contains a new
            line character. This is removed before being passed back to
            the calling FORTRAN routine.

         \sstitem
         The actual argument corresponding to STRING should be at least
            24 characters long.
      }
   }

   \sstdiytopic{
      External Routines Used
   }{
      cnf: cnfCptr, cnfExprt
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 8.1

         \sstitem
         ANSI C standard (1989), section 4.12.3.1
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_CALLOC
}{
   Allocate space for several objects of specified type
}{
   \sstdescription{
      The routine allocates an amount of virtual memory specified by
      NMEMB and TYPE. The number of bytes allocated is equal to the
      number of bytes required to store a single variable of type TYPE,
      multiplied by NMEMB. A pointer to the allocated storage is
      returned in PNTR. This pointer can be passed on to other
      subroutines using the \%VAL construct. If the storage cannot be
      allocated, then PNTR is set to zero, STATUS is set to PSX\_\_NOALL
      and an error is reported.
   }
   \sstinvocation{
      CALL PSX\_CALLOC( NMEMB, TYPE, PNTR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NMEMB = INTEGER (Given)
      }{
         The number of locations of TYPE required
      }
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The type of each location
      }
      \sstsubsection{
         PNTR = POINTER (Returned)
      }{
         A pointer to the allocated storage.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CALL PSX\_CALLOC( 20, '\_INTEGER', PNTR, STATUS )\\
         CALL SUB1( \%VAL(PNTR), 20, STATUS  )\\
             ...\\
         SUBROUTINE SUB1( ARRAY, N, STATUS )\\
         INTEGER N\\
         INTEGER ARRAY( N )\\
              ...
      }{
         Generates storage for an array.

         The call to PSX\_CALLOC allocates storage for a 20 element array
         of type INTEGER. The pointer to this storage is then passed to
         subroutine SUB1, where it is accessed as an array of INTEGERs.
         We assume SUB1 returns without action if STATUS is bad.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Storage allocated by PSX\_CALLOC should be returned by a call to
            \htmlref{PSX\_FREE}{PSX_FREE}
            when it is no longer needed.

         \sstitem
         PNTR is declared to be of type POINTER. This is usually
            represented in FORTRAN as an INTEGER, although any type that
            uses the same amount of storage would be just as good.
            The pointer will have been registered for C and FORTRAN use
            according to the scheme described in
            \xref{SUN/209}{sun209}{pointers},
            allowing its use where pointers are longer than INTEGERs.
            For portability, the construct
            \%VAL(\xref{CNF\_PVAL}{sun209}
            {accessing_dynamic_memory_from_c_and_fortran}(PNTR)),
            rather than simply \%VAL(PNTR),
            should be used to pass the pointer to the subroutine.
             Function CNF\_PVAL is described in SUN/209 Section
            `Pointers'.

         \sstitem
         If several calls to PSX\_CALLOC are made, the space returned by
            each call is completely separate from that made by any other
            call. In particular, the program should not assume that the
            space returned by successive calls is contiguous.

         \sstitem
         PSX\_CALLOC differs from the POSIX function calloc in that the
            size of each member to be allocated is specified by a character
            string (TYPE) rather than as a numerical value. This has been
            done to increase the portability of the routine.

         \sstitem
         The allowed values of TYPE are \_INTEGER, \_REAL, \_DOUBLE,
            \_LOGICAL, \_CHAR, \_BYTE, \_UBYTE, \_WORD and \_UWORD.
            The number of bytes allocated for each is as defined in the
            f77.h header file.
      }
   }

   \sstdiytopic{
      External Routines Used
   }{
      cnf: cnf Calloc, cnfFptr, cnfImpn
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 8.1

         \sstitem
         ANSI C standard (1989), section 4.10.3.1
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_CHDIR
}{
   Change current working directory
}{
   \sstdescription{
      Provides a Fortran interface to change working directory.
   }
   \sstinvocation{
      CALL PSX\_CHDIR( DIR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DIR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         On exit contains the name of the current directory. Status will be set to
         PSX\_\_ERRNO on error.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         The global status. No action takes place if status is bad on entry.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX Standard IEEE Std 1003.1-1988
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) Particle Physics and Astronomy Research Council 2006
   }
}

\sstroutine{
   PSX\_CTIME
}{
   Convert the calendar time to a character string
}{
   \sstdescription{
      Convert the number of ticks since the beginning of the calendar
      (the value returned by
      \htmlref{PSX\_TIME}{PSX_TIME})
      to a character string.
   }
   \sstinvocation{
      CALL PSX\_CTIME( NTICKS, STRING, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NTICKS = INTEGER (Given)
      }{
         The number of ticks since the start of the calendar.
      }
      \sstsubsection{
         STRING = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The character string representation of the time.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CALL PSX\_TIME( NTICKS, STATUS )\\
         CALL PSX\_CTIME( NTICKS, STRING, STATUS )\\
         PRINT $*$,'The time is ',STRING\\
      }{
         Prints the current time as something like:\\
         \texttt{"Wed Apr 17 09:01:04 1991"} (without the quotes).
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The C string returned by the POSIX function ctime contains a
            new line character. This is removed before being passed back
            to the FORTRAN routine.

         \sstitem
         The actual argument corresponding to STRING should be at least
            24 characters long.
      }
   }

   \sstdiytopic{
      External Routines Used
   }{
      cnf: cnfExprt
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 8.1

         \sstitem
         ANSI C standard (1989), section 4.12.3.2
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_CUSERID
}{
   Get the username
}{
   \sstdescription{
      This routine will get a username associated with the effective
      user ID of the current process.  If the username cannot be found,
      a blank string is returned.

   }
   \sstinvocation{
      CALL PSX\_CUSERID( USER, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         USER = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The username
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         On a Unix system the translation from effective user ID to
            username is performed. Since there can be several usernames
            associated with a user ID, there is no guarantee that the value
            returned will be unique.

         \sstitem
         The Unix function cuserid is no longer in the IEEE 1003.1-1990
            standard, so an alternative to this routine should be used.

         \sstitem
         If the first attempt to get the username fails, one more attempt
            is made. This overcomes an occasional (timing?) problem on Linux.

     }
   }

   \sstdiytopic{
      External Routines Used
   }{
      cnf: cnfExprt
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 4.2.4
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_FREE
}{
   Free virtual memory
}{
   \sstdescription{
      The routine frees the virtual memory pointed to by PNTR that was
      previously allocated by a call to
      \htmlref{PSX\_CALLOC}{PSX_CALLOC}
      or
      \htmlref{PSX\_MALLOC}{PSX_MALLOC}.
   }
   \sstinvocation{
      CALL PSX\_FREE( PNTR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNTR = POINTER (Given and Returned)
      }{
         A pointer to the allocated storage.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         PNTR is declared to be of type POINTER. This is usually
            represented in FORTRAN as an INTEGER, although any type that
            uses the same amount of storage would be just as good.
      }
   }

   \sstdiytopic{
      External Routines Used
   }{
      cnf: cnfCptr, cnfFree
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 8.1

         \sstitem
         ANSI C standard (1989), section 4.10.3.2
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_GETCWD
}{
   Rename a file
}{
   \sstdescription{
      Provides a Fortran interface to obtain the current working directory.
      Some Fortran implementations provide a GETCWD builtin but this is provided
      for compatibility.
   }
   \sstinvocation{
      CALL PSX\_GETWCD( CWD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CWD = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         On exit contains the name of the current directory. Status will be set to
         PSX\_\_TRUNC if the string is too short to hold the directory.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      Internally, may use getwd or getcwd.
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX Standard ISO/IEC 9945-1:1990
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) Particle Physics and Astronomy Research Council 2006
   }
}
\sstroutine{
   PSX\_GETEGID
}{
   Gets the effective group ID
}{
   \sstdescription{
      The routine obtains the effective group identification number of the
      calling process and returns the value in GID.
   }
   \sstinvocation{
      CALL PSX\_GETEGID( GID, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         GID = INTEGER (Returned)
      }{
         The value of the effective group ID.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 4.2.1
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_GETENV
}{
   Translate an environment variable
}{
   \sstdescription{
      The routine tries to get the translation of the environment
      variable NAME. If it succeeds, it returns the translation in
      TRANS. If it fails, it sets STATUS to PSX\_\_NOENV and reports
      an error.
   }
   \sstinvocation{
      CALL PSX\_GETENV( NAME, TRANS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the environment variable to be translated.
      }
      \sstsubsection{
         TRANS = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The translation of the environment variable.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CALL PSX\_GETENV( \texttt{'}USER\texttt{'}, TRANS, STATUS )
      }{
         This will return the value of the environment variable USER,
         i.e. the username of the current process.
      }
   }

   \sstdiytopic{
      External Routines Used
   }{
      cnf: cnfCreim, cnfExprt, cnfFree
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 4.6.1

         \sstitem
         ANSI C standard (1989), section 4.10.4.4
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_GETEUID
}{
   Gets the effective user ID
}{
   \sstdescription{
      The routine obtains the effective user identification number of the
      calling process and returns the value in UID.
   }
   \sstinvocation{
      CALL PSX\_GETEUID( UID, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         UID = INTEGER (Returned)
      }{
         The value of the effective user ID.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 4.2.1
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_GETGID
}{
   Gets the real group ID
}{
   \sstdescription{
      The routine obtains the real group identification number of the calling
      process and returns the value in GID.
   }
   \sstinvocation{
      CALL PSX\_GETGID( GID, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         GID = INTEGER (Returned)
      }{
         The value of the real group ID.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 4.2.1
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_GETPID
}{
   Gets the process ID
}{
   \sstdescription{
      The routine obtains the process identification number of the current
      process and returns the value in PID.
   }
   \sstinvocation{
      CALL PSX\_GETPID( PID, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PID = INTEGER (Returned)
      }{
         The value of the process ID.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         When the same program is run several times on a Unix system,
           a different PID is returned every time.
      }
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 4.1.1
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_GETPPID
}{
   Gets the process ID of the parent process
}{
   \sstdescription{
      The routine obtains the process identification number of the parent
      process and returns the value in PID.
   }
   \sstinvocation{
      CALL PSX\_GETPPID( PID, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PID = INTEGER (Returned)
      }{
         The value of the process ID of the parent process.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If a program that calls this routine is run several times, then
           unlike GETPID, it will always return the same process ID as all
           the processes will have the same parent.
      }
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 4.1.1
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_GETUID
}{
   Gets the real user ID
}{
   \sstdescription{
      The routine obtains the real user identification number of the calling
      process and returns the value in UID.
   }
   \sstinvocation{
      CALL PSX\_GETUID( UID, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         UID = INTEGER (Returned)
      }{
         The value of the real user ID.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 4.2.1
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_GMTIME
}{
   Convert the value returned by PSX\_TIME to individual GMT values
}{
   \sstdescription{
      Convert the value returned by PSX\_TIME into a set of usable
      numbers expressed in GMT, and a pointer to the corresponding C structure.
      If GMT is not available, STATUS will be set to PSX\_\_NOGMT and an error
      is reported.
   }
   \sstinvocation{
       CALL PSX\_GMTIME( NTICKS, SECS, MINS, HOURS, DAY, MONTH, YEAR,\\
      :   WDAY, YDAY, TSTRCT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NTICKS = INTEGER (Given)
      }{
         The number of ticks since the start of the calendar.
      }
      \sstsubsection{
         SECS = INTEGER (Returned)
      }{
         The number of seconds in the current time.
      }
      \sstsubsection{
         MINS = INTEGER (Returned)
      }{
         The number of minutes in the current time.
      }
      \sstsubsection{
         HOURS = INTEGER (Returned)
      }{
         The number of hours in the current time.
      }
      \sstsubsection{
         DAY = INTEGER (Returned)
      }{
         The number of the day of the month.
      }
      \sstsubsection{
         MONTH = INTEGER (Returned)
      }{
         The number of the month in the year.
      }
      \sstsubsection{
         YEAR = INTEGER (Returned)
      }{
         The number of the years since 1900.
      }
      \sstsubsection{
         WDAY = INTEGER (Returned)
      }{
         The number of the day in the week.
      }
      \sstsubsection{
         YDAY = INTEGER (Returned)
      }{
         The number of the day in the year.
      }
      \sstsubsection{
         TSTRCT = POINTER (Returned)
      }{
         A pointer to the C time structure.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The value of MONTH is 0 for January, 1 for February, etc. This
            is to maintain compatibility with the C run time library.

         \sstitem
         The value of YEAR is 0 for 1900, 100 for 2000, 101 for 2001, etc.

         \sstitem
         The value of YDAY is 0 for the first of January, 1 for the
            second of January, etc. This is to maintain compatibility with
            the C run time library.

         \sstitem
         The value of WDAY is 0 for Sunday, 1 for Monday, etc.

         \sstitem
         The pointer TSTRCT points to the C structure that contains the
            information about the time. This pointer is needed as it may be
            passed on to
            \htmlref{PSX\_ASCTIME}{PSX_ASCTIME}.
            The structure will be overwritten by any future call to
            PSX\_GMTIME or
            \htmlref{PSX\_\-LOCALTIME}{PSX_LOCALTIME}.

         \sstitem
         TSTRCT is declared to be of type POINTER. This is usually
            represented in FORTRAN as an INTEGER, although any type that
             uses the same amount of storage would be just as good.
      }
   }

   \sstdiytopic{
      External Routines Used
   }{
      cnf: cnfFptr, cnfMalloc
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 4.2.1

         \sstitem
         ANSI C standard (1989), section 4.12.3.3
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 2000 Council for the Central Laboratory of the Research
      Councils
   }
}
\sstroutine{
   PSX\_ISATTY
}{
   Determine if a file is a terminal
}{
   \sstdescription{
      Determine if FILDSC is a valid file descriptor associated with a
      terminal. ISTTY is set to TRUE if the file descriptor is
      associated with a terminal and FALSE otherwise.
   }
   \sstinvocation{
      CALL PSX\_ISATTY( FILDSC, ISTTY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FILDSC = INTEGER (Given)
      }{
         The file descriptor, which is just an integer.
      }
      \sstsubsection{
         ISTTY = LOGICAL (Returned)
      }{
         Is the file descriptor associated with a terminal?
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CALL PSX\_ISATTY( 0, ISTTY, STATUS )
      }{
         Is the standard input channel a terminal?
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         On Unix the standard file descriptors are 0,1,2, for stdin,
            stdout and stderr, respectively.
      }
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 4.7.2
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_LOCALTIME
}{
   Convert the value returned by PSX\_TIME to individual local time values
}{
   \sstdescription{
      Convert the value returned by PSX\_TIME into a set of usable
      numbers expressed in local time, and a pointer to the corresponding C
      structure.
   }
   \sstinvocation{
       CALL PSX\_LOCALTIME( NTICKS, SECS, MINS, HOURS, DAY, MONTH, YEAR,\\
      :   WDAY, YDAY, ISDST, TSTRCT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NTICKS = INTEGER (Given)
      }{
         The number of ticks since the start of the calendar.
      }
      \sstsubsection{
         SECS = INTEGER (Returned)
      }{
         The number of seconds in the current time.
      }
      \sstsubsection{
         MINS = INTEGER (Returned)
      }{
         The number of minutes in the current time.
      }
      \sstsubsection{
         HOURS = INTEGER (Returned)
      }{
         The number of hours in the current time.
      }
      \sstsubsection{
         DAY = INTEGER (Returned)
      }{
         The number of the day of the month.
      }
      \sstsubsection{
         MONTH = INTEGER (Returned)
      }{
         The number of the month in the year.
      }
      \sstsubsection{
         YEAR = INTEGER (Returned)
      }{
         The number of the years since 1900.
      }
      \sstsubsection{
         WDAY = INTEGER (Returned)
      }{
         The number of the day in the week.
      }
      \sstsubsection{
         YDAY = INTEGER (Returned)
      }{
         The number of the day in the year.
      }
      \sstsubsection{
         ISDST = INTEGER (Returned)
      }{
         Daylight savings time flag.
      }
      \sstsubsection{
         TSTRCT = POINTER (Returned)
      }{
         A pointer to the C time structure.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The value of MONTH is 0 for January, 1 for February, etc. This
            is to maintain compatibility with the C run time library.

         \sstitem
         The value of YEAR is 0 for 1900, 100 for 2000, 101 for 2001, etc.

         \sstitem
         The value of YDAY is 0 for the first of January, 1 for the
            second of January, etc. This is to maintain compatibility with
            the C run time library.

         \sstitem
         The value of WDAY is 0 for Sunday, 1 for Monday, etc.

         \sstitem
         The value of ISDST is 1 when daylight saving time is in effect,
            0 when it is not and -1 when the information is not available.

         \sstitem
         The pointer TSTRCT points to the C structure that contains the
            information about the time. This pointer is needed as it may be
            passed on to
            \htmlref{PSX\_ASCTIME}{PSX_ASCTIME}.
            The structure will be overwritten by any future call to
            PSX\_LOCALTIME or
            \htmlref{PSX\_GMTIME}{PSX_GMTIME}.

         \sstitem
         TSTRCT is declared to be of type POINTER. This is usually
            represented in FORTRAN as an INTEGER, although any type that
            uses the same amount of storage would be just as good.
      }
   }

   \sstdiytopic{
      External Routines Used
   }{
      cnf: cnfFptr, cnfMalloc
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 4.2.1

         \sstitem
         ANSI C standard (1989), section 4.12.3.4
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_MALLOC
}{
   Allocate virtual memory
}{
   \sstdescription{
      The routine allocates an amount of virtual memory specified by
      SIZE. The unit of SIZE is the amount of storage required to store
      a single character. A pointer to the allocated storage is
      returned in PNTR. This pointer can be passed on to other
      subroutines using the \%VAL construct. If the storage cannot be
      allocated, then PNTR is set to zero, STATUS is set to PSX\_\_NOALL
      and an error is reported.
   }
   \sstinvocation{
      CALL PSX\_MALLOC( SIZE, PNTR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The amount of virtual memory to be allocated.
      }
      \sstsubsection{
         PNTR = POINTER (Returned)
      }{
         A pointer to the allocated storage.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CALL PSX\_MALLOC( 40, PNTR, STATUS )\\
         CALL SUB1( \%VAL(PNTR), 10, STATUS )\\
            ...\\
         SUBROUTINE SUB1( ARRAY, N, STATUS )\\
         INTEGER N\\
         INTEGER ARRAY( N )\\
            ...\\
      }{
         Allocates 40 bytes and uses this as a 10 element INTEGER array.

         The call to PSX\_MALLOC allocates forty bytes of storage. The
         pointer to this storage is then passed to subroutine SUB1,
         where it is accessed as an array of INTEGERs.
         We assume SUB1 returns without action if STATUS is bad.

         Note that in
         this case the program needs to know that an INTEGER variable
         is stored in four bytes. \emph{This is not portable}. In such a case
         it is better to use PSX\_CALLOC or to use the symbolic
         constants NUM\_NB$<$T$>$ defined in the file PRM\_PAR to determine
         the number of bytes per unit of storage. (See
         \xref{SUN/39}{sun39}{} for a
         description of these constants).
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Storage allocated by PSX\_MALLOC should be returned by a call to
            PSX\_FREE when it is no longer needed.

         \sstitem
         PNTR is declared to be of type POINTER. This is usually
            represented in FORTRAN as an INTEGER, although any type that
            uses the same amount of storage would be just as good.
            The pointer will have been registered for C and FORTRAN use
            according to the scheme described in
            \xref{SUN/209}{sun209}{pointers},
            allowing its use where pointers are longer than INTEGERs.
            For portability, the construct
            \%VAL(\xref{CNF\_PVAL}{sun209}
            {accessing_dynamic_memory_from_c_and_fortran}(PNTR)),
            rather than simply \%VAL(PNTR),
            should be used to pass the pointer to the subroutine.
            Function CNF\_PVAL is described in SUN/209 Section
            `Pointers'.

         \sstitem
         If several calls to PSX\_MALLOC are made, the space returned by
            each call is completely separate from that made by any other
            call. In particular, the program should not assume that the
            space returned by successive calls is contiguous.
      }
   }

   \sstdiytopic{
      External Routines Used
   }{
      cnf: cnfFptr, cnfMalloc
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 8.1

         \sstitem
         ANSI C standard (1989), section 4.10.3.3
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_PUTENV
}{
   Set a new environment variable value
}{
   \sstdescription{
      The routine sets the specified environment variable to the
      supplied value. If it fails it sets STATUS to PSX\_\_NOMEM.
   }
   \sstinvocation{
      CALL PSX\_PUTENV( NAME, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the environment variable to be set.
      }
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The new value of the environment variable.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CALL PSX\_PUTENV( \texttt{'}DATADIR\texttt{'}, DIR, STATUS )
      }{
         Set the DATADIR environment variable to the value stored
         in the DIR character string.
       }
   }

   \sstdiytopic{
      External Routines Used
   }{
      cnf: cnfCreim, cnfExprt, cnfFree
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 4.6.1

         \sstitem
         ANSI C standard (1989), section 4.10.4.4
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 2003 Particle Physics and Astronomy Research Council

   }
}
\sstroutine{
   PSX\_RAND
}{
   Generate a random number
}{
   \sstdescription{
      Generate a random number. The number is generated as the integer
      INUM. The maximum value that this may have is returned as MAXNUM.
      Also the value of INUM divided by MAXNUM is returned as FNUM.
   }
   \sstinvocation{
      CALL PSX\_RAND( INUM, MAXNUM, FNUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INUM = INTEGER (Returned)
      }{
         The random (integer) number.
      }
      \sstsubsection{
         MAXNUM = INTEGER (Returned)
      }{
         The maximum value that INUM may have.
      }
      \sstsubsection{
         FNUM = REAL (Returned)
      }{
         The value INUM/MAXNUM.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A seed for the random number generator may be set with
         \htmlref{PSX\_SRAND}{PSX_SRAND}.

         \sstitem
         The sequence of numbers generated by the operating system
         service that is called by this routine is not always as random
         as it should be. It is probably better to use a different
         routine such as one of the NAG routines. This routine is
         included here for completeness, though.
      }
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 8.1

         \sstitem
         ANSI C standard (1989), section 4.10.2.1
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_REALLOC
}{
   Change the size of an allocated region of virtual memory
}{
   \sstdescription{
      The routine changes the size of the region of virtual memory
      pointed to by PNTR. The new size may be larger or smaller than
      the old size. The contents of the object pointed to by PNTR
      shall be unchanged up to the lesser of the old and new sizes.
   }
   \sstinvocation{
      CALL PSX\_REALLOC( SIZE, PNTR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The new amount of virtual memory required
      }
      \sstsubsection{
         PNTR = POINTER (Given and Returned)
      }{
         A pointer to the allocated storage
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CALL PSX\_MALLOC( 20, PNTR, STATUS )\\
            ...\\
         CALL PSX\_REALLOC( 40, PNTR, STATUS )\\
         CALL SUB1( \%VAL(PNTR), 10, STATUS )\\
            ...\\
         SUBROUTINE SUB1( ARRAY, N, STATUS )\\
         INTEGER N\\
         INTEGER ARRAY( N )\\
            ...\\
      }{
         Allocate 20 bytes of storage, then extend it to 40 bytes.

         The call to
         \htmlref{PSX\_MALLOC}{PSX_MALLOC} allocates twenty bytes of storage.
         The subsequent call to PSX\_REALLOC extends this area to forty
         bytes.  The pointer to this storage is then passed to
         subroutine SUB1, where it is accessed as an array of INTEGERs.
         We assume SUB1 returns without action if STATUS is bad.

         Note that in this case the program needs to know that an
         INTEGER variable is stored in four bytes. \emph{This is not
         portable}. In such a case it is better to use the symbolic
         constants NUM\_NB$<$T$>$ defined in the file PRM\_PAR to determine
         the number of bytes per unit of storage. (See
         \xref{SUN/39}{sun39}{} for a
         description of these constants).
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Storage allocated by PSX\_REALLOC should be returned by a call
            to PSX\_FREE when it is no longer needed.

         \sstitem
         PNTR is declared to be of type POINTER. This is usually
            represented in FORTRAN as an INTEGER, although any type that
            uses the same amount of storage would be just as good.
            The pointer will have been registered for C and FORTRAN use
            according to the scheme described in
            \xref{SUN/209}{sun209}{pointers},
            allowing its use where pointers are longer than INTEGERs.
            For portability, the construct
            \%VAL(\xref{CNF\_PVAL}{sun209}
            {accessing_dynamic_memory_from_c_and_fortran}(PNTR)),
            rather than simply \%VAL(PNTR),
            should be used to pass the pointer to the subroutine.
            Function CNF\_PVAL is described in SUN/209 Section
            `Pointers'.

         \sstitem
         If SIZE is zero, then the space pointed to by PNTR is freed.

         \sstitem
         If the space that PNTR pointed to has been deallocated by a
            call to PSX\_FREE (or to PSX\_REALLOC with SIZE = 0), then it is
            undefined whether the pointer can subsequently be used by
            PSX\_REALLOC.  Consequently this should not be attempted, even
            though it will work on some machines.
      }
   }

   \sstdiytopic{
      External Routines Used
   }{
      cnf: cnfCptr, cnfFptr, cnfMalloc, cnfRegp, cnfUregp
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 8.1

         \sstitem
         ANSI C standard (1989), section 4.10.3.4
      }
   }
\sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_REMOVE
}{
   Remove a file or directory
}{
   \sstdescription{
      This C function calls the \texttt{"}remove\texttt{"} RTL function to remove a specified
      file or directory. It is equivalent to \texttt{"}unlink\texttt{"} for files and \texttt{"}rmdir\texttt{"}
      for directories. A directory must be empty. On error, STATUS is set
     to PSX\_\_ERRNO and the error message will contain the system error
     message.
   }
   \sstinvocation{
      CALL PSX\_REMOVE( PATHNAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PATHNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The path to the file.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The inherited global status.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CALL PSX\_REMOVE( \texttt{'}tmp.dat\texttt{'}, STATUS )
      }{
         This will remove the file tmp.dat
      }
   }
   \sstdiytopic{
      External Routines Used
   }{
      cnf: cnfImprt
      ems: emsSyser
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard, IEEE Std 1003.1
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1999-2004 CLRC
   }
}
\sstroutine{
   PSX\_RENAME
}{
   Rename a file
}{
   \sstdescription{
      Provides a Fortran interface to rename files. The file with the
      name specified by the first argument is renamed to the second
      name.
   }
   \sstinvocation{
      CALL PSX\_RENAME( INFIL, OUTFIL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INFIL = CHARACTER$*$($*$) (Given)
      }{
         The name of the file to rename
      }
      \sstsubsection{
         OUTFIL = CHARACTER$*$($*$) (Given)
      }{
         The new name of the file
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX Standard
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) University of Birmingham, 1995
      Copyright (C) Council for the Central Laboratory of the Research Councils 2001
      Copyright (C) Particle Physics and Astronomy Research Council 2006
   }
}

\sstroutine{
   PSX\_SRAND
}{
   Set the seed for the random number generator
}{
   \sstdescription{
      The argument SEED is used to set a new seed for the sequence of
      random numbers returned by the subroutine PSX\_RAND. If PSX\_SRAND
      is called with the same value of SEED, then the values returned by
      subsequent calls to
      \htmlref{PSX\_RAND}{PSX_RAND} will be the same. If PSX\_RAND is
      called before calling PSX\_SRAND, then the sequence of random
      number returned by PSX\_RAND will be the same as if PSX\_SRAND had
      been called with SEED set to one.
   }
   \sstinvocation{
      CALL PSX\_SRAND( SEED, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SEED = INTEGER (Given)
      }{
         The seed for the random number generator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The range of values allowed for SEED is not specified. It is
            unlikely that values between 1 and the maximum integral value
            that PSX\_RAND can return will cause problems.
      }
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 8.1

         \sstitem
         ANSI C standard (1989), section 4.10.2.2
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_STAT
}{
   Obtain information about a file
}{
   \sstdescription{
      The routine tries to get information about a specified file. If it
      succeeds, it returns the information in either IVAL or CVAL. If it
      fails, it sets STATUS to PSX\_\_ERRNO and reports an error.
   }
   \sstinvocation{
      CALL PSX\_STAT( PATH, ITEM, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PATH = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The full path to the file.
      }
      \sstsubsection{
         ITEM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The item of information required about the file. See \texttt{"}Items\texttt{"}
         below.
      }
      \sstsubsection{
         VALUE = INTEGER (Returned)
      }{
         The value for the requested item of information.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Items
   }{
      The ITEM argument can take any of the following values:

      \sstitemlist{

         \sstitem
         \texttt{"}UID\texttt{"} - user ID of owner.

         \sstitem
         \texttt{"}GID\texttt{"} - group ID of owner.

         \sstitem
         \texttt{"}SIZE\texttt{"} - total file size, in bytes.

         \sstitem
         \texttt{"}ATIME\texttt{"} - time of last access.

         \sstitem
         \texttt{"}CTIME\texttt{"} - time of last status change (e.g. file creation).

         \sstitem
         \texttt{"}MTIME\texttt{"} - time of last modification.

      }
      The time values are returned as the number of ticks since an
      arbitrary point in the past. See PSX\_TIME.
   }
}
\sstroutine{
   PSX\_TIME
}{
   Get the current calendar time
}{
   \sstdescription{
      Determine the current calendar time. The encoding of the value is
      unspecified, but is the number of ticks since some date in the
      past. If it is not possible to get the value of NTICKS, STATUS is
      set to PSX\_\_NOTIM and an error is reported.
   }
   \sstinvocation{
      CALL PSX\_TIME( NTICKS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NTICKS = INTEGER (Returned)
      }{
         The current time.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine is not directly useful in itself, but the value
            returned in NTICKS can be passed to other routines that process
            it further.
      }
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 4.5.1

         \sstitem
         ANSI C standard (1989), section 4.12.2.4
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_TTYNAME
}{
   Get the name of the terminal
}{
   \sstdescription{
      Get the name of the terminal attached to the given file descriptor.
   }
   \sstinvocation{
      CALL PSX\_TTYNAME( FILDSC, TNAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FILDSC = INTEGER (Given)
      }{
         The file descriptor.
      }
      \sstsubsection{
         TNAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of the terminal attached to FILDSC.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CALL PSX\_TTYNAME( 0, TNAME, STATUS )
      }{
         When run on a Unix system, this will return something like
         "/dev/ttyp2" (without the quotes).
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If a terminal name is not found, then a blank string is
            returned in TNAME.
      }
   }

   \sstdiytopic{
      External Routines Used
   }{
      cnf: cnfExprt
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 4.7.2
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}
\sstroutine{
   PSX\_UNAME
}{
   Gets information about the host computer system
}{
   \sstdescription{
      The routine inquires about the operating system, the name of the computer
      and the type of the hardware.
      If an error is detected then STATUS is set to SAI\_\_ERROR and an error
      is reported, although this should not happen.
   }
   \sstinvocation{
      CALL PSX\_UNAME( SYSNAME, NODENAME, RELEASE, VERSION, MACHINE, \\
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SYSNAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Name of the operating system.
      }
      \sstsubsection{
         NODENAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Node name of the computer.
      }
      \sstsubsection{
         RELEASE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Version of the operating system.
      }
      \sstsubsection{
         VERSION = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Sub-version of the operating system.
      }
      \sstsubsection{
         MACHINE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Name of the hardware of the computer.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CALL PSX\_UNAME( SYSNAME, NODENAME, RELEASE, VERSION, MACHINE, STATUS)
      }{
         When run on a SUN workstation, this will return values
         something like:

         \begin{tabular}{ll}
         SYSNAME = &  SunOS \\
         NODENAME = &  rlssp1 \\
         RELEASE = &  4.1.1 \\
         VERSION = &  1 \\
         MACHINE = &  sun4c
         \end{tabular}
      }
      \sstexamplesubsection{
         CALL PSX\_UNAME( SYSNAME, NODENAME, RELEASE, VERSION, MACHINE, STATUS)
      }{
         When run on a DECstation, this will return values something like:

         \begin{tabular}{ll}
         SYSNAME = & ULTRIX \\
         NODENAME = &  rlsux1 \\
         RELEASE = &  4.0 \\
         VERSION = &  0 \\
         MACHINE = &  RISC
         \end{tabular}
      }
   }

   \sstdiytopic{
      External Routines Used
   }{
      cnf: cnfCopyf, cnfExprt
   }

   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         POSIX standard (1988), section 4.4.1
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1991 Science \& Engineering Research Council
   }
}


\newpage
\section{\xlabel{routines_that_have_not_been_implemented}Routines that have not been implemented}
\label{not-implelmented}

This is an alphabetical list of POSIX routines that have been considered for
implementation as PSX routines and have been rejected as unnecessary. Any
routine that has not been implemented, yet is not in the following list has
simply not yet been looked at and may well be done in the future.

If you have a need for any routine that has not been implemented, for whatever
the reason, then please contact the author of this document, who will endeavour
to change this.
\begin{description}
\notimproutine{GETGROUPS}{}{}
            {Get the supplementary group IDs of the calling process}
\notimproutine{SETGID}{}{}
            {Sets the real and effective group ID}
\notimproutine{SETUID}{}{}
            {Sets the real and effective user ID}
\end{description}

\section{\xlabel{notes_for_system_programmers}Notes for System Programmers}

Although the PSX routines appear to the user as FORTRAN subroutines,
they are actually written in C. The FORTRAN~--~C interface is handled
by the macros and functions of Starlink's
\xref{CNF}{sun209}{}
package (see SUN/209).
The use of these macros makes the source code sufficiently portable that it
runs on all Starlink supported hardware platforms.

Despite the fact that the routines are written in C, all character strings are
returned as normal FORTRAN strings with trailing blanks.

The PSX routines call the C run time library.

The PSX routines report errors via
\xref{EMS}{ssn4}{}  (see SSN/4).
While this is a standard
feature of Starlink subroutine libraries, occasionally it will be
necessary \emph{not} to report errors via EMS. For example, if a PSX routine
is used within EMS, and that PSX routine were to report an error then
there is the potential for recursive error reports being generated.
Also, if the PSX routines were needed on a non-Starlink system, then
EMS would not necessarily be present. To try to take account of these
situations, the PSX routines actually call the internal routine
\texttt{psx1\_rep\_c} to report an error. This normally calls
\texttt{emsRep} (the C interface to
\xref{\texttt{EMS\_REP}}{ssn4}{EMS_REP}),
but could be re-coded where required.

% ? End of main text
\end{document}
