\documentclass[twoside,11pt]{article}

% ? Specify used packages
% \usepackage{graphicx}        %  Use this one for final production.
% \usepackage[draft]{graphicx} %  Use this one for drafting.
% ? End of specify used packages

\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocsource}    {sun\stardocnumber}
\newcommand{\stardoccopyright}
{Copyright \copyright\ 2000 Council for the Central Laboratory of the Research Councils}

% Variable part - replace [xxx] as appropriate.
\newcommand{\stardocnumber}    {2.8}
\newcommand{\stardocauthors}   {D.S.\ Berry \\ M.B.\ Taylor}
\newcommand{\stardocdate}      {22nd October 2009}
\newcommand{\stardoctitle}     {NDG \\ [\latex{1ex}]
                                Routines for Accessing Groups of NDFs}
\newcommand{\stardocversion}   {Version 5.8}
\newcommand{\stardocmanual}    {Programmer's Manual}
\newcommand{\stardocabstract}  {
This document describes the routines provided within the NDG subroutine
library for accessing groups of NDF data objects.
}
% ? End of document identification
% -----------------------------------------------------------------------------

% +
%  Name:
%     sun.tex
%
%  Purpose:
%     Template for Starlink User Note (SUN) documents.
%     Refer to SUN/199
%
%  Authors:
%     AJC: A.J.Chipperfield (Starlink, RAL)
%     BLY: M.J.Bly (Starlink, RAL)
%     PWD: Peter W. Draper (Starlink, Durham University)
%
%  History:
%     17-JAN-1996 (AJC):
%        Original with hypertext macros, based on MDL plain originals.
%     16-JUN-1997 (BLY):
%        Adapted for LaTeX2e.
%        Added picture commands.
%     13-AUG-1998 (PWD):
%        Converted for use with LaTeX2HTML version 98.2 and
%        Star2HTML version 1.3.
%      1-FEB-2000 (AJC):
%        Add Copyright statement in LaTeX
%     {Add further history here}
%
% -

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markboth{\stardocname}{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %begin{latexonly} and %end{latexonly} lines (used by
%  LaTeX2HTML to signify text it shouldn't process).
%begin{latexonly}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

\newenvironment{latexonly}{}{}
\newcommand{\latex}[1]{#1}
\newcommand{\html}[1]{}
\newcommand{\latexhtml}[2]{#1}
\newcommand{\HTMLcode}[2][]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{\LaTeX2\texttt{HTML}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\renewcommand{\_}{\texttt{\symbol{95}}}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
%end{latexonly}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.

% Command for displaying routines in routine lists:
% =================================================

\newcommand{\noteroutine}[2]{{\small \bf #1} \\
                              \hspace*{3em} {\em #2} \\[1.5ex]}
\begin{htmlonly}
   \newcommand{\noteroutine}[2]{
      \begin{description}
         \item [{\bf {#1}}] {\em #2}
      \end{description}
   }
\end{htmlonly}

% Latex only section. Surround this with a latexonly environment.
\newcommand{\latexonlysection}[1]{\section{#1}}
\begin{htmlonly}
   \newcommand{\latexonlysection}[1]{#1}
\end{htmlonly}

%+
%  Name:
%     SST.TEX

%  Purpose:
%     Define LaTeX commands for laying out Starlink routine descriptions.

%  Language:
%     LaTeX

%  Type of Module:
%     LaTeX data file.

%  Description:
%     This file defines LaTeX commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by LaTeX and
%     by LaTeX2html. The contents of this file should be included in the
%     source prior to any statements that make use of the sst commands.

%  Notes:
%     The style file html.sty provided with LaTeX2html needs to be used.
%     This must be before this file.

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)
%     PDRAPER: P.W. Draper (Starlink - Durham University)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     8-DEC-1994 (PDRAPER):
%        Added support for simplified formatting using LaTeX2html.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

%-

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}
\newlength{\sstexampleslength}
\newlength{\sstexampleswidth}

%  Define a \tt font of the required size.
\latex{\newfont{\ssttt}{cmtt10 scaled 1095}}
\html{\newcommand{\ssttt}{\tt}}

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \setlength{\sstexampleslength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-5.0pt}
   \settowidth{\sstexampleswidth}{{\bf Examples:}}
   \addtolength{\sstexampleslength}{-\sstexampleswidth}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{}
\\[1.3ex]{\raggedright \ssttt #1}}

%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{ \item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[2]{\sloppy
\item[\parbox{\sstexampleslength}{\ssttt #1}] \mbox{} \vspace{1.0ex}
\\ #2 }

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}]
\mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%% Now define html equivalents of those already set. These are used by
%  latex2html and are defined in the html.sty files.
\begin{htmlonly}

%  sstroutine.
   \newcommand{\sstroutine}[3]{
      \subsection{#1\xlabel{#1}-\label{#1}#2}
      \begin{description}
         #3
      \end{description}
   }

%  sstdescription
   \newcommand{\sstdescription}[1]{\item[Description:]
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstusage
   \newcommand{\sstusage}[1]{\item[Usage:]
      \begin{description}
         {\ssttt #1}
      \end{description}
      \\
   }

%  sstinvocation
   \newcommand{\sstinvocation}[1]{\item[Invocation:]
      \begin{description}
         {\ssttt #1}
      \end{description}
      \\
   }

%  sstarguments
   \newcommand{\sstarguments}[1]{
      \item[Arguments:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstreturnedvalue
   \newcommand{\sstreturnedvalue}[1]{
      \item[Returned Value:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstparameters
   \newcommand{\sstparameters}[1]{
      \item[Parameters:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstexamples
   \newcommand{\sstexamples}[1]{
      \item[Examples:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstsubsection
   \newcommand{\sstsubsection}[1]{\item[{#1}]}

%  sstexamplesubsection
   \newcommand{\sstexamplesubsection}[2]{\item[{\ssttt #1}] #2}

%  sstnotes
   \newcommand{\sstnotes}[1]{\item[Notes:] #1 }

%  sstdiytopic
   \newcommand{\sstdiytopic}[2]{\item[{#1}] #2 }

%  sstimplementationstatus
   \newcommand{\sstimplementationstatus}[1]{
      \item[Implementation Status:] #1
   }

%  sstitemlist
   \newcommand{\sstitemlist}[1]{
      \begin{itemize}
         #1
      \end{itemize}
      \\
   }
%  sstitem
   \newcommand{\sstitem}{\item}

\end{htmlonly}

%  End of "sst.tex" layout definitions.
%.



% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / \textsc{Rutherford Appleton Laboratory} \hfill \textbf{\stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Huge\textbf{\stardoctitle \\ [2.5ex]}}
   {\LARGE\textbf{\stardocversion \\ [4ex]}}
   {\Huge\textbf{\stardocmanual}}
   \end{center}
   \vspace{5mm}

% ? Add picture here if required for the LaTeX version.
%   e.g. \includegraphics[scale=0.3]{filename.ps}
% ? End of picture

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\textbf{Abstract}}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1> \end{rawhtml}
      \stardoctitle\\
      \stardocversion\\
      \stardocmanual
   \begin{rawhtml} </H1> <HR> \end{rawhtml}

% ? Add picture here if required for the hypertext version.
%   e.g. \includegraphics[scale=0.7]{filename.ps}
% ? End of picture

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory\ \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC / Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://www.starlink.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://www.starlink.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents.
%  ================================
%  Add table of contents header and a navigation button to return to this
%  point in the document (this should always go before the abstract \section).
  \label{stardoccontents}
  \begin{rawhtml}
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}
% ? End of new section for abstract
\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%  ==================
\stardocabstract
% ? End of document abstract

% -----------------------------------------------------------------------------
% ? Latex Copyright Statement
%  =========================
\begin{latexonly}
\newpage
\vspace*{\fill}
\stardoccopyright
\end{latexonly}
% ? End of Latex copyright statement

% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
  \newpage
  \begin{latexonly}
    \setlength{\parskip}{0mm}
    \tableofcontents
    \setlength{\parskip}{\medskipamount}
    \markboth{\stardocname}{\stardocname}
  \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------

\cleardoublepage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

\section {Introduction}

If an application prompts the user for an NDF using the facilities of the NDF\_
system (see \xref{SUN/33}{sun33}{}), the user may only reply with the name of a single NDF. Some
applications allow many input NDFs to be specified and the need to
type in every NDF name explicitly each time the program is run can become time
consuming. The NDG package provides a means of giving the user the
ability to specify a list (or ``Group'') of NDFs as a reply to a single prompt
for an parameter.

The current version of NDG can process NDFs which are stored as
components within an HDS container file, and can also process foreign
data formats using the system described in \xref{SSN/20}{ssn20}{}.


\section {Interaction Between NDG and GRP}
NDG uses the facilities of the GRP package and users of NDG should be familiar
with the content of \xref{SUN/150}{sun150}{} which describes the GRP package. Groups
created by NDG routines should be deleted when no longer needed using
\xref{GRP\_DELET}{sun150}{GRP\_DELET}.

\section {General overview of the NDG\_ system}
As a broad outline, applications use the NDG\_ package as follows:

\begin{enumerate}

\item A call is made to \htmlref{NDG\_ASSOC}{NDG\_ASSOC} which causes the user
to be prompted for a single parameter. This parameter can be of any type.
The user replies with a ``group expression'' (see
\xref{SUN/150}{sun150}{}), which contains the names of a group of {\em
existing} NDFs to be used as inputs by the application\footnote{The routine
\htmlref{NDG\_ASEXP}{NDG\_ASEXP} performs the same function but does not
use the parameter system - it expects the group expression to be supplied by
the calling routine.}. For instance, the group expression may be

\begin{verbatim}
     m51_b[23]s1_ds,m51_b[23]s2_ds,m51_b[23]s2?_ds,^files.lis
\end{verbatim}

This is a complicated example, probably more complicated than would be
used in practice, but it highlights the facilities of the GRP and NDG
packages, e.g. wild cards (``?'', ``$*$'' or ``[..]'' ), lists of files,
or indirection through a text file (``\verb+^+'').

The \htmlref{NDG\_ASSOC}{NDG\_ASSOC} routine produces a list of explicit NDF names, which are stored
internally within the GRP system.

\item What happens next depends on the application, but a common example may be
the initiation of a DO loop to loop through the input NDFs (NDG\_ASSOC returns
the total number of NDF names in the group).

\item To access a particular NDF, the application calls routine \htmlref{NDG\_NDFAS}{NDG\_NDFAS}
supplying an index, $n$, within the group (i.e $n$ is an integer in the range 1
to the group size returned by NDG\_ASSOC). NDG\_NDFAS returns an NDF identifier
to the $n$th NDF in the group. This identifier can then be used to access the
NDF in the normal manner using the NDF\_ routines (\xref{SUN/33}{sun33}{}). The identifier
should be annulled when it is no longer needed using \xref{NDF\_ANNUL}{sun33}{NDF\_ANNUL} in the
normal way.

\item Once the application has finished processing the group of NDFs, it calls
\xref{GRP\_DELET}{sun150}{GRP\_DELET} which deletes the group, releasing all resources reserved by the group.

\item Routine NDG\_ASSOC can also be used to append a list of NDF names
obtained from the environment, to a previously defined group.

The routine \htmlref{NDG\_CREAT}{NDG\_CREAT} produces a group containing the names of
NDFs which are to be created by the application. The routine \htmlref{NDG\_NDFCR}{NDG\_NDFCR} will
create a new NDF with a name given by a group member, and returns an NDF
identifier to it. Routine \htmlref{NDG\_NDFPR}{NDG\_NDFPR} creates a new NDF by propagation from a
previously existing NDF, in a similar manner to the NDF routine \xref{NDF\_PROP}{sun33}{NDF\_PROP} (see
\xref{SUN/33}{sun33}{}).

The names of output NDFs given by users usually relate to the input NDF names.
When NDG\_CREAT is called, it creates a group of NDF names either by modifying
all the names in a specified input group using a ``modification element'' (see
\xref{SUN/150}{sun150}{}), or by getting a list of new names from the user.

\item Applications which produce a group of output NDFs could also produce a
text file holding the names of the output NDFs. Such a file can be used
as input to the next application, using the indirection facility. A text
file listing of all the NDFs in a group can be produced by routine
GRP\_LIST (or GRP\_LISTF).

\end{enumerate}

See the detailed descriptions of \htmlref{NDG\_ASSOC}{NDG\_ASSOC} and \htmlref{NDG\_CREAT}{NDG\_CREAT} below for details
of the processing of existing and new NDF names.

\section{An example NDG application}

The following gives a short example of how NDG routines might be
used within an ADAM task.
\begin{quote}
\latexonly{\small}
\begin{verbatim}
      SUBROUTINE COPY( STATUS )

*  Global Constants:
      INCLUDE 'GRP_PAR'          ! Standard GRP constants

*  Local Variables:
      INTEGER GIDIN              ! GRP identifier for group of input NDFs
      INTEGER GIDOUT             ! GRP identifer for group of output NDFs
      INTEGER I                  ! Loop counter
      INTEGER NDFIN              ! NDF identifier for input NDF
      INTEGER NDFOUT             ! NDF identifier for output NDF
      INTEGER NUMIN              ! Number of input NDFs
      INTEGER NUMOUT             ! Number of output NDFs
      INTEGER STATUS             ! The global status
      LOGICAL FLAG               ! Has group ended with flag character?
*.

*  Inialise the group identifiers to indicate that groups do not have
*  any initial members.
      GIDIN = GRP__NOID
      GIDOUT = GRP__NOID

*  Create group of input NDFs using the parameter IN.
      CALL NDG_ASSOC( 'IN', .TRUE., GIDIN, NUMIN, FLAG, STATUS )

*  Create group of output NDFs using the parameter OUT, which possibly
*  works by modifying the values in the input group.
      CALL NDG_CREAT( 'OUT', GIDIN, GIDOUT, NUMOUT, FLAG, STATUS )

*  Loop over group members.
      DO I = 1, NUMIN

*  Get the identifier for an existing NDF from the input group.
         CALL NDG_NDFAS( GIDIN, I, 'READ', NDFIN, STATUS )

*  Create a new NDF by propagation using the name in the output group.
         CALL NDG_NDFPR( NDFIN, 'Data,Variance,Quality,WCS', GIDOUT, I,
     :                   NDFOUT, STATUS )

*  Relase NDF resources.
         CALL NDF_ANNUL( NDFIN, STATUS )
         CALL NDF_ANNUL( NDFOUT, STATUS )
      END DO

*  Release GRP resources.
      CALL GRP_DELET( GIDIN, STATUS )
      CALL GRP_DELET( GIDOUT, STATUS )

      END
\end{verbatim}
\end{quote}
When this program is compiled and run, the user is asked for
two ADAM parameters, IN and OUT.  Each NDF in the list specified
by the IN parameter is simply copied to the corresponding name in the
list specified by the OUT parameter.  For instance, running
\begin{quote}
\latexonly{\small}
\begin{verbatim}
copy in=data[12] out=*-new
\end{verbatim}
\end{quote}
would write new NDFs {\tt data1-new.sdf} and {\tt data2-new.sdf}
which were copies of the existing files {\tt data1.sdf} and {\tt data2.sdf}.
If {\tt data1} and {\tt data2} do not represent NDF structures,
an error will be signalled and the user will be prompted to enter
a different value for IN.
If any of the elements of the IN list represents an HDS container file
which holds multiple NDF structures directly within it, each of these
will be added to the list of NDFs to be processed, and the
output list will be constructed with a corresponding structure.
For instance, if the HDS file {\tt obs.sdf} contains three NDFs at
its top level called O1, O2 and O3, then invoking
\begin{quote}
\latexonly{\small}
\begin{verbatim}
copy in=obs out=obs-copy
\end{verbatim}
\end{quote}
will result in a new container file {\tt obs-copy.sdf} being written,
which contains three NDF structures called O1, O2 and O3.

Note that a few corners have been cut in the above code,
in particular checking that the input and output groups have the
same size and STATUS testing.  Additionally, no action is taken
when the FLAG character is given at the end of a group specification --
conventionally this would indicate that the user should be allowed
to add further members.

\appendix

\begin{latexonly}
\latexonlysection{List of Routines}

\noteroutine{
      CALL NDG\_ASEXP( GRPEXP, VERB, IGRP1, IGRP2, SIZE, FLAG, STATUS )
}{
   Store names of existing NDFs supplied as a group expression by the
   calling routine.
}
\noteroutine{
      CALL NDG\_ASSO1( PARAM, VERB, MODE, INDF, FIELDS, STATUS )
}{
   Obtain an identifier for a single existing NDF using a specified
   parameter
}
\noteroutine{
      CALL NDG\_ASSOC( PARAM, VERB, IGRP, SIZE, FLAG, STATUS )
}{
   Store names of existing NDFs specified through the environment
}
\noteroutine{
      CALL NDG\_CREA1( PARAM, FTYPE, NDIM, LBND, UBND, INDF, NAME,
                      STATUS )
}{
   Create a single new simple NDF using a specified parameter
}
\noteroutine{
      CALL NDG\_CREAT( PARAM, IGRP0, IGRP, SIZE, FLAG, STATUS )
}{
   Obtain the names of a group of NDF to be created from the
   environment
}
\noteroutine{
      CALL NDG\_CREP1( PARAM, FTYPE, NDIM, UBND, INDF, NAME, STATUS )
}{
   Create a single new primitive NDF using a specified parameter
}
\noteroutine{
      CALL NDG\_GTSUP( IGRP, I, FIELDS, STATUS )
}{
   Get supplemental information for an NDF
}
\noteroutine{
      CALL NDG\_NDFAS( IGRP, INDEX, MODE, INDF, STATUS )
}{
   Obtain an NDF identifier for an existing NDF
}
\noteroutine{
      CALL NDG\_NDFCO( INDF1, IGRP, INDEX, INDF2, STATUS )
}{
   Obtain an NDF identifier for a new NDF created by copying an
   existing NDF
}
\noteroutine{
      CALL NDG\_NDFCP( IGRP, INDEX, FTYPE, NDIM, UBND, INDF, STATUS )
}{
   Obtain an NDF identifier for a new primitive NDF
}
\noteroutine{
      CALL NDG\_NDFCR( IGRP, INDEX, FTYPE, NDIM, LBND, UBND, INDF,
                      STATUS )
}{
   Obtain an NDF identifier for a new simple NDF
}
\noteroutine{
      CALL NDG\_NDFPR( INDF1, CLIST, IGRP, INDEX, INDF2, STATUS )
}{
   Obtain an NDF identifier for a new NDF created by propagation from
   an existing NDF
}
\noteroutine{
      CALL NDG\_PROP1( INDF1, CLIST, PARAM, INDF2, NAME, STATUS )
}{
   Create a single new NDF by propagation using a specified parameter
}
\noteroutine{
      CALL NDG\_PTSUP( IGRP, I, FIELDS, STATUS )
}{
   Store supplemental information for an NDF
}
\noteroutine{
      CALL NDG\_SETSZ( IGRP, SIZE, STATUS )
}{
   Reduces the size of an NDG group
}

\end{latexonly}


\section{Routines for accessing groups of NDFs}
\label {SEC:FULLSPEC}

% Routine descriptions:
% =====================
\small


\sstroutine{
   NDG\_ASEXP
}{
   Store names of existing NDFs supplied as a group expression
}{
   \sstdescription{
      The supplied group expression is parsed (using the facilities of
      the GRP routine GRP\_GROUP, see SUN/150) to produce a list of
      explicit names for existing NDFs which are appended to the end of
      the supplied group (a new group is created if none is supplied).
      NDF identifiers for particular members of the group can be obtained
      using NDG\_NDFAS.

      If any of the NDFs specified by the group expression cannot be
      accessed, an error is reported and STATUS is returned equal to
      NDG\_\_NOFIL. If this happens strings holding the name of each
      bad NDF are appended to the group identified by IGRP1 (so long
      as IGRP1 is not equal to GRP\_\_NOID).
   }
   \sstinvocation{
      CALL NDG\_ASEXP( GRPEXP, VERB, IGRP1, IGRP2, SIZE, FLAG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         GRPEXP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The group expression specifying the NDF names to be stored
         in the group.
      }
      \sstsubsection{
         VERB = LOGICAL (Given)
      }{
         If TRUE then errors which occur whilst accessing supplied NDFs
         are flushed so that the user can see the details ({\tt "}verbose{\tt "} mode).
         Otherwise, they are annulled and a general {\tt "}Cannot access file xyz{\tt "}
         message is reported instead.
      }
      \sstsubsection{
         IGRP1 = INTEGER (Given)
      }{
         The identifier of a group to which the names of any
         inaccessible NDFs will be appended. The group should already
         have been created by a call to GRP\_NEW, and should be deleted
         when no longer needed by a call to GRP\_DELET. If IGRP1 is
         supplied equal to symbolic constant GRP\_\_NOID, then no
         information is stored describing the bad NDFs.
      }
      \sstsubsection{
         IGRP2 = INTEGER (Given and Returned)
      }{
         The identifier of the group in which the NDF names are to be
         stored. A new group is created if the supplied value is GRP\_\_NOID.
         It should be deleted when no longer needed using GRP\_DELET.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total number of NDF names in the returned group IGRP2.
      }
      \sstsubsection{
         FLAG = LOGICAL (Returned)
      }{
         If the group expression was terminated by the GRP {\tt "}flag
         character{\tt "}, then FLAG is returned .TRUE. Otherwise it is
         returned .FALSE. Returned .FALSE. if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Any file names containing wildcards are expanded into a list of NDF
         names. The supplied strings are interpreted by a shell (/bin/tcsh if
         it exists, otherwise /bin/csh, otherwise /bin/sh), and so may
         contain shell meta-characters (e.g. twiddle, \$HOME, even command
         substitution and pipes - but pipe characters {\tt "}$|${\tt "} need to be escaped
         using a backslash {\tt "}$\backslash${\tt "} to avoid them being interpreted as GRP
         editing characters).

         \sstitem
         Each supplied name may include an HDS path. For instance,
         {\tt "}/home/dsb/mydata.a.c(1).b{\tt "} refers to an NDF stored in component
         {\tt "}a.c(1).b{\tt "} in the HDS container file /home/dsb/mydata.sdf. Note,
         wild cards are not allowed within HDS component paths (i.e. they
         are only allowed within the specification of the container file).

         \sstitem
         If an HDS object is specified which is not an NDF, then the
         object will be searched for NDF components. This search is
         recursive, in that any components of the specified object are also
         searched. The supplied name will be expanded into a group of names,
         one for each NDF found within the specified HDS object. Note, NDFs
         are not themselves searched for other NDFs. That is, the expanded
         group of names will not include any NDF which is contained within
         another NDF (i.e. NDFs which are stored as an extension item of
         another NDF are not included in the group). For instance, if the
         string {\tt "}fred{\tt "} is given, the HDS file fred.sdf will be searched for
         NDFs and the returned group will contain references for all NDFs
         found within fred.sdf.

         \sstitem
         If the environment variable NDF\_FORMATS\_IN is defined (see
         SSN/20) then all possible NDFs matching the supplied string are
         included in the returned group. For instance, if the string {\tt "}fred{\tt "}
         is supplied, then the returned group will contain references to all
         files with basename fred which also have a file type specified in
         NDF\_FORMATS\_IN. If a FITS file {\tt "}fred.fit{\tt "} exists, and HDS file
         {\tt "}fred.sdf{\tt "} also exists (and contains an NDF), then supplying the
         name {\tt "}fred{\tt "} will result in both being included in the returned
         group. If the file {\tt "}fred.sdf{\tt "} contains a component called {\tt "}.fit{\tt "},
         then this will be included in the returned group in place of
         {\tt "}fred.sdf{\tt "}.

         \sstitem
         NDFs contained within HDS files are opened in order to ensure
         that they are valid NDFs. The NDF name is returned in IGRP1 if there
         are no valid NDFs matching a supplied name. No check is made that any
         foreign data files contain valid NDFs since this would involve a
         potentially expensive data conversion. So, for instance, {\tt "}$*$.fit{\tt "} could
         pick up FITS catalogues as well as FITS images. If a foreign data file
         does not contain a valid NDF, an error will be reported when the NDF
         is accessed using NDG\_NDFAS.

         \sstitem
         Each element in the returned group contains a full specification
         for an NDF. Several other groups are created by this routine, and
         are associated with the returned group by means of a GRP {\tt "}owner-slave{\tt "}
         relationship. These supplemental groups are automatically deleted
         when the returned group is deleted using GRP\_DELET. The returned
         group should not be altered using GRP directly because corresponding
         changes may need to be made to the supplemental groups. Routines
         NDG\_SETSZ, NDG\_GTSUP and NDG\_PTSUP are provided to manipulate the
         entire chain of groups. The full chain (starting from the head) is
         as follows:

         \sstitem
            NDF slice specifications

         \sstitem
            HDS paths

         \sstitem
            File types

         \sstitem
            Base file names

         \sstitem
            Directory paths

         \sstitem
            Full NDF specification (this is the returned group IGRP)
      }
   }
}
\sstroutine{
   NDG\_ASSO1
}{
   Obtain an identifier for a single existing NDF using a specified
   parameter
}{
   \sstdescription{
      This routine is equivalent to NDF\_ASSOC except that it allows the
      NDF to be specified using a GRP group expression (for instance, its
      name may be given within a text file, etc). The first NDF in the
      group expression is returned. Any other names in the group
      expression are ignored. Supplemental information describing the
      separate fields in the NDF specification are also returned.
   }
   \sstinvocation{
      CALL NDG\_ASSO1( PARAM, VERB, MODE, INDF, FIELDS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         VERB = LOGICAL (Given)
      }{
         If TRUE then errors which occur whilst accessing supplied NDFs
         are flushed so that the user can see them before re-prompting for
         a new NDF ({\tt "}verbose{\tt "} mode). Otherwise, they are annulled and
         a general {\tt "}Cannot access file xyz{\tt "} message is displayed before
         re-prompting.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of NDF access required: {\tt '}READ{\tt '}, {\tt '}UPDATE{\tt '} or {\tt '}WRITE{\tt '}.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         FIELDS( 6 ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Each element contains the following on exit:
         \begin{enumerate}
         \item NDF slice specifications
         \item HDS paths
         \item File types
         \item Base file names
         \item Directory paths
         \item Full NDF specification (this is the returned group - IGRP)
         \end{enumerate}
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_ASSOC
}{
   Store names of existing NDFs specified through the environment
}{
   \sstdescription{
      A group expression is obtained from the environment using the
      supplied parameter. The expression is parsed (using the
      facilities of the GRP routine GRP\_GROUP, see \xref{SUN/150}{sun150}{}) to produce
      a list of explicit names for existing NDFs which are appended to the
      end of the supplied group (a new group is created if none is
      supplied). If an error occurs while parsing the group expression, the
      user is re-prompted for a new group expression. NDF identifiers for
      particular members of the group can be obtained using NDG\_NDFAS.
   }
   \sstinvocation{
      CALL NDG\_ASSOC( PARAM, VERB, IGRP, SIZE, FLAG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER$*$($*$) (Given)
      }{
         The parameter with which to associate the group expression.
      }
      \sstsubsection{
         VERB = LOGICAL (Given)
      }{
         If TRUE then errors which occur whilst accessing supplied NDFs
         are flushed so that the user can see them before re-prompting for
         a new NDF ({\tt "}verbose{\tt "} mode). Otherwise, they are annulled and
         a general {\tt "}Cannot access file xyz{\tt "} message is displayed before
         re-prompting.
      }
      \sstsubsection{
         IGRP = INTEGER (Given and Returned)
      }{
         The identifier of the group in which the NDF names are to be
         stored. A new group is created if the supplied value is GRP\_\_NOID.
         It should be deleted when no longer needed using GRP\_DELET.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total number of NDF names in the returned group.
      }
      \sstsubsection{
         FLAG = LOGICAL (Returned)
      }{
         If the group expression was terminated by the GRP {\tt "}flag
         character{\tt "}, then FLAG is returned true. Otherwise it is
         returned false. Returned .FALSE. if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Any file names containing wildcards or "[..]" globbing patterns
	 are expanded into a list of NDF names. The supplied strings are
	 interpreted by a shell (/bin/tcsh if it exists, otherwise
	 /bin/csh, otherwise /bin/sh), and so may contain shell
	 meta-characters (e.g. twiddle, \$HOME, even command substitution
	 and pipes - but pipe characters {\tt "}$|${\tt "} need to be
	 escaped using a backslash {\tt "}$\backslash${\tt "} to avoid
	 them being interpreted as GRP editing characters).

         \sstitem
         Each supplied name may include an HDS path. For instance,
         {\tt "}/home/dsb/mydata.a.c(1).b{\tt "} refers to an NDF stored in component
         {\tt "}a.c(1).b{\tt "} in the HDS container file /home/dsb/mydata.sdf. Note,
         wild cards are not allowed within HDS component paths (i.e. they
         are only allowed within the specification of the container file).

         \sstitem
         If an HDS object is specified which is not an NDF, then the
         object will be searched for NDF components. This search is
         recursive, in that any components of the specified object are also
         searched. The supplied name will be expanded into a group of names,
         one for each NDF found within the specified HDS object. Note, NDFs
         are not themselves searched for other NDFs. That is, the expanded
         group of names will not include any NDF which is contained within
         another NDF (i.e. NDFs which are stored as an extension item of
         another NDF are not included in the group). For instance, if the
         string {\tt "}fred{\tt "} is given, the HDS file fred.sdf will be searched for
         NDFs and the returned group will contain references for all NDFs
         found within fred.sdf.

         \sstitem
         If the environment variable NDF\_FORMATS\_IN is defined (see
         \xref{SSN/20}{ssn20}{}) then only the highest priority file with any give file name
         is included in the returned group. The priority of a file is
         determined by its file type. Native NDFs (.sdf) have highest
         priority. After that, priority decreases along the list of file
         types specified in NDF\_FORMATS\_OUT. If no file type is given by
         the user, the highest priority available file type is used. If an
         explicit file type is given, then that file type is used.

         \sstitem

         Care should be taken if a trailing string enclosed in square
	 brackets is appended to the end of the file name. These are
	 interpreted first as a globbing pattern. Thus {\tt
	 "}fred[12]{\tt "} would match files with base names {\tt
	 "}fred1{\tt "} and {\tt "}fred2{\tt "}. If the pattern does not
	 match any existing files, then the trailing {\tt "}[..]{\tt "}
	 string is next interpreted as a foreign extension specifier.
	 Thus if fred.fit is a multi-extension FITS file, {\tt
	 "}fred[12]{\tt "} would be interpreted as the twelfth image
	 extension in fred.fit only if files cannot be found with
	 basenames {\tt "}fred1{\tt "} or {\tt "}fred2{\tt "}.

         \sstitem
         NDFs contained within HDS files are opened in order to ensure
         that they are valid NDFs. The user is notified if there are no
         valid NDFs matching a supplied name, and they are asked to supply
         a replacement parameter value. No check is made that any foreign
         data files contain valid NDFs since this would involve a potentially
         expensive data conversion. So, for instance, {\tt "}$*$.fit{\tt "} could pick up
         FITS catalogues as well as FITS images. If a foreign data file does
         not contain a valid NDF, an error will be reported when the NDF is
         accessed using NDG\_NDFAS.

         \sstitem
         Each element in the returned group contains a full specification
         for an NDF. Several other groups are created by this routine, and
         are associated with the returned group by means of a GRP {\tt "}owner-slave{\tt "}
         relationship. These supplemental groups are automatically deleted
         when the returned group is deleted using GRP\_DELET. The returned
         group should not be altered using GRP directly because corresponding
         changes may need to be made to the supplemental groups. Routines
         NDG\_SETSZ, NDG\_GTSUP and NDG\_PTSUP are provided to manipulate the
         entire chain of groups. The full chain (starting from the head) is
         as follows:

         \sstitem
            NDF slice specifications

         \sstitem
            HDS paths

         \sstitem
            File types

         \sstitem
            Base file names

         \sstitem
            Directory paths

         \sstitem
            Full NDF specification (this is the returned group IGRP)

         \sstitem
         If an error is reported the group is returned unaltered. If
         no group is supplied, an empty group is returned.

         \sstitem
         A null value (!) can be given for the parameter to indicate
         that no more NDFs are to be specified. The corresponding error
         is annulled before returning unless no NDFs have been added to
         the group.

         \sstitem
         If the last character in the supplied group expression is
         a colon (:), a list of the NDFs represented by the group
         expression (minus the colon) is displayed, but none are
         actually added to the group. The user is then re-prompted for
         a new group expression.
      }
   }
}

\sstroutine{
   NDG\_COPY
}{
   Copy a section of an existing NDG group to a new group
}{
   \sstdescription{
      This routine extends the functionality of GRP\_COPY when copying
      elements from a group created by NDG. Such groups have
      {\tt "}supplemental information{\tt "} associated with them that holds further
      information about each NDF in the group. This function ensures that
      the returned group also has such supplemental information.

      NDG{\tt '}s supplemental information is stored in a chain of {\tt "}slave
      groups{\tt "} that are attached to each other using the facilities of
      GRP (e.g. see GRP\_SOWN). The supplied group is the lowest level
      {\tt "}slave{\tt "} in this chain.
   }
   \sstinvocation{
      CALL NDG\_COPY( IGRP, INDXLO, INDXHI, REJECT, IGRP2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP1 = INTEGER (Given)
      }{
         A GRP identifier for the input group.
      }
      \sstsubsection{
         INDXLO = INTEGER (Given)
      }{
         The lowest index to reject or to copy.
      }
      \sstsubsection{
         INDXHI = INTEGER (Given)
      }{
         The highest index to reject or to copy.
      }
      \sstsubsection{
         REJECT = LOGICAL ( Given)
      }{
         If reject is .TRUE., then names in the given range are
         rejected.  Otherwise, names in the given range are copied.
      }
      \sstsubsection{
         IGRP2 = INTEGER (Returned)
      }{
         A GRP identifier for the created group. Returned equal to
         GRP\_\_NOID if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_CPSUP
}{
   Copy supplemental information for an NDF
}{
   \sstdescription{
      Copies an entry with its supplemental information from one group to
      another, appending it to the end of the output group.
   }
   \sstinvocation{
      CALL NDG\_CPSUP( IGRP1, I, IGRP2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP1 = INTEGER (Given)
      }{
         The NDG group as returned by NDG\_ASSOC, etc.
      }
      \sstsubsection{
         I = INTEGER (Given)
      }{
         The index, within IGRP1, of the entry to copy.
      }
      \sstsubsection{
         IGRP2 = INTEGER (Given)
      }{
         The NDG group to which the copied information should be appended.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_CREA1
}{
   Create a single new simple NDF using a specified parameter
}{
   \sstdescription{
      This routine is equivalent to NDF\_CREAT except that it allows the
      NDF to be specified using a GRP group expression (for instance, its
      name may be given within a text file, etc). The first NDF in the
      group expression is returned. Any other names in the group
      expression are ignored. Any modification elements in the supplied
      group expression will be treated literally.
   }
   \sstinvocation{
      CALL NDG\_CREA1( PARAM, FTYPE, NDIM, LBND, UBND, INDF, NAME,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Full data type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_DOUBLE{\tt '} or
         {\tt '}COMPLEX\_REAL{\tt '}).
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         Lower pixel-index bounds of the NDF.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full file specification for the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_CREAT
}{
   Obtain the names of a group of NDF to be created from the
   environment
}{
   \sstdescription{
      A group expression is obtained from the environment using the
      supplied parameter. The expression is parsed (using the
      facilities of the GRP routine GRP\_GROUP, see \xref{SUN/150}{sun150}{}) to produce
      a list of explicit NDF names. These names are appended
      to the group identified by IGRP. The user is re-prompted if an
      error occurs while parsing the group expression. If IGRP has the
      value GRP\_\_NOID on entry, then a new group is created and IGRP is
      returned holding the new group identifier.

      If IGRP0 holds a valid group identifier on entry, then the group
      identified by IGRP0 is used as the basis for any modification
      element contained in the group expression obtained from the
      environment. If IGRP0 holds an invalid identifier (such as
      GRP\_\_NOID) on entry then modification elements are included
      literally in the output group.
   }
   \sstinvocation{
      CALL NDG\_CREAT( PARAM, IGRP0, IGRP, SIZE, FLAG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER$*$($*$) (Given)
      }{
         The parameter with which to associate the group.
      }
      \sstsubsection{
         IGRP0 = INTEGER (Given)
      }{
         The GRP identifier for the group to be used as the basis for
         any modification elements. If a valid GRP identifier is
         supplied, and if the supplied group expression contains a
         modification element, then:

         \sstitemlist{

            \sstitem
            the basis token (an asterisk) is replaced by the file basename
            associated with the corresponding element of the basis group (the
            {\tt "}basis NDF{\tt "}).

            \sstitem
            if no directory specification is included in the group expression,
            the directory specification associated with the basis NDF is used.

            \sstitem
            if no HDS component path is included in the group expression,
            the HDS component path associated with the basis NDF (if any) is
            used. Any required higher level HDS objects are created in the
            output HDS file by copying the structure of the HDS file containing
            the basis NDF. Thus if, the basis NDF is fred.a.b(2).c, and the
            group expression is {\tt "}$*$\_a{\tt "}, then an HDS container file called
            {\tt "}fred\_a.sdf{\tt "} is created by copying fred.sdf and then deleting all
            NDFs from fred\_a.sdf (unless this has already been done while
            creating a previous member of the returned group). Other non-NDF
            components in fred\_a.sdf are retained. This ensures that all necessary
            structure exists in fred\_a.sdf, so that the NDF fred\_a.a.b(2).c
            can be created when necessary.

         }
         The supplied group will often be created by NDG\_ASSOC, but
         groups created {\tt "}by hand{\tt "} using GRP directly can also be used
         (i.e. without the supplemental groups created by NDG). In
         this case, there are no defaults for directory path, file type,
         or HDS component path, and the basis token ({\tt "}$*${\tt "}) in the group
         expression represents the full basis file specification supplied
         in IGRP0, not just the file basename.
      }
      \sstsubsection{
         IGRP = INTEGER (Given and Returned)
      }{
         The GRP identifier for the group to which the supplied .sdf
         files are to be appended.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total number of file names in the returned group.
      }
      \sstsubsection{
         FLAG = LOGICAL (Returned)
      }{
         If the group expression was terminated by the GRP {\tt "}flag{\tt "}
         character, then FLAG is returned .TRUE. Otherwise it is
         returned .FALSE. Returned .FALSE. if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If an error is reported the group is returned unaltered.

         \sstitem
         A null value (!) can be given for the parameter to indicate
         that no more NDFs are to be specified. The corresponding error
         is annulled before returning unless no NDFs have been added to
         the group.

         \sstitem
         Explicit file types are included in all the elements of the returned
         group. This is done because the name may be passed out to a script (eg
         POLPACK:POLKA) which may change the value of NDF\_FORMATS\_OUT before
         using the NDF name. If no file type is supplied in the group
         expression, then the first file type listed in the current value of
         the NDF\_FORMATS\_OUT environment variable (see \xref{SSN/20}{ssn20}{}) is used. If
         this is {\tt "}$*${\tt "} then the file type is copied from the corresponding input
         file if a modification element was used to specify the output file
         name (if the NDF was not specified by a modification element, the
         second file type in NDF\_FORMATS\_OUT is used).

         \sstitem
         If the last character in the supplied group expression is
         a colon (:), a list of the NDFs represented by the group
         expression (minus the colon) is displayed, but none are
         actually added to the group. The user is then re-prompted for
         a new group expression.

         \sstitem
         The returned group has no associated groups holding supplemental
         information (unlike the group returned by NDG\_ASSOC).
      }
   }
}
\sstroutine{
   NDG\_CREP1
}{
   Create a single new primitive NDF using a specified parameter
}{
   \sstdescription{
      This routine is equivalent to NDF\_CREP except that it allows the
      NDF to be specified using a GRP group expression (for instance, its
      name may be given within a text file, etc). The first NDF in the
      group expression is returned. Any other names in the group
      expression are ignored. Any modification elements in the supplied
      group expression will be treated literally.
   }
   \sstinvocation{
      CALL NDG\_CREP1( PARAM, FTYPE, NDIM, UBND, INDF, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_REAL{\tt '}). Note that
         complex types are not permitted when creating a primitive NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF (the lower bound of each
         dimension is taken to be 1).
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full file specification for the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_CREXP
}{
   Store the names of a specified group of NDF to be created
}{
   \sstdescription{
      The supplied group expression is parsed (using the facilities of
      the GRP routine GRP\_GROUP, see SUN/150) to produce a list of
      explicit NDF names. No check is made to see if these NDFs exist
      or not, and any wild-cards in the NDF names are ignored. The names
      are appended to the group identified by IGRP. If IGRP has the
      value GRP\_\_NOID on entry, then a new group is created and IGRP is
      returned holding the new group identifier.

      If IGRP0 holds a valid group identifier on entry, then the group
      identified by IGRP0 is used as the basis for any modification
      element contained in the supplied group expression. If IGRP0 holds
      an invalid identifier (such as GRP\_\_NOID) on entry then
      modification elements are included literally in the output group.
   }
   \sstinvocation{
      CALL NDG\_CREXP( GRPEXP, IGRP0, IGRP, SIZE, FLAG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         GRPEXP = CHARACTER$*$($*$) (Given)
      }{
         The group expression specifying the NDF names to be stored in
         the group.
      }
      \sstsubsection{
         IGRP0 = INTEGER (Given)
      }{
         The GRP identifier for the group to be used as the basis for
         any modification elements.
      }
      \sstsubsection{
         IGRP = INTEGER (Given and Returned)
      }{
         The GRP identifier for the group to which the supplied NDF
         names are to be appended.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total number of NDF names in the returned group.
      }
      \sstsubsection{
         FLAG = LOGICAL (Returned)
      }{
         If the group expression was terminated by the GRP {\tt "}flag{\tt "}
         character, then FLAG is returned .TRUE. Otherwise it is
         returned .FALSE. Retuned .FALSE. if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_GTSUP
}{
   Get supplemental information for an NDF
}{
   \sstdescription{
      Returns the supplemental information associated with a given entry
      in an NDG group.
   }
   \sstinvocation{
      CALL NDG\_GTSUP( IGRP, I, FIELDS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         The NDG group as returned by NDG\_ASSOC, etc. This should be the last
         group in a GRP owner-slave chain.
      }
      \sstsubsection{
         I = INTEGER (Given)
      }{
         The index of the required entry.
      }
      \sstsubsection{
         FIELDS( 6 ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The supplemental information associated with the entry specified
         by I. Each element of the returned array contains the following:
         \begin{enumerate}
            \item NDF slice specification (if any)
            \item HDS path (if any)
            \item File type
            \item Base file name
            \item Directory path
            \item Full NDF specification
         \end{enumerate}

         This information is obtained from a set of groups associated with
         the supplied group IGRP by means of a chain of GRP {\tt "}owner-slave{\tt "}
         relationships. If any of these groups do not exist, the corresponding
         elements of the above array are returned blank. Note, Element 6,
         the full NDF specification, is obtained directly from the supplied
         group IGRP.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}


\sstroutine{
   NDF\_MOREG
}{
   Search for NDFs within the extensions of a supplied NDF
}{
   \sstdescription{
      Each extension within the supplied NDF is searched to see if it
      contains any NDFs. The paths to any such NDFs are appended to the
      end of the supplied group (a new group is created if none is
      supplied). NDF identifiers for particular members of the group can
      be obtained using NDG\_NDFAS.
   }
   \sstinvocation{
      CALL NDF\_MOREG( INDF, IGRP, SIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The identifier for the NDF to be searched.
      }
      \sstsubsection{
         IGRP = INTEGER (Given and Returned)
      }{
         The identifier of the group in which NDF names are to be
         stored. A new group is created if the supplied value is GRP\_\_NOID.
         It should be deleted when no longer needed using GRP\_DELET.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total number of NDF names in the returned group IGRP.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Each element in the returned group contains a full specification
         for an NDF. Several other groups are created by this routine, and
         are associated with the returned group by means of a GRP {\tt "}owner-slave{\tt "}
         relationship. These supplemental groups are automatically deleted
         when the returned group is deleted using GRP\_DELET. The returned
         group should not be altered using GRP directly because corresponding
         changes may need to be made to the supplemental groups. Routines
         NDG\_SETSZ, NDG\_GTSUP and NDG\_PTSUP are provided to manipulate the
         entire chain of groups. The full chain (starting from the head) is
         as follows:

         \sstitem
            NDF slice specifications

         \sstitem
            HDS paths

         \sstitem
            File types

         \sstitem
            Base file names

         \sstitem
            Directory paths

         \sstitem
            Full NDF specification (this is the returned group IGRP)
      }
   }
}

\sstroutine{
   NDG\_NDFAS
}{
   Obtain an NDF identifier for an existing NDF
}{
   \sstdescription{
      The routine returns an NDF identifier for an existing NDF. The
      name of the NDF is held at a given index within a given group.
      It is equivalent to NDF\_ASSOC.
   }
   \sstinvocation{
      CALL NDG\_NDFAS( IGRP, INDEX, MODE, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for a group holding the names of NDFs. This
         will often be created using NDG\_ASSOC, but groups created {\tt "}by
         hand{\tt "} using GRP directly (i.e. without the supplemental groups
         created by NDG\_ASSOC) can also be used.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group at which the name of the NDF to be
         accessed is stored.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of NDF access required: {\tt '}READ{\tt '}, {\tt '}UPDATE{\tt '} or {\tt '}WRITE{\tt '}.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}

\sstroutine{
   NDG\_NDFCO
}{
   Obtain an NDF identifier for a new NDF created by copying an existing NDF
}{
   \sstdescription{
      The routine returns an NDF identifier for a new NDF created by
      copying an existing NDF. The name of the new NDF is held
      at a given index within a given group. It is equivalent to NDF\_PROP.
   }
   \sstinvocation{
      CALL NDG\_NDFCO( INDF1, IGRP, INDEX, INDF2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for an existing NDF (or NDF section) to act as a
         template.
      }
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for a group holding the names of NDFs. This
         will often be created using NDG\_ASSOC, but groups created {\tt "}by
         hand{\tt "} using GRP directly (i.e. without the supplemental groups
         created by NDG\_ASSOC) can also be used.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group at which the name of the NDF to be
         accessed is stored.
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         Identifier for the new NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}

\sstroutine{
   NDG\_NDFCP
}{
   Obtain an NDF identifier for a new primitive NDF
}{
   \sstdescription{
      The routine returns an NDF identifier for a new primitive NDF created
      with the specified attributes. The name of the new NDF is held
      at a given index within a given group. It is equivalent to NDF\_CREP.
   }
   \sstinvocation{
      CALL NDG\_NDFCP( IGRP, INDEX, FTYPE, NDIM, UBND, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for a group holding the names of NDFs. This
         will often be created using NDG\_ASSOC, but groups created {\tt "}by
         hand{\tt "} using GRP directly (i.e. without the supplemental groups
         created by NDG\_ASSOC) can also be used.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group at which the name of the NDF to be
         created is stored.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_REAL{\tt '}). Note that
         complex types are not permitted when creating a primitive NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF (the lower bound of each
         dimension is taken to be 1).
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_NDFCR
}{
   Obtain an NDF identifier for a new simple NDF
}{
   \sstdescription{
      The routine returns an NDF identifier for a new simple NDF created
      with the specified attributes. The name of the new NDF is held
      at a given index within a given group. It is equivalent to NDF\_CREAT.
   }
   \sstinvocation{
      CALL NDG\_NDFCR( IGRP, INDEX, FTYPE, NDIM, LBND, UBND, INDF,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for a group holding the names of NDFs. This
         will often be created using NDG\_CREAT, but groups created {\tt "}by
         hand{\tt "} using GRP directly can also be used.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group at which the name of the NDF to be
         created is stored.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Full data type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_DOUBLE{\tt '} or
         {\tt '}COMPLEX\_REAL{\tt '}).
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         Lower pixel-index bounds of the NDF.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_NDFPR
}{
   Obtain an NDF identifier for a new NDF created by propagation from
   an existing NDF
}{
   \sstdescription{
      The routine returns an NDF identifier for a new NDF created by
      propagation from an existing NDF. The name of the new NDF is held
      at a given index within a given group. It is equivalent to NDF\_PROP.
   }
   \sstinvocation{
      CALL NDG\_NDFPR( INDF1, CLIST, IGRP, INDEX, INDF2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for an existing NDF (or NDF section) to act as a
         template.
      }
      \sstsubsection{
         CLIST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of the NDF components which are to be
         propagated to the new data structure. By default, the HISTORY,
         LABEL and TITLE components and all extensions are propagated.
      }
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for a group holding the names of NDFs. This
         will often be created using NDG\_ASSOC, but groups created {\tt "}by
         hand{\tt "} using GRP directly (i.e. without the supplemental groups
         created by NDG\_ASSOC) can also be used.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group at which the name of the NDF to be
         accessed is stored.
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         Identifier for the new NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}

\sstroutine{
   NDG\_PROP1
}{
   Create a single new NDF by propagation using a specified parameter
}{
   \sstdescription{
      This routine is equivalent to NDF\_PROP except that it allows the
      NDF to be specified using a GRP group expression (for instance, its
      name may be given within a text file, etc). The first NDF in the
      group expression is returned. Any other names in the group
      expression are ignored. Modification elements use the name of the
      supplied NDF as the basis name.
   }
   \sstinvocation{
      CALL NDG\_PROP1( INDF1, CLIST, PARAM, INDF2, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for an existing NDF (or NDF section) to act as a
         template.
      }
      \sstsubsection{
         CLIST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of the NDF components which are to be
         propagated to the new data structure. By default, the HISTORY,
         LABEL and TITLE components and all extensions are propagated.
      }
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter for the new NDF.
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         Identifier for the new NDF.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full file specification for the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_PTSUP
}{
   Store supplemental information for an NDF
}{
   \sstdescription{
      Stores the supplied items of supplemental information for a given
      entry in an NDG group. The GRP groups needed to store this
      supplemental information are created if they do not already exist,
      and associated with the supplied group by means of a chain of GRP
      {\tt "}owner-slave{\tt "} relationships. They will be deleted automatically when
      the supplied group is deleted using GRP\_DELET.
   }
   \sstinvocation{
      CALL NDG\_PTSUP( IGRP, I, FIELDS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         The NDG group as returned by NDG\_ASSOC, etc. This should be the last
         group in a GRP owner-slave chain.
      }
      \sstsubsection{
         I = INTEGER (Given)
      }{
         The index of the required entry.
      }
      \sstsubsection{
         FIELDS( 6 ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The supplemental information to be stored with the entry specified
         by I. Each element of the supplied array should contain the
         following:
            \begin{enumerate}
            \item NDF slice specification (if any)
            \item HDS path (if any)
            \item File type
            \item Base file name
            \item Directory path
            \item Full NDF specification
            \end{enumerate}
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}


\sstroutine{
   NDG\_SETSZ
}{
   Reduces the size of an NDG group
}{
   \sstdescription{
      This routine should be used instead of GRP\_SETSZ to set the size of
      a group created by NDG. It sets the size of the supplied group, and
      also sets the size of each of the supplemental groups associated with
      the supplied group.
   }
   \sstinvocation{
      CALL NDG\_SETSZ( IGRP, SIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         The NDG group as returned by NDG\_ASSOC, etc. This should be the last
         group in a GRP owner-slave chain.
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The new group size. Must be less than or equal to the size of the
         smallest group in the chain.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\newpage

\section{Routines for accessing NDF Provenance}

This section describes all the functions used for reading, writing,
modifying and querying provenance information in an NDF.

The provenance information in an NDF encapsulates details of all the
other NDFs that were used in the creation of the NDF. The information is
hierarchical and includes parents, grandparents, great-grandparents,
etc., all the way back to ``root ancestors'' (a root ancestor is an ancestor
NDF that has no recorded parents).

On disk, the provenance information is stored in an NDF extension called
``PROVENANCE'' (for details see the section ``The PROVENANCE Extension''
below). The ndgReadProv function reads this information and copies it
into an in-memory structure for faster access. All the other public
functions defined by this module accept an identifier for such an
in-memory structure as their first argument. The ndgWriteProv function
can be used to write the in-memory structure back out to disk as a
PROVENANCE extension in an NDF. The in-memory structure should be freed
when no longer needed, using ndgFreeProv.

\subsection{Functions Provides:}
The following public functions are available. There is an equivalent set
of F77 routines with names formed by converting the C name to upper case
and inserting an underscore after the initial ``NDG'' string (C and F77
versions are - for the most part - documented individually in separate
prologues below):

\begin{itemize}
   \item  ndgCopyProv: Create a deep copy of a provenance structure.
   \item  ndgBegpv: Begin an NDF provenance block.
   \item  ndgCountProv: Return the number of ancestors in a provenance structure.
   \item  ndgFormatProv: Format all the information in a provenance structure.
   \item  ndgEndpv: End an NDF provenance block.
   \item  ndgFreeProv: Free the resources used by a provenance structure.
   \item  ndgGetProv: Get information about a specific ancestor.
   \item  ndgHideProv: Hide a specific ancestor.
   \item  ndgHltpv: Temporarily stop recording NDFs within a provenance block
   \item  ndgIsHiddenProv: See if an ancestor is hidden.
   \item  ndgModifyProv: Modify information stored for a specific ancestor.
   \item  ndgPutProv: Add a new ancestor NDF into a provenance structure.
   \item  ndgReadProv: Create a new provenance structure by reading a given NDF.
   \item  ndgRemoveProv: Remove ancestors from a provenance structure.
   \item  ndgRootProv: Identify root ancestors in a provenance structure.
   \item  ndgUnhashProv: Clear the hash code describing the creation of the Provenance.
   \item  ndgUnhideProv: Ensure an ancestor is not hidden.
   \item  ndgWriteProv: Writes a provenance structure out to an NDF.
\end{itemize}

Note, within a provenance block, it is possible to prevent selected NDFs
receiving provenance by using ndgHltpv (NDG\_HLTPV) to stop the recording
of NDF names before the NDFs are accessed, and then calling ndgHltpv
again afterwards to re-establish the recording of NDF names.

\subsection{The PROVENANCE Extension:}

The PROVENANCE extension in an NDF contains four components: ``PARENTS'',
``ANCESTORS'', ``CREATOR'', ``DATE'' and ``HASH''. The DATE component is a
character string holding the date and time at which the information in
the provenance extension was last modified. The date is UTC formatted by
PSX\_ASCTIME. The ANCESTORS component is a 1D array of ``PROV'' structures
(described below). Each element describes a single NDF that was used in
the creation of the main NDF, either directly or indirectly. The PARENTS
component is a 1D integer array holding the indices within the ANCESTORS
array of the NDFs that are the direct parents of the main NDF. The
CREATOR component holds an arbitrary identifier for the software that
created the main NDF. The HASH component is an integer that identifies
the contents of the current History record in the NDF at the time the
PROVENANCE extension was created. This is used to determine which history
records to copy into the PROVENANCE extension if the main NDF is used in
the creation of another NDF.

Each PROV structure describes a single NDF that was used in the creation
of the main NDF, and can contain the following components; ``PARENTS'',
``DATE'', ``PATH'', ``CREATOR'', ``HISTORY'' and ``MORE''. If present, the PARENTS
component is a 1D integer array holding the the indices within the
ANCESTORS array of the direct parents of the ancestor NDF. If PARENTS is
not present, the ancestor NDF is a ``root'' NDF (that is, it has no known
parents). If present, the DATE component is a string holding the
formatted UTC date at which the provenance information for the ancestor
NDF was determined. If this date is not known, the DATE component will
not be present (this will be the case, for instance, for all root NDFs).
The PATH component will always be present, and is a string holding the
full path to the ancestor NDF. This includes any HDS path within the
container file, but will not include any NDF or HDS section specifier.
Neither will it include the trailing ``.sdf'' suffix. If present, the MORE
component is an arbitrary HDS structure in which any extra information
about the ancestor NDF can be stored. The CREATOR component holds an
arbitrary identifier for the software that created the ancestor NDF. The
HISTORY component is an array of ``HISREC'' structures, each containing a
copy of a single History record from the NDF described by the PROV
structure. Only History records that describe operations performed on the
NDF itself are stored (including the record that describes the creation
of the NDF). That is, History records inherited from the NDF's own
parents are not included.

Each HISREC structure contains the following components (all taken from
the corresponding items in the NDF History record): DATE, COMMAND, USER
and TEXT. If the history record was created by the default NDF history
writing mechanism, the TEXT component will contain a list of environment
parameter values used by (or created by) the corresponding command, and
another statement of the software that performed the action.

\newpage

\subsection{Full Fortran Function Specifications}
\sstroutine{
   NDG\_BEGPV
}{
   Begin an NDF provenance block
}{
   \sstdescription{
      This routine should be called to mark the start of an NDF
      provenance block. The block should be ended by a matching
      call to NDG\_ENDPV. See NDG\_ENDPV for more details.

      Note - provenance blocks must not be nested.
   }
   \sstinvocation{
      CALL NDG\_BEGPV( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_COPYPROV
}{
   Copy a Provenance structure, optionally removing any hidden ancestors
}{
   \sstdescription{
      This routine produces a deep copy of the supplied Provenance
      structure, and then optionally uses NDG\_REMOVEPROV to remove any
      hidden ancestors from the copy.
   }
   \sstinvocation{
      CALL NDG\_COPYPROV( IPROV, CLEANSE, IPROV2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPROV = INTEGER (Given)
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by NDG\_READPROV.
      }
      \sstsubsection{
         CLEANSE = LOGICAL (Given)
      }{
         If .TRUE., then any ancestors which have been hidden using
         NDG\_HIDEPROV are removed from the returned Provenance structure
         (see NDG\_REMOVEPROV).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_COUNTPROV
}{
   Return the number of ancestors in a provenance structure
}{
   \sstdescription{
      This routine returns the number of ancestors described in the
      supplied provenance structure.
   }
   \sstinvocation{
      CALL NDG\_COUNTPROV( IPROV, COUNT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPROV = INTEGER (Given)
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by NDG\_READPROV.
      }
      \sstsubsection{
         COUNT = INTEGER (Returned)
      }{
         The number of ancestors in the supplied provenance structure.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_ENDPV
}{
   End an NDF provenance block
}{
   \sstdescription{
      This routine should be called to mark the end of an NDF
      provenance block. The block should have been started by a
      matching call to NDG\_BEGPV. Note, provenance blocks must
      not be nested.

      During a provenance block, a list is maintained of all the
      existing NDFs that have had their Data array mapped (either in
      read or update mode) during the block. Another list is maintained
      of all the NDFs that have been written (either existing NDFs
      accessed in update mode or new NDFs) during the block.

      When the block ends, the provenance information within each
      NDF in the second may be modified to include all the NDFs in the
      first list as parents. Whether or not this occurs is controlled by
      the AUTOPROV environment variable. If AUTOPROV is set to {\tt '}1{\tt '} then
      the input NDFs are added to the provenance information in the
      output NDF. If AUTOPROV is set to anything other than {\tt '}1{\tt '} then the
      output provenance is not updated. If AUTOPROV is not set at all,
      then the output provenance will be updated only if one or more of
      the input NDFs contains a PROVENANCE extension.
   }
   \sstinvocation{
      CALL NDG\_ENDPV( CREATR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CREATR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         An identifier for the calling application. The format of the
         identifier is arbitrary, but the form {\tt "}PACKAGE:COMMAND{\tt "}
         is recommended.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_FORMATPROV
}{
   Format the information in a provenance structure
}{
   \sstdescription{
      This routine returns an AST KeyMap holding a set of text strings
      containing information taken from the supplied provenance structure.

      The returned KeyMap has an entry with key {\tt "}0{\tt "} that describes the NDF
      from which the provenance was read. It also has an entry describing
      each ancestor NDF. These entries have keys {\tt "}1{\tt "}, {\tt "}2{\tt "}, {\tt "}3{\tt "}, etc, up to
      the number of ancestors in the NDF.

      Each of these entries contains a pointer to another AST KeyMap
      which may contain any subset of the following entries (all of which,
      except for HISTORY, are strings):

      {\tt "}ID{\tt "} - the integer index within the ancestors array (zero for the
             main NDF).

      {\tt "}PATH{\tt "} - The full path or base name for the NDF (see {\tt "}base{\tt "}).

      {\tt "}DATE{\tt "} - The date of creation of the NDF.

      {\tt "}CREATOR{\tt "} - The software item that created the NDF.

      {\tt "}PARENTS{\tt "} - A comma-separated list of indices into the ancestors
             array that identifies the direct parents of the NDF.

      {\tt "}MORE{\tt "} - A summary of the contents of the MORE structure associated
             with the NDF.

      {\tt "}HISTORY{\tt "} - A vector entry holding one or more KeyMaps. Each
             KeyMap contains items that describe an action performed on
             the ancestor. The actions are stored in chronological order
             within the vector entry. The last KeyMap in the vector
             describes the action that created the ancestor NDF. Any
             earlier KeyMaps in the vector describe any subsequent actions
             performed on the ancestor NDF prior to it being used in the
             creation of its parent. Each KeyMap contains the following
             scalar character entries (all taken from the corresponding
             record in the NDF HISTORY component):

      \sstitemlist{

         \sstitem
                {\tt "}DATE{\tt "}: The date and time of the action (e.g. {\tt "}2009-JUN-24
                          14:00:53.752{\tt "} ).

         \sstitem
                {\tt "}COMMAND{\tt "}: An indication of the command that performed the
                          action (e.g. {\tt "}WCSATTRIB (KAPPA 1.10-6){\tt "} ).

         \sstitem
                {\tt "}USER{\tt "}: The user name that performed the action
                          (e.g. {\tt "}dsb{\tt "}).

         \sstitem
                {\tt "}TEXT{\tt "}: The full text of the NDF history record. This is
                          arbitrary, but for NDFs created by Starlink
                          software it will usually include environment
                          parameter values, and the full path of the command
                          that performed the action.

      }
      Finally, the returned KeyMap has an entry with key {\tt "}MXLEN{\tt "} that is
      again a pointer to another KeyMap with the same entries listed
      above (except that it has no {\tt "}HISTORY{\tt "} entry). However, this time
      the entries are integers, not strings, and holds the maximum field
      width used to format the strings.
   }
   \sstinvocation{
      CALL NDG\_FORMATPROV( IPROV, BASE, KEYMAP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPROV = INTEGER (Given)
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by NDG\_READPROV.
      }
      \sstsubsection{
         BASE = LOGICAL (Given)
      }{
         If .TRUE., then the PATH field in the returned KeyMap holds the
         base name of each NDF rather than the full path.
      }
      \sstsubsection{
         KEYMAP = INTEGER (Returned)
      }{
         A pointer to the returned AST KeyMap.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_FREEPROV
}{
   Free a structure holding provenance information
}{
   \sstdescription{
      This routine frees the resources used to hold a provenance structure.
   }
   \sstinvocation{
      CALL NDG\_FREEPROV( IPROV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPROV = INTEGER (Given and Returned)
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by NDG\_READPROV. Returned holding
         NDG\_\_NULL.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This function attempts to execute even if an error has already
         occurred.
      }
   }
}
\sstroutine{
   NDG\_GETPROV
}{
   Create a KeyMap holding information about an ancestor
}{
   \sstdescription{
      This routine returns information about a specified ancestor in the
      supplied provenance structure.
   }
   \sstinvocation{
      CALL NDG\_GETPROV( IPROV, IANC, KM, MORE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPROV = INTEGER (Given)
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by NDG\_READPROV.
      }
      \sstsubsection{
         IANC = INTEGER (Given)
      }{
         The index of the ancestor NDF for which information should be
         returned. A value of zero will result in information being returned
         that describes the NDF from which the provenance information was
         read. Otherwise, the IANC value is used as an index into the
         ANCESTORS array. No error is reported if IANC is too large, but a
         null identifier will be returned as the function value.
      }
      \sstsubsection{
         KM = INTEGER (Returned)
      }{
         A pointer to an AST KeyMap containing entries with the following
         keys and values:

         \sstitemlist{

            \sstitem
            {\tt "}PATH{\tt "}: A string holding the path of the ancestor NDF.

            \sstitem
            {\tt "}DATE{\tt "}: A string holding the formatted UTC date and time at
              which the provenance information for the ancestor NDF was
              recorded.

            \sstitem
            {\tt "}CREATOR{\tt "}: A string identifying the software that created the
              ancestor NDF.

            \sstitem
            {\tt "}PARENTS{\tt "}: A 1D vector of integers that are the indices of the
              immediate parents of the ancestor.

            \sstitem
            {\tt "}MORE{\tt "}: A KeyMap containing any scalar or vector primitive
              values stored at the top level of the associated HDS MORE
              structure. The HDS name of the component is used as the key.
              The full contents of the MORE structure are returned by the
              MORE argument (see above).

            \sstitem
            {\tt "}HISTORY{\tt "}: A vector entry holding one or more KeyMaps. Each
              KeyMap contains items that describe an action performed on
              the ancestor. The actions are stored in chronological order
              within the vector entry. The last KeyMap in the vector
              describes the action that created the ancestor NDF. Any
              earlier KeyMaps in the vector describe any subsequent actions
              performed on the ancestor NDF prior to it being used in the
              creation of its parent. Each KeyMap contains the following
              scalar character entries (all taken from the corresponding
              record in the NDF HISTORY component):

            \sstitem
              {\tt "}DATE{\tt "}: The date and time of the action (e.g. {\tt "}2009-JUN-24
                14:00:53.752{\tt "} ).

            \sstitem
              {\tt "}COMMAND{\tt "}: An indication of the command that performed the
                action (e.g. {\tt "}WCSATTRIB (KAPPA 1.10-6){\tt "} ).

            \sstitem
              {\tt "}USER{\tt "}: The user name that performed the action (e.g. {\tt "}dsb{\tt "}).

            \sstitem
              {\tt "}TEXT{\tt "}: The full text of the NDF history record. This is
                arbitrary, but for NDFs created by Starlink software it will
                usually include environment parameter values, and the full
                path of the command that performed the action.

         }
         If the specified ancestor does not have any of these items of
         information, then the corresponding entry will not be present
         in the returned KeyMap. For instance, if the ancestor has no
         immediate parent NDFs, then the {\tt "}PARENTS{\tt "} entry will not be
         present in the KeyMap. A NULL pointer will be returned if the
         NDF has no provenance extension, or if {\tt "}ianc{\tt "} is outside the
         bounds of the ANCESTORS array (and is not zero). The returned
         KeyMap pointer should be annulled when it is no longer needed,
         either by calling astAnnul explicitly, or by relying on astEnd
         to annul it (together with all the other AST Objects created in
         the current AST Object context).
      }
      \sstsubsection{
         MORE = CHARACTER $*$ (DAT\_\_SZLOC) (Returned)
      }{
         A locator for a temporary HDS object containing a full deep copy
         of each component of the MORE structure associated with the
         requested ancestor. The returned locator should be annulled using
         DAT\_ANNUL when no longer needed. A value of DAT\_\_NOLOC will be
         returned if the requested ancestor has no MORE component. Note,
         the returned object will be assigned an arbitrary HDS Name, which
         will not in general be {\tt "}MORE{\tt "}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_HIDEPROV
}{
   Hide an ancestor in a provenance structure
}{
   \sstdescription{
      This function flags a specified ancestor as {\tt "}hidden{\tt "}. The only
      effect this has is that the ancestor will not be included in
      Provenance structures created by the NDG\_COPYPROV function.
   }
   \sstinvocation{
      CALL NDG\_HIDEPROV( IPROV, IANC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPROV = INTEGER (Given)
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by ndgReadProv
      }
      \sstsubsection{
         IANC = INTEGER (Given)
      }{
         The index of the ancestor NDF to be hidden. The value is used as an
         index into the ANCESTORS array. An error will be reported if the
         value is too large, or is less than 1 (the main NDF cannot be
         hidden).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_HLTPV
}{
   Temporarily halt an NDF provenance block
}{
   \sstdescription{
      This routine can be called to stop subseqently accessed NDFs
      being added to the list of NDFs that will receive updated
      provenance information when NDG\_ENDPV is called to end the
      current provenance block.
   }
   \sstinvocation{
      CALL NDG\_HLTPV( NEW, OLD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NEW = LOGICAL (Read)
      }{
         The new required provenance-recording state.
      }
      \sstsubsection{
         OLD = LOGICAL (Returned)
      }{
         The provenance-recording state on entry to this routine.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A .FALSE. provenance-recording state means that any subseqently
         accessed NDFs will not be added to the list of NDFs to receive
         updated provenance information when NDG\_ENDPV is called.

         \sstitem
         A .TRUE. provenance-recording state means that any subseqently
         accessed NDFs are added to the list of NDFs to receive updated
         provenance information when NDG\_ENDPV is called.
      }
   }
}
\sstroutine{
   NDG\_ISHIDDENPROV
}{
   See if an ancestor in a provenance structure is hidden
}{
   \sstdescription{
      This function returns a TRUE. value for HIDDEN if the specified
      ancestor has been hidden. See NDG\_HIDEPROV and NDG\_COPYPROV.
   }
   \sstinvocation{
      CALL NDG\_ISHIDDENPROV( IPROV, IANC, HIDDEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPROV = INTEGER (Given)
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by NDG\_READPROV.
      }
      \sstsubsection{
         IANC = INTEGER (Given)
      }{
         The index of the ancestor NDF to be checked. The value is used as
         an index into the ANCESTORS array. An error will be reported if the
         value is too large, or is less than 0.
      }
      \sstsubsection{
         HIDDEN = LOGICAL (Returned)
      }{
         .TRUE. if the ancestor is hidden.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_MODIFYPROV
}{
   Modify the information stored for a particular ancestor
}{
   \sstdescription{
      This routine modifies the information stored for a given ancestor
      in the supplied provenance structure. The new values to store
      are supplied in an AST KeyMap such as returned by NDG\_GETPROV.
   }
   \sstinvocation{
      CALL NDG\_MODIFYPROV( IPROV, IANC, KM, MORE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPROV = INTEGER (Given)
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by NDG\_READPROV.
      }
      \sstsubsection{
         IANC = INTEGER (Given)
      }{
         The index of the ancestor NDF for which information should be
         modified. A value of zero will result in information about the NDF
         specified by INDF being modified. Otherwise, the IANC value
         is used as an index into the ANCESTORS array. An error is reported
         if IANC is too large.
      }
      \sstsubsection{
         KM = INTEGER (Given)
      }{
         A pointer to an AST KeyMap containing the values to store. Entries
         with the following keys are recognised:

         \sstitemlist{

            \sstitem
            {\tt "}PATH{\tt "}: A string holding the path of the ancestor NDF.

            \sstitem
            {\tt "}DATE{\tt "}: A string holding the formatted UTC date and time at
              which the provenance information for the ancestor NDF was
              recorded.

            \sstitem
            {\tt "}CREATOR{\tt "}: A string identifying the software that created the
              ancestor NDF.

            \sstitem
            {\tt "}MORE{\tt "}: A KeyMap containing extra information to store at the
            top level of the MORE component for the ancestor. Only entries
            holding primitive data values (scalar or vector) are used -
            entries holding nested KeyMaps, etc, are ignored. If an entry in
            this KeyMap has the same name as a component in the supplied
            MORE HDS structure, then the KeyMap value is used in preference to
            the HDS value.

         }
         If the {\tt "}DATE{\tt "} or {\tt "}CREATOR{\tt "} components are missing then the
         corresponding item of information will be deleted from the
         provenance extension. To delete the {\tt "}MORE{\tt "} component in the
         provenance extension, supply a KeyMap without a MORE entry, and
         also supply DAT\_NOLOC for the {\tt "}more{\tt "} argument. An error is
         reported if the supplied KeyMap has no {\tt "}PATH{\tt "} entry. Note, the
         PARENTS list and HISTORY information stored with the specified
         ancestor cannot be modified (any {\tt "}PARENTS{\tt "} or {\tt "}HISTORY{\tt "}
         component in the supplied HDS structure will be ignored).
      }
      \sstsubsection{
         MORE = CHARACTER $*$ (DAT\_\_SZLOC) (Given)
      }{
         A locator for an HDS object containing additional information to
         be associated with the requested ancestor. DAT\_\_NOLOC may be
         supplied for this argument. The contents of the MORE component
         in the provenance extension will be the union of any structure
         supplied through this argument, and any values supplied through
         the MORE entry in the supplied KeyMap. If the same component
         name occurs in both, then the KeyMap value takes precedence.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_PUTPROV
}{
   Add an NDF to the list of ancestors
}{
   \sstdescription{
      This routine modifies the supplied provenance structure to indicate
      that a given NDF was used in the creation of the NDF associated with
      the supplied provenance structure.
   }
   \sstinvocation{
      CALL NDG\_PUTPROV( IPROV, INDF, MORE, MORE2, ISROOT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPROV = INTEGER (Given)
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by NDG\_READPROV.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         An identifier for an NDF that is to be added into the list of
         ancestor NDFs in the supplied provenance information.
      }
      \sstsubsection{
         MORE = CHARACTER $*$ (DAT\_\_SZLOC) (Given)
      }{
         A locator for an HDS structure containing arbitrary additional
         information about the new ancestor NDF, and how it was used in the
         creation of the output NDF.
      }
      \sstsubsection{
         MORE2 = INTEGER (Given)
      }{
         A pointer to an AstKeyMap holding extra items of information
         to be added into the MORE component. Only entries holding primitive
         data values (scalar or vector) are used - entries holding nested
         KeyMaps, etc, are ignored. If an entry in this KeyMap has the same
         name as a component in the supplied MORE HDS structure, then the
         KeyMap value is used in preference to the HDS value.
      }
      \sstsubsection{
         ISROOT = LOGICAL (Given)
      }{
         If TRUE, then the new ancestor NDF will be treated as a root
         NDF. That is, any provenance information in the supplied NDF is
         ignored. If FALSE, then any provenance information in the NDF is
         copied into the supplied provenance structure. The new ancestor NDF
         is then only a root NDF if it contains no provenance information.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_READPROV
}{
   Read the provenance information from an NDF
}{
   \sstdescription{
      This function reads the information stored in the {\tt "}PROVENANCE{\tt "}
      extension of an NDF, storing it in a memory-resident structure for
      faster access. An identifier for this structure is returned, and
      can be passed to other NDG provenance functions to manipulate the
      contents of the structure.

      If the NDF has no provenance information (for instance, if it is a
      newly created NDF), the returned structure will contain just the
      supplied creator name (which may be blank), and an empty ancestor
      list.

      The structure should be freed when it is no longer needed by
      calling NDG\_FREEPROV.

      The structure should be freed when it is no longer needed by
      calling NDG\_FREEPROV.
   }
   \sstinvocation{
      CALL NDG\_READPROV( INDF, CREATOR, IPROV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         An identifier for the NDF containing the provenance information
         to be read.
      }
      \sstsubsection{
         CREATOR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A text identifier for the software that created INDF (usually the
         name of the calling application). The format of the identifier
         is arbitrary, but the form {\tt "}PACKAGE:COMMAND{\tt "} is recommended.
      }
      \sstsubsection{
         IPROV = INTEGER (Returned)
      }{
         An identifier for the structure holding the provenance information
         read from the NDF. NDG\_\_NULL is returned if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_REMOVEPROV
}{
   Remove one or more ancestors from a provenance structure
}{
   \sstdescription{
      This routine removes one or more ancestors from the supplied
      provenance structure. The direct parents of the removed ancestor
      are assigned to the direct children of the removed ancestor. Note,
      any history records stored in the removed ancestors are lost.
   }
   \sstinvocation{
      CALL NDG\_REMOVEPROV( IPROV, NANC, IANC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPROV = INTEGER (Given)
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by NDG\_READPROV.
      }
      \sstsubsection{
         NANC = INTEGER (Given)
      }{
         The length of the ANC array.
      }
      \sstsubsection{
         ANC( $*$ )  = INTEGER (Given)
      }{
         An array holding the indices of the ancestor NDFs to be removed.
         Each supplied value must be at least 1, and must be no more than
         the number of ancestors in the provenance extension (as returned
         by NDG\_COUNTPROV). An error is reported otherwise. The supplied
         list is sorted into decreasing order before use so that the
         highest index ancestor is removed first.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_ROOTPROV
}{
   Identify the root ancestors in a provenance structure
}{
   \sstdescription{
      This routine searches the supplied provenance structure for root
      ancestors, and returns information about them. An ancestor is a root
      ancestor if it does not itself have any ancestors.
   }
   \sstinvocation{
      CALL NDG\_ROOTPROV( IPROV, KM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPROV = INTEGER (Given)
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by NDG\_READPROV.
      }
      \sstsubsection{
         KM = INTEGER (Returned)
      }{
         A pointer to an AST KeyMap containing an entry for each root
         ancestor. The key associated with each entry is the path to the
         NDF and the value of the entry is an integer that gives the
         position of the root ancestor within the list of all ancestors.
         This integer value can be supplied to ndgGetProv in order to get
         further information about the root ancestor. The first ancestor NDF
         has an index of one. An index of zero refers to the NDF from which
         the provenance information was read.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_UNHASHPROV
}{
   Clear the hash code describing the creation of the Provenance
}{
   \sstdescription{
      Each ancestor in a Provenance structure may contain a copy of the
      History information stored in the associated ancestor NDF. Storing
      the complete History component from each ancestor NDF would be very
      wastefull since the NDF History component will usually contain not
      only records of operations performed on the ancestor NDF, but also
      all History records inherited from the {\tt "}primary{\tt "} NDF (i.e. the NDF
      from which the ancestor was propagated). Since these inherited
      History records will already be stored with other ancestors in the
      Provenance structure, it is not necessary to store them again.
      However, this means that when we add a new parent into a Provenance
      structure using NDG\_PUTPROV, NDG needs some way of knowing which
      records within the new NDF are unique to the NDF (and should thus
      be stored in the Provenance structure), and which were inherited
      from earlier ancestors (and will thus already be stored in the
      Provenance structure). The solution is for each PROVENANCE extension
      to include a {\tt "}creator{\tt "} hash code for the History record that describes
      the creation of the NDF. When an NDF is supplied to NDG\_PUTPROV, each
      History record, starting with the most recent, is copied from the
      NDF into the Provenance structure, until a History record is found
      which has a hash code equal to the creator hash code in the NDF. The
      copying of history records then stops since all earlier history
      records will already be present in the Provenance structure.

      This routine clears the creator hash code in the supplied
      Provenance structure, so that a new one will be calculated when the
      Provenance structure is written to an NDF using NDG\_WRITEPROV. This
      is useful for instance if the Provenance was written to the NDF
      using NDG\_WRITEPROV before the NDF History record was completed. In
      this case, you would probably want to re-read the Provenance from
      the NDF, use this function to clear the creator hash code, and then
      re-write the Provenance to the NDF, thus forcing a new creator hash
      code to be stored in the NDF.
   }
   \sstinvocation{
      CALL NDG\_UNHASHPROV( IPROV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPROV = INTEGER (Given)
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by NDG\_READPROV.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_UNHIDEPROV
}{
   Un-hide an ancestor in a provenance structure
}{
   \sstdescription{
      This function ensures that a given ancestor is not flagged as
      {\tt "}hidden{\tt "}. See NDG\_HIDEPROV and NDG\_COPYPROV.
   }
   \sstinvocation{
      CALL NDG\_UNHIDEPROV( IPROV, IANC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPROV = INTEGER (Given)
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by ndgReadProv
      }
      \sstsubsection{
         IANC = INTEGER (Given)
      }{
         The index of the ancestor NDF to be un-hidden. The value is used as
         an index into the ANCESTORS array. An error will be reported if the
         value is too large, or is less than 0.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         No error is reported if the specified ancestor is not currently
         hidden (in which case this function returns without action).
      }
   }
}
\sstroutine{
   NDG\_WRITEPROV
}{
   Write provenance information to an NDF
}{
   \sstdescription{
      This routine writes the contents of the supplied provenance
      structure out to a given NDF, replacing any existing provenance
      information in the NDF.
   }
   \sstinvocation{
      CALL NDG\_WRITEPROV( IPROV, INDF, WHDEF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPROV = INTEGER (Given)
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by NDG\_READPROV.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         Identifier for the NDF in which to store the provenance
         information.
      }
      \sstsubsection{
         WHDEF = INTEGER (Given)
      }{
         The correct recording of history information within the
         PROVENANCE extension requires that the current history record
         within the supplied NDF at the time this function is called,
         describes the creation of the NDF. Very often, an application
         will not itself add any history to the NDF, but will instead
         rely on the automatic recording of default history provided by
         the NDF library. Normally, default history is recorded when the
         NDF is released from the NDF system (e.g. using NDF\_ANNUL or
         NDF\_END). So if this function is called prior to the release of
         the NDF (which it normally will be), then the default history
         information will not yet have been recorded, resulting in
         incorrect information being stored in the PROVENANCE extension.
         For this reason, the WHDEF argument is supplied. If it is set
         to .TRUE., a check is made to see if default history has already
         been stored in the NDF. If .FALSE., default history is stored
         in the NDF before going on to create the PROVENANCE extension.
         Applications that do not use the default history recording
         mechanism, but instead store their own history information,
         should supply .FALSE. for WHDEF, and should also ensure that
         history information has been stored in the NDF before calling
         this routine.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\newpage
\subsection{Full C Function Specifications}
\sstroutine{
   ndgBegpv
}{
   Begin an NDF provenance block
}{
   \sstdescription{
      This routine should be called to mark the start of an NDF
      provenance block. The block should be ended by a matching
      call to ndgEndpv. See ndgEndpv for more details.

      Note - provenance blocks must not be nested.
   }
   \sstinvocation{
      void ndgBegpv( int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}
\sstroutine{
   ndgCopyProv
}{
   Copy a Provenance structure, optionally removing any hidden ancestors
}{
   \sstdescription{
      This function produces a deep copy of the supplied Provenance
      structure, and then optionally uses ndgRemoveProv to remove any
      hidden ancestors from the copy. A pointer to the copy is returned.
   }
   \sstinvocation{
      NdgProvenance $*$ndgCopyProv( NdgProvenance $*$prov, int cleanse,
                                  int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         prov
      }{
         A pointer to the provenance information to be Copied.
      }
      \sstsubsection{
         cleanse
      }{
         If non-zero, then any ancestors which have been hidden using
         ndgHideProv are removed from the returned Provenance structure
         (see ndgRemoveProv).
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         A pointer to the new Provenance structure, which should be freed
      }{
      }
      \sstsubsection{
         using ndgFreeProv when no longer needed.
      }{
      }
   }
}
\sstroutine{
   ndgCountProv
}{
   Return the number of ancestors in a provenance structure
}{
   \sstdescription{
      This function returns the number of ancestors described in the
      supplied provenance structure.
   }
   \sstinvocation{
      result = ndgCountProv( NdgProvenance $*$prov, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         prov
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by ndgReadProv
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         The number of ancestor NDFs stored in the supplied provenance
      }{
      }
      \sstsubsection{
         structure, or zero if an error occurs.
      }{
      }
   }
}
\sstroutine{
   ndgEndpv
}{
   End an NDF provenance block
}{
   \sstdescription{
      This routine should be called to mark the end of an NDF
      provenance block. The block should have been started by a
      matching call to ndgBegpv. Note, provenance blocks must
      not be nested.

      During a provenance block, a list is maintained of all the
      existing NDFs that have had their Data array mapped (either in
      read or update mode) during the block. Another list is maintained
      of all the NDFs that have been written (either existing NDFs
      accessed in update mode or new NDFs) during the block.

      When the block ends, the provenance information within each
      NDF in the second may be modified to include all the NDFs in the
      first list as parents. Whether or not this occurs is controlled by
      the AUTOPROV environment variable. If AUTOPROV is set to {\tt '}1{\tt '} then
      the input NDFs are added to the provenance information in the
      output NDF. If AUTOPROV is set to anything other than {\tt '}1{\tt '} then the
      output provenance is not updated. If AUTOPROV is not set at all,
      then the output provenance will be updated only if one or more of
      the input NDFs contains a PROVENANCE extension.
   }
   \sstinvocation{
      void ndgEndpv( const char $*$creatr, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         creatr
      }{
         An identifier for the calling application. The format of the
         identifier is arbitrary, but the form {\tt "}PACKAGE:COMMAND{\tt "}
         is recommended.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}
\sstroutine{
   ndgFormatProv
}{
   Format the information in a provenance structure
}{
   \sstdescription{
      This function returns an AST KeyMap holding a set of text strings
      containing information taken from the supplied provenance structure.

      The returned KeyMap has an entry with key {\tt "}0{\tt "} that describes the NDF
      from which the provenance was read. It also has an entry describing
      each ancestor NDF. These entries have keys {\tt "}1{\tt "}, {\tt "}2{\tt "}, {\tt "}3{\tt "}, etc, up to
      the number of ancestors in the NDF.

      Each of these entries contains a pointer to another AST KeyMap
      which may contain any subset of the following entries (all of which
      are strings):

      {\tt "}ID{\tt "} - the integer index within the ancestors array (zero for the
             main NDF).

      {\tt "}PATH{\tt "} - The full path or base name for the NDF (see {\tt "}base{\tt "}).

      {\tt "}DATE{\tt "} - The date of creation of the NDF.

      {\tt "}CREATOR{\tt "} - The software item that created the NDF.

      {\tt "}PARENTS{\tt "} - A comma-separated list of indices into the ancestors
             array that identifies the direct parents of the NDF.

      {\tt "}MORE{\tt "} - A summary of the contents of the MORE structure associated
             with the NDF.

      {\tt "}HISTORY{\tt "} - A vector entry holding one or more KeyMaps. Each
             KeyMap contains items that describe an action performed on
             the ancestor. The actions are stored in chronological order
             within the vector entry. The last KeyMap in the vector
             describes the action that created the ancestor NDF. Any
             earlier KeyMaps in the vector describe any subsequent actions
             performed on the ancestor NDF prior to it being used in the
             creation of its parent. Each KeyMap contains the following
             scalar character entries (all taken from the corresponding
             record in the NDF HISTORY component):

      \sstitemlist{

         \sstitem
                {\tt "}DATE{\tt "}: The date and time of the action (e.g. {\tt "}2009-JUN-24
                          14:00:53.752{\tt "} ).

         \sstitem
                {\tt "}COMMAND{\tt "}: An indication of the command that performed the
                          action (e.g. {\tt "}WCSATTRIB (KAPPA 1.10-6){\tt "} ).

         \sstitem
                {\tt "}USER{\tt "}: The user name that performed the action
                          (e.g. {\tt "}dsb{\tt "}).

         \sstitem
                {\tt "}TEXT{\tt "}: The full text of the NDF history record. This is
                          arbitrary, but for NDFs created by Starlink
                          software it will usually include environment
                          parameter values, and the full path of the command
                          that performed the action.

      }
      Finally, the returned KeyMap has an entry with key {\tt "}MXLEN{\tt "} that is
      again a pointer to another KeyMap with the same entries listed
      above (except that it has no {\tt "}HISTORY{\tt "} entry). However, this time
      the entries are integers, not strings, and holds the maximum field
      width used to format the strings.
   }
   \sstinvocation{
      void ndgFormatProv( NdgProvenance $*$prov, int base, AstKeyMap $*$$*$keymap,
                          int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         prov
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by ndgReadProv
      }
      \sstsubsection{
         base
      }{
         If non-zero, then the PATH field in the returned KeyMap holds the
         base name of each NDF rather than the full path.
      }
      \sstsubsection{
         keymap
      }{
         A location at which to returned a pointer to the returned AST KeyMap.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}
\sstroutine{
   ndgFreeProv
}{
   Free a structure holding provenance information
}{
   \sstdescription{
      This function frees the resources used to hold a provenance
      structure.
   }
   \sstinvocation{
      NdgProvenance $*$ndgFreeProv( NdgProvenance $*$prov, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         prov
      }{
         A pointer to the provenance information to be freed.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         A NULL pointer is returned.
      }{
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This function attempts to execute even if an error has already
         occurred.
      }
   }
}
\sstroutine{
   ndgGetProv
}{
   Create a KeyMap holding information about an ancestor
}{
   \sstdescription{
      This function returns information about a specified ancestor in the
      supplied provenance structure.
   }
   \sstinvocation{
      result = ndgGetProv( NdgProvenance $*$prov, int ianc, HDSLoc $*$$*$more,
                           int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         prov
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by ndgReadProv
      }
      \sstsubsection{
         ianc
      }{
         The index of the ancestor NDF for which information should be
         returned. A value of zero will result in information being returned
         that describes the NDF from which the provenance information was
         read. Otherwise, the {\tt "}ianc{\tt "} value is used as an index into the
         ANCESTORS array. No error is reported if {\tt "}ianc{\tt "} is too large, but a
         NULL pointer will be returned as the function value.
      }
      \sstsubsection{
         more
      }{
         The location at which to return a pointer to a locator for a
         temporary HDS object containing a full deep copy of the MORE
         structure associated with the requested ancestor. The
         returned locator should be annulled using datAnnul when no
         longer needed. A NULL pointer may be supplied for this argument
         if the MORE structure is not needed. A NULL pointer will be
         returned if the requested ancestor has no MORE component. Note,
         the returned object will be assigned an arbitrary HDS Name,
         which will not in general be {\tt "}MORE{\tt "}.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         A pointer to an AST KeyMap containing entries with the following
      }{
      }
      \sstsubsection{
         keys and values:
      }{
      }
      \sstsubsection{
         - {\tt "}PATH{\tt "}: A string holding the path of the ancestor NDF.
      }{
      }
      \sstsubsection{
         - {\tt "}DATE{\tt "}: A string holding the formatted UTC date and time at
      }{
         which the provenance information for the ancestor NDF was
         recorded.
      }
      \sstsubsection{
         - {\tt "}CREATOR{\tt "}: A string identifying the software that created the
      }{
         ancestor NDF.
      }
      \sstsubsection{
         - {\tt "}PARENTS{\tt "}: A 1D vector of integers that are the indices of
      }{
         the immediate parents of the ancestor.
      }
      \sstsubsection{
         - {\tt "}MORE{\tt "}: A KeyMap containing any scalar or vector primitive
      }{
         values stored at the top level of the associated HDS MORE
         structure. The HDS name of the component is used as the key.
         The full contents of the MORE structure are returned by the
         {\tt "}more{\tt "} argument (see above).
      }
      \sstsubsection{
         - {\tt "}HISTORY{\tt "}: A vector entry holding one or more KeyMaps. Each
      }{
         KeyMap contains items that describe an action performed on
         the ancestor. The actions are stored in chronological order
         within the vector entry. The last KeyMap in the vector
         describes the action that created the ancestor NDF. Any
         earlier KeyMaps in the vector describe any subsequent actions
         performed on the ancestor NDF prior to it being used in the
         creation of its parent. Each KeyMap contains the following
         scalar character entries (all taken from the corresponding
         record in the NDF HISTORY component):
         \sstitemlist{

            \sstitem
            {\tt "}DATE{\tt "}: The date and time of the action (e.g. {\tt "}2009-JUN-24
              14:00:53.752{\tt "} ).

            \sstitem
            {\tt "}COMMAND{\tt "}: An indication of the command that performed the
              action (e.g. {\tt "}WCSATTRIB (KAPPA 1.10-6){\tt "} ).

            \sstitem
            {\tt "}USER{\tt "}: The user name that performed the action (e.g. {\tt "}dsb{\tt "}).

            \sstitem
            {\tt "}TEXT{\tt "}: The full text of the NDF history record. This is
              arbitrary, but for NDFs created by Starlink software it will
              usually include environment parameter values, and the full
              path of the command that performed the action.
         }
      }
      \sstsubsection{
         If the specified ancestor does not have any of these items of
      }{
      }
      \sstsubsection{
         information, then the corresponding entry will not be present
      }{
      }
      \sstsubsection{
         in the returned KeyMap. For instance, if the ancestor has no
      }{
      }
      \sstsubsection{
         immediate parent NDFs, then the {\tt "}PARENTS{\tt "} entry will not be
      }{
      }
      \sstsubsection{
         present in the KeyMap. A NULL pointer will be returned if the
      }{
      }
      \sstsubsection{
         NDF has no provenance extension, or if {\tt "}ianc{\tt "} is outside the
      }{
      }
      \sstsubsection{
         bounds of the ANCESTORS array (and is not zero). The returned
      }{
      }
      \sstsubsection{
         KeyMap pointer should be annulled when it is no longer needed,
      }{
      }
      \sstsubsection{
         either by calling astAnnul explicitly, or by relying on astEnd
      }{
      }
      \sstsubsection{
         to annul it (together with all the other AST Objects created in
      }{
      }
      \sstsubsection{
         the current AST Object context).
      }{
      }
   }
}
\sstroutine{
   ndgHideProv
}{
   Hide an ancestor in a provenance structure
}{
   \sstdescription{
      This function flags a specified ancestor as {\tt "}hidden{\tt "}. The only
      effect this has is that the ancestor will not be included in
      Provenance structures created by the ndgCopyProv function.
   }
   \sstinvocation{
      ndgHideProv( NdgProvenance $*$prov, int ianc, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         prov
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by ndgReadProv
      }
      \sstsubsection{
         ianc
      }{
         The index of the ancestor NDF to be hidden. The value is used as an
         index into the ANCESTORS array. An error will be reported if the
         value is too large, or is less than 1 (the main NDF cannot be
         hidden).
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}
\sstroutine{
   ndgIsHiddenProv
}{
   See if an ancestor in a provenance structure is hidden
}{
   \sstdescription{
      This function returns a non-zero value if the specified ancestor
      has been hidden. See ndgHideProv and ndgCopyProv.
   }
   \sstinvocation{
      int ndgIsHiddenProv( NdgProvenance $*$prov, int ianc, int $*$status );
   }
   \sstarguments{
      \sstsubsection{
         prov
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by ndgReadProv
      }
      \sstsubsection{
         ianc
      }{
         The index of the ancestor NDF to be checked. The value is used as
         an index into the ANCESTORS array. An error will be reported if the
         value is too large, or is less than 0.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}
\sstroutine{
   ndgModifyProv
}{
   Modify the information stored for a particular ancestor
}{
   \sstdescription{
      This function modifies the information stored for a given ancestor
      in the supplied provenance structure. The new values to store
      are supplied in an Ast KeyMap such as returned by ndgGetProv.
   }
   \sstinvocation{
      void ndgModifyProv( NdgProvenance $*$prov, int ianc, AstKeyMap $*$km,
                          HDSLoc $*$more, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         prov
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by ndgReadProv
      }
      \sstsubsection{
         ianc
      }{
         The index of the ancestor NDF for which information should be
         modified. A value of zero will result in information being modified
         for the NDF from which the the supplied provenance structure was
         read. Otherwise, the {\tt "}ianc{\tt "} value is used as an index into the
         ANCESTORS array. An error is reported if {\tt "}ianc{\tt "} is too large.
      }
      \sstsubsection{
         km
      }{
         A pointer to an AST KeyMap containing the values to store. Entries
         with the following keys are recognised:

         \sstitemlist{

            \sstitem
            {\tt "}PATH{\tt "}: A string holding the path of the ancestor NDF.

            \sstitem
            {\tt "}DATE{\tt "}: A string holding the formatted UTC date and time at
              which the provenance information for the ancestor NDF was
              recorded.

            \sstitem
            {\tt "}CREATOR{\tt "}: A string identifying the software that created the
              ancestor NDF.

            \sstitem
            {\tt "}MORE{\tt "}: A KeyMap containing extra information to store at the
            top level of the MORE component for the ancestor. Only entries
            holding primitive data values (scalar or vector) are used -
            entries holding nested KeyMaps, etc, are ignored. If an entry in
            this KeyMap has the same name as a component in the supplied
            {\tt "}more{\tt "} HDS structure, then the KeyMap value is used in preference
            to the HDS value.

         }
         If the {\tt "}DATE{\tt "} or {\tt "}CREATOR{\tt "} components are missing then the
         corresponding item of information will be deleted from the
         provenance extension. To delete the {\tt "}MORE{\tt "} component in the
         provenance extension, supply a KeyMap without a MORE entry, and
         also supply DAT\_NOLOC for the {\tt "}more{\tt "} argument. An error is
         reported if the supplied KeyMap has no {\tt "}PATH{\tt "} entry. Note, the
         PARENTS list and HISTORY information stored with the specified
         ancestor cannot be modified (any {\tt "}PARENTS{\tt "} or {\tt "}HISTORY{\tt "}
         component in the supplied HDS structure will be ignored).
      }
      \sstsubsection{
         more
      }{
         A locator for an HDS object containing additional information to
         be associated with the requested ancestor. A NULL pointer may be
         supplied for this argument The contents of the MORE component
         in the provenance extension will be the union of any structure
         supplied through this argument, and any values supplied through
         the MORE entry in the supplied KeyMap. If the same component
         name occurs in both, then the KeyMap value takes precedence.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}
\sstroutine{
   ndgPutProv
}{
   Add an NDF to the list of ancestors
}{
   \sstdescription{
      This function modifies the supplied provenance structure to indicate
      that a given NDF was used in the creation of the NDF associated with
      the supplied provenance structure.
   }
   \sstinvocation{
      ndgPutProv( NdgProvenance $*$prov, int indf, HDSLoc $*$more,
                  AstKeyMap $*$more2, int isroot, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         prov
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by ndgReadProv
      }
      \sstsubsection{
         indf
      }{
         An identifier for an NDF that is to be added into the list of
         ancestor NDFs in the supplied provenance information.
      }
      \sstsubsection{
         more
      }{
         A locator for an HDS structure containing arbitrary additional
         information about the new ancestor NDF, and how it was used in the
         creation of the output NDF. A NULL pointer can be supplied if
         required.
      }
      \sstsubsection{
         more2
      }{
         A pointer to an AstKeyMap holding extra items of information
         to be added into the MORE component. Only entries holding primitive
         data values (scalar or vector) are used - entries holding nested
         KeyMaps, etc, are ignored. If an entry in this KeyMap has the same
         name as a component in the supplied {\tt "}more{\tt "} HDS structure, then the
         KeyMap value is used in preference to the HDS value. A NULL pointer
         can be supplied if required.
      }
      \sstsubsection{
         isroot
      }{
         If non-zero, then the new ancestor NDF will be treated as a root
         NDF. That is, any provenance information in the supplied NDF is
         ignored. If zero, then any provenance information in the NDF is
         copied into the supplied provenance structure. The new ancestor NDF
         is then only a root NDF if it contains no provenance information.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}
\sstroutine{
   ndgReadProv
}{
   Read the provenance information from an NDF
}{
   \sstdescription{
      This function reads the information stored in the {\tt "}PROVENANCE{\tt "}
      extension of an NDF, storing it in a memory-resident structure for
      faster access. A pointer that identifies this structure is returned,
      and can be passed to other NDG provenance functions to manipulate
      the contents of the structure.

      If the NDF has no provenance information (for instance, if it is a
      newly created NDF), the returned structure will contain just the
      supplied creator name (which may be blank), and an empty ancestor
      list.

      The structure should be freed when it is no longer needed by
      calling ndgFreeProv.
   }
   \sstinvocation{
      NdgProvenance $*$ndgReadProv( int indf, const char $*$creator, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         indf
      }{
         An identifier for the NDF containing the provenance information
         to be read.
      }
      \sstsubsection{
         creator
      }{
         A text identifier for the software that created INDF (usually the
         name of the calling application). The format of the identifier
         is arbitrary, but the form {\tt "}PACKAGE:COMMAND{\tt "} is recommended.
         This value is only used if the the NDF does not contain any
         existing provenance information.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         A pointer that identifies the structure holding the provenance
      }{
      }
      \sstsubsection{
         information read from the NDF. Note, this is not a genuine pointer
      }{
      }
      \sstsubsection{
         to the structure and should not be de-referenced. A NULL pointer is
      }{
      }
      \sstsubsection{
         returned if an error occurs.
      }{
      }
   }
}
\sstroutine{
   ndgRemoveProv
}{
   Remove one or more ancestors from a provenance structure
}{
   \sstdescription{
      This routine removes one or more ancestors from the supplied
      provenance structure. The direct parents of the removed ancestor
      are assigned to the direct children of the removed ancestor. Note,
      any history records stored in the removed ancestors are lost.
   }
   \sstinvocation{
      void ndgRemoveProv( NdgProvenance $*$prov, int nanc, int $*$anc,
                          int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         prov
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by ndgReadProv
      }
      \sstsubsection{
         nanc
      }{
         The length of the {\tt "}anc{\tt "} array.
      }
      \sstsubsection{
         anc
      }{
         Pointer to an array holding the indices of the ancestor NDFs to be
         removed. Each supplied value must be at least 1, and must be no
         more than the number of ancestors in the provenance extension
         (as returned by ndgCountProv). An error is reported otherwise. The
         supplied list is sorted into decreasing order before use so that
         the highest index ancestor is removed first.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}
\sstroutine{
   ndgRootProv
}{
   Identify the root ancestors in a provenance structure
}{
   \sstdescription{
      This function searches the supplied provenance structure for root
      ancestors, and returns information about them. An ancestor is a root
      ancestor if it does not itself have any ancestors.
   }
   \sstinvocation{
      AstKeyMap $*$ndgRootProv( NdgProvenance $*$prov, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         prov
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by ndgReadProv
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         A pointer to an AST KeyMap containing an entry for each root
      }{
      }
      \sstsubsection{
         ancestor. The key associated with each entry is the path to the
      }{
      }
      \sstsubsection{
         NDF and the value of the entry is an integer that gives the
      }{
      }
      \sstsubsection{
         position of the root ancestor within the list of all ancestors.
      }{
      }
      \sstsubsection{
         This integer value can be supplied to ndgGetProv in order to get
      }{
      }
      \sstsubsection{
         further information about the root ancestor. The first ancestor NDF
      }{
      }
      \sstsubsection{
         has an index of one. An index of zero refers to the NDF from which
      }{
      }
      \sstsubsection{
         the provenance information was read.
      }{
      }
   }
}
\sstroutine{
   ndgUnhashProv
}{
   Clear the hash code describing the creation of the Provenance
}{
   \sstdescription{
      Each ancestor in a Provenance structure may contain a copy of the
      History information stored in the associated ancestor NDF. Storing
      the complete History component from each ancestor NDF would be very
      wastefull since the NDF History component will usually contain not
      only records of operations performed on the ancestor NDF, but also
      all History records inherited from the {\tt "}primary{\tt "} NDF (i.e. the NDF
      from which the ancestor was propagated). Since these inherited
      History records will already be stored with other ancestors in the
      Provenance structure, it is not necessary to store them again.
      However, this means that when we add a new parent into a Provenance
      structure using ndgPutProv, NDG needs some way of knowing which
      records within the new NDF are unique to the NDF (and should thus
      be stored in the Provenance structure), and which were inherited
      from earlier ancestors (and will thus already be stored in the
      Provenance structure). The solution is for each PROVENANCE extension
      to include a {\tt "}creator{\tt "} hash code for the History record that describes
      the creation of the NDF. When an NDF is supplied to ndgPutProv, each
      History record, starting with the most recent, is copied from the
      NDF into the Provenance structure, until a History record is found
      which has a hash code equal to the creator hash code in the NDF. The
      copying of history records then stops since all earlier history
      records will already be present in the Provenance structure.

      This routine clears the creator hash code in the supplied
      Provenance structure, so that a new one will be calculated when the
      Provenance structure is written to an NDF using ndgWriteProv. This
      is useful for instance if the Provenance was written to the NDF
      using ndgWriteProv before the NDF History record was completed. In
      this case, you would probably want to re-read the Provenance from
      the NDF, use this function to clear the creator hash code, and then
      re-write the Provenance to the NDF, thus forcing a new creator hash
      code to be stored in the NDF.
   }
   \sstinvocation{
      void ndgUnhashProv( NdgProvenance $*$prov, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         prov
      }{
         An identifier for a structure holding the provenance information
         as returned by ndgReadProv or ndgReadVotProv.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}
\sstroutine{
   ndgUnhideProv
}{
   Un-hide an ancestor in a provenance structure
}{
   \sstdescription{
      This function ensures that a given ancestor is not flagged as
      {\tt "}hidden{\tt "}. See ndgHideProv and ndgCopyProv.
   }
   \sstinvocation{
      ndgUnhideProv( NdgProvenance $*$prov, int ianc, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         prov
      }{
         An identifier for a structure holding the provenance information
         read from an NDF, as returned by ndgReadProv
      }
      \sstsubsection{
         ianc
      }{
         The index of the ancestor NDF to be un-hidden. The value is used as
         an index into the ANCESTORS array. An error will be reported if the
         value is too large, or is less than 0.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         No error is reported if the specified ancestor is not currently
         hidden (in which case this function returns without action).
      }
   }
}
\sstroutine{
   ndgWriteProv
}{
   Write provenance information to an NDF
}{
   \sstdescription{
      This function writes the contents of the supplied provenance
      structure out to a given NDF, replacing any existing provenance
      information in the NDF.
   }
   \sstinvocation{
      void ndgWriteProv( NdgProvenance $*$prov, int indf, int whdef,
                         int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         prov
      }{
         A pointer to the provenance information to be written out.
      }
      \sstsubsection{
         indf
      }{
         Identifier for the NDF in which to store the provenance
         information.
      }
      \sstsubsection{
         whdef
      }{
         The correct recording of history information within the
         PROVENANCE extension requires that the current history record
         within the supplied NDF at the time this function is called,
         describes the creation of the NDF. Very often, an application
         will not itself add any history to the NDF, but will instead
         rely on the automatic recording of default history provided by
         the NDF library. Normally, default history is recorded when the
         NDF is released from the NDF system (e.g. using ndfAnnul or
         ndfEnd). So if this function is called prior to the release of
         the NDF (which it normally will be), then the default history
         information will not yet have been recorded, resulting in
         incorrect information being stored in the PROVENANCE extension.
         For this reason, the {\tt "}whdef{\tt "} argument is supplied. If it is set
         to a non-zero value, a check is made to see if default history
         has already been stored in the NDF. If not, default history is
         stored in the NDF before going on to create the PROVENANCE
         extension. Applications that do not use the default history
         recording mechanism, but instead store their own history
         information, should supply a zero value for {\tt "}whdef{\tt "} and should
         also ensure that history information has been stored in the NDF
         before calling this function.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}

\section{Routines for controling recording of GRP group contents}

The functions described in this section allow the contents of GRP
groups to be appended to the default history record written by the
NDF library.

If an ADAM application accesses a parameter as a GRP group, the default
history record added by the NDF library to any output NDFs will include
the group expression supplied in response to the associated parameter
prompt. This is not always very informative - for instance, if the group
expression gives the name of a file from which the group contents are to
be read, rather than giving the group contents directly, then name of the
file will be recorded in the default history record but not the contents
of the file.

The NDG functions described below allow the default history record to be
expanded to include the contents of any GRP group parameters accessed by
the application. The contents of each such group is described in a new
line of text that begings with the string ``Group: <PARAM>='', where
<PARAM> is the name of the parameter with which the group is associated.

There are two parts to using these facilities:

\begin{enumerate}
\item Each time a group parameter is accessed, the group must be
``registered'' with NDG using ndgAddgh (NDG\_ADDGH).
\item Before the application accesses any group parameters, it must begin
a ``GRP history'' block by calling ndgBeggh (NDG\_BEGGH). When the
application has finished accessing group parameters, and producing output
NDFs, it should end the GRP history block by calling ndgEndgh (NDG\_ENDGH).
\end{enumerate}

During a GRP history block, a record is kept of all NDFs to which the NDF
library writes default history information. When ndgEndgh is called, the
contents of all groups registered using ndgAddgh within the GRP history
block, are appended to the current history record in each of the NDFs to
which default history has been written.

Note, within a GRP history block, it is possible to prevent selected NDFs
receiving this extra information by using ndgHltgh (NDG\_HLTGH) to stop
the recording of NDF names before the NDFs identifiers are annulled
(which is normally when the default history is written out), and then
calling ndgHltgh again afterwards to re-establish the recording of NDF
names.

The C interfaces are the direct equivalent of the F77 interfaces
described below - convert the F77 name to lower-case, remove the
underscore and capitalise the following character.

\sstroutine{
   NDG\_ADDGH
}{
   Register a GRP group for GRP NDF history recording
}{
   \sstdescription{
      This routine should be called to indicate that the contents of the
      supplied GRP group should be included in the default History
      information written out by the NDF library. It returns without
      action unless a GRP NDF history block has previously been created
      by calling NDG\_BEGGH.
   }
   \sstinvocation{
      CALL NDG\_ADDGH( PARAM, IGRP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter associated with the group.
      }
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         The GRP group identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The group is registered only if the current value of the
         associated parameter contains an {\tt "}INDIRECTION{\tt "} or {\tt "}NAME\_TOKEN{\tt "}
         control character (see SUN/150). This prevents group descriptions
         being added to the NDF history if the contents of the group are
         already described fully by the parameters list.

         \sstitem
         This routine records a copy of the group contents at the time
         this routine is called. Any subsequent changes to the contents of
         the group are not included in the default NDF history.

         \sstitem
         This routine can be invoked multiple times for the same parameter.
         Later invocations will replace the group contents registered by
         earlier invocations.
      }
   }
}
\sstroutine{
   NDG\_BEGGH
}{
   Begin a GRP NDF history block
}{
   \sstdescription{
      This routine should be called to mark the start of a GRP NDF
      history block. The block should be ended by a matching
      call to NDG\_ENDGH. See NDG\_ENDGH for more details.

      Note - GRP NDF history blocks must not be nested.
   }
   \sstinvocation{
      CALL NDG\_BEGGH( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_ENDGH
}{
   End a GRP NDF history block
}{
   \sstdescription{
      This routine should be called to mark the end of a GRP NDF
      history block. The block should have been started by a
      matching call to NDG\_BEGGH. Note, GRP NDF history blocks must
      not be nested.

      During a GRP NDF history block, application code can register GRP
      groups using routine NDG\_ADDGH. When default history information is
      written to any NDF, a handler routine is called that adds a new
      history record to the NDF for each currently registered GRP group.
      The new history record identifies the ADAM parameter with which the
      group is associated, and lists the contents of the group (as it
      existed at the time the group was registered - any subsequent changes
      to the group contents are ignored).
   }
   \sstinvocation{
      CALL NDG\_ENDGH( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_HLTGH
}{
   Temporarily halt a GRP history block
}{
   \sstdescription{
      This routine can be called to stop subseqently accessed NDFs
      being added to the list of NDFs that will receive extra history
      holding GRP group contents when NDG\_ENDGH is called to end the
      current GRP history block.

      In addition, if the GRP history block is halted, this routine will
      ensure that the AUTO\_HISTORY tuning parameter used by the NDF
      library is set to zero, thus preventing the automatic creation of
      History components in any new NDFs. When the block is un-halted
      this tuning parameter is set back to the value it had at the time
      the block was halted.
   }
   \sstinvocation{
      CALL NDG\_HLTGH( NEW, OLD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NEW = LOGICAL (Read)
      }{
         The new required GRP history-recording state.
      }
      \sstsubsection{
         OLD = LOGICAL (Returned)
      }{
         The GRP history-recording state on entry to this routine.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A .FALSE. GRP history-recording state means that any subseqently
         accessed NDFs will not be added to the list of NDFs to receive
         extra history holding GRP group contents when NDG\_ENDPV is called.

         \sstitem
         A .TRUE. GRP history-recording state means that any subseqently
         accessed NDFs are added to the list of NDFs to receive  extra
         history holding GRP group contents when NDG\_ENDPV is called.
      }
   }
}
\sstroutine{
   NDG\_HWRGH
}{
   Write GRP history to an NDF
}{
   \sstdescription{
      This routine appends a description of each currently registered GRP
      group to the current History record in the supplied NDF. See
      NDF\_ENDGH. It returns without action if 1) the NDF library has not
      yet written a default history record to the NDF, or 2) GRP history
      has already been written to the NDF.
   }
   \sstinvocation{
      CALL NDG\_HWRGH( INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\section{Changes Introduced in NDG Version 5.8}
\begin{itemize}
   \item Added functions for appending GRP group contents to default
    history records written by the NDF library.
   \item New function ndgHltpv (NDG\_HLTPV) allows selected NDFs to be
    exempted from a provenance block.
\end{itemize}

\section{Changes Introduced in NDG Version 5.7}
\begin{itemize}
   \item The Provenance handling API has changed to use a temporary
    in-memory structure to describe a PROVENANCE extension, rather than
    every function accessing the NDF on disk.
   \item The PROVENANCE extension now allows the recording of NDF History
    with each ancestor.
\end{itemize}

\section{Changes Introduced in NDG Version 5.6}
\begin{itemize}
   \item A new C function ndgRmprvs has been added, that removes multiple
         provenance ancestors from an NDF.
   \item A new C function ndgGtprvk has been added, that returns provenance
         information for a given ancestor in the form of an AST KeyMap.
\end{itemize}

\section{Changes Introduced in NDG Version 5.5}
\begin{itemize}
   \item A new routine NDG\_MOREG has been added which searches the
         extensions of a supplied NDF for encapsulated NDFs, appending
         the paths to such NDFs to a supplied GRP group.
\end{itemize}

\section{Changes Introduced in NDG Version 5.4}
\begin{itemize}
   \item Added new routines: NDG\_MDPRV.
\end{itemize}

\section{Changes Introduced in NDG Version 5.3}
\begin{itemize}
   \item Added routines for storing and retrieving provenance information:
         NDG\_PTPRV, NDG\_RTPRV, NDG\_GTPRV, NDG\_BEGPV and NDG\_ENDPV.
\end{itemize}

\section{Changes Introduced in NDG Version 5.2}
\begin{itemize}
   \item The C routine ndg1\_regsb.c has been changed to avoid warning
         message about "tmpnam" when linking applications on Redhat Linux
	 systems.
\end{itemize}

\section{Changes Introduced in NDG Version 5.1}
\begin{itemize}
   \item A new routine NDG\_ASEXP has been added which allows a group of
         existing NDFs to be created from a group expression supplied as
         a subroutine argument. This is very similar to NDG\_ASSOC except
         that NDG\_ASSOC gets the group expression from the parameter system
         instead of from its argument list.
\end{itemize}

\end{document}
