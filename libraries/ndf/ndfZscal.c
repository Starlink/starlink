#include <stdlib.h>
#include "sae_par.h"
#include "dat_par.h"
#include "ndf1.h"
#include "ndf_err.h"
#include "ndf.h"
#include "star/util.h"
#include <string.h>
#include "mers.h"

void ndfZscal_( int indf1, const char *type, double scale[], double zero[],
               int *place, int *indf2, int *status ){
/*
*+
*  Name:
*     ndfZscal

*  Purpose:
*     Create a compressed copy of an NDF using "scale" compression

*  Synopsis:
*     void ndfZscal( int indf1, const char *type, double scale[],
*                    double zero[], int *place, int *indf2, int *status )

*  Description:
*     This function creates a new NDF holding a compressed copy of the
*     supplied NDF. The compression is performed by scaling the DATA and
*     VARIANCE arrays using a simple linear scaling, and then casting the
*     scaled values into the specified data type. The amount of
*     compression, and the amount of information lost, is thus determined
*     by the input and output data types. For instance, if the input NDF is
*     of type _DOUBLE (eight bytes) and the output is of type _WORD (two
*     bytes), the compression ratio for each array component will be four
*     to one.

*  Parameters:
*     indf1
*        Identifier for the input NDF.
*     type
*        Pointer to a null terminated string holding the numeric type of
*        the output NDF's DATA component (e.g. "_REAL" or "_INTEGER").
*     scale
*        The scale factors to use when compressing the array components in
*        the supplied NDF. The DATA array will be scaled using "scale"( 1 )
*        and the VARIANCE array - if present - will be scaled using
*        "scale"( 2 ). If either of these is set to VAL__BADD, then a
*        suitable value will be found automatically by inspecting the
*        supplied array values. The values actually used will be returned
*        on exit. See "Notes:" below. On exit, any supplied values will be
*        rounded to values that can be represented accurately in the data
*        type of the input NDF. The supplied "scale" array should have at
*        least "2" elements.
*     zero
*        The zero offsets to use when compressing the array components in
*        the supplied NDF. The DATA array will be offset using "zero"( 1 )
*        and the VARIANCE array - if present - will be offset using "zero"(
*        2 ). If either of these is set to VAL__BADD, then a suitable value
*        will be found automatically by inspecting the supplied array
*        values. The values actually used will be returned on exit. See
*        "Notes:" below. On exit, any supplied values will be rounded to
*        values that can be represented accurately in the data type of the
*        input NDF. The supplied "zero" array should have at least "2"
*        elements.
*     *place
*        An NDF placeholder (e.g. generated by the ndfPlace function) which
*        indicates the position in the data system where the new NDF will
*        reside. The placeholder is annulled by this function, and a value
*        of NDF__NOPL will be returned (as defined in the include file
*        "ndf.h").
*     *indf2
*        Returned holding the identifier for the new NDF.
*     *status
*        The global status.

*  Notes:
*     -  The compressed data may not be of type _DOUBLE. An error will be
*     reported if "type" is "_DOUBLE".
*     -  Only arrays that are stored in SIMPLE or PRIMITIVE form can be
*     compressed. An error is reported if any other storage form is
*     encountered whilst compressing the input NDF.
*     -  The uncompressed array values are obtained by multiplying the
*     compressed values by "scale" and then adding on "zero".
*     -  The default scale and zero values (used if VAL__BADD values are
*     supplied for "scale" and/or "zero") are chosen so that the extreme
*     array values will fit into the dynamic range of the output data type,
*     allowing a small safety margin.
*     -  Complex arrays cannot be compressed using this function. An error
*     will be reported if the input NDF has a complex type, or if "TYPE"
*     represents a complex data type.
*     -  The resulting NDF will be read-only. An error will be reported if
*     an attempt is made to map it for WRITE or UPDATE access.
*     - When the output NDF is mapped for READ access, uncompression occurs
*     automatically. The pointer returned by ndfMap provides access to the
*     uncompressed array values.
*     -  The result of copying a compressed NDF (for instance, using
*     ndfProp, etc.) will be an equivalent uncompressed NDF.
*     - When applied to a compressed NDF, the ndfType and ndfFtype
*     functions return information about the data type of the uncompressed
*     NDF.
*     -  If this function is called with "status" set, then a value of
*     NDF__NOID will be returned for the "indf2" parameter, although no
*     further processing will occur. The same value will also be returned
*     if the function should fail for any reason. In either event, the
*     placeholder will still be annulled. The NDF__NOID constant is defined
*     in the header file "ndf.h".

*  Copyright:
*     Copyright (C) 2018 East Asian Observatory
*     All rights reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or modify
*     it under the terms of the GNU General Public License as published by
*     the Free Software Foundation; either version 2 of the License, or (at
*     your option) any later version.
*
*     This program is distributed in the hope that it will be useful,but
*     WITHOUT ANY WARRANTY; without even the implied warranty of
*     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
*     General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 51 Franklin Street,Fifth Floor, Boston, MA
*     02110-1301, USA

*  Authors:
*     RFWS: R.F. Warren-Smith (STARLINK)
*     DSB: David S. Berry (EAO)

*  History:
*     3-APR-2019 (DSB):
*        Original version, based on equivalent Fortran function by RFWS.

*-
*/

/* Local Variables: */
   NdfACB *acb1;         /* Pointer to input NDF entry in ACB */
   NdfACB *acb2;         /* Pointer to output NDF entry in ACB */
   NdfPCB *pcb;          /* Pointer to placeholder entry in the PCB */
   char comp[ 2 ][ 9 ] = { "DATA", "VARIANCE" };       /* Names of array
                                                         components to scale */
   const char *datyp[ NDF__NTYP ];  /* Data */
   char form[ NDF__SZFRM + 1 ];    /* Array storage form */
   int cpf[ NDF__NCPF ];/* Component propagation flags */
   int erase;            /* Whether to erase placeholder object */
   int icomp;            /* Component index */
   int intype;           /* Data type of input NDF */
   int ncomp;            /* The number of array components to scale */
   int outtyp;           /* Data type of output NDF */
   int there;            /* Does the VARIANCE component exist? */
   size_t el;            /* Number of array elements */
   void *pntr1;          /* Pointer to input array */
   void *pntr2;          /* Pointer to output array# */

/* Local Data: */
   datyp[ NDF__TYPB ] = "_BYTE";
   datyp[ NDF__TYPD ] = "_DOUBLE";
   datyp[ NDF__TYPI ] = "_INTEGER";
   datyp[ NDF__TYPK ] = "_INT64";
   datyp[ NDF__TYPR ] = "_REAL";
   datyp[ NDF__TYPUB ] = "_UBYTE";
   datyp[ NDF__TYPUW ] = "_UWORD";
   datyp[ NDF__TYPW ] = "_WORD";

/* Set an initial value for the INDF parameter. */
   *indf2 = NDF__NOID;

/* Check the inherited status */
   if( *status != SAI__OK ) return;

/* Ensure the NDF library has been initialised. */
   NDF_INIT( status );

/* Import the NDF placeholder, converting it to a PCB index. */
   pcb = NULL;
   ndf1Imppl( *place, &pcb, status );

/* Import the input NDF identifier. */
   ndf1Impid( indf1, &acb1, status );

/* Parse the output data type. */
   ndf1Pstyp( type, &outtyp, status );

/* Report an error if the input DATA array is not stored in SIMPLE
   or PRIMITIVE form. */
   aryForm( acb1->did, form, status );
   if( strcmp( form, "SIMPLE" ) && strcmp( form, "PRIMITIVE" ) && *status
       == SAI__OK ) {
      *status = NDF__BADSF;
      msgSetc( "F", form );
      errRep( " ", "The NDF is already compressed (using ^F compression).",
              status );
   }

/* Propagate all components of the input NDF, except for the DATA and
   VARIANCE arrays, to create a new base NDF and an ACB entry to describe it. */
   for( icomp = 0; icomp < NDF__NCPF; icomp++ ){
      cpf[ icomp ] = 1;
   }
   cpf[ NDF__DCPF ] = 0;
   cpf[ NDF__VCPF ] = 0;

   ndf1Prp( acb1, 0, NULL, cpf, pcb, &acb2, status );

/* Set a new full data type for the data and variance arrays of the new
   NDF. Since the NDF has only just been created, we know its array
   component are not mapped, so we do not need to check. */
   aryStype( type, acb2->did, status );
   ndf1Vsftp( type, acb2, status );

/* If the variance component does not exist, we only need to loop over
   one array component (DATA). */
   ndf1Vsta( acb1, &there, status );
   if( there ) {
      ncomp = 2;
   } else {
      ncomp = 1;
   }

/* Loop to scale the DATA and VARIANCE arrays */
   for( icomp = 0; icomp < ncomp; icomp++ ){

/* If this is the VARIANCE component, report an error if the input
   VARIANCE array is not stored in SIMPLE form. */
      if( icomp + 1 == 2 ) {
         ndf1Vfrm( acb1, form, sizeof( form ), status );
         if( strcmp( form, "SIMPLE" ) && *status == SAI__OK ) {
            *status = NDF__BADSF;
            msgSetc( "F", form );
            errRep( " ", "The NDF is already compressed (using ^F "
                    "compression).", status );
         }
      }

/* Determine the numeric type of the input array. */
      ndf1Typ( acb1, comp[ icomp ], &intype, status );

/* Map the input array for READ access. */
      ndf1Map( acb1, comp[ icomp ], datyp[ intype ], 0, "READ", &pntr1,
               &pntr1, status );

/* Map the output array for WRITE access. */
      ndf1Map( acb2, comp[ icomp ], type, 0, "WRITE", &pntr2, &pntr2, status );

/* Calculate the number of array elements. */
      arySize( acb1->did, &el, status );

/* Scale the input array, storing the results in the output array. If
   necessary, default scale and zero terms are found and returned. */
      ndf1Zscal( intype, pntr1, el, outtyp, scale + icomp, zero + icomp,
                 pntr2, status );

/* Unmap the input and output arrays. */
      ndf1Ump( acb1, comp[ icomp ], status );
      ndf1Ump( acb2, comp[ icomp ], status );

   }

/* Store the scale and zero terms with the output NDF. */
   ndf1Zpsca( acb2, intype, scale, zero, status );

/* Export an identifier for the new NDF. */
   *indf2 = ndf1Expid( ( NdfObject * ) acb2, status );

/* If an error occurred, then annul any ACB entry which may have been
   acquired. */
   if( *status != SAI__OK ) ndf1Anl( &acb2, status );

/* Annul the placeholder, erasing the associated object if any error has
   occurred. */
   if( pcb ) {
      erase = ( *status != SAI__OK );
      NDF__PCB_LOCK_MUTEX;
      ndf1Annpl( erase, &pcb, status );
      NDF__PCB_UNLOCK_MUTEX;
   }

/* Reset the "place" parameter. */
   *place = NDF__NOPL;

/* If an error occurred, reset the "indf2" parameter, report the error context
   and call the error tracing function. */
   if( *status != SAI__OK ) {
      *indf2 = NDF__NOID;
      errRep( " ", "ndfZscal: Error compressing an NDF using the SCALE "
              "algorithm.", status );
      ndf1Trace( "ndfZscal", status );
   }

/* Restablish the original AST status pointer */
   NDF_FINAL

}

