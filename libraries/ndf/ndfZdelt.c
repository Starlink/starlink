#include "sae_par.h"
#include "dat_par.h"
#include "ndf1.h"
#include "ndf_err.h"
#include "ndf.h"
#include "mers.h"
#include "star/util.h"

void ndfZdelt_( int indf1, const char *comp, float minrat, int zaxis,
               const char *type, int *place, int *indf2, float *zratio,
               int *status ){
/*
*+
*  Name:
*     ndfZdelt

*  Purpose:
*     Create a compressed copy of an NDF using DELTA compression

*  Synopsis:
*     void ndfZdelt( int indf1, const char *comp, float minrat, int zaxis,
*                    const char *type, int *place, int *indf2,
*                    float *zratio, int *status )

*  Description:
*     This function creates a copy of the supplied NDF, and then compresses
*     selected array components within the copy using delta compression.
*     This compression is lossless, but only operates on arrays holding
*     integer values. It assumes that adjacent integer values in each input
*     array tend to be close in value, and so differences between adjacent
*     values can be represented in fewer bits than the absolute values
*     themselves. The differences are taken along a nominated pixel axis
*     within the supplied array (specified by parameter "zaxis"). Any input
*     value that differs from its earlier neighbour by more than the data
*     range of the selected data type is stored explicitly using the data
*     type of the input array.
*
*     Further compression is achieved by replacing runs of equal input
*     values by a single occurrence of the value with a correspsonding
*     repetition count.
*
*     It should be noted that the degree of compression achieved is
*     dependent on the nature of the data, and it is possible for a
*     compressed array to occupy more space than the uncompressed array.
*     The mean compression factor actually achieved is returned in
*     parameter "zratio" (the ratio of the supplied NDF size to the
*     compressed NDF size).

*  Parameters:
*     indf1
*        Identifier for the input NDF.
*     comp
*        Pointer to a null terminated string holding A comma-separated list
*        of component names to be compressed. These may be selected from
*        "DATA, "VARIANCE" or "QUALITY". Additionally, if "*" is supplied
*        all three components will be compressed.
*     minrat
*        The minimum allowed compression ratio for an array (the ratio of
*        the supplied array size to the compressed array size). If
*        compressing an array results in a compression ratio smaller than
*        or equal to "minrat", then the array is left uncompressed in the
*        returned NDF. If the supplied value is zero or negative, then each
*        array will be compressed regardless of the compression ratio.
*     zaxis
*        The index of the pixel axis along which differences are to be
*        taken. If this is zero, a default value will be selected for each
*        array that gives the greatest compression. An error will be
*        reported if a value less than zero or greater than the number of
*        axes in the input array is supplied.
*     type
*        Pointer to a null terminated string holding the data type in which
*        to store the differences between adjacent array values. This must
*        be one of "_BYTE", "_WORD" or "_INTEGER". Additionally, a blank
*        string may be supplied in which case a default value will be
*        selected for each array that gives the greatest compression.
*     *place
*        An NDF placeholder (e.g. generated by the ndfPlace function) which
*        indicates the position in the data system where the new NDF will
*        reside. The placeholder is annulled by this function, and a value
*        of NDF__NOPL will be returned (as defined in the include file
*        "ndf.h").
*     *indf2
*        Returned holding the identifier for the new NDF.
*     *zratio
*        Returned holding the mean compression ratio actually achieved for
*        the array components specified by "comp". The compression ratio
*        for an array is the ratio of the number of bytes needed to hold
*        the numerical values in the supplied array, to the number of bytes
*        needed to hold the numerical values in the compressed array. It
*        does not include the small overheads associated with the extra
*        labels, etc, needed to store compressed data, and so may be
*        inaccurate for small arrays. Additionally, this ratio only takes
*        the specified array components into account. If the NDF contains
*        significant quantities of data in other components, then the
*        overall compression of the whole NDF will be less.
*     *status
*        The global status.

*  Notes:
*     -  An error is reported if any of the arrays to be compressed holds
*     floating point values. The exception is that floating point values
*     that are stored as scaled integers (see ndfZscal) are accepted.
*     -  If the input NDF is already stored in DELTA format, it will be
*     uncompressed and then recompressed using the supplied parameter
*     values.
*     -  An error will result if any of the specified array components of
*     the input NDF are currently mapped for access.
*     -  Complex arrays cannot be compressed using this function. An error
*     will be reported if the input NDF has a complex type, or if "TYPE"
*     represents a complex data type.
*     -  Delta compressed arrays are read-only. An error will be reported
*     if an attempt is made to map a delta compressed array for WRITE or
*     UPDATE access.
*     - When delta compressed arrays are mapped for READ access,
*     uncompression occurs automatically. The pointer returned by ndfMap
*     provides access to the uncompressed array values.
*     -  The result of copying a compressed NDF (for instance, using
*     ndfProp, etc.) will be an equivalent uncompressed NDF.
*     - When applied to a compressed NDF, the ndfType and ndfFtype
*     functions return information about the data type of the uncompressed
*     NDF.
*     -  If this function is called with "status" set, then a value of
*     NDF__NOID will be returned for the "indf2" parameter, although no
*     further processing will occur. The same value will also be returned
*     if the function should fail for any reason. In either event, the
*     placeholder will still be annulled. The NDF__NOID constant is defined
*     in the header file "ndf.h".

*  Copyright:
*     Copyright (C) 2018 East Asian Observatory
*     All rights reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or modify
*     it under the terms of the GNU General Public License as published by
*     the Free Software Foundation; either version 2 of the License, or (at
*     your option) any later version.
*
*     This program is distributed in the hope that it will be useful,but
*     WITHOUT ANY WARRANTY; without even the implied warranty of
*     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
*     General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 51 Franklin Street,Fifth Floor, Boston, MA
*     02110-1301, USA

*  Authors:
*     RFWS: R.F. Warren-Smith (STARLINK)
*     DSB: David S. Berry (EAO)

*  History:
*     3-APR-2019 (DSB):
*        Original version, based on equivalent Fortran function by RFWS.

*-
*/

/* Local Variables: */
   Ary *ary;             /* ARY identifier for array to be compressed */
   AryPlace *aplace;     /* ARY_ placeholder for compressed array */
   NdfACB *acb1;         /* Pointer to input NDF entry in ACB */
   NdfACB *acb2;         /* Pointer to output NDF entry in ACB */
   NdfDCB *dcb1;         /* Pointer to input NDF entry in DCB */
   NdfDCB *dcb2;         /* Pointer to output NDF entry in DCB */
   NdfPCB *pcb;          /* Pointer to placeholder entry in the PCB */
   const char *cnames[ 3 ] = { "DATA", "VARIANCE", "QUALITY" };    /* Allowed component
                                                                   names */
   float sumrat;         /* Sum of compression ratios */
   float zrat;           /* Compression ratio for a single array */
   int cflags[ 3 ];      /* Flags giving the components to compress */
   int cpf[ NDF__NCPF ];/* Component propagation flags */
   int erase;            /* Whether to erase placeholder object */
   int icomp;            /* Component index */
   int mapped;           /* Is ARY array mapped through current id? */
   int ncomp;            /* The number of components to compress */
   int nmap;             /* No. of times array is mapped through any id */
   int nrat;             /* The number of values summed in SUMRAT */

/* Set an initial value for the INDF and "zratio" arguments. */
   *indf2 = NDF__NOID;
   *zratio = 1.0;

/* Check the inherited status */
   if( *status != SAI__OK ) return;

/* Ensure the NDF library has been initialised. */
   NDF_INIT( status );

/* Import the NDF placeholder, converting it to a PCB index. */
   pcb = NULL;
   ndf1Imppl( *place, &pcb, status );

/* Import the input NDF identifier. */
   ndf1Impid( indf1, &acb1, status );

/* Get flags indicating which arrays are to be compressed. */
   ndf1Vclst( comp, 3, cnames, cflags, &ncomp, status );
   if( ncomp == 0 && *status == SAI__OK ) {
      *status = NDF__CNMIN;
      errRep( " ", "Invalid blank array component name specified (possible "
              "programming error).", status );
   }

/* Copy the whole input NDF, except for the arrays being compressed, to
   create a new base NDF and an ACB entry to describe it. */
   for( icomp = 0; icomp < NDF__NCPF; icomp++ ){
      cpf[ icomp ] = 1;
   }
   if( cflags[ 0 ] ) cpf[ NDF__DCPF ] = 0;
   if( cflags[ 1 ] ) cpf[ NDF__VCPF ] = 0;
   if( cflags[ 2 ] ) cpf[ NDF__QCPF ] = 0;
   ndf1Prp( acb1, 0, NULL, cpf, pcb, &acb2, status );

/* Get the DCB index for the input and output NDFs. */
   dcb1 = acb1->dcb;
   dcb2 = acb2->dcb;

/* Initialise the sum of the compression ratios achioeved for individual
   array components. */
   sumrat = 0.0;
   nrat = 0;

/* Loop round compressing the required array components in the order
   "DATA", "VARIANCE", "QUALITY". */
   for( icomp = 0; icomp < 3; icomp++ ){

/* If the array is to be compressed, see if it exists in the input NDF. */
      if( cflags[ icomp ] ) {
         if( icomp + 1 == 1 ) {
            aryState( acb1->did, cflags + 0, status );
         } else if( icomp + 1 == 2 ) {
            ndf1Vsta( acb1, cflags + 1, status );
         } else {
            ndf1Qsta( acb1, cflags + 2, status );
         }
      }

/* Only compress the array if it was included in the supplied "comp" list,
   exists, and no error has occurred. */
      if( cflags[ icomp ] && *status == SAI__OK ) {

/* Get information about the array. */
         if( icomp + 1 == 1 ) {
            ary = acb1->did;
            mapped = acb1->dmap;
            nmap = dcb1->ndmap;

         } else if( icomp + 1 == 2 ) {
            ary = acb1->vid;
            mapped = acb1->vmap;
            nmap = dcb1->nvmap;

         } else {
            ary = acb1->qid;
            mapped = acb1->qmap;
            nmap = dcb1->nqmap;
         }

/* Check that the array is not already mapped for access through the
   current ACB entry. Report an error if it is. */
         if( mapped && *status == SAI__OK ) {
            *status = NDF__ISMAP;
            ndf1Amsg( "N", acb1 );
            msgSetc( "A", cnames[ icomp ] );
            errRep( " ", "The ^A component in the NDF '^N' is already "
                    "mapped for access through the specified identifier "
                    "(possible programming error).", status );

/* Check that the array is not mapped at all. Report an error if it is. */
         } else if( nmap != 0 && *status == SAI__OK ) {
            *status = NDF__ISMAP;
            ndf1Dmsg( "N", dcb1 );
            msgSetc( "A", cnames[ icomp ] );
            errRep( " ", "The ^A component the NDF '^N' is already mapped "
                    "for access through another identifier (possible "
                    "programming error).", status );

/* If the above checks were passed, attempt to compress the array. */
         } else if( *status == SAI__OK ) {

/* DATA
   ---- */
            if( icomp + 1 == 1 ) {

/* Delete the existing data array in the output (a dummy array with
   undefined values created by ndf1Prp above). Also remove the reference
   to the ARY array within the ACB entry (we know it is the only ACB
   entry that refers to this array because we have just created it). */
               aryAnnul( &acb2->did, status );
               aryDelet( &dcb2->did, status );

/* Compress the old data array, storing the compressed data in the
   DATA_ARRAY component of the new data object. Store the resulting identifier
   in the new DCB entry. */
               aryPlace( dcb2->loc, "DATA_ARRAY", &aplace, status );
               aryDelta( ary, zaxis, type, minrat, &aplace, &zrat,
                         &dcb2->did, status );

/* Store the new ARY identifier in the ACB. */
               aryClone( dcb2->did, &acb2->did, status );

/* Update the storage form of the data array. */
               star_strlcpy( dcb2->defrm, "DELTA", sizeof( dcb2->defrm ) );

/* Note whether DCB data information is correct. */
               dcb2->kd = ( *status == SAI__OK );

/* VARIANCE
   -------- */
            } else if( icomp + 1 == 2 ) {

/* Compress the old variance array, storing the compressed data in the
   VARIANCE component of the new data object. Store the resulting identifier
   in the new DCB entry. */
               aryPlace( dcb2->loc, "VARIANCE", &aplace, status );
               aryDelta( ary, zaxis, type, minrat, &aplace, &zrat,
                         &dcb2->vid, status );

/* Store the new ARY identifier in the ACB. */
               aryClone( dcb2->vid, &acb2->vid, status );

/* Update the storage form of the variance array. */
               star_strlcpy( dcb2->vfrm, "DELTA", sizeof( dcb2->vfrm ) );

/* Note whether DCB variance information is correct. */
               dcb2->kv = ( *status == SAI__OK );

/* QUALITY
   ------- */
            } else {

/* Create a new quality structure in the new data object and obtain a
   locator to it for storage in the new DCB entry. */
               datNew( dcb2->loc, "QUALITY", "QUALITY", 0, NULL, status );
               datFind( dcb2->loc, "QUALITY", &dcb2->qloc, status );

/* Copy the old BADBITS component into the new quality structure, if
   available. Also propagate the badbits value to the new DCB entry. */
               ndf1Cpync( dcb1->qloc, "BADBITS", dcb2->qloc, status );
               dcb2->qbb = dcb1->qbb;

/* Compress the old quality array, storing the compressed data in the new
   quality structure. Store the resulting identifier in the new DCB entry. */
               aryPlace( dcb2->qloc, "QUALITY", &aplace, status );
               aryDelta( ary, zaxis, type, minrat, &aplace, &zrat,
                         &dcb2->qid, status );

/* Store the new ARY identifier in the ACB. */
               aryClone( dcb2->qid, &acb2->qid, status );

/* Update the storage form of the quality array. */
               star_strlcpy( dcb2->qfrm, "DELTA", sizeof( dcb2->qfrm ) );

/* Note whether DCB quality information is correct. */
               dcb2->kq = ( *status == SAI__OK );
            }

/* Form the sum of the compression ratios. If the compression achieved
   for this array was too low, it will not have been compressed, so use
   a value of 1.0. */
            if( minrat > 0.0 && zrat <= minrat ) zrat = 1.0;

            sumrat += zrat;
            nrat++;

         }
      }
   }

/* Return the mean compression ratio */
   if( nrat > 0 ) *zratio = sumrat/nrat;

/* Export an identifier for the new NDF. */
   *indf2 = ndf1Expid( ( NdfObject * ) acb2, status );

/* If an error occurred, then annul any ACB entry which may have been
   acquired. */
   if( *status != SAI__OK ) ndf1Anl( &acb2, status );

/* Annul the supplied placeholder, erasing the associated object if any
   error has occurred. */
   if( pcb ) {
      erase = ( *status != SAI__OK );
      NDF__PCB_LOCK_MUTEX;
      ndf1Annpl( erase, &pcb, status );
      NDF__PCB_UNLOCK_MUTEX;
   }

/* Reset the "place" parameter. */
   *place = NDF__NOPL;

/* If an error occurred, reset the "indf2" parameter, report the error context
   and call the error tracing function. */
   if( *status != SAI__OK ) {
      *indf2 = NDF__NOID;
      errRep( " ", "ndfZdelt: Error compressing an NDF using delta "
              "compression.", status );
      ndf1Trace( "ndfZdelt", status );
   }

/* Restablish the original AST status pointer */
   NDF_FINAL

}

