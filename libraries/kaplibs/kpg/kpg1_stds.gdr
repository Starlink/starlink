      SUBROUTINE KPG1_STDS<T>( IWCS, NDIM, EL, NGOOD, DMIN, MINP, MINC,
     :                         DMAX, MAXP, MAXC, SUM, MEAN, STDEV, SKEW,
     :                         KURTOS, MEDIAN, MODE, NUMPER, PERCNT,
     :                         PERVAL, MAXWCS, MINWCS, STATUS )
*+
*  Name:
*     KPG1_STDSx
 
*  Purpose:
*     Displays statistics generated by KPG1_STATx, KPG_OSTAx, and
*     KPG1_HSTAx.
 
*  Language:
*     Starlink Fortran 77.
 
*  Invocation:
*     CALL KPG1_STDSx( IWCS, NDIM, EL, NGOOD, DMIN, MINP, MINC,
*                      DMAX, MAXP, MAXC, SUM, MEAN, STDEV, SKEW,
*                      KURTOS, MEDIAN, MODE, NUMPER, PERCNT, PERVAL,
*                      MAXWCS, MINWCS, STATUS )
 
*  Description:
*     This routine displays the statistics of pixel data as generated by
*     the routines KPG1_STATx, KPG_OSTAx, and KPG1_HSTAx.
 
*  Arguments:
*     IWCS = INTEGER (Given)
*        Pointer to WCS FrameSet.
*     NDIM = INTEGER (Given)
*        Number of dimensions of the array whose statistics are being
*        displayed.
*     EL = INTEGER (Given)
*        Total number of pixels in the array.
*     NGOOD = INTEGER (Given)
*        Number of valid pixels which contributed to the statistics.
*     DMIN = DOUBLE PRECISION (Given)
*        Minimum pixel value.
*     MINP( NDIM ) = INTEGER (Given)
*        Pixel indices at which the minimum pixel value was (first)
*        found.
*     MINC( NDIM ) = DOUBLE PRECISION (Given)
*        The co-ordinate values of the centre of the minimum pixel.
*     DMAX = DOUBLE PRECISION (Given)
*        Maximum pixel value.
*     MAXP( NDIM ) = INTEGER (Given)
*        Pixel indices at which the maximum pixel value was (first)
*        found.
*     MAXC( NDIM ) = DOUBLE PRECISION (Given)
*        The co-ordinate values of the centre of the maximum pixel.
*     SUM = DOUBLE PRECISION (Given)
*        Pixel sum.
*     MEAN = DOUBLE PRECISION (Given)
*        Pixel mean value.
*     STDEV = DOUBLE PRECISION (Given)
*        Pixel standard deviation value.
*     SKEW = DOUBLE PRECISION (Given)
*        Skewness of the pixel values.
*     KURTOS = DOUBLE PRECISION (Given)
*        Pixel kurtosis.
*     MEDIAN = DOUBLE PRECISION (Given)
*        Median value.
*     MODE = DOUBLE PRECISION (Given)
*        Modal value.
*     NUMPER = INTEGER (Given)
*        Number of percentiles values to report.
*     PERCNT( NUMPER ) = REAL (Given)
*        The array of percentiles levels corresponding to the values
*        given by PERVAL.  They should be in the range 0.0 to 100.0,
*        and preferably in ascending order.  If there are none to
*        report, set NUMPER to 1 and pass the bad value in PERCNT( 1 ).
*     PERVAL( NUMPER ) = DOUBLE PRECISION (Given)
*        Percentile values corresponding to the percentile fractions
*        in PERCNT.
*     MAXWCS = CHARACTER * ( * ) (Returned)
*        The formatted WCS co-ordinates at the minimum position.
*     MINWCS = CHARACTER * ( * ) (Returned)
*        The formatted WCS co-ordinates at the minimum position.
*     STATUS = INTEGER (Given and Returned)
*        The global status.
 
*  Notes:
*     -  There is a routine for both real and double-precision
*     statistics: replace "x" in the routine name by R or D as
*     appropriate. Note that the two routines have identical argument
*     lists (with floating-point qualitities in double precision) but
*     differ in the precision with which the results are displayed.
*     -  If the value of NGOOD is not positive, then this routine will
*     assume that all the derived statistics (except for the sum) are
*     undefined and will not display them.
*     -  If a statistic is undefined, i.e. has the bad value, it is
*     not reported.  In the case of arrays, the first value is checked.
*     For the co-ordinates and pixel indices of the extreme values both
*     of the first elements of these must be good to display these
*     positions.
 
*  Copyright:
*     Copyright (C) 1988, 1990, 1991, 1993 Science & Engineering 
*                   Research Council.
*     Copyright (C) 1996, 2004 Central Laboratory of the Research
*                   Councils.
*     Copyright (C) 2006 Particle Physics & Astronomy Research
*                   Council.
*     Copyright (C) 2007, 2010 Science & Technology Facilities Council.
*     All Rights Reserved.

*  Licence:
*     This programme is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either Version 2 of
*     the License, or (at your option) any later version.
*     
*     This programme is distributed in the hope that it will be
*     useful, but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE.  See the GNU General Public License for more details.
*     
*     You should have received a copy of the GNU General Public License
*     along with this programme; if not, write to the Free Software
*     Foundation, Inc., 51, Franklin Street, Fifth Floor, Boston, MA
*     02110-1301, USA.

*  Authors:
*     DSB: David S. Berry (STARLINK)
*     MJC: Malcolm J. Currie (STARLINK)
*     RFWS: R.F. Warren-Smith (STARLINK, RAL)
*     {enter_new_authors_here}
 
*  History:
*     1988 February 19 (MJC):
*        First implementation.
*     1990 January 23 (MJC):
*        No report for invalid pixels for negative number.
*     1990 March 8 (MJC):
*        Added extra arguments to output the co-ordinates of the
*        maximum and minimum values.
*     1991 March 18 (RFWS):
*        Changed to handle new data from the generic version of the
*        statistics generating routine.
*     1991 March 27 (RFWS):
*        Converted to a generic routine, handling R and D precisions.
*        Supressed display of undefined statistics.
*     1996 March 11 (MJC):
*        Redo addition of the ordered statistics and checking for bad
*        values (originally around 1993).
*     6-AUG-2004 (DSB):
*        Re-instated generic source and added argument IWCS. Display WCS
*        co-ordinates instead of AXIS co-ordinates. 
*     6-JAN-2006 (DSB):
*        Normalise WCS co-ordinates before displaying them.
*     18-MAY-2007 (DSB):
*        Added arguments MINWCS and MAXWCS.
*     2010 July 21 (MJC):
*        Added and reported arguments SKEW and KURTOS.
*     2018 January 20 (MJC):
*        Initialise returned values before the status check.  A WCS
*        string could be undefined if its corresponding value is bad.
*     {enter_further_changes_here}

*  Bugs:
*     {note_new_bugs_here}
 
*-
 
*  Type Definitions:
      IMPLICIT NONE              ! no implicit typing allowed
 
*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'PRM_PAR'          ! VAL__ constants
      INCLUDE 'NDF_PAR'          ! NDF__ constants
      INCLUDE 'AST_PAR'          ! AST_ functions
 
*  Arguments Given:
      INTEGER IWCS
      INTEGER NDIM
      INTEGER EL
      INTEGER NGOOD
      DOUBLE PRECISION DMIN
      INTEGER MINP( NDIM )
      DOUBLE PRECISION MINC( NDIM )
      DOUBLE PRECISION DMAX
      INTEGER MAXP( NDIM )
      DOUBLE PRECISION MAXC( NDIM )
      DOUBLE PRECISION SUM
      DOUBLE PRECISION MEAN
      DOUBLE PRECISION STDEV
      DOUBLE PRECISION SKEW
      DOUBLE PRECISION KURTOS
      DOUBLE PRECISION MEDIAN
      DOUBLE PRECISION MODE
      INTEGER NUMPER
      REAL PERCNT( NUMPER )
      DOUBLE PRECISION PERVAL( NUMPER )
 
*  Arguments Returned:
      CHARACTER MAXWCS*(*)
      CHARACTER MINWCS*(*)

*  Status:
      INTEGER  STATUS
 
*  Local Variables:
      CHARACTER * ( 5 ) PCENT    ! Buffer for formatting percentages
      CHARACTER * ( 80 ) BUF1    ! Text buffer
      DOUBLE PRECISION POSIN( NDF__MXDIM ) ! Input pixel co-ordinates
      DOUBLE PRECISION POS( NDF__MXDIM ) ! Ouput WCS co-ordinates
      INTEGER I                  ! Loop counter for dimensions
      INTEGER IPIX               ! Index of PIXEL Frame in IWCS
      INTEGER MAP                ! Mapping from PIXEL to current co-ords
      INTEGER NWCS               ! Number of current Frame co-ordinates
      INTEGER NC1                ! Number of characters in BUF1
      INTEGER NC2                ! No. of characters in WCS text string
 
*  Internal References:
      INCLUDE 'NUM_DEC_CVT'      ! NUM_ type conversion functions
      INCLUDE 'NUM_DEF_CVT'
 
*.

*  Initialised returned values.
      MAXWCS = ' '
      MINWCS = ' '

*  Check the inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Store the number of WCS axes.
      NWCS = AST_GETI( IWCS, 'NAXES', STATUS ) 

*  Get the Mapping from PIXEL Frame to the current Frame.
      CALL KPG1_ASFFR( IWCS, 'PIXEL', IPIX, STATUS )
      MAP = AST_GETMAPPING( IWCS, IPIX, AST__CURRENT, STATUS )
 
*  Display the pixel sum.
      CALL MSG_BLANK( STATUS )
      CALL MSG_SET<T>( 'SUM', NUM_DTO<T>( SUM ) )
      CALL MSG_OUT( 'STATS_SUM',
     :'         Pixel sum              : ^SUM',
     :              STATUS )
 
*  Display the mean pixel value.
      IF ( NGOOD .GT. 0 ) THEN
         IF ( MEAN .NE. VAL__BADD ) THEN
            CALL MSG_SET<T>( 'MEAN', NUM_DTO<T>( MEAN ) )
            CALL MSG_OUT( 'STATS_MEAN',
     :        '         Pixel mean             : ^MEAN', STATUS )
         END IF
 
*  Display the standard deviation.
         IF ( STDEV .NE. VAL__BADD ) THEN
            CALL MSG_SET<T>( 'STDEV', NUM_DTO<T>( STDEV ) )
            CALL MSG_OUT( 'STATS_STDEV',
     :        '         Standard deviation     : ^STDEV', STATUS )
         END IF
 
*  Display the skewness.
         IF ( SKEW .NE. VAL__BADD ) THEN
            CALL MSG_SET<T>( 'SKEW', NUM_DTO<T>( SKEW ) )
            CALL MSG_OUT( 'STATS_SKEW',
     :        '         Skewness               : ^SKEW', STATUS )
         END IF

*  Display the kurtosis.
         IF ( KURTOS .NE. VAL__BADD ) THEN
            CALL MSG_SET<T>( 'KURTOSIS', NUM_DTO<T>( KURTOS ) )
            CALL MSG_OUT( 'STATS_KURTOSIS',
     :        '         Kurtosis               : ^KURTOSIS', STATUS )
         END IF

*  Display the minimum value found.
         IF ( DMIN .NE. VAL__BADD ) THEN
            CALL MSG_SET<T>( 'MINIMUM', NUM_DTO<T>( DMIN ) )
            CALL MSG_OUT( 'STATS_MIN',
     :        '         Minimum pixel value    : ^MINIMUM', STATUS )
         END IF
 
*  Format the indices and co-ordinates of the centre of the minimum
*  pixel as character strings.
         IF ( MINP( 1 ) .NE. VAL__BADI ) THEN

*  Now create the pixel text string.
            NC1 = 0
            CALL CHR_PUTC( '(', BUF1, NC1 )
            DO I = 1, NDIM
               IF ( I .GT. 1 ) CALL CHR_PUTC( ', ', BUF1, NC1 )
               CALL CHR_PUTI( MINP( I ), BUF1, NC1 )
            END DO
            CALL CHR_PUTC( ')', BUF1, NC1 )
 
*  Display the minimum pixel's indices.
            CALL MSG_SETC( 'IMIN', BUF1( : NC1 ) )
            CALL MSG_OUT( 'STATS_IMIN',
     :        '            At pixel            : ^IMIN', STATUS )
 
*  Transform the pixel co-ordinates to WCS co-ordinates, and normalize.
            DO I = 1, NDIM
               POSIN( I ) = DBLE( MINP( I ) ) - 0.5D0
            END DO
            CALL AST_TRANN( MAP, 1, NDIM, 1, POSIN, .TRUE., NWCS, 1,
     :                      POS, STATUS )
            CALL AST_NORM( IWCS, POS, STATUS ) 

*  Now create the WCS text string.
            NC2 = 0
            DO I = 1, NWCS
               IF ( I .GT. 1 ) CALL CHR_PUTC( ', ', MINWCS, NC2 )
               CALL CHR_APPND( AST_FORMAT( IWCS, I, POS( I ), STATUS ), 
     :                        MINWCS, NC2 )
            END DO
 
*  Display the minimum pixel's WCS co-ordinates.
            CALL MSG_SETC( 'CMIN', MINWCS( : NC2 ) )
            CALL MSG_OUT( 'STATS_CMIN',
     :        '            Co-ordinate         : (^CMIN)', STATUS )
         END IF
 
*  Display the maximum pixel value found.
         IF ( DMAX .NE. VAL__BADD ) THEN
            CALL MSG_SET<T>( 'MAXIMUM', NUM_DTO<T>( DMAX ) )
            CALL MSG_OUT( 'STATS_MAX',
     :        '         Maximum pixel value    : ^MAXIMUM', STATUS )
         END IF
 
*  Format the indices and co-ordinates of the centre of the maximum
*  pixel as character strings.
         IF ( MAXP( 1 ) .NE. VAL__BADI .AND.
     :        MAXC( 1 ) .NE. VAL__BADD ) THEN

*  Now create the pixel text string.
            NC1 = 0
            CALL CHR_PUTC( '(', BUF1, NC1 )
            DO I = 1, NDIM
               IF ( I .GT. 1 ) CALL CHR_PUTC( ', ', BUF1, NC1 )
               CALL CHR_PUTI( MAXP( I ), BUF1, NC1 )
            END DO
            CALL CHR_PUTC( ')', BUF1, NC1 )
 
*  Display the maximum pixel's indices.
            CALL MSG_SETC( 'IMAX', BUF1( : NC1 ) )
            CALL MSG_OUT( 'STATS_IMAX',
     :        '            At pixel            : ^IMAX', STATUS )
 
*  Transform the pixel co-ordinates to WCS co-ordinates. and normalise 
*  them.
            DO I = 1, NDIM
               POSIN( I ) = DBLE( MAXP( I ) ) - 0.5D0
            END DO
            CALL AST_TRANN( MAP, 1, NDIM, 1, POSIN, .TRUE., NWCS, 1,
     :                      POS, STATUS )
            CALL AST_NORM( IWCS, POS, STATUS ) 

*  Now create the WCS text string.
            NC2 = 0
            DO I = 1, NWCS
               IF ( I .GT. 1 ) CALL CHR_PUTC( ', ', MAXWCS, NC2 )
               CALL CHR_APPND( AST_FORMAT( IWCS, I, POS( I ), STATUS ), 
     :                        MAXWCS, NC2 )
            END DO
 
*  Display the maximum pixel's WCS co-ordinates.
            CALL MSG_SETC( 'CMAX', MAXWCS( : NC2 ) )
            CALL MSG_OUT( 'STATS_CMAX',
     :        '            Co-ordinate         : (^CMAX)', STATUS )

         END IF
 
*  Display the median value.
         IF ( MEDIAN .NE. VAL__BADD ) THEN
            CALL MSG_SET<T>( 'MEDIAN', NUM_DTO<T>( MEDIAN ) )
            CALL MSG_OUT( 'STATS_MEDIAN',
     :        '         Pixel median           : ^MEDIAN', STATUS )
         END IF
 
*  Display the mode.
         IF ( MODE .NE. VAL__BADD ) THEN
            CALL MSG_SET<T>( 'MODE', NUM_DTO<T>( MODE ) )
            CALL MSG_OUT( 'STATS_MODE',
     :        '         Pixel mode             : ^MODE', STATUS )
         END IF
 
*  Display the percentile values.  To retain alignment, use different
*  formatting for 100.0 percentile.
         IF ( PERCNT( 1 ) .NE. VAL__BADR ) THEN
            DO 3 I = 1, NUMPER
               IF ( PERVAL( I ) .NE. VAL__BADD ) THEN
                  IF ( PERCNT( I ) .GT. 99.995 ) THEN
                     CALL MSG_FMTR( 'PERC', 'F5.1', PERCNT( I ) )
                  ELSE
                     CALL MSG_FMTR( 'PERC', 'F5.2', PERCNT( I ) )
                  END IF
                  CALL MSG_SET<T>( 'PERVAL', NUM_DTO<T>( PERVAL( I ) ) )
                  CALL MSG_OUT( 'STATS_PERC',
     :              '         Pixel ^PERC percentile : ^PERVAL',
     :                          STATUS )
               END IF
    3       CONTINUE
         END IF
      END IF
 
*  Show how many pixels are in the NDF.
      CALL MSG_SETI( 'EL', EL )
      CALL MSG_OUT( 'STATS_NGOOD',
     :'         Total number of pixels : ^EL',
     :              STATUS )
 
*  Show how many pixels contributed to the statistics.
      CALL MSG_SETI( 'NGOOD', NGOOD )
      WRITE( PCENT, '(F5.1)' ) 100.0 * REAL( NGOOD ) / REAL( EL )
      CALL CHR_LDBLK( PCENT )
      CALL MSG_SETC( 'PCENT', PCENT )
      CALL MSG_OUT( 'STATS_NGOOD',
     :'         Number of pixels used  : ^NGOOD (^PCENT%%)',
     :              STATUS )
 
*  Show how many pixels did not contribute.
      IF ( NGOOD .LT. EL ) THEN
         CALL MSG_SETI( 'NBAD', EL - NGOOD )
         WRITE( PCENT, '(F5.1)' )
     :          100.0 * REAL( EL - NGOOD ) / REAL( EL )
         CALL CHR_LDBLK( PCENT )
         CALL MSG_SETC( 'PCENT', PCENT )
         CALL MSG_OUT( 'STATS_NBAD',
     :'         No. of pixels excluded : ^NBAD (^PCENT%%)',
     :                 STATUS )
      END IF
      CALL MSG_OUT( 'BLANK', ' ', STATUS )
 
*  Annul the AST pointers.
      CALL AST_ANNUL( MAP, STATUS )

      END
