      SUBROUTINE KPG1_STFL8<T>( IWCS, NDIM, EL, NGOOD, DMIN, MINP, MINC,
     :                         DMAX, MAXP, MAXC, SUM, MEAN, STDEV, SKEW,
     :                         KURTOS, MEDIAN, MODE, NUMPER, PERCNT,
     :                         PERVAL, IFIL, STATUS )
*+
*  Name:
*     KPG1_STFL8x

*  Purpose:
*     Writes statistics generated by KPG1_STATx, KPG_OSTAx, and
*     KPG1_HSTAx to a text file.

*  Language:
*     Starlink Fortran 77.

*  Invocation:
*     CALL KPG1_STFL8x( IWCS, NDIM, EL, NGOOD, DMIN, MINP, MINC,
*                      DMAX, MAXP, MAXC, SUM, MEAN, STDEV, SKEW,
*                      KURTOS, MEDIAN, MODE, NUMPER, PERCNT, PERVAL,
*                      IFIL, STATUS )

*  Description:
*     This routine writes the statistics of pixel data as generated by
*     the routines KPG1_STATx, KPG_OSTAx, and KPG1_HSTAx to a text file.

*  Arguments:
*     IWCS = INTEGER (Given)
*        Pointer to WCS FrameSet.
*     NDIM = INTEGER (Given)
*        Number of dimensions of the array whose statistics are being
*        displayed.
*     EL = INTEGER*8 (Given)
*        Total number of pixels in the array.
*     NGOOD = INTEGER*8 (Given)
*        Number of valid pixels which contributed to the statistics.
*     DMIN = DOUBLE PRECISION (Given)
*        Minimum pixel value.
*     MINP( NDIM ) = INTEGER*8 (Given)
*        Pixel indices at which the minimum pixel value was (first)
*        found.
*     MINC( NDIM ) = DOUBLE PRECISION (Given)
*        The co-ordinate values of the centre of the minimum pixel.
*     DMAX = DOUBLE PRECISION (Given)
*        Maximum pixel value.
*     MAXP( NDIM ) = INTEGER*8 (Given)
*        Pixel indices at which the maximum pixel value was (first)
*        found.
*     MAXC( NDIM ) = DOUBLE PRECISION (Given)
*        The co-ordinate values of the centre of the maximum pixel.
*     SUM = DOUBLE PRECISION (Given)
*        Pixel sum.
*     MEAN = DOUBLE PRECISION (Given)
*        Pixel mean value.
*     STDEV = DOUBLE PRECISION (Given)
*        Pixel standard deviation value.
*     SKEW = DOUBLE PRECISION (Given)
*        Skewness of the pixel values.
*     KURTOS = DOUBLE PRECISION (Given)
*        Pixel kurtosis.
*     MEDIAN = DOUBLE PRECISION (Given)
*        Median value.
*     MODE = DOUBLE PRECISION (Given)
*        Modal value.
*     NUMPER = INTEGER (Given)
*        Number of percentiles values to report.
*     PERCNT( NUMPER ) = REAL (Given)
*        The array of percentiles levels corresponding to the values
*        given by PERVAL.  They should be in the range 0.0 to 100.0,
*        and preferably in ascending order.  If there are none to
*        report, set NUMPER to 1 and pass the bad value in PERCNT( 1 ).
*     PERVAL( NUMPER ) = DOUBLE PRECISION (Given)
*        Percentile values corresponding to the percentile fractions
*        in PERCNT.
*     IFIL = INTEGER (Given)
*        FIO_ file descriptor for the output file.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Notes:
*     -  There is a routine for both real and double-precision
*     statistics: replace "x" in the routine name by R or D as
*     appropriate. Note that the two routines have identical argument
*     lists (with floating-point qualitities in double precision) but
*     differ in the precision with which the results are displayed.
*     -  If the value of NGOOD is not positive, then this routine will
*     assume that all the derived statistics (except for the sum) are
*     undefined and will not display them.
*     -  If a statistic is undefined, i.e. has the bad value, it is
*     not reported.  In the case of arrays, the first value is checked.
*     For the co-ordinates and pixel indices of the extreme values both
*     of the first elements of these must be good to display these
*     positions.

*  Copyright:
*     Copyright (C) 1991, 1992 Science & Engineering Research Council.
*     Copyright (C) 1996, 2004 Central Laboratory of the Research
*                   Councils.
*     Copyright (C) 2006 Particle Physics & Astronomy Research
*                   Council.
*     Copyright (C) 2010 Science & Technology Facilities Council.
*     All Rights Reserved.

*  Licence:
*     This programme is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either Version 2 of
*     the License, or (at your option) any later version.
*
*     This programme is distributed in the hope that it will be
*     useful, but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE.  See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this programme; if not, write to the Free Software
*     Foundation, Inc., 51, Franklin Street, Fifth Floor, Boston, MA
*     02110-1301, USA.

*  Authors:
*     DSB: David S. Berry (STARLINK)
*     RFWS: R.F. Warren-Smith (STARLINK, RAL)
*     MJC: Malcolm J. Currie (STARLINK)
*     {enter_new_authors_here}

*  History:
*     1991 March 28 (RFWS):
*        Original version, derived from KPG1_STDSx.
*     1996 March 11 (MJC):
*        Redo addition of the ordered statistics and checking for bad
*        values (originally c.1992).
*     6-AUG-2004 (DSB):
*        Re-instated generic source and added argument IWCS. Display WCS
*        coords instead of AXIS coords.
*     6-JAN-2006 (DSB):
*        Normalise WCS coords before displaying them.
*     2010 July 21 (MJC):
*        Added and reported arguments SKEW and KURTOS.
*     5-DEC-2019 (DSB):
*        Support huge files.
*     {enter_further_changes_here}

*  Bugs:
*     {note_new_bugs_here}

*-

*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'PRM_PAR'          ! VAL__ constants
      INCLUDE 'NDF_PAR'          ! NDF__ constants
      INCLUDE 'AST_PAR'          ! AST_ functions

*  Arguments Given:
      INTEGER IWCS
      INTEGER NDIM
      INTEGER*8 EL
      INTEGER*8 NGOOD
      DOUBLE PRECISION DMIN
      INTEGER*8 MINP( NDIM )
      DOUBLE PRECISION MINC( NDIM )
      DOUBLE PRECISION DMAX
      INTEGER*8 MAXP( NDIM )
      DOUBLE PRECISION MAXC( NDIM )
      DOUBLE PRECISION SUM
      DOUBLE PRECISION MEAN
      DOUBLE PRECISION STDEV
      DOUBLE PRECISION SKEW
      DOUBLE PRECISION KURTOS
      DOUBLE PRECISION MEDIAN
      DOUBLE PRECISION MODE
      INTEGER NUMPER
      REAL PERCNT( NUMPER )
      DOUBLE PRECISION PERVAL( NUMPER )

      INTEGER IFIL

*  Status:
      INTEGER  STATUS

*  Local Variables:
      CHARACTER*80 BUF1          ! Text buffer
      CHARACTER*80 BUF2          ! Text buffer
      INTEGER I                  ! Loop counter for dimensions
      INTEGER IPIX               ! Index of PIXEL Frame in IWCS
      INTEGER MAP                ! Mapping from PIXEL to current co-ords
      INTEGER NC1                ! Number of characters in BUF1
      INTEGER NC2                ! Number of characters in BUF2
      INTEGER NWCS               ! Number of current Frame co-ords
      CHARACTER*5 PCENT          ! Buffer for formatting percentages
      DOUBLE PRECISION POS( NDF__MXDIM ) ! Ouput WCS co-ords
      DOUBLE PRECISION POSIN( NDF__MXDIM ) ! Input pixel co-ords

*  Internal References:
      INCLUDE 'NUM_DEC_CVT'      ! NUM_ type conversion functions
      INCLUDE 'NUM_DEF_CVT'

*.

*  Check the inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Store the number of WCS axes.
      NWCS = AST_GETI( IWCS, 'NAXES', STATUS )

*  Get the Mapping from PIXEL Frame to the current Frame.
      CALL KPG1_ASFFR( IWCS, 'PIXEL', IPIX, STATUS )
      MAP = AST_GETMAPPING( IWCS, IPIX, AST__CURRENT, STATUS )

*  Display the pixel sum.
      CALL FIO_WRITE( IFIL, ' ', STATUS )
      NC1 = 0
      CALL CHR_PUTC( '         Pixel sum              : ', BUF1, NC1 )
      CALL CHR_PUT<T>( NUM_DTO<T>( SUM ), BUF1, NC1 )
      CALL FIO_WRITE( IFIL, BUF1( : NC1 ), STATUS )

*  Display the mean pixel value.
      IF ( NGOOD .GT. 0 ) THEN
         IF ( MEAN .NE. VAL__BADD ) THEN
            NC1 = 0
            CALL CHR_PUTC( '         Pixel mean             : ', BUF1,
     :                     NC1 )
            CALL CHR_PUT<T>( NUM_DTO<T>( MEAN ), BUF1, NC1 )
            CALL FIO_WRITE( IFIL, BUF1( : NC1 ), STATUS )
         END IF

*  Display the standard deviation.
         IF ( STDEV .NE. VAL__BADD ) THEN
            NC1 = 0
            CALL CHR_PUTC( '         Standard deviation     : ', BUF1,
     :                     NC1 )
            CALL CHR_PUT<T>( NUM_DTO<T>( STDEV ), BUF1, NC1 )
            CALL FIO_WRITE( IFIL, BUF1( : NC1 ), STATUS )
         END IF

*  Display the skewness.
         IF ( SKEW .NE. VAL__BADD ) THEN
            NC1 = 0
            CALL CHR_PUTC( '         Skewness               : ', BUF1,
     :                     NC1 )
            CALL CHR_PUT<T>( NUM_DTO<T>( SKEW ), BUF1, NC1 )
            CALL FIO_WRITE( IFIL, BUF1( : NC1 ), STATUS )
         END IF

*  Display the kurtosis.
         IF ( KURTOS .NE. VAL__BADD ) THEN
            NC1 = 0
            CALL CHR_PUTC( '         Kurtosis               : ', BUF1,
     :                     NC1 )
            CALL CHR_PUT<T>( NUM_DTO<T>( KURTOS ), BUF1, NC1 )
            CALL FIO_WRITE( IFIL, BUF1( : NC1 ), STATUS )
         END IF

*  Display the minimum value found.
         IF ( DMIN .NE. VAL__BADD ) THEN
            NC1 = 0
            CALL CHR_PUTC( '         Minimum pixel value    : ', BUF1,
     :                     NC1 )
            CALL CHR_PUT<T>( NUM_DTO<T>( DMIN ), BUF1, NC1 )
            CALL FIO_WRITE( IFIL, BUF1( : NC1 ), STATUS )
         END IF

*  Format the indices and WCS co-ordinates of the centre of the minimum
*  pixel as character strings.
         IF ( MINP( 1 ) .NE. VAL__BADK ) THEN

*  First do the pixel indices.
            NC1 = 0
            CALL CHR_PUTC( '            At pixel            : (', BUF1,
     :                     NC1 )
            DO I = 1, NDIM
               IF ( I .GT. 1 ) CALL CHR_PUTC( ', ', BUF1, NC1 )
               CALL CHR_PUTK( MINP( I ), BUF1, NC1 )
            END DO
            CALL CHR_PUTC( ')', BUF1, NC1 )

            CALL FIO_WRITE( IFIL, BUF1( : NC1 ), STATUS )

*  Now do the WCS coords. Transform the pixel coords to WCS coords.
            DO I = 1, NDIM
               POSIN( I ) = DBLE( MINP( I ) ) - 0.5D0
            END DO
            CALL AST_TRANN( MAP, 1, NDIM, 1, POSIN, .TRUE., NWCS, 1,
     :                      POS, STATUS )
            CALL AST_NORM( IWCS, POS, STATUS )

*  Now create the WCS text string.
            NC2 = 0
            CALL CHR_PUTC( '            Co-ordinate         : (', BUF2,
     :                     NC2 )
            DO I = 1, NDIM
               IF ( I .GT. 1 ) CALL CHR_PUTC( ', ', BUF2, NC2 )
               CALL CHR_APPND( AST_FORMAT( IWCS, I, POS( I ), STATUS ),
     :                        BUF2, NC2 )
            END DO
            CALL CHR_PUTC( ')', BUF2, NC2 )

*  Display it.
            CALL FIO_WRITE( IFIL, BUF2( : NC2 ), STATUS )

         END IF

*  Display the maximum pixel value found.
         IF ( DMAX .NE. VAL__BADD ) THEN
            NC1 = 0
            CALL CHR_PUTC( '         Maximum pixel value    : ', BUF1,
     :                     NC1 )
            CALL CHR_PUT<T>( NUM_DTO<T>( DMAX ), BUF1, NC1 )
            CALL FIO_WRITE( IFIL, BUF1( : NC1 ), STATUS )
         END IF

*  Format the indices and co-ordinates of the centre of the maximum
*  pixel as character strings.
         IF ( MAXP( 1 ) .NE. VAL__BADK ) THEN

*  First do the pixel indices.
            NC1 = 0
            CALL CHR_PUTC( '            At pixel            : (', BUF1,
     :                     NC1 )
            DO I = 1, NDIM
               IF ( I .GT. 1 ) CALL CHR_PUTC( ', ', BUF1, NC1 )
               CALL CHR_PUTK( MAXP( I ), BUF1, NC1 )
            END DO
            CALL CHR_PUTC( ')', BUF1, NC1 )

            CALL FIO_WRITE( IFIL, BUF1( : NC1 ), STATUS )

*  Now do the WCS coords. Transform the pixel coords to WCS coords.
            DO I = 1, NDIM
               POSIN( I ) = DBLE( MAXP( I ) ) - 0.5D0
            END DO
            CALL AST_TRANN( MAP, 1, NDIM, 1, POSIN, .TRUE., NWCS, 1,
     :                      POS, STATUS )
            CALL AST_NORM( IWCS, POS, STATUS )

*  Now create the WCS text string.
            NC2 = 0
            CALL CHR_PUTC( '            Co-ordinate         : (', BUF2,
     :                     NC2 )
            DO I = 1, NDIM
               IF ( I .GT. 1 ) CALL CHR_PUTC( ', ', BUF2, NC2 )
               CALL CHR_APPND( AST_FORMAT( IWCS, I, POS( I ), STATUS ),
     :                        BUF2, NC2 )
            END DO
            CALL CHR_PUTC( ')', BUF2, NC2 )

*  Display it.
            CALL FIO_WRITE( IFIL, BUF2( : NC2 ), STATUS )

         END IF

*  Display the median value.
         IF ( MEDIAN .NE. VAL__BADD ) THEN
            NC1 = 0
            CALL CHR_PUTC( '         Pixel median           : ', BUF1,
     :                     NC1 )
            CALL CHR_PUT<T>( NUM_DTO<T>( MEDIAN ), BUF1, NC1 )
            CALL FIO_WRITE( IFIL, BUF1( : NC1 ), STATUS )
         END IF

*  Display the mode.
         IF ( MODE .NE. VAL__BADD ) THEN
            NC1 = 0
            CALL CHR_PUTC( '         Pixel mode             : ', BUF1,
     :                     NC1 )
            CALL CHR_PUT<T>( NUM_DTO<T>( MODE ), BUF1, NC1 )
            CALL FIO_WRITE( IFIL, BUF1( : NC1 ), STATUS )
         END IF

*  Display the percentile values.  To retain alignment, use different
*  formatting for 100.0 percentile.
         IF ( PERCNT( 1 ) .NE. VAL__BADR ) THEN
            DO 3 I = 1, NUMPER
               IF ( PERVAL( I ) .NE. VAL__BADD ) THEN
                  NC1 = 0
                  CALL CHR_PUTC( '         Pixel ' , BUF1, NC1 )

                  IF ( PERCNT( I ) .GT. 99.995 ) THEN
                     CALL CHR_PUTC( '100.0', BUF1, NC1 )
                  ELSE
                     WRITE( PCENT, '(F5.2)' ) PERCNT( I )
                     CALL CHR_PUTC( PCENT, BUF1, NC1 )
                  END IF
                  CALL CHR_PUTC( ' percentile : ' , BUF1, NC1 )

                  CALL CHR_PUT<T>( NUM_DTO<T>( PERVAL( I ) ), BUF1,
     :                             NC1 )
                  CALL FIO_WRITE( IFIL, BUF1( : NC1 ), STATUS )
               END IF
    3       CONTINUE
         END IF
      END IF

*  Show how many pixels are in the NDF.
      NC1 = 0
      CALL CHR_PUTC( '         Total number of pixels : ', BUF1, NC1 )
      CALL CHR_PUTK( EL, BUF1, NC1 )
      CALL FIO_WRITE( IFIL, BUF1( : NC1 ), STATUS )

*  Show how many pixels contributed to the statistics.
      NC1 = 0
      CALL CHR_PUTC( '         Number of pixels used  : ', BUF1, NC1 )
      CALL CHR_PUTK( NGOOD, BUF1, NC1 )
      CALL CHR_PUTC( ' (', BUF1, NC1 )
      WRITE( PCENT, '(F5.1)' ) 100.0 * REAL( NGOOD ) / REAL( EL )
      CALL CHR_LDBLK( PCENT )
      CALL CHR_PUTC( PCENT, BUF1, NC1 )
      CALL CHR_PUTC( '%)', BUF1, NC1 )
      CALL FIO_WRITE( IFIL, BUF1( : NC1 ), STATUS )

*  Show how many pixels did not contribute.
      IF ( NGOOD .LT. EL ) THEN
         NC1 = 0
         CALL CHR_PUTC( '         No. of pixels excluded : ', BUF1,
     :                  NC1 )
         CALL CHR_PUTK( EL - NGOOD, BUF1, NC1 )
         CALL CHR_PUTC( ' (', BUF1, NC1 )
         WRITE( PCENT, '(F5.1)' )
     :          100.0 * REAL( EL - NGOOD ) / REAL( EL )
         CALL CHR_LDBLK( PCENT )
         CALL CHR_PUTC( PCENT, BUF1, NC1 )
         CALL CHR_PUTC( '%)', BUF1, NC1 )
         CALL FIO_WRITE( IFIL, BUF1( : NC1 ), STATUS )
      END IF
      CALL FIO_WRITE( IFIL, ' ', STATUS )

*  Annul the Mapping pointer.
      CALL AST_ANNUL( MAP, STATUS )

      END
